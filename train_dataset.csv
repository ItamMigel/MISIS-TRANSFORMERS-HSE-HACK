Unnamed: 0,id,task_id,description,input,output,student_solution,author_solution,author_comment,type,prompt
0,13,1,"Реализуйте программу, которая проверит, что цвет используется только в проекте по созданию логотипа, но не в проекте по созданию дизайна сайта:

Даны два списка logo_project и cite_project с кодами используемых цветов (строки).
В переменную color считывается код цвета (строка). Этот код уже написан.
Программа должна проверять, что код цвета color есть только в списке logo_project, и если да, то печатать True. 
В остальных случаях программа печатает False. ","['#a7f0ca', '#e4e3b3', '#a7a8f0', '#c0ced7', '#a7f0ca']","['True', 'False', 'False', 'False', 'True']","logo_project = ['#a7a8f0', '#a7f0ca', '#b3b4e4', '#e4b3cd', '#e4e3b3', '#c0ced7']
cite_project = ['#e4e3b3', '#a7a8f0', '#ccb1e6', '#b4f99e', '#f9b59e', '#c0ced7']

color = input()

if color in logo_project and color in cite_project:
    print(True)
else:
    print(False)","logo_project = ['#a7a8f0', '#a7f0ca', '#b3b4e4', '#e4b3cd', '#e4e3b3', '#c0ced7']
cite_project = ['#e4e3b3', '#a7a8f0', '#ccb1e6', '#b4f99e', '#f9b59e', '#c0ced7']

color = input()

if color in logo_project and not(color in cite_project):
    print(True)
else:
    print(False)","Ошибка в открытых тестах. 

Обратите внимание на неверный оператор сравнения — необходимо проверить, что цвет не находится в списке cite_project.","['open', 'open', 'open', 'closed', 'closed']","<Task description>: Реализуйте программу, которая проверит, что цвет используется только в проекте по созданию логотипа, но не в проекте по созданию дизайна сайта:

Даны два списка logo_project и cite_project с кодами используемых цветов (строки).
В переменную color считывается код цвета (строка). Этот код уже написан.
Программа должна проверять, что код цвета color есть только в списке logo_project, и если да, то печатать True. 
В остальных случаях программа печатает False.  
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: #a7f0ca 
<Вывод>: True 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: #e4e3b3 
<Вывод>: False 
<Example 3>: 
<Тип теста 3>: open 
<Ввод>: #a7a8f0 
<Вывод>: False 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: #c0ced7 
<Вывод>: False 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: #a7f0ca 
<Вывод>: True 
<Решение студента>: logo_project = ['#a7a8f0', '#a7f0ca', '#b3b4e4', '#e4b3cd', '#e4e3b3', '#c0ced7']
cite_project = ['#e4e3b3', '#a7a8f0', '#ccb1e6', '#b4f99e', '#f9b59e', '#c0ced7']

color = input()

if color in logo_project and color in cite_project:
    print(True)
else:
    print(False) 
<Идеальное решение>: logo_project = ['#a7a8f0', '#a7f0ca', '#b3b4e4', '#e4b3cd', '#e4e3b3', '#c0ced7']
cite_project = ['#e4e3b3', '#a7a8f0', '#ccb1e6', '#b4f99e', '#f9b59e', '#c0ced7']

color = input()

if color in logo_project and not(color in cite_project):
    print(True)
else:
    print(False) 


<Комментарий эксперта>:"
1,14,1,"Реализуйте программу, которая проверит, что цвет используется только в проекте по созданию логотипа, но не в проекте по созданию дизайна сайта:

Даны два списка logo_project и cite_project с кодами используемых цветов (строки).
В переменную color считывается код цвета (строка). Этот код уже написан.
Программа должна проверять, что код цвета color есть только в списке logo_project, и если да, то печатать True. 
В остальных случаях программа печатает False. ","['#a7f0ca', '#e4e3b3', '#a7a8f0', '#c0ced7', '#a7f0ca']","['True', 'False', 'False', 'False', 'True']","logo_project = ['#a7a8f0', '#a7f0ca', '#b3b4e4', '#e4b3cd', '#e4e3b3', '#c0ced7']
cite_project = ['#e4e3b3', '#a7a8f0', '#ccb1e6', '#b4f99e', '#f9b59e', '#c0ced7']

color = input()

if not(color in logo_project) and not(color in cite_project):
    print(True)
else:
    print(False)","logo_project = ['#a7a8f0', '#a7f0ca', '#b3b4e4', '#e4b3cd', '#e4e3b3', '#c0ced7']
cite_project = ['#e4e3b3', '#a7a8f0', '#ccb1e6', '#b4f99e', '#f9b59e', '#c0ced7']

color = input()

if color in logo_project and not(color in cite_project):
    print(True)
else:
    print(False)","Ошибка в открытых тестах. 

Обратите внимание на неверный оператор сравнения — необходимо проверить, что цвет находится в списке logo_project.","['open', 'open', 'open', 'closed', 'closed']","<Task description>: Реализуйте программу, которая проверит, что цвет используется только в проекте по созданию логотипа, но не в проекте по созданию дизайна сайта:

Даны два списка logo_project и cite_project с кодами используемых цветов (строки).
В переменную color считывается код цвета (строка). Этот код уже написан.
Программа должна проверять, что код цвета color есть только в списке logo_project, и если да, то печатать True. 
В остальных случаях программа печатает False.  
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: #a7f0ca 
<Вывод>: True 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: #e4e3b3 
<Вывод>: False 
<Example 3>: 
<Тип теста 3>: open 
<Ввод>: #a7a8f0 
<Вывод>: False 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: #c0ced7 
<Вывод>: False 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: #a7f0ca 
<Вывод>: True 
<Решение студента>: logo_project = ['#a7a8f0', '#a7f0ca', '#b3b4e4', '#e4b3cd', '#e4e3b3', '#c0ced7']
cite_project = ['#e4e3b3', '#a7a8f0', '#ccb1e6', '#b4f99e', '#f9b59e', '#c0ced7']

color = input()

if not(color in logo_project) and not(color in cite_project):
    print(True)
else:
    print(False) 
<Идеальное решение>: logo_project = ['#a7a8f0', '#a7f0ca', '#b3b4e4', '#e4b3cd', '#e4e3b3', '#c0ced7']
cite_project = ['#e4e3b3', '#a7a8f0', '#ccb1e6', '#b4f99e', '#f9b59e', '#c0ced7']

color = input()

if color in logo_project and not(color in cite_project):
    print(True)
else:
    print(False) 


<Комментарий эксперта>:"
2,15,1,"Реализуйте программу, которая проверит, что цвет используется только в проекте по созданию логотипа, но не в проекте по созданию дизайна сайта:

Даны два списка logo_project и cite_project с кодами используемых цветов (строки).
В переменную color считывается код цвета (строка). Этот код уже написан.
Программа должна проверять, что код цвета color есть только в списке logo_project, и если да, то печатать True. 
В остальных случаях программа печатает False. ","['#a7f0ca', '#e4e3b3', '#a7a8f0', '#c0ced7', '#a7f0ca']","['True', 'False', 'False', 'False', 'True']","logo_project = ['#a7a8f0', '#a7f0ca', '#b3b4e4', '#e4b3cd', '#e4e3b3', '#c0ced7']
cite_project = ['#e4e3b3', '#a7a8f0', '#ccb1e6', '#b4f99e', '#f9b59e', '#c0ced7']

color = input()

if not(color in logo_project) and color in cite_project:
    print(True)
else:
    print(False)","logo_project = ['#a7a8f0', '#a7f0ca', '#b3b4e4', '#e4b3cd', '#e4e3b3', '#c0ced7']
cite_project = ['#e4e3b3', '#a7a8f0', '#ccb1e6', '#b4f99e', '#f9b59e', '#c0ced7']

color = input()

if color in logo_project and not(color in cite_project):
    print(True)
else:
    print(False)","Ошибка в открытых тестах. 

Обратите внимание на неверный оператор сравнения — необходимо проверить, что цвет находится в списке logo_project и не находится в списке cite_project.","['open', 'open', 'open', 'closed', 'closed']","<Task description>: Реализуйте программу, которая проверит, что цвет используется только в проекте по созданию логотипа, но не в проекте по созданию дизайна сайта:

Даны два списка logo_project и cite_project с кодами используемых цветов (строки).
В переменную color считывается код цвета (строка). Этот код уже написан.
Программа должна проверять, что код цвета color есть только в списке logo_project, и если да, то печатать True. 
В остальных случаях программа печатает False.  
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: #a7f0ca 
<Вывод>: True 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: #e4e3b3 
<Вывод>: False 
<Example 3>: 
<Тип теста 3>: open 
<Ввод>: #a7a8f0 
<Вывод>: False 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: #c0ced7 
<Вывод>: False 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: #a7f0ca 
<Вывод>: True 
<Решение студента>: logo_project = ['#a7a8f0', '#a7f0ca', '#b3b4e4', '#e4b3cd', '#e4e3b3', '#c0ced7']
cite_project = ['#e4e3b3', '#a7a8f0', '#ccb1e6', '#b4f99e', '#f9b59e', '#c0ced7']

color = input()

if not(color in logo_project) and color in cite_project:
    print(True)
else:
    print(False) 
<Идеальное решение>: logo_project = ['#a7a8f0', '#a7f0ca', '#b3b4e4', '#e4b3cd', '#e4e3b3', '#c0ced7']
cite_project = ['#e4e3b3', '#a7a8f0', '#ccb1e6', '#b4f99e', '#f9b59e', '#c0ced7']

color = input()

if color in logo_project and not(color in cite_project):
    print(True)
else:
    print(False) 


<Комментарий эксперта>:"
3,16,1,"Реализуйте программу, которая проверит, что цвет используется только в проекте по созданию логотипа, но не в проекте по созданию дизайна сайта:

Даны два списка logo_project и cite_project с кодами используемых цветов (строки).
В переменную color считывается код цвета (строка). Этот код уже написан.
Программа должна проверять, что код цвета color есть только в списке logo_project, и если да, то печатать True. 
В остальных случаях программа печатает False. ","['#a7f0ca', '#e4e3b3', '#a7a8f0', '#c0ced7', '#a7f0ca']","['True', 'False', 'False', 'False', 'True']","logo_project = ['#a7a8f0', '#a7f0ca', '#b3b4e4', '#e4b3cd', '#e4e3b3', '#c0ced7']
cite_project = ['#e4e3b3', '#a7a8f0', '#ccb1e6', '#b4f99e', '#f9b59e', '#c0ced7']

color = input()

if color in logo_project and not(color in cite_project):
    print(False)
else:
    print(True)","logo_project = ['#a7a8f0', '#a7f0ca', '#b3b4e4', '#e4b3cd', '#e4e3b3', '#c0ced7']
cite_project = ['#e4e3b3', '#a7a8f0', '#ccb1e6', '#b4f99e', '#f9b59e', '#c0ced7']

color = input()

if color in logo_project and not(color in cite_project):
    print(True)
else:
    print(False)","Ошибка в открытых тестах. 

Обратите внимание на неверный выбор булевого значения.","['open', 'open', 'open', 'closed', 'closed']","<Task description>: Реализуйте программу, которая проверит, что цвет используется только в проекте по созданию логотипа, но не в проекте по созданию дизайна сайта:

Даны два списка logo_project и cite_project с кодами используемых цветов (строки).
В переменную color считывается код цвета (строка). Этот код уже написан.
Программа должна проверять, что код цвета color есть только в списке logo_project, и если да, то печатать True. 
В остальных случаях программа печатает False.  
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: #a7f0ca 
<Вывод>: True 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: #e4e3b3 
<Вывод>: False 
<Example 3>: 
<Тип теста 3>: open 
<Ввод>: #a7a8f0 
<Вывод>: False 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: #c0ced7 
<Вывод>: False 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: #a7f0ca 
<Вывод>: True 
<Решение студента>: logo_project = ['#a7a8f0', '#a7f0ca', '#b3b4e4', '#e4b3cd', '#e4e3b3', '#c0ced7']
cite_project = ['#e4e3b3', '#a7a8f0', '#ccb1e6', '#b4f99e', '#f9b59e', '#c0ced7']

color = input()

if color in logo_project and not(color in cite_project):
    print(False)
else:
    print(True) 
<Идеальное решение>: logo_project = ['#a7a8f0', '#a7f0ca', '#b3b4e4', '#e4b3cd', '#e4e3b3', '#c0ced7']
cite_project = ['#e4e3b3', '#a7a8f0', '#ccb1e6', '#b4f99e', '#f9b59e', '#c0ced7']

color = input()

if color in logo_project and not(color in cite_project):
    print(True)
else:
    print(False) 


<Комментарий эксперта>:"
4,17,1,"Реализуйте программу, которая проверит, что цвет используется только в проекте по созданию логотипа, но не в проекте по созданию дизайна сайта:

Даны два списка logo_project и cite_project с кодами используемых цветов (строки).
В переменную color считывается код цвета (строка). Этот код уже написан.
Программа должна проверять, что код цвета color есть только в списке logo_project, и если да, то печатать True. 
В остальных случаях программа печатает False. ","['#a7f0ca', '#e4e3b3', '#a7a8f0', '#c0ced7', '#a7f0ca']","['True', 'False', 'False', 'False', 'True']","logo_project = ['#a7a8f0', '#a7f0ca', '#b3b4e4', '#e4b3cd', '#e4e3b3', '#c0ced7']
cite_project = ['#e4e3b3', '#a7a8f0', '#ccb1e6', '#b4f99e', '#f9b59e', '#c0ced7']

color = input()

if color in logo_project and not(color in cite_project):
    print(True)
else
    print(False)","logo_project = ['#a7a8f0', '#a7f0ca', '#b3b4e4', '#e4b3cd', '#e4e3b3', '#c0ced7']
cite_project = ['#e4e3b3', '#a7a8f0', '#ccb1e6', '#b4f99e', '#f9b59e', '#c0ced7']

color = input()

if color in logo_project and not(color in cite_project):
    print(True)
else:
    print(False)",Вы забыли поставить двоеточие после условия.,"['open', 'open', 'open', 'closed', 'closed']","<Task description>: Реализуйте программу, которая проверит, что цвет используется только в проекте по созданию логотипа, но не в проекте по созданию дизайна сайта:

Даны два списка logo_project и cite_project с кодами используемых цветов (строки).
В переменную color считывается код цвета (строка). Этот код уже написан.
Программа должна проверять, что код цвета color есть только в списке logo_project, и если да, то печатать True. 
В остальных случаях программа печатает False.  
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: #a7f0ca 
<Вывод>: True 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: #e4e3b3 
<Вывод>: False 
<Example 3>: 
<Тип теста 3>: open 
<Ввод>: #a7a8f0 
<Вывод>: False 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: #c0ced7 
<Вывод>: False 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: #a7f0ca 
<Вывод>: True 
<Решение студента>: logo_project = ['#a7a8f0', '#a7f0ca', '#b3b4e4', '#e4b3cd', '#e4e3b3', '#c0ced7']
cite_project = ['#e4e3b3', '#a7a8f0', '#ccb1e6', '#b4f99e', '#f9b59e', '#c0ced7']

color = input()

if color in logo_project and not(color in cite_project):
    print(True)
else
    print(False) 
<Идеальное решение>: logo_project = ['#a7a8f0', '#a7f0ca', '#b3b4e4', '#e4b3cd', '#e4e3b3', '#c0ced7']
cite_project = ['#e4e3b3', '#a7a8f0', '#ccb1e6', '#b4f99e', '#f9b59e', '#c0ced7']

color = input()

if color in logo_project and not(color in cite_project):
    print(True)
else:
    print(False) 


<Комментарий эксперта>:"
5,18,1,"Реализуйте программу, которая проверит, что цвет используется только в проекте по созданию логотипа, но не в проекте по созданию дизайна сайта:

Даны два списка logo_project и cite_project с кодами используемых цветов (строки).
В переменную color считывается код цвета (строка). Этот код уже написан.
Программа должна проверять, что код цвета color есть только в списке logo_project, и если да, то печатать True. 
В остальных случаях программа печатает False. ","['#a7f0ca', '#e4e3b3', '#a7a8f0', '#c0ced7', '#a7f0ca']","['True', 'False', 'False', 'False', 'True']","logo_project = ['#a7a8f0', '#a7f0ca', '#b3b4e4', '#e4b3cd', '#e4e3b3', '#c0ced7']
cite_project = ['#e4e3b3', '#a7a8f0', '#ccb1e6', '#b4f99e', '#f9b59e', '#c0ced7']

colour = input()

if color in logo_project and not(color in cite_project):
    print(True)
else:
    print(False)","logo_project = ['#a7a8f0', '#a7f0ca', '#b3b4e4', '#e4b3cd', '#e4e3b3', '#c0ced7']
cite_project = ['#e4e3b3', '#a7a8f0', '#ccb1e6', '#b4f99e', '#f9b59e', '#c0ced7']

color = input()

if color in logo_project and not(color in cite_project):
    print(True)
else:
    print(False)",Необходимо использовать одинаковые названия переменных. ,"['open', 'open', 'open', 'closed', 'closed']","<Task description>: Реализуйте программу, которая проверит, что цвет используется только в проекте по созданию логотипа, но не в проекте по созданию дизайна сайта:

Даны два списка logo_project и cite_project с кодами используемых цветов (строки).
В переменную color считывается код цвета (строка). Этот код уже написан.
Программа должна проверять, что код цвета color есть только в списке logo_project, и если да, то печатать True. 
В остальных случаях программа печатает False.  
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: #a7f0ca 
<Вывод>: True 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: #e4e3b3 
<Вывод>: False 
<Example 3>: 
<Тип теста 3>: open 
<Ввод>: #a7a8f0 
<Вывод>: False 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: #c0ced7 
<Вывод>: False 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: #a7f0ca 
<Вывод>: True 
<Решение студента>: logo_project = ['#a7a8f0', '#a7f0ca', '#b3b4e4', '#e4b3cd', '#e4e3b3', '#c0ced7']
cite_project = ['#e4e3b3', '#a7a8f0', '#ccb1e6', '#b4f99e', '#f9b59e', '#c0ced7']

colour = input()

if color in logo_project and not(color in cite_project):
    print(True)
else:
    print(False) 
<Идеальное решение>: logo_project = ['#a7a8f0', '#a7f0ca', '#b3b4e4', '#e4b3cd', '#e4e3b3', '#c0ced7']
cite_project = ['#e4e3b3', '#a7a8f0', '#ccb1e6', '#b4f99e', '#f9b59e', '#c0ced7']

color = input()

if color in logo_project and not(color in cite_project):
    print(True)
else:
    print(False) 


<Комментарий эксперта>:"
6,19,1,"Реализуйте программу, которая проверит, что цвет используется только в проекте по созданию логотипа, но не в проекте по созданию дизайна сайта:

Даны два списка logo_project и cite_project с кодами используемых цветов (строки).
В переменную color считывается код цвета (строка). Этот код уже написан.
Программа должна проверять, что код цвета color есть только в списке logo_project, и если да, то печатать True. 
В остальных случаях программа печатает False. ","['#a7f0ca', '#e4e3b3', '#a7a8f0', '#c0ced7', '#a7f0ca']","['True', 'False', 'False', 'False', 'True']","logo_project = ['#a7a8f0', '#a7f0ca', '#b3b4e4', '#e4b3cd', '#e4e3b3', '#c0ced7']
cite_project = ['#e4e3b3', '#a7a8f0', '#ccb1e6', '#b4f99e', '#f9b59e', '#c0ced7']

color = input()

if color in logo_project and not(color in cite_project):
    print(True)
else:
print(False)","logo_project = ['#a7a8f0', '#a7f0ca', '#b3b4e4', '#e4b3cd', '#e4e3b3', '#c0ced7']
cite_project = ['#e4e3b3', '#a7a8f0', '#ccb1e6', '#b4f99e', '#f9b59e', '#c0ced7']

color = input()

if color in logo_project and not(color in cite_project):
    print(True)
else:
    print(False)",Вы некорректно поставили отступы перед функцией print().,"['open', 'open', 'open', 'closed', 'closed']","<Task description>: Реализуйте программу, которая проверит, что цвет используется только в проекте по созданию логотипа, но не в проекте по созданию дизайна сайта:

Даны два списка logo_project и cite_project с кодами используемых цветов (строки).
В переменную color считывается код цвета (строка). Этот код уже написан.
Программа должна проверять, что код цвета color есть только в списке logo_project, и если да, то печатать True. 
В остальных случаях программа печатает False.  
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: #a7f0ca 
<Вывод>: True 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: #e4e3b3 
<Вывод>: False 
<Example 3>: 
<Тип теста 3>: open 
<Ввод>: #a7a8f0 
<Вывод>: False 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: #c0ced7 
<Вывод>: False 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: #a7f0ca 
<Вывод>: True 
<Решение студента>: logo_project = ['#a7a8f0', '#a7f0ca', '#b3b4e4', '#e4b3cd', '#e4e3b3', '#c0ced7']
cite_project = ['#e4e3b3', '#a7a8f0', '#ccb1e6', '#b4f99e', '#f9b59e', '#c0ced7']

color = input()

if color in logo_project and not(color in cite_project):
    print(True)
else:
print(False) 
<Идеальное решение>: logo_project = ['#a7a8f0', '#a7f0ca', '#b3b4e4', '#e4b3cd', '#e4e3b3', '#c0ced7']
cite_project = ['#e4e3b3', '#a7a8f0', '#ccb1e6', '#b4f99e', '#f9b59e', '#c0ced7']

color = input()

if color in logo_project and not(color in cite_project):
    print(True)
else:
    print(False) 


<Комментарий эксперта>:"
7,20,1,"Реализуйте программу, которая проверит, что цвет используется только в проекте по созданию логотипа, но не в проекте по созданию дизайна сайта:

Даны два списка logo_project и cite_project с кодами используемых цветов (строки).
В переменную color считывается код цвета (строка). Этот код уже написан.
Программа должна проверять, что код цвета color есть только в списке logo_project, и если да, то печатать True. 
В остальных случаях программа печатает False. ","['#a7f0ca', '#e4e3b3', '#a7a8f0', '#c0ced7', '#a7f0ca']","['True', 'False', 'False', 'False', 'True']","logo_project = ['#a7a8f0', '#a7f0ca', '#b3b4e4', '#e4b3cd', '#e4e3b3', '#c0ced7']
cite_project = ['#e4e3b3', '#a7a8f0', '#ccb1e6', '#b4f99e', '#f9b59e', '#c0ced7']

color = input()

if color in logo_project and not(color in cite_project):
    print(True)
else:
    print(False","logo_project = ['#a7a8f0', '#a7f0ca', '#b3b4e4', '#e4b3cd', '#e4e3b3', '#c0ced7']
cite_project = ['#e4e3b3', '#a7a8f0', '#ccb1e6', '#b4f99e', '#f9b59e', '#c0ced7']

color = input()

if color in logo_project and not(color in cite_project):
    print(True)
else:
    print(False)",Вы забыли поставить закрывающую скобку функции print().,"['open', 'open', 'open', 'closed', 'closed']","<Task description>: Реализуйте программу, которая проверит, что цвет используется только в проекте по созданию логотипа, но не в проекте по созданию дизайна сайта:

Даны два списка logo_project и cite_project с кодами используемых цветов (строки).
В переменную color считывается код цвета (строка). Этот код уже написан.
Программа должна проверять, что код цвета color есть только в списке logo_project, и если да, то печатать True. 
В остальных случаях программа печатает False.  
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: #a7f0ca 
<Вывод>: True 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: #e4e3b3 
<Вывод>: False 
<Example 3>: 
<Тип теста 3>: open 
<Ввод>: #a7a8f0 
<Вывод>: False 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: #c0ced7 
<Вывод>: False 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: #a7f0ca 
<Вывод>: True 
<Решение студента>: logo_project = ['#a7a8f0', '#a7f0ca', '#b3b4e4', '#e4b3cd', '#e4e3b3', '#c0ced7']
cite_project = ['#e4e3b3', '#a7a8f0', '#ccb1e6', '#b4f99e', '#f9b59e', '#c0ced7']

color = input()

if color in logo_project and not(color in cite_project):
    print(True)
else:
    print(False 
<Идеальное решение>: logo_project = ['#a7a8f0', '#a7f0ca', '#b3b4e4', '#e4b3cd', '#e4e3b3', '#c0ced7']
cite_project = ['#e4e3b3', '#a7a8f0', '#ccb1e6', '#b4f99e', '#f9b59e', '#c0ced7']

color = input()

if color in logo_project and not(color in cite_project):
    print(True)
else:
    print(False) 


<Комментарий эксперта>:"
8,21,1,"Реализуйте программу, которая проверит, что цвет используется только в проекте по созданию логотипа, но не в проекте по созданию дизайна сайта:

Даны два списка logo_project и cite_project с кодами используемых цветов (строки).
В переменную color считывается код цвета (строка). Этот код уже написан.
Программа должна проверять, что код цвета color есть только в списке logo_project, и если да, то печатать True. 
В остальных случаях программа печатает False. ","['#a7f0ca', '#e4e3b3', '#a7a8f0', '#c0ced7', '#a7f0ca']","['True', 'False', 'False', 'False', 'True']","logo_project = ['#a7a8f0', '#a7f0ca', '#b3b4e4', '#e4b3cd', '#e4e3b3', '#c0ced7']
cite_project = ['#e4e3b3', '#a7a8f0', '#ccb1e6', '#b4f99e', '#f9b59e', '#c0ced7']

color = input()

if color in logo_project and not in cite_project:
    print(True)
else:
    print(False)","logo_project = ['#a7a8f0', '#a7f0ca', '#b3b4e4', '#e4b3cd', '#e4e3b3', '#c0ced7']
cite_project = ['#e4e3b3', '#a7a8f0', '#ccb1e6', '#b4f99e', '#f9b59e', '#c0ced7']

color = input()

if color in logo_project and not(color in cite_project):
    print(True)
else:
    print(False)","Проверьте написание метода, который хотите применить к спискам. ","['open', 'open', 'open', 'closed', 'closed']","<Task description>: Реализуйте программу, которая проверит, что цвет используется только в проекте по созданию логотипа, но не в проекте по созданию дизайна сайта:

Даны два списка logo_project и cite_project с кодами используемых цветов (строки).
В переменную color считывается код цвета (строка). Этот код уже написан.
Программа должна проверять, что код цвета color есть только в списке logo_project, и если да, то печатать True. 
В остальных случаях программа печатает False.  
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: #a7f0ca 
<Вывод>: True 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: #e4e3b3 
<Вывод>: False 
<Example 3>: 
<Тип теста 3>: open 
<Ввод>: #a7a8f0 
<Вывод>: False 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: #c0ced7 
<Вывод>: False 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: #a7f0ca 
<Вывод>: True 
<Решение студента>: logo_project = ['#a7a8f0', '#a7f0ca', '#b3b4e4', '#e4b3cd', '#e4e3b3', '#c0ced7']
cite_project = ['#e4e3b3', '#a7a8f0', '#ccb1e6', '#b4f99e', '#f9b59e', '#c0ced7']

color = input()

if color in logo_project and not in cite_project:
    print(True)
else:
    print(False) 
<Идеальное решение>: logo_project = ['#a7a8f0', '#a7f0ca', '#b3b4e4', '#e4b3cd', '#e4e3b3', '#c0ced7']
cite_project = ['#e4e3b3', '#a7a8f0', '#ccb1e6', '#b4f99e', '#f9b59e', '#c0ced7']

color = input()

if color in logo_project and not(color in cite_project):
    print(True)
else:
    print(False) 


<Комментарий эксперта>:"
9,22,1,"Реализуйте программу, которая проверит, что цвет используется только в проекте по созданию логотипа, но не в проекте по созданию дизайна сайта:

Даны два списка logo_project и cite_project с кодами используемых цветов (строки).
В переменную color считывается код цвета (строка). Этот код уже написан.
Программа должна проверять, что код цвета color есть только в списке logo_project, и если да, то печатать True. 
В остальных случаях программа печатает False. ","['#a7f0ca', '#e4e3b3', '#a7a8f0', '#c0ced7', '#a7f0ca']","['True', 'False', 'False', 'False', 'True']","logo_project = ['#a7a8f0', '#a7f0ca', '#b3b4e4', '#e4b3cd', '#e4e3b3', '#c0ced7']
cite_project = ['#e4e3b3', '#a7a8f0', '#ccb1e6', '#b4f99e', '#f9b59e', '#c0ced7']

color = int(input())

if color in logo_project and not(color in cite_project):
    print(True)
else:
    print(False)","logo_project = ['#a7a8f0', '#a7f0ca', '#b3b4e4', '#e4b3cd', '#e4e3b3', '#c0ced7']
cite_project = ['#e4e3b3', '#a7a8f0', '#ccb1e6', '#b4f99e', '#f9b59e', '#c0ced7']

color = input()

if color in logo_project and not(color in cite_project):
    print(True)
else:
    print(False)",В данном случае не нужно применять функцию int() к переменной color. ,"['open', 'open', 'open', 'closed', 'closed']","<Task description>: Реализуйте программу, которая проверит, что цвет используется только в проекте по созданию логотипа, но не в проекте по созданию дизайна сайта:

Даны два списка logo_project и cite_project с кодами используемых цветов (строки).
В переменную color считывается код цвета (строка). Этот код уже написан.
Программа должна проверять, что код цвета color есть только в списке logo_project, и если да, то печатать True. 
В остальных случаях программа печатает False.  
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: #a7f0ca 
<Вывод>: True 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: #e4e3b3 
<Вывод>: False 
<Example 3>: 
<Тип теста 3>: open 
<Ввод>: #a7a8f0 
<Вывод>: False 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: #c0ced7 
<Вывод>: False 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: #a7f0ca 
<Вывод>: True 
<Решение студента>: logo_project = ['#a7a8f0', '#a7f0ca', '#b3b4e4', '#e4b3cd', '#e4e3b3', '#c0ced7']
cite_project = ['#e4e3b3', '#a7a8f0', '#ccb1e6', '#b4f99e', '#f9b59e', '#c0ced7']

color = int(input())

if color in logo_project and not(color in cite_project):
    print(True)
else:
    print(False) 
<Идеальное решение>: logo_project = ['#a7a8f0', '#a7f0ca', '#b3b4e4', '#e4b3cd', '#e4e3b3', '#c0ced7']
cite_project = ['#e4e3b3', '#a7a8f0', '#ccb1e6', '#b4f99e', '#f9b59e', '#c0ced7']

color = input()

if color in logo_project and not(color in cite_project):
    print(True)
else:
    print(False) 


<Комментарий эксперта>:"
10,23,1,"Реализуйте программу, которая проверит, что цвет используется только в проекте по созданию логотипа, но не в проекте по созданию дизайна сайта:

Даны два списка logo_project и cite_project с кодами используемых цветов (строки).
В переменную color считывается код цвета (строка). Этот код уже написан.
Программа должна проверять, что код цвета color есть только в списке logo_project, и если да, то печатать True. 
В остальных случаях программа печатает False. ","['#a7f0ca', '#e4e3b3', '#a7a8f0', '#c0ced7', '#a7f0ca']","['True', 'False', 'False', 'False', 'True']","logo_project = ['#a7a8f0', '#a7f0ca', '#b3b4e4', '#e4b3cd', '#e4e3b3', '#c0ced7']
cite_project = ['#e4e3b3', '#a7a8f0', '#ccb1e6', '#b4f99e', '#f9b59e', '#c0ced7']

color = input()

if color in logo_project and not(color in cite_project):
    print(True)
else color in cite_project:
    print(False)","logo_project = ['#a7a8f0', '#a7f0ca', '#b3b4e4', '#e4b3cd', '#e4e3b3', '#c0ced7']
cite_project = ['#e4e3b3', '#a7a8f0', '#ccb1e6', '#b4f99e', '#f9b59e', '#c0ced7']

color = input()

if color in logo_project and not(color in cite_project):
    print(True)
else:
    print(False)","Обратите внимание, что после else не нужно прописывать никаких условий.","['open', 'open', 'open', 'closed', 'closed']","<Task description>: Реализуйте программу, которая проверит, что цвет используется только в проекте по созданию логотипа, но не в проекте по созданию дизайна сайта:

Даны два списка logo_project и cite_project с кодами используемых цветов (строки).
В переменную color считывается код цвета (строка). Этот код уже написан.
Программа должна проверять, что код цвета color есть только в списке logo_project, и если да, то печатать True. 
В остальных случаях программа печатает False.  
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: #a7f0ca 
<Вывод>: True 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: #e4e3b3 
<Вывод>: False 
<Example 3>: 
<Тип теста 3>: open 
<Ввод>: #a7a8f0 
<Вывод>: False 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: #c0ced7 
<Вывод>: False 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: #a7f0ca 
<Вывод>: True 
<Решение студента>: logo_project = ['#a7a8f0', '#a7f0ca', '#b3b4e4', '#e4b3cd', '#e4e3b3', '#c0ced7']
cite_project = ['#e4e3b3', '#a7a8f0', '#ccb1e6', '#b4f99e', '#f9b59e', '#c0ced7']

color = input()

if color in logo_project and not(color in cite_project):
    print(True)
else color in cite_project:
    print(False) 
<Идеальное решение>: logo_project = ['#a7a8f0', '#a7f0ca', '#b3b4e4', '#e4b3cd', '#e4e3b3', '#c0ced7']
cite_project = ['#e4e3b3', '#a7a8f0', '#ccb1e6', '#b4f99e', '#f9b59e', '#c0ced7']

color = input()

if color in logo_project and not(color in cite_project):
    print(True)
else:
    print(False) 


<Комментарий эксперта>:"
11,24,1,"Реализуйте программу, которая проверит, что цвет используется только в проекте по созданию логотипа, но не в проекте по созданию дизайна сайта:

Даны два списка logo_project и cite_project с кодами используемых цветов (строки).
В переменную color считывается код цвета (строка). Этот код уже написан.
Программа должна проверять, что код цвета color есть только в списке logo_project, и если да, то печатать True. 
В остальных случаях программа печатает False. ","['#a7f0ca', '#e4e3b3', '#a7a8f0', '#c0ced7', '#a7f0ca']","['True', 'False', 'False', 'False', 'True']","logo_project = ['#a7a8f0', '#a7f0ca', '#b3b4e4', '#e4b3cd', '#e4e3b3', '#c0ced7']
cite_project = ['#e4e3b3', '#a7a8f0', '#ccb1e6', '#b4f99e', '#f9b59e', '#c0ced7']

color = input()

if color in logo_project and not(color in cite_project):
    print(true)
else:
    print(false)","logo_project = ['#a7a8f0', '#a7f0ca', '#b3b4e4', '#e4b3cd', '#e4e3b3', '#c0ced7']
cite_project = ['#e4e3b3', '#a7a8f0', '#ccb1e6', '#b4f99e', '#f9b59e', '#c0ced7']

color = input()

if color in logo_project and not(color in cite_project):
    print(True)
else:
    print(False)",Обратите внимание на неверный синтаксис булевых значений.,"['open', 'open', 'open', 'closed', 'closed']","<Task description>: Реализуйте программу, которая проверит, что цвет используется только в проекте по созданию логотипа, но не в проекте по созданию дизайна сайта:

Даны два списка logo_project и cite_project с кодами используемых цветов (строки).
В переменную color считывается код цвета (строка). Этот код уже написан.
Программа должна проверять, что код цвета color есть только в списке logo_project, и если да, то печатать True. 
В остальных случаях программа печатает False.  
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: #a7f0ca 
<Вывод>: True 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: #e4e3b3 
<Вывод>: False 
<Example 3>: 
<Тип теста 3>: open 
<Ввод>: #a7a8f0 
<Вывод>: False 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: #c0ced7 
<Вывод>: False 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: #a7f0ca 
<Вывод>: True 
<Решение студента>: logo_project = ['#a7a8f0', '#a7f0ca', '#b3b4e4', '#e4b3cd', '#e4e3b3', '#c0ced7']
cite_project = ['#e4e3b3', '#a7a8f0', '#ccb1e6', '#b4f99e', '#f9b59e', '#c0ced7']

color = input()

if color in logo_project and not(color in cite_project):
    print(true)
else:
    print(false) 
<Идеальное решение>: logo_project = ['#a7a8f0', '#a7f0ca', '#b3b4e4', '#e4b3cd', '#e4e3b3', '#c0ced7']
cite_project = ['#e4e3b3', '#a7a8f0', '#ccb1e6', '#b4f99e', '#f9b59e', '#c0ced7']

color = input()

if color in logo_project and not(color in cite_project):
    print(True)
else:
    print(False) 


<Комментарий эксперта>:"
12,25,1,"Реализуйте программу, которая проверит, что цвет используется только в проекте по созданию логотипа, но не в проекте по созданию дизайна сайта:

Даны два списка logo_project и cite_project с кодами используемых цветов (строки).
В переменную color считывается код цвета (строка). Этот код уже написан.
Программа должна проверять, что код цвета color есть только в списке logo_project, и если да, то печатать True. 
В остальных случаях программа печатает False. ","['#a7f0ca', '#e4e3b3', '#a7a8f0', '#c0ced7', '#a7f0ca']","['True', 'False', 'False', 'False', 'True']","logo_project = ['#a7a8f0', '#a7f0ca', '#b3b4e4', '#e4b3cd', '#e4e3b3', '#c0ced7']
cite_project = ['#e4e3b3', '#a7a8f0', '#ccb1e6', '#b4f99e', '#f9b59e', '#c0ced7']

color = input()

if color in logoproject and not(color in citeproject):
    print(True)
else:
    print(False)","logo_project = ['#a7a8f0', '#a7f0ca', '#b3b4e4', '#e4b3cd', '#e4e3b3', '#c0ced7']
cite_project = ['#e4e3b3', '#a7a8f0', '#ccb1e6', '#b4f99e', '#f9b59e', '#c0ced7']

color = input()

if color in logo_project and not(color in cite_project):
    print(True)
else:
    print(False)",Обратите внимание на неверный синтаксис переменных.,"['open', 'open', 'open', 'closed', 'closed']","<Task description>: Реализуйте программу, которая проверит, что цвет используется только в проекте по созданию логотипа, но не в проекте по созданию дизайна сайта:

Даны два списка logo_project и cite_project с кодами используемых цветов (строки).
В переменную color считывается код цвета (строка). Этот код уже написан.
Программа должна проверять, что код цвета color есть только в списке logo_project, и если да, то печатать True. 
В остальных случаях программа печатает False.  
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: #a7f0ca 
<Вывод>: True 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: #e4e3b3 
<Вывод>: False 
<Example 3>: 
<Тип теста 3>: open 
<Ввод>: #a7a8f0 
<Вывод>: False 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: #c0ced7 
<Вывод>: False 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: #a7f0ca 
<Вывод>: True 
<Решение студента>: logo_project = ['#a7a8f0', '#a7f0ca', '#b3b4e4', '#e4b3cd', '#e4e3b3', '#c0ced7']
cite_project = ['#e4e3b3', '#a7a8f0', '#ccb1e6', '#b4f99e', '#f9b59e', '#c0ced7']

color = input()

if color in logoproject and not(color in citeproject):
    print(True)
else:
    print(False) 
<Идеальное решение>: logo_project = ['#a7a8f0', '#a7f0ca', '#b3b4e4', '#e4b3cd', '#e4e3b3', '#c0ced7']
cite_project = ['#e4e3b3', '#a7a8f0', '#ccb1e6', '#b4f99e', '#f9b59e', '#c0ced7']

color = input()

if color in logo_project and not(color in cite_project):
    print(True)
else:
    print(False) 


<Комментарий эксперта>:"
13,26,1,"Реализуйте программу, которая проверит, что цвет используется только в проекте по созданию логотипа, но не в проекте по созданию дизайна сайта:

Даны два списка logo_project и cite_project с кодами используемых цветов (строки).
В переменную color считывается код цвета (строка). Этот код уже написан.
Программа должна проверять, что код цвета color есть только в списке logo_project, и если да, то печатать True. 
В остальных случаях программа печатает False. ","['#a7f0ca', '#e4e3b3', '#a7a8f0', '#c0ced7', '#a7f0ca']","['True', 'False', 'False', 'False', 'True']","logo_project = ['#a7a8f0', '#a7f0ca', '#b3b4e4', '#e4b3cd', '#e4e3b3', '#c0ced7']
cite_project = ['#e4e3b3', '#a7a8f0', '#ccb1e6', '#b4f99e', '#f9b59e', '#c0ced7']

color = input()

if not(color in cite_project):
    print(True)
else:
    print(False)","logo_project = ['#a7a8f0', '#a7f0ca', '#b3b4e4', '#e4b3cd', '#e4e3b3', '#c0ced7']
cite_project = ['#e4e3b3', '#a7a8f0', '#ccb1e6', '#b4f99e', '#f9b59e', '#c0ced7']

color = input()

if color in logo_project and not(color in cite_project):
    print(True)
else:
    print(False)","Ошибка в открытых и скрытых тестах. 

Ваш код охватывает не все возможные случаи. Например, он не проверяет, присутствует ли цвет в списке logo_project. Попробуйте дополнить условие if, чтобы охватить все возможные случаи.","['open', 'open', 'open', 'closed', 'closed']","<Task description>: Реализуйте программу, которая проверит, что цвет используется только в проекте по созданию логотипа, но не в проекте по созданию дизайна сайта:

Даны два списка logo_project и cite_project с кодами используемых цветов (строки).
В переменную color считывается код цвета (строка). Этот код уже написан.
Программа должна проверять, что код цвета color есть только в списке logo_project, и если да, то печатать True. 
В остальных случаях программа печатает False.  
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: #a7f0ca 
<Вывод>: True 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: #e4e3b3 
<Вывод>: False 
<Example 3>: 
<Тип теста 3>: open 
<Ввод>: #a7a8f0 
<Вывод>: False 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: #c0ced7 
<Вывод>: False 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: #a7f0ca 
<Вывод>: True 
<Решение студента>: logo_project = ['#a7a8f0', '#a7f0ca', '#b3b4e4', '#e4b3cd', '#e4e3b3', '#c0ced7']
cite_project = ['#e4e3b3', '#a7a8f0', '#ccb1e6', '#b4f99e', '#f9b59e', '#c0ced7']

color = input()

if not(color in cite_project):
    print(True)
else:
    print(False) 
<Идеальное решение>: logo_project = ['#a7a8f0', '#a7f0ca', '#b3b4e4', '#e4b3cd', '#e4e3b3', '#c0ced7']
cite_project = ['#e4e3b3', '#a7a8f0', '#ccb1e6', '#b4f99e', '#f9b59e', '#c0ced7']

color = input()

if color in logo_project and not(color in cite_project):
    print(True)
else:
    print(False) 


<Комментарий эксперта>:"
14,27,2,"Реализуйте программу, которая определит количество корректных названий проектов для конкурса дизайнеров интерьера:

В цикле while считываются названия проектов до тех пор, пока не введена строка ""СТОП"".
Гарантируется, что названия проектов не повторяются. 
Гарантируется, что до строки ""СТОП"" будет введена как минимум одна строка.
Напечатайте количество проектов, которые состоят только из заглавных букв и в которых нет знака подчеркивания.","['ПРОЕКТ 1\nПРОЕКТ_2\nпроект 3\nПроект_4\nинтерьер_\n_диз_ИНТ\nСТОП', 'ПРОЕКТ_1\nработа_ФИН\nФинальная_работа\nСТОП', '123_ПРОГА_П\n123_прога_п\n123ПРОГАП?\n123 ПРОГА п\nСТОП', '_дизайнер_\n_ПРОГРАМИСТ_\n_пробный\nПРОЕКТ!\n_____п\nСТОП', 'ПРОЕКТ_1\nПРОЕКТ_2\nПРОЕКТ_3\nПРОЕКТ!4\nСТОП']","['1', '0', '1', '1', '1']","result = 0

while True:
    info = input()
    if info == 'END':
        break
    
    if '_' not in info and info.isupper():
        result += 1
        
print(result)","result = 0

while True:
    info = input()
    if info == 'СТОП':
        break
    
    if '_' not in info and info.isupper():
        result += 1
        
print(result)",Обратите внимание на некорректное использование переменной для прерывания цикла while. ,"['open', 'open', 'closed', 'closed', 'closed']","<Task description>: Реализуйте программу, которая определит количество корректных названий проектов для конкурса дизайнеров интерьера:

В цикле while считываются названия проектов до тех пор, пока не введена строка ""СТОП"".
Гарантируется, что названия проектов не повторяются. 
Гарантируется, что до строки ""СТОП"" будет введена как минимум одна строка.
Напечатайте количество проектов, которые состоят только из заглавных букв и в которых нет знака подчеркивания. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: ПРОЕКТ 1
ПРОЕКТ_2
проект 3
Проект_4
интерьер_
_диз_ИНТ
СТОП 
<Вывод>: 1 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: ПРОЕКТ_1
работа_ФИН
Финальная_работа
СТОП 
<Вывод>: 0 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: 123_ПРОГА_П
123_прога_п
123ПРОГАП?
123 ПРОГА п
СТОП 
<Вывод>: 1 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: _дизайнер_
_ПРОГРАМИСТ_
_пробный
ПРОЕКТ!
_____п
СТОП 
<Вывод>: 1 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: ПРОЕКТ_1
ПРОЕКТ_2
ПРОЕКТ_3
ПРОЕКТ!4
СТОП 
<Вывод>: 1 
<Решение студента>: result = 0

while True:
    info = input()
    if info == 'END':
        break
    
    if '_' not in info and info.isupper():
        result += 1
        
print(result) 
<Идеальное решение>: result = 0

while True:
    info = input()
    if info == 'СТОП':
        break
    
    if '_' not in info and info.isupper():
        result += 1
        
print(result) 


<Комментарий эксперта>:"
15,28,2,"Реализуйте программу, которая определит количество корректных названий проектов для конкурса дизайнеров интерьера:

В цикле while считываются названия проектов до тех пор, пока не введена строка ""СТОП"".
Гарантируется, что названия проектов не повторяются. 
Гарантируется, что до строки ""СТОП"" будет введена как минимум одна строка.
Напечатайте количество проектов, которые состоят только из заглавных букв и в которых нет знака подчеркивания.","['ПРОЕКТ 1\nПРОЕКТ_2\nпроект 3\nПроект_4\nинтерьер_\n_диз_ИНТ\nСТОП', 'ПРОЕКТ_1\nработа_ФИН\nФинальная_работа\nСТОП', '123_ПРОГА_П\n123_прога_п\n123ПРОГАП?\n123 ПРОГА п\nСТОП', '_дизайнер_\n_ПРОГРАМИСТ_\n_пробный\nПРОЕКТ!\n_____п\nСТОП', 'ПРОЕКТ_1\nПРОЕКТ_2\nПРОЕКТ_3\nПРОЕКТ!4\nСТОП']","['1', '0', '1', '1', '1']","result = 0

while True:
    info = input()
    if info == 'СТОП':
    break
    
    if '_' not in info and info.isupper():
        result += 1
        
print(result)","result = 0

while True:
    info = input()
    if info == 'СТОП':
        break
    
    if '_' not in info and info.isupper():
        result += 1
        
print(result)",Обратите внимание на ошибку в табуляции выражения break.,"['open', 'open', 'closed', 'closed', 'closed']","<Task description>: Реализуйте программу, которая определит количество корректных названий проектов для конкурса дизайнеров интерьера:

В цикле while считываются названия проектов до тех пор, пока не введена строка ""СТОП"".
Гарантируется, что названия проектов не повторяются. 
Гарантируется, что до строки ""СТОП"" будет введена как минимум одна строка.
Напечатайте количество проектов, которые состоят только из заглавных букв и в которых нет знака подчеркивания. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: ПРОЕКТ 1
ПРОЕКТ_2
проект 3
Проект_4
интерьер_
_диз_ИНТ
СТОП 
<Вывод>: 1 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: ПРОЕКТ_1
работа_ФИН
Финальная_работа
СТОП 
<Вывод>: 0 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: 123_ПРОГА_П
123_прога_п
123ПРОГАП?
123 ПРОГА п
СТОП 
<Вывод>: 1 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: _дизайнер_
_ПРОГРАМИСТ_
_пробный
ПРОЕКТ!
_____п
СТОП 
<Вывод>: 1 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: ПРОЕКТ_1
ПРОЕКТ_2
ПРОЕКТ_3
ПРОЕКТ!4
СТОП 
<Вывод>: 1 
<Решение студента>: result = 0

while True:
    info = input()
    if info == 'СТОП':
    break
    
    if '_' not in info and info.isupper():
        result += 1
        
print(result) 
<Идеальное решение>: result = 0

while True:
    info = input()
    if info == 'СТОП':
        break
    
    if '_' not in info and info.isupper():
        result += 1
        
print(result) 


<Комментарий эксперта>:"
16,29,2,"Реализуйте программу, которая определит количество корректных названий проектов для конкурса дизайнеров интерьера:

В цикле while считываются названия проектов до тех пор, пока не введена строка ""СТОП"".
Гарантируется, что названия проектов не повторяются. 
Гарантируется, что до строки ""СТОП"" будет введена как минимум одна строка.
Напечатайте количество проектов, которые состоят только из заглавных букв и в которых нет знака подчеркивания.","['ПРОЕКТ 1\nПРОЕКТ_2\nпроект 3\nПроект_4\nинтерьер_\n_диз_ИНТ\nСТОП', 'ПРОЕКТ_1\nработа_ФИН\nФинальная_работа\nСТОП', '123_ПРОГА_П\n123_прога_п\n123ПРОГАП?\n123 ПРОГА п\nСТОП', '_дизайнер_\n_ПРОГРАМИСТ_\n_пробный\nПРОЕКТ!\n_____п\nСТОП', 'ПРОЕКТ_1\nПРОЕКТ_2\nПРОЕКТ_3\nПРОЕКТ!4\nСТОП']","['1', '0', '1', '1', '1']","result = 0

while True:
    info = input()
    if result == 'СТОП':
        break
    
    if '_' not in info and info.isupper():
        result += 1
        
print(result)","result = 0

while True:
    info = input()
    if info == 'СТОП':
        break
    
    if '_' not in info and info.isupper():
        result += 1
        
print(result)",Вы использовали неверную переменную для остановки цикла while.,"['open', 'open', 'closed', 'closed', 'closed']","<Task description>: Реализуйте программу, которая определит количество корректных названий проектов для конкурса дизайнеров интерьера:

В цикле while считываются названия проектов до тех пор, пока не введена строка ""СТОП"".
Гарантируется, что названия проектов не повторяются. 
Гарантируется, что до строки ""СТОП"" будет введена как минимум одна строка.
Напечатайте количество проектов, которые состоят только из заглавных букв и в которых нет знака подчеркивания. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: ПРОЕКТ 1
ПРОЕКТ_2
проект 3
Проект_4
интерьер_
_диз_ИНТ
СТОП 
<Вывод>: 1 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: ПРОЕКТ_1
работа_ФИН
Финальная_работа
СТОП 
<Вывод>: 0 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: 123_ПРОГА_П
123_прога_п
123ПРОГАП?
123 ПРОГА п
СТОП 
<Вывод>: 1 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: _дизайнер_
_ПРОГРАМИСТ_
_пробный
ПРОЕКТ!
_____п
СТОП 
<Вывод>: 1 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: ПРОЕКТ_1
ПРОЕКТ_2
ПРОЕКТ_3
ПРОЕКТ!4
СТОП 
<Вывод>: 1 
<Решение студента>: result = 0

while True:
    info = input()
    if result == 'СТОП':
        break
    
    if '_' not in info and info.isupper():
        result += 1
        
print(result) 
<Идеальное решение>: result = 0

while True:
    info = input()
    if info == 'СТОП':
        break
    
    if '_' not in info and info.isupper():
        result += 1
        
print(result) 


<Комментарий эксперта>:"
17,30,2,"Реализуйте программу, которая определит количество корректных названий проектов для конкурса дизайнеров интерьера:

В цикле while считываются названия проектов до тех пор, пока не введена строка ""СТОП"".
Гарантируется, что названия проектов не повторяются. 
Гарантируется, что до строки ""СТОП"" будет введена как минимум одна строка.
Напечатайте количество проектов, которые состоят только из заглавных букв и в которых нет знака подчеркивания.","['ПРОЕКТ 1\nПРОЕКТ_2\nпроект 3\nПроект_4\nинтерьер_\n_диз_ИНТ\nСТОП', 'ПРОЕКТ_1\nработа_ФИН\nФинальная_работа\nСТОП', '123_ПРОГА_П\n123_прога_п\n123ПРОГАП?\n123 ПРОГА п\nСТОП', '_дизайнер_\n_ПРОГРАМИСТ_\n_пробный\nПРОЕКТ!\n_____п\nСТОП', 'ПРОЕКТ_1\nПРОЕКТ_2\nПРОЕКТ_3\nПРОЕКТ!4\nСТОП']","['1', '0', '1', '1', '1']","result = 0

while True
    info = input()
    if info == 'СТОП':
        break
    
    if '_' not in info and info.isupper():
        result += 1
        
print(result)","result = 0

while True:
    info = input()
    if info == 'СТОП':
        break
    
    if '_' not in info and info.isupper():
        result += 1
        
print(result)",Вы забыли поставить двоеточие после условия в цикле while.,"['open', 'open', 'closed', 'closed', 'closed']","<Task description>: Реализуйте программу, которая определит количество корректных названий проектов для конкурса дизайнеров интерьера:

В цикле while считываются названия проектов до тех пор, пока не введена строка ""СТОП"".
Гарантируется, что названия проектов не повторяются. 
Гарантируется, что до строки ""СТОП"" будет введена как минимум одна строка.
Напечатайте количество проектов, которые состоят только из заглавных букв и в которых нет знака подчеркивания. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: ПРОЕКТ 1
ПРОЕКТ_2
проект 3
Проект_4
интерьер_
_диз_ИНТ
СТОП 
<Вывод>: 1 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: ПРОЕКТ_1
работа_ФИН
Финальная_работа
СТОП 
<Вывод>: 0 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: 123_ПРОГА_П
123_прога_п
123ПРОГАП?
123 ПРОГА п
СТОП 
<Вывод>: 1 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: _дизайнер_
_ПРОГРАМИСТ_
_пробный
ПРОЕКТ!
_____п
СТОП 
<Вывод>: 1 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: ПРОЕКТ_1
ПРОЕКТ_2
ПРОЕКТ_3
ПРОЕКТ!4
СТОП 
<Вывод>: 1 
<Решение студента>: result = 0

while True
    info = input()
    if info == 'СТОП':
        break
    
    if '_' not in info and info.isupper():
        result += 1
        
print(result) 
<Идеальное решение>: result = 0

while True:
    info = input()
    if info == 'СТОП':
        break
    
    if '_' not in info and info.isupper():
        result += 1
        
print(result) 


<Комментарий эксперта>:"
18,31,2,"Реализуйте программу, которая определит количество корректных названий проектов для конкурса дизайнеров интерьера:

В цикле while считываются названия проектов до тех пор, пока не введена строка ""СТОП"".
Гарантируется, что названия проектов не повторяются. 
Гарантируется, что до строки ""СТОП"" будет введена как минимум одна строка.
Напечатайте количество проектов, которые состоят только из заглавных букв и в которых нет знака подчеркивания.","['ПРОЕКТ 1\nПРОЕКТ_2\nпроект 3\nПроект_4\nинтерьер_\n_диз_ИНТ\nСТОП', 'ПРОЕКТ_1\nработа_ФИН\nФинальная_работа\nСТОП', '123_ПРОГА_П\n123_прога_п\n123ПРОГАП?\n123 ПРОГА п\nСТОП', '_дизайнер_\n_ПРОГРАМИСТ_\n_пробный\nПРОЕКТ!\n_____п\nСТОП', 'ПРОЕКТ_1\nПРОЕКТ_2\nПРОЕКТ_3\nПРОЕКТ!4\nСТОП']","['1', '0', '1', '1', '1']","result = 0

while True:
    info = input()
    if info = 'СТОП':
        break
    
    if '_' not in info and info.isupper():
        result += 1
        
print(result)","result = 0

while True:
    info = input()
    if info == 'СТОП':
        break
    
    if '_' not in info and info.isupper():
        result += 1
        
print(result)",Вы используете некорректное условие для остановки цикла while.,"['open', 'open', 'closed', 'closed', 'closed']","<Task description>: Реализуйте программу, которая определит количество корректных названий проектов для конкурса дизайнеров интерьера:

В цикле while считываются названия проектов до тех пор, пока не введена строка ""СТОП"".
Гарантируется, что названия проектов не повторяются. 
Гарантируется, что до строки ""СТОП"" будет введена как минимум одна строка.
Напечатайте количество проектов, которые состоят только из заглавных букв и в которых нет знака подчеркивания. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: ПРОЕКТ 1
ПРОЕКТ_2
проект 3
Проект_4
интерьер_
_диз_ИНТ
СТОП 
<Вывод>: 1 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: ПРОЕКТ_1
работа_ФИН
Финальная_работа
СТОП 
<Вывод>: 0 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: 123_ПРОГА_П
123_прога_п
123ПРОГАП?
123 ПРОГА п
СТОП 
<Вывод>: 1 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: _дизайнер_
_ПРОГРАМИСТ_
_пробный
ПРОЕКТ!
_____п
СТОП 
<Вывод>: 1 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: ПРОЕКТ_1
ПРОЕКТ_2
ПРОЕКТ_3
ПРОЕКТ!4
СТОП 
<Вывод>: 1 
<Решение студента>: result = 0

while True:
    info = input()
    if info = 'СТОП':
        break
    
    if '_' not in info and info.isupper():
        result += 1
        
print(result) 
<Идеальное решение>: result = 0

while True:
    info = input()
    if info == 'СТОП':
        break
    
    if '_' not in info and info.isupper():
        result += 1
        
print(result) 


<Комментарий эксперта>:"
19,32,2,"Реализуйте программу, которая определит количество корректных названий проектов для конкурса дизайнеров интерьера:

В цикле while считываются названия проектов до тех пор, пока не введена строка ""СТОП"".
Гарантируется, что названия проектов не повторяются. 
Гарантируется, что до строки ""СТОП"" будет введена как минимум одна строка.
Напечатайте количество проектов, которые состоят только из заглавных букв и в которых нет знака подчеркивания.","['ПРОЕКТ 1\nПРОЕКТ_2\nпроект 3\nПроект_4\nинтерьер_\n_диз_ИНТ\nСТОП', 'ПРОЕКТ_1\nработа_ФИН\nФинальная_работа\nСТОП', '123_ПРОГА_П\n123_прога_п\n123ПРОГАП?\n123 ПРОГА п\nСТОП', '_дизайнер_\n_ПРОГРАМИСТ_\n_пробный\nПРОЕКТ!\n_____п\nСТОП', 'ПРОЕКТ_1\nПРОЕКТ_2\nПРОЕКТ_3\nПРОЕКТ!4\nСТОП']","['1', '0', '1', '1', '1']","while True:
    info = input()
    if info == 'СТОП':
        break
    
    if '_' not in info and info.isupper():
        result += 1
        
print(result)","result = 0

while True:
    info = input()
    if info == 'СТОП':
        break
    
    if '_' not in info and info.isupper():
        result += 1
        
print(result)","Обратите внимание, что переменная result не определена.","['open', 'open', 'closed', 'closed', 'closed']","<Task description>: Реализуйте программу, которая определит количество корректных названий проектов для конкурса дизайнеров интерьера:

В цикле while считываются названия проектов до тех пор, пока не введена строка ""СТОП"".
Гарантируется, что названия проектов не повторяются. 
Гарантируется, что до строки ""СТОП"" будет введена как минимум одна строка.
Напечатайте количество проектов, которые состоят только из заглавных букв и в которых нет знака подчеркивания. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: ПРОЕКТ 1
ПРОЕКТ_2
проект 3
Проект_4
интерьер_
_диз_ИНТ
СТОП 
<Вывод>: 1 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: ПРОЕКТ_1
работа_ФИН
Финальная_работа
СТОП 
<Вывод>: 0 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: 123_ПРОГА_П
123_прога_п
123ПРОГАП?
123 ПРОГА п
СТОП 
<Вывод>: 1 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: _дизайнер_
_ПРОГРАМИСТ_
_пробный
ПРОЕКТ!
_____п
СТОП 
<Вывод>: 1 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: ПРОЕКТ_1
ПРОЕКТ_2
ПРОЕКТ_3
ПРОЕКТ!4
СТОП 
<Вывод>: 1 
<Решение студента>: while True:
    info = input()
    if info == 'СТОП':
        break
    
    if '_' not in info and info.isupper():
        result += 1
        
print(result) 
<Идеальное решение>: result = 0

while True:
    info = input()
    if info == 'СТОП':
        break
    
    if '_' not in info and info.isupper():
        result += 1
        
print(result) 


<Комментарий эксперта>:"
20,33,2,"Реализуйте программу, которая определит количество корректных названий проектов для конкурса дизайнеров интерьера:

В цикле while считываются названия проектов до тех пор, пока не введена строка ""СТОП"".
Гарантируется, что названия проектов не повторяются. 
Гарантируется, что до строки ""СТОП"" будет введена как минимум одна строка.
Напечатайте количество проектов, которые состоят только из заглавных букв и в которых нет знака подчеркивания.","['ПРОЕКТ 1\nПРОЕКТ_2\nпроект 3\nПроект_4\nинтерьер_\n_диз_ИНТ\nСТОП', 'ПРОЕКТ_1\nработа_ФИН\nФинальная_работа\nСТОП', '123_ПРОГА_П\n123_прога_п\n123ПРОГАП?\n123 ПРОГА п\nСТОП', '_дизайнер_\n_ПРОГРАМИСТ_\n_пробный\nПРОЕКТ!\n_____п\nСТОП', 'ПРОЕКТ_1\nПРОЕКТ_2\nПРОЕКТ_3\nПРОЕКТ!4\nСТОП']","['1', '0', '1', '1', '1']","result = 0

while True:
    info = input()
    if info == 'СТОП':
        break
    
if '_' not in info and info.isupper():
    result += 1
        
print(result)","result = 0

while True:
    info = input()
    if info == 'СТОП':
        break
    
    if '_' not in info and info.isupper():
        result += 1
        
print(result)",Обратите внимание на ошибку в табуляции условия if.,"['open', 'open', 'closed', 'closed', 'closed']","<Task description>: Реализуйте программу, которая определит количество корректных названий проектов для конкурса дизайнеров интерьера:

В цикле while считываются названия проектов до тех пор, пока не введена строка ""СТОП"".
Гарантируется, что названия проектов не повторяются. 
Гарантируется, что до строки ""СТОП"" будет введена как минимум одна строка.
Напечатайте количество проектов, которые состоят только из заглавных букв и в которых нет знака подчеркивания. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: ПРОЕКТ 1
ПРОЕКТ_2
проект 3
Проект_4
интерьер_
_диз_ИНТ
СТОП 
<Вывод>: 1 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: ПРОЕКТ_1
работа_ФИН
Финальная_работа
СТОП 
<Вывод>: 0 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: 123_ПРОГА_П
123_прога_п
123ПРОГАП?
123 ПРОГА п
СТОП 
<Вывод>: 1 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: _дизайнер_
_ПРОГРАМИСТ_
_пробный
ПРОЕКТ!
_____п
СТОП 
<Вывод>: 1 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: ПРОЕКТ_1
ПРОЕКТ_2
ПРОЕКТ_3
ПРОЕКТ!4
СТОП 
<Вывод>: 1 
<Решение студента>: result = 0

while True:
    info = input()
    if info == 'СТОП':
        break
    
if '_' not in info and info.isupper():
    result += 1
        
print(result) 
<Идеальное решение>: result = 0

while True:
    info = input()
    if info == 'СТОП':
        break
    
    if '_' not in info and info.isupper():
        result += 1
        
print(result) 


<Комментарий эксперта>:"
21,34,2,"Реализуйте программу, которая определит количество корректных названий проектов для конкурса дизайнеров интерьера:

В цикле while считываются названия проектов до тех пор, пока не введена строка ""СТОП"".
Гарантируется, что названия проектов не повторяются. 
Гарантируется, что до строки ""СТОП"" будет введена как минимум одна строка.
Напечатайте количество проектов, которые состоят только из заглавных букв и в которых нет знака подчеркивания.","['ПРОЕКТ 1\nПРОЕКТ_2\nпроект 3\nПроект_4\nинтерьер_\n_диз_ИНТ\nСТОП', 'ПРОЕКТ_1\nработа_ФИН\nФинальная_работа\nСТОП', '123_ПРОГА_П\n123_прога_п\n123ПРОГАП?\n123 ПРОГА п\nСТОП', '_дизайнер_\n_ПРОГРАМИСТ_\n_пробный\nПРОЕКТ!\n_____п\nСТОП', 'ПРОЕКТ_1\nПРОЕКТ_2\nПРОЕКТ_3\nПРОЕКТ!4\nСТОП']","['1', '0', '1', '1', '1']","result = 0

while True:
    info = input()
    if info == 'СТОП':
        break
    
    if _ not in info and info.isupper():
        result += 1
        
print(result)","result = 0

while True:
    info = input()
    if info == 'СТОП':
        break
    
    if '_' not in info and info.isupper():
        result += 1
        
print(result)",Вы забыли поставить знак нижнего подчеркивания в кавычки.,"['open', 'open', 'closed', 'closed', 'closed']","<Task description>: Реализуйте программу, которая определит количество корректных названий проектов для конкурса дизайнеров интерьера:

В цикле while считываются названия проектов до тех пор, пока не введена строка ""СТОП"".
Гарантируется, что названия проектов не повторяются. 
Гарантируется, что до строки ""СТОП"" будет введена как минимум одна строка.
Напечатайте количество проектов, которые состоят только из заглавных букв и в которых нет знака подчеркивания. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: ПРОЕКТ 1
ПРОЕКТ_2
проект 3
Проект_4
интерьер_
_диз_ИНТ
СТОП 
<Вывод>: 1 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: ПРОЕКТ_1
работа_ФИН
Финальная_работа
СТОП 
<Вывод>: 0 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: 123_ПРОГА_П
123_прога_п
123ПРОГАП?
123 ПРОГА п
СТОП 
<Вывод>: 1 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: _дизайнер_
_ПРОГРАМИСТ_
_пробный
ПРОЕКТ!
_____п
СТОП 
<Вывод>: 1 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: ПРОЕКТ_1
ПРОЕКТ_2
ПРОЕКТ_3
ПРОЕКТ!4
СТОП 
<Вывод>: 1 
<Решение студента>: result = 0

while True:
    info = input()
    if info == 'СТОП':
        break
    
    if _ not in info and info.isupper():
        result += 1
        
print(result) 
<Идеальное решение>: result = 0

while True:
    info = input()
    if info == 'СТОП':
        break
    
    if '_' not in info and info.isupper():
        result += 1
        
print(result) 


<Комментарий эксперта>:"
22,35,2,"Реализуйте программу, которая определит количество корректных названий проектов для конкурса дизайнеров интерьера:

В цикле while считываются названия проектов до тех пор, пока не введена строка ""СТОП"".
Гарантируется, что названия проектов не повторяются. 
Гарантируется, что до строки ""СТОП"" будет введена как минимум одна строка.
Напечатайте количество проектов, которые состоят только из заглавных букв и в которых нет знака подчеркивания.","['ПРОЕКТ 1\nПРОЕКТ_2\nпроект 3\nПроект_4\nинтерьер_\n_диз_ИНТ\nСТОП', 'ПРОЕКТ_1\nработа_ФИН\nФинальная_работа\nСТОП', '123_ПРОГА_П\n123_прога_п\n123ПРОГАП?\n123 ПРОГА п\nСТОП', '_дизайнер_\n_ПРОГРАМИСТ_\n_пробный\nПРОЕКТ!\n_____п\nСТОП', 'ПРОЕКТ_1\nПРОЕКТ_2\nПРОЕКТ_3\nПРОЕКТ!4\nСТОП']","['1', '0', '1', '1', '1']","result = 0

while True:
    info = input()
    if info == 'СТОП':
        break
    
    if '_' in info and info.isupper():
        result += 1
        
print(result)","result = 0

while True:
    info = input()
    if info == 'СТОП':
        break
    
    if '_' not in info and info.isupper():
        result += 1
        
print(result)","Ошибка в открытых и скрытых тестах. 

Ваш код некорректно проверяет условия задания. Например, он считает количество проектов, которые состоят только из заглавных букв и в которых есть знак подчеркивания. Попробуйте изменить условие if, чтобы скорректировать ошибку.","['open', 'open', 'closed', 'closed', 'closed']","<Task description>: Реализуйте программу, которая определит количество корректных названий проектов для конкурса дизайнеров интерьера:

В цикле while считываются названия проектов до тех пор, пока не введена строка ""СТОП"".
Гарантируется, что названия проектов не повторяются. 
Гарантируется, что до строки ""СТОП"" будет введена как минимум одна строка.
Напечатайте количество проектов, которые состоят только из заглавных букв и в которых нет знака подчеркивания. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: ПРОЕКТ 1
ПРОЕКТ_2
проект 3
Проект_4
интерьер_
_диз_ИНТ
СТОП 
<Вывод>: 1 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: ПРОЕКТ_1
работа_ФИН
Финальная_работа
СТОП 
<Вывод>: 0 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: 123_ПРОГА_П
123_прога_п
123ПРОГАП?
123 ПРОГА п
СТОП 
<Вывод>: 1 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: _дизайнер_
_ПРОГРАМИСТ_
_пробный
ПРОЕКТ!
_____п
СТОП 
<Вывод>: 1 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: ПРОЕКТ_1
ПРОЕКТ_2
ПРОЕКТ_3
ПРОЕКТ!4
СТОП 
<Вывод>: 1 
<Решение студента>: result = 0

while True:
    info = input()
    if info == 'СТОП':
        break
    
    if '_' in info and info.isupper():
        result += 1
        
print(result) 
<Идеальное решение>: result = 0

while True:
    info = input()
    if info == 'СТОП':
        break
    
    if '_' not in info and info.isupper():
        result += 1
        
print(result) 


<Комментарий эксперта>:"
23,36,2,"Реализуйте программу, которая определит количество корректных названий проектов для конкурса дизайнеров интерьера:

В цикле while считываются названия проектов до тех пор, пока не введена строка ""СТОП"".
Гарантируется, что названия проектов не повторяются. 
Гарантируется, что до строки ""СТОП"" будет введена как минимум одна строка.
Напечатайте количество проектов, которые состоят только из заглавных букв и в которых нет знака подчеркивания.","['ПРОЕКТ 1\nПРОЕКТ_2\nпроект 3\nПроект_4\nинтерьер_\n_диз_ИНТ\nСТОП', 'ПРОЕКТ_1\nработа_ФИН\nФинальная_работа\nСТОП', '123_ПРОГА_П\n123_прога_п\n123ПРОГАП?\n123 ПРОГА п\nСТОП', '_дизайнер_\n_ПРОГРАМИСТ_\n_пробный\nПРОЕКТ!\n_____п\nСТОП', 'ПРОЕКТ_1\nПРОЕКТ_2\nПРОЕКТ_3\nПРОЕКТ!4\nСТОП']","['1', '0', '1', '1', '1']","result = 0

while True:
    info = input()
    if info == 'СТОП':
        break
    
    if '_' not in info:
        result += 1
        
print(result)","result = 0

while True:
    info = input()
    if info == 'СТОП':
        break
    
    if '_' not in info and info.isupper():
        result += 1
        
print(result)","Ошибка в открытых и скрытых тестах. 

Ваш код охватывает не все возможные случаи. Например, он не проверяет, состоят ли проекты только из заглавных букв. Попробуйте дополнить условие if, чтобы охватить все возможные случаи.","['open', 'open', 'closed', 'closed', 'closed']","<Task description>: Реализуйте программу, которая определит количество корректных названий проектов для конкурса дизайнеров интерьера:

В цикле while считываются названия проектов до тех пор, пока не введена строка ""СТОП"".
Гарантируется, что названия проектов не повторяются. 
Гарантируется, что до строки ""СТОП"" будет введена как минимум одна строка.
Напечатайте количество проектов, которые состоят только из заглавных букв и в которых нет знака подчеркивания. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: ПРОЕКТ 1
ПРОЕКТ_2
проект 3
Проект_4
интерьер_
_диз_ИНТ
СТОП 
<Вывод>: 1 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: ПРОЕКТ_1
работа_ФИН
Финальная_работа
СТОП 
<Вывод>: 0 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: 123_ПРОГА_П
123_прога_п
123ПРОГАП?
123 ПРОГА п
СТОП 
<Вывод>: 1 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: _дизайнер_
_ПРОГРАМИСТ_
_пробный
ПРОЕКТ!
_____п
СТОП 
<Вывод>: 1 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: ПРОЕКТ_1
ПРОЕКТ_2
ПРОЕКТ_3
ПРОЕКТ!4
СТОП 
<Вывод>: 1 
<Решение студента>: result = 0

while True:
    info = input()
    if info == 'СТОП':
        break
    
    if '_' not in info:
        result += 1
        
print(result) 
<Идеальное решение>: result = 0

while True:
    info = input()
    if info == 'СТОП':
        break
    
    if '_' not in info and info.isupper():
        result += 1
        
print(result) 


<Комментарий эксперта>:"
24,37,2,"Реализуйте программу, которая определит количество корректных названий проектов для конкурса дизайнеров интерьера:

В цикле while считываются названия проектов до тех пор, пока не введена строка ""СТОП"".
Гарантируется, что названия проектов не повторяются. 
Гарантируется, что до строки ""СТОП"" будет введена как минимум одна строка.
Напечатайте количество проектов, которые состоят только из заглавных букв и в которых нет знака подчеркивания.","['ПРОЕКТ 1\nПРОЕКТ_2\nпроект 3\nПроект_4\nинтерьер_\n_диз_ИНТ\nСТОП', 'ПРОЕКТ_1\nработа_ФИН\nФинальная_работа\nСТОП', '123_ПРОГА_П\n123_прога_п\n123ПРОГАП?\n123 ПРОГА п\nСТОП', '_дизайнер_\n_ПРОГРАМИСТ_\n_пробный\nПРОЕКТ!\n_____п\nСТОП', 'ПРОЕКТ_1\nПРОЕКТ_2\nПРОЕКТ_3\nПРОЕКТ!4\nСТОП']","['1', '0', '1', '1', '1']","result = 0

while True:
    info = input()
    if info == 'СТОП':
        break
    
    if '_' not in info and info.upper():
        result += 1
        
print(result)","result = 0

while True:
    info = input()
    if info == 'СТОП':
        break
    
    if '_' not in info and info.isupper():
        result += 1
        
print(result)",Ошибка в использовании метода проверки заглавных букв. Метод .upper() конвертирует все символы строки в заглавные.,"['open', 'open', 'closed', 'closed', 'closed']","<Task description>: Реализуйте программу, которая определит количество корректных названий проектов для конкурса дизайнеров интерьера:

В цикле while считываются названия проектов до тех пор, пока не введена строка ""СТОП"".
Гарантируется, что названия проектов не повторяются. 
Гарантируется, что до строки ""СТОП"" будет введена как минимум одна строка.
Напечатайте количество проектов, которые состоят только из заглавных букв и в которых нет знака подчеркивания. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: ПРОЕКТ 1
ПРОЕКТ_2
проект 3
Проект_4
интерьер_
_диз_ИНТ
СТОП 
<Вывод>: 1 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: ПРОЕКТ_1
работа_ФИН
Финальная_работа
СТОП 
<Вывод>: 0 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: 123_ПРОГА_П
123_прога_п
123ПРОГАП?
123 ПРОГА п
СТОП 
<Вывод>: 1 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: _дизайнер_
_ПРОГРАМИСТ_
_пробный
ПРОЕКТ!
_____п
СТОП 
<Вывод>: 1 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: ПРОЕКТ_1
ПРОЕКТ_2
ПРОЕКТ_3
ПРОЕКТ!4
СТОП 
<Вывод>: 1 
<Решение студента>: result = 0

while True:
    info = input()
    if info == 'СТОП':
        break
    
    if '_' not in info and info.upper():
        result += 1
        
print(result) 
<Идеальное решение>: result = 0

while True:
    info = input()
    if info == 'СТОП':
        break
    
    if '_' not in info and info.isupper():
        result += 1
        
print(result) 


<Комментарий эксперта>:"
25,38,2,"Реализуйте программу, которая определит количество корректных названий проектов для конкурса дизайнеров интерьера:

В цикле while считываются названия проектов до тех пор, пока не введена строка ""СТОП"".
Гарантируется, что названия проектов не повторяются. 
Гарантируется, что до строки ""СТОП"" будет введена как минимум одна строка.
Напечатайте количество проектов, которые состоят только из заглавных букв и в которых нет знака подчеркивания.","['ПРОЕКТ 1\nПРОЕКТ_2\nпроект 3\nПроект_4\nинтерьер_\n_диз_ИНТ\nСТОП', 'ПРОЕКТ_1\nработа_ФИН\nФинальная_работа\nСТОП', '123_ПРОГА_П\n123_прога_п\n123ПРОГАП?\n123 ПРОГА п\nСТОП', '_дизайнер_\n_ПРОГРАМИСТ_\n_пробный\nПРОЕКТ!\n_____п\nСТОП', 'ПРОЕКТ_1\nПРОЕКТ_2\nПРОЕКТ_3\nПРОЕКТ!4\nСТОП']","['1', '0', '1', '1', '1']","result = 0

while True:
    info = input()
    if info == 'СТОП':
        break
    
    if '_' not in info and info.isupper():
        info += 1
        
print(result)","result = 0

while True:
    info = input()
    if info == 'СТОП':
        break
    
    if '_' not in info and info.isupper():
        result += 1
        
print(result)","Ошибка в открытых и скрытых тестах. 

Ваш код использует некорректную переменную для подсчета количества проектов, соответствующих условиям задания.","['open', 'open', 'closed', 'closed', 'closed']","<Task description>: Реализуйте программу, которая определит количество корректных названий проектов для конкурса дизайнеров интерьера:

В цикле while считываются названия проектов до тех пор, пока не введена строка ""СТОП"".
Гарантируется, что названия проектов не повторяются. 
Гарантируется, что до строки ""СТОП"" будет введена как минимум одна строка.
Напечатайте количество проектов, которые состоят только из заглавных букв и в которых нет знака подчеркивания. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: ПРОЕКТ 1
ПРОЕКТ_2
проект 3
Проект_4
интерьер_
_диз_ИНТ
СТОП 
<Вывод>: 1 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: ПРОЕКТ_1
работа_ФИН
Финальная_работа
СТОП 
<Вывод>: 0 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: 123_ПРОГА_П
123_прога_п
123ПРОГАП?
123 ПРОГА п
СТОП 
<Вывод>: 1 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: _дизайнер_
_ПРОГРАМИСТ_
_пробный
ПРОЕКТ!
_____п
СТОП 
<Вывод>: 1 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: ПРОЕКТ_1
ПРОЕКТ_2
ПРОЕКТ_3
ПРОЕКТ!4
СТОП 
<Вывод>: 1 
<Решение студента>: result = 0

while True:
    info = input()
    if info == 'СТОП':
        break
    
    if '_' not in info and info.isupper():
        info += 1
        
print(result) 
<Идеальное решение>: result = 0

while True:
    info = input()
    if info == 'СТОП':
        break
    
    if '_' not in info and info.isupper():
        result += 1
        
print(result) 


<Комментарий эксперта>:"
26,39,2,"Реализуйте программу, которая определит количество корректных названий проектов для конкурса дизайнеров интерьера:

В цикле while считываются названия проектов до тех пор, пока не введена строка ""СТОП"".
Гарантируется, что названия проектов не повторяются. 
Гарантируется, что до строки ""СТОП"" будет введена как минимум одна строка.
Напечатайте количество проектов, которые состоят только из заглавных букв и в которых нет знака подчеркивания.","['ПРОЕКТ 1\nПРОЕКТ_2\nпроект 3\nПроект_4\nинтерьер_\n_диз_ИНТ\nСТОП', 'ПРОЕКТ_1\nработа_ФИН\nФинальная_работа\nСТОП', '123_ПРОГА_П\n123_прога_п\n123ПРОГАП?\n123 ПРОГА п\nСТОП', '_дизайнер_\n_ПРОГРАМИСТ_\n_пробный\nПРОЕКТ!\n_____п\nСТОП', 'ПРОЕКТ_1\nПРОЕКТ_2\nПРОЕКТ_3\nПРОЕКТ!4\nСТОП']","['1', '0', '1', '1', '1']","result = 0

while True:
    info = input()
    if info == 'СТОП':
        break
    
    if '_' not in info and info.isupper():
        result + 1
        
print(result)","result = 0

while True:
    info = input()
    if info == 'СТОП':
        break
    
    if '_' not in info and info.isupper():
        result += 1
        
print(result)","Ошибка в методе подсчета количества проектов, соответствующих условиям задания.","['open', 'open', 'closed', 'closed', 'closed']","<Task description>: Реализуйте программу, которая определит количество корректных названий проектов для конкурса дизайнеров интерьера:

В цикле while считываются названия проектов до тех пор, пока не введена строка ""СТОП"".
Гарантируется, что названия проектов не повторяются. 
Гарантируется, что до строки ""СТОП"" будет введена как минимум одна строка.
Напечатайте количество проектов, которые состоят только из заглавных букв и в которых нет знака подчеркивания. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: ПРОЕКТ 1
ПРОЕКТ_2
проект 3
Проект_4
интерьер_
_диз_ИНТ
СТОП 
<Вывод>: 1 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: ПРОЕКТ_1
работа_ФИН
Финальная_работа
СТОП 
<Вывод>: 0 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: 123_ПРОГА_П
123_прога_п
123ПРОГАП?
123 ПРОГА п
СТОП 
<Вывод>: 1 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: _дизайнер_
_ПРОГРАМИСТ_
_пробный
ПРОЕКТ!
_____п
СТОП 
<Вывод>: 1 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: ПРОЕКТ_1
ПРОЕКТ_2
ПРОЕКТ_3
ПРОЕКТ!4
СТОП 
<Вывод>: 1 
<Решение студента>: result = 0

while True:
    info = input()
    if info == 'СТОП':
        break
    
    if '_' not in info and info.isupper():
        result + 1
        
print(result) 
<Идеальное решение>: result = 0

while True:
    info = input()
    if info == 'СТОП':
        break
    
    if '_' not in info and info.isupper():
        result += 1
        
print(result) 


<Комментарий эксперта>:"
27,40,2,"Реализуйте программу, которая определит количество корректных названий проектов для конкурса дизайнеров интерьера:

В цикле while считываются названия проектов до тех пор, пока не введена строка ""СТОП"".
Гарантируется, что названия проектов не повторяются. 
Гарантируется, что до строки ""СТОП"" будет введена как минимум одна строка.
Напечатайте количество проектов, которые состоят только из заглавных букв и в которых нет знака подчеркивания.","['ПРОЕКТ 1\nПРОЕКТ_2\nпроект 3\nПроект_4\nинтерьер_\n_диз_ИНТ\nСТОП', 'ПРОЕКТ_1\nработа_ФИН\nФинальная_работа\nСТОП', '123_ПРОГА_П\n123_прога_п\n123ПРОГАП?\n123 ПРОГА п\nСТОП', '_дизайнер_\n_ПРОГРАМИСТ_\n_пробный\nПРОЕКТ!\n_____п\nСТОП', 'ПРОЕКТ_1\nПРОЕКТ_2\nПРОЕКТ_3\nПРОЕКТ!4\nСТОП']","['1', '0', '1', '1', '1']","result = 0

while True:
    info = input()
    if info == 'СТОП':
        break
    
    if '_' not in info and info.isupper():
        result += 1
        
    print(result)","result = 0

while True:
    info = input()
    if info == 'СТОП':
        break
    
    if '_' not in info and info.isupper():
        result += 1
        
print(result)",Вы некорректно поставили отступы перед функцией print().,"['open', 'open', 'closed', 'closed', 'closed']","<Task description>: Реализуйте программу, которая определит количество корректных названий проектов для конкурса дизайнеров интерьера:

В цикле while считываются названия проектов до тех пор, пока не введена строка ""СТОП"".
Гарантируется, что названия проектов не повторяются. 
Гарантируется, что до строки ""СТОП"" будет введена как минимум одна строка.
Напечатайте количество проектов, которые состоят только из заглавных букв и в которых нет знака подчеркивания. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: ПРОЕКТ 1
ПРОЕКТ_2
проект 3
Проект_4
интерьер_
_диз_ИНТ
СТОП 
<Вывод>: 1 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: ПРОЕКТ_1
работа_ФИН
Финальная_работа
СТОП 
<Вывод>: 0 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: 123_ПРОГА_П
123_прога_п
123ПРОГАП?
123 ПРОГА п
СТОП 
<Вывод>: 1 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: _дизайнер_
_ПРОГРАМИСТ_
_пробный
ПРОЕКТ!
_____п
СТОП 
<Вывод>: 1 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: ПРОЕКТ_1
ПРОЕКТ_2
ПРОЕКТ_3
ПРОЕКТ!4
СТОП 
<Вывод>: 1 
<Решение студента>: result = 0

while True:
    info = input()
    if info == 'СТОП':
        break
    
    if '_' not in info and info.isupper():
        result += 1
        
    print(result) 
<Идеальное решение>: result = 0

while True:
    info = input()
    if info == 'СТОП':
        break
    
    if '_' not in info and info.isupper():
        result += 1
        
print(result) 


<Комментарий эксперта>:"
28,41,2,"Реализуйте программу, которая определит количество корректных названий проектов для конкурса дизайнеров интерьера:

В цикле while считываются названия проектов до тех пор, пока не введена строка ""СТОП"".
Гарантируется, что названия проектов не повторяются. 
Гарантируется, что до строки ""СТОП"" будет введена как минимум одна строка.
Напечатайте количество проектов, которые состоят только из заглавных букв и в которых нет знака подчеркивания.","['ПРОЕКТ 1\nПРОЕКТ_2\nпроект 3\nПроект_4\nинтерьер_\n_диз_ИНТ\nСТОП', 'ПРОЕКТ_1\nработа_ФИН\nФинальная_работа\nСТОП', '123_ПРОГА_П\n123_прога_п\n123ПРОГАП?\n123 ПРОГА п\nСТОП', '_дизайнер_\n_ПРОГРАМИСТ_\n_пробный\nПРОЕКТ!\n_____п\nСТОП', 'ПРОЕКТ_1\nПРОЕКТ_2\nПРОЕКТ_3\nПРОЕКТ!4\nСТОП']","['1', '0', '1', '1', '1']","result = 0

while True:
    info = input()
    if info == 'СТОП':
        break
    
    if '_' not in info and info.isupper():
        result += 1
        
print(info)","result = 0

while True:
    info = input()
    if info == 'СТОП':
        break
    
    if '_' not in info and info.isupper():
        result += 1
        
print(result)",Вы вывели неверную переменную.,"['open', 'open', 'closed', 'closed', 'closed']","<Task description>: Реализуйте программу, которая определит количество корректных названий проектов для конкурса дизайнеров интерьера:

В цикле while считываются названия проектов до тех пор, пока не введена строка ""СТОП"".
Гарантируется, что названия проектов не повторяются. 
Гарантируется, что до строки ""СТОП"" будет введена как минимум одна строка.
Напечатайте количество проектов, которые состоят только из заглавных букв и в которых нет знака подчеркивания. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: ПРОЕКТ 1
ПРОЕКТ_2
проект 3
Проект_4
интерьер_
_диз_ИНТ
СТОП 
<Вывод>: 1 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: ПРОЕКТ_1
работа_ФИН
Финальная_работа
СТОП 
<Вывод>: 0 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: 123_ПРОГА_П
123_прога_п
123ПРОГАП?
123 ПРОГА п
СТОП 
<Вывод>: 1 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: _дизайнер_
_ПРОГРАМИСТ_
_пробный
ПРОЕКТ!
_____п
СТОП 
<Вывод>: 1 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: ПРОЕКТ_1
ПРОЕКТ_2
ПРОЕКТ_3
ПРОЕКТ!4
СТОП 
<Вывод>: 1 
<Решение студента>: result = 0

while True:
    info = input()
    if info == 'СТОП':
        break
    
    if '_' not in info and info.isupper():
        result += 1
        
print(info) 
<Идеальное решение>: result = 0

while True:
    info = input()
    if info == 'СТОП':
        break
    
    if '_' not in info and info.isupper():
        result += 1
        
print(result) 


<Комментарий эксперта>:"
29,42,2,"Реализуйте программу, которая определит количество корректных названий проектов для конкурса дизайнеров интерьера:

В цикле while считываются названия проектов до тех пор, пока не введена строка ""СТОП"".
Гарантируется, что названия проектов не повторяются. 
Гарантируется, что до строки ""СТОП"" будет введена как минимум одна строка.
Напечатайте количество проектов, которые состоят только из заглавных букв и в которых нет знака подчеркивания.","['ПРОЕКТ 1\nПРОЕКТ_2\nпроект 3\nПроект_4\nинтерьер_\n_диз_ИНТ\nСТОП', 'ПРОЕКТ_1\nработа_ФИН\nФинальная_работа\nСТОП', '123_ПРОГА_П\n123_прога_п\n123ПРОГАП?\n123 ПРОГА п\nСТОП', '_дизайнер_\n_ПРОГРАМИСТ_\n_пробный\nПРОЕКТ!\n_____п\nСТОП', 'ПРОЕКТ_1\nПРОЕКТ_2\nПРОЕКТ_3\nПРОЕКТ!4\nСТОП']","['1', '0', '1', '1', '1']","result = 0

while True:
    info = input()
    if info == 'СТОП':
        break
    
    if '_' not in info:
        result += 1
    elif  info.isupper():
        result += 1
        
print(result)","result = 0

while True:
    info = input()
    if info == 'СТОП':
        break
    
    if '_' not in info and info.isupper():
        result += 1
        
print(result)","Ошибка в открытых и скрытых тестах. 

Обратите внимание, что вы должны проверить, что условия (""состоят только из заглавных букв и в которых нет знака подчеркивания"") выполняются одновременно.","['open', 'open', 'closed', 'closed', 'closed']","<Task description>: Реализуйте программу, которая определит количество корректных названий проектов для конкурса дизайнеров интерьера:

В цикле while считываются названия проектов до тех пор, пока не введена строка ""СТОП"".
Гарантируется, что названия проектов не повторяются. 
Гарантируется, что до строки ""СТОП"" будет введена как минимум одна строка.
Напечатайте количество проектов, которые состоят только из заглавных букв и в которых нет знака подчеркивания. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: ПРОЕКТ 1
ПРОЕКТ_2
проект 3
Проект_4
интерьер_
_диз_ИНТ
СТОП 
<Вывод>: 1 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: ПРОЕКТ_1
работа_ФИН
Финальная_работа
СТОП 
<Вывод>: 0 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: 123_ПРОГА_П
123_прога_п
123ПРОГАП?
123 ПРОГА п
СТОП 
<Вывод>: 1 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: _дизайнер_
_ПРОГРАМИСТ_
_пробный
ПРОЕКТ!
_____п
СТОП 
<Вывод>: 1 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: ПРОЕКТ_1
ПРОЕКТ_2
ПРОЕКТ_3
ПРОЕКТ!4
СТОП 
<Вывод>: 1 
<Решение студента>: result = 0

while True:
    info = input()
    if info == 'СТОП':
        break
    
    if '_' not in info:
        result += 1
    elif  info.isupper():
        result += 1
        
print(result) 
<Идеальное решение>: result = 0

while True:
    info = input()
    if info == 'СТОП':
        break
    
    if '_' not in info and info.isupper():
        result += 1
        
print(result) 


<Комментарий эксперта>:"
30,43,3,"Реализуйте программу, которая напечатает хэштеги из фраз для лендинга сайта: 

В переменную logo считывается текст лендинга. Этот код уже написан.
Программа проверяет, есть ли в этом тексте хэштеги.  Хэштегами можно считать все элементы, которые начинаются со знака ""#"" и которые не состоят только из цифр (не включая знак ""#""). Гарантируется, что хэштеги отделены от другого текста пробелом. 
В конце программа печатает все хэштеги через запятую с пробелом. Хэштеги выводятся в том же порядке, в котором они идут в тексте.
Если знаков хэштегов в тексте нет, то программа ничего не печатает.","['Выучите китайский язык без усилий выполняя задания в приложении ( #the_best_app ) за #20 дней.', 'Ваш вопрос ( #question ) - наш ответ ( #answer ) ! Мы всегда с Вами yf #100 %', 'Мощный рывок для Вашего @бизнеса', 'Я никогда не был #счастье1 #любовь123 #123_123 qwe#qwe', '9 из 10 экспертов рекомендуют # наш #_1223 продукт #__ .', '# #123 #qswr_1 @qws1 $1#qwd 1#123_qwe #0 #____ #$567123']","['#the_best_app', '#question, #answer', nan, '#счастье1, #любовь123, #123_123', '#, #_1223, #__', '#, #qswr_1, #____, #$567123']","logo = input()

res = {}
for info in logo.split():
    if info.startswith('#') and info[1:].isdigit() == False:      
        res.append(info)
        
print(*res, sep=', ')","logo = input()

res = []
for info in logo.split():
    if info.startswith('#') and info[1:].isdigit() == False:      
        res.append(info)
        
print(*res, sep=', ')","Обратите внимание, что к словарям не применим метод .append().","['open', 'open', 'open', 'closed', 'closed', 'closed']","<Task description>: Реализуйте программу, которая напечатает хэштеги из фраз для лендинга сайта: 

В переменную logo считывается текст лендинга. Этот код уже написан.
Программа проверяет, есть ли в этом тексте хэштеги.  Хэштегами можно считать все элементы, которые начинаются со знака ""#"" и которые не состоят только из цифр (не включая знак ""#""). Гарантируется, что хэштеги отделены от другого текста пробелом. 
В конце программа печатает все хэштеги через запятую с пробелом. Хэштеги выводятся в том же порядке, в котором они идут в тексте.
Если знаков хэштегов в тексте нет, то программа ничего не печатает. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: Выучите китайский язык без усилий выполняя задания в приложении ( #the_best_app ) за #20 дней. 
<Вывод>: #the_best_app 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: Ваш вопрос ( #question ) - наш ответ ( #answer ) ! Мы всегда с Вами yf #100 % 
<Вывод>: #question, #answer 
<Example 3>: 
<Тип теста 3>: open 
<Ввод>: Мощный рывок для Вашего @бизнеса 
<Вывод>: nan 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: Я никогда не был #счастье1 #любовь123 #123_123 qwe#qwe 
<Вывод>: #счастье1, #любовь123, #123_123 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: 9 из 10 экспертов рекомендуют # наш #_1223 продукт #__ . 
<Вывод>: #, #_1223, #__ 
<Example 6>: 
<Тип теста 6>: closed 
<Ввод>: # #123 #qswr_1 @qws1 $1#qwd 1#123_qwe #0 #____ #$567123 
<Вывод>: #, #qswr_1, #____, #$567123 
<Решение студента>: logo = input()

res = {}
for info in logo.split():
    if info.startswith('#') and info[1:].isdigit() == False:      
        res.append(info)
        
print(*res, sep=', ') 
<Идеальное решение>: logo = input()

res = []
for info in logo.split():
    if info.startswith('#') and info[1:].isdigit() == False:      
        res.append(info)
        
print(*res, sep=', ') 


<Комментарий эксперта>:"
31,44,3,"Реализуйте программу, которая напечатает хэштеги из фраз для лендинга сайта: 

В переменную logo считывается текст лендинга. Этот код уже написан.
Программа проверяет, есть ли в этом тексте хэштеги.  Хэштегами можно считать все элементы, которые начинаются со знака ""#"" и которые не состоят только из цифр (не включая знак ""#""). Гарантируется, что хэштеги отделены от другого текста пробелом. 
В конце программа печатает все хэштеги через запятую с пробелом. Хэштеги выводятся в том же порядке, в котором они идут в тексте.
Если знаков хэштегов в тексте нет, то программа ничего не печатает.","['Выучите китайский язык без усилий выполняя задания в приложении ( #the_best_app ) за #20 дней.', 'Ваш вопрос ( #question ) - наш ответ ( #answer ) ! Мы всегда с Вами yf #100 %', 'Мощный рывок для Вашего @бизнеса', 'Я никогда не был #счастье1 #любовь123 #123_123 qwe#qwe', '9 из 10 экспертов рекомендуют # наш #_1223 продукт #__ .', '# #123 #qswr_1 @qws1 $1#qwd 1#123_qwe #0 #____ #$567123']","['#the_best_app', '#question, #answer', nan, '#счастье1, #любовь123, #123_123', '#, #_1223, #__', '#, #qswr_1, #____, #$567123']","logo = input()

res = []
for i in logo.split():
    if info.startswith('#') and info[1:].isdigit() == False:      
        res.append(info)
        
print(*res, sep=', ')","logo = input()

res = []
for info in logo.split():
    if info.startswith('#') and info[1:].isdigit() == False:      
        res.append(info)
        
print(*res, sep=', ')",Ошибка в определении переменной. Переменная info не задана.,"['open', 'open', 'open', 'closed', 'closed', 'closed']","<Task description>: Реализуйте программу, которая напечатает хэштеги из фраз для лендинга сайта: 

В переменную logo считывается текст лендинга. Этот код уже написан.
Программа проверяет, есть ли в этом тексте хэштеги.  Хэштегами можно считать все элементы, которые начинаются со знака ""#"" и которые не состоят только из цифр (не включая знак ""#""). Гарантируется, что хэштеги отделены от другого текста пробелом. 
В конце программа печатает все хэштеги через запятую с пробелом. Хэштеги выводятся в том же порядке, в котором они идут в тексте.
Если знаков хэштегов в тексте нет, то программа ничего не печатает. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: Выучите китайский язык без усилий выполняя задания в приложении ( #the_best_app ) за #20 дней. 
<Вывод>: #the_best_app 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: Ваш вопрос ( #question ) - наш ответ ( #answer ) ! Мы всегда с Вами yf #100 % 
<Вывод>: #question, #answer 
<Example 3>: 
<Тип теста 3>: open 
<Ввод>: Мощный рывок для Вашего @бизнеса 
<Вывод>: nan 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: Я никогда не был #счастье1 #любовь123 #123_123 qwe#qwe 
<Вывод>: #счастье1, #любовь123, #123_123 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: 9 из 10 экспертов рекомендуют # наш #_1223 продукт #__ . 
<Вывод>: #, #_1223, #__ 
<Example 6>: 
<Тип теста 6>: closed 
<Ввод>: # #123 #qswr_1 @qws1 $1#qwd 1#123_qwe #0 #____ #$567123 
<Вывод>: #, #qswr_1, #____, #$567123 
<Решение студента>: logo = input()

res = []
for i in logo.split():
    if info.startswith('#') and info[1:].isdigit() == False:      
        res.append(info)
        
print(*res, sep=', ') 
<Идеальное решение>: logo = input()

res = []
for info in logo.split():
    if info.startswith('#') and info[1:].isdigit() == False:      
        res.append(info)
        
print(*res, sep=', ') 


<Комментарий эксперта>:"
32,45,3,"Реализуйте программу, которая напечатает хэштеги из фраз для лендинга сайта: 

В переменную logo считывается текст лендинга. Этот код уже написан.
Программа проверяет, есть ли в этом тексте хэштеги.  Хэштегами можно считать все элементы, которые начинаются со знака ""#"" и которые не состоят только из цифр (не включая знак ""#""). Гарантируется, что хэштеги отделены от другого текста пробелом. 
В конце программа печатает все хэштеги через запятую с пробелом. Хэштеги выводятся в том же порядке, в котором они идут в тексте.
Если знаков хэштегов в тексте нет, то программа ничего не печатает.","['Выучите китайский язык без усилий выполняя задания в приложении ( #the_best_app ) за #20 дней.', 'Ваш вопрос ( #question ) - наш ответ ( #answer ) ! Мы всегда с Вами yf #100 %', 'Мощный рывок для Вашего @бизнеса', 'Я никогда не был #счастье1 #любовь123 #123_123 qwe#qwe', '9 из 10 экспертов рекомендуют # наш #_1223 продукт #__ .', '# #123 #qswr_1 @qws1 $1#qwd 1#123_qwe #0 #____ #$567123']","['#the_best_app', '#question, #answer', nan, '#счастье1, #любовь123, #123_123', '#, #_1223, #__', '#, #qswr_1, #____, #$567123']","logo = input()

res = []
for info in logo.split()
    if info.startswith('#') and info[1:].isdigit() == False:      
        res.append(info)
        
print(*res, sep=', ')","logo = input()

res = []
for info in logo.split():
    if info.startswith('#') and info[1:].isdigit() == False:      
        res.append(info)
        
print(*res, sep=', ')",Вы забыли поставить двоеточие после условия в цикле for.,"['open', 'open', 'open', 'closed', 'closed', 'closed']","<Task description>: Реализуйте программу, которая напечатает хэштеги из фраз для лендинга сайта: 

В переменную logo считывается текст лендинга. Этот код уже написан.
Программа проверяет, есть ли в этом тексте хэштеги.  Хэштегами можно считать все элементы, которые начинаются со знака ""#"" и которые не состоят только из цифр (не включая знак ""#""). Гарантируется, что хэштеги отделены от другого текста пробелом. 
В конце программа печатает все хэштеги через запятую с пробелом. Хэштеги выводятся в том же порядке, в котором они идут в тексте.
Если знаков хэштегов в тексте нет, то программа ничего не печатает. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: Выучите китайский язык без усилий выполняя задания в приложении ( #the_best_app ) за #20 дней. 
<Вывод>: #the_best_app 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: Ваш вопрос ( #question ) - наш ответ ( #answer ) ! Мы всегда с Вами yf #100 % 
<Вывод>: #question, #answer 
<Example 3>: 
<Тип теста 3>: open 
<Ввод>: Мощный рывок для Вашего @бизнеса 
<Вывод>: nan 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: Я никогда не был #счастье1 #любовь123 #123_123 qwe#qwe 
<Вывод>: #счастье1, #любовь123, #123_123 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: 9 из 10 экспертов рекомендуют # наш #_1223 продукт #__ . 
<Вывод>: #, #_1223, #__ 
<Example 6>: 
<Тип теста 6>: closed 
<Ввод>: # #123 #qswr_1 @qws1 $1#qwd 1#123_qwe #0 #____ #$567123 
<Вывод>: #, #qswr_1, #____, #$567123 
<Решение студента>: logo = input()

res = []
for info in logo.split()
    if info.startswith('#') and info[1:].isdigit() == False:      
        res.append(info)
        
print(*res, sep=', ') 
<Идеальное решение>: logo = input()

res = []
for info in logo.split():
    if info.startswith('#') and info[1:].isdigit() == False:      
        res.append(info)
        
print(*res, sep=', ') 


<Комментарий эксперта>:"
33,46,3,"Реализуйте программу, которая напечатает хэштеги из фраз для лендинга сайта: 

В переменную logo считывается текст лендинга. Этот код уже написан.
Программа проверяет, есть ли в этом тексте хэштеги.  Хэштегами можно считать все элементы, которые начинаются со знака ""#"" и которые не состоят только из цифр (не включая знак ""#""). Гарантируется, что хэштеги отделены от другого текста пробелом. 
В конце программа печатает все хэштеги через запятую с пробелом. Хэштеги выводятся в том же порядке, в котором они идут в тексте.
Если знаков хэштегов в тексте нет, то программа ничего не печатает.","['Выучите китайский язык без усилий выполняя задания в приложении ( #the_best_app ) за #20 дней.', 'Ваш вопрос ( #question ) - наш ответ ( #answer ) ! Мы всегда с Вами yf #100 %', 'Мощный рывок для Вашего @бизнеса', 'Я никогда не был #счастье1 #любовь123 #123_123 qwe#qwe', '9 из 10 экспертов рекомендуют # наш #_1223 продукт #__ .', '# #123 #qswr_1 @qws1 $1#qwd 1#123_qwe #0 #____ #$567123']","['#the_best_app', '#question, #answer', nan, '#счастье1, #любовь123, #123_123', '#, #_1223, #__', '#, #qswr_1, #____, #$567123']","logo = input()

res = []
for info in logo:
    if info.startswith('#') and info[1:].isdigit() == False:      
        res.append(info)
        
print(*res, sep=', ')","logo = input()

res = []
for info in logo.split():
    if info.startswith('#') and info[1:].isdigit() == False:      
        res.append(info)
        
print(*res, sep=', ')","Ошибка в открытых и скрытых тестах. 

Ваш код некорректно обращается к каждому элементу переменной logo. Попробуйте изменить условие if, чтобы скорректировать ошибку.","['open', 'open', 'open', 'closed', 'closed', 'closed']","<Task description>: Реализуйте программу, которая напечатает хэштеги из фраз для лендинга сайта: 

В переменную logo считывается текст лендинга. Этот код уже написан.
Программа проверяет, есть ли в этом тексте хэштеги.  Хэштегами можно считать все элементы, которые начинаются со знака ""#"" и которые не состоят только из цифр (не включая знак ""#""). Гарантируется, что хэштеги отделены от другого текста пробелом. 
В конце программа печатает все хэштеги через запятую с пробелом. Хэштеги выводятся в том же порядке, в котором они идут в тексте.
Если знаков хэштегов в тексте нет, то программа ничего не печатает. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: Выучите китайский язык без усилий выполняя задания в приложении ( #the_best_app ) за #20 дней. 
<Вывод>: #the_best_app 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: Ваш вопрос ( #question ) - наш ответ ( #answer ) ! Мы всегда с Вами yf #100 % 
<Вывод>: #question, #answer 
<Example 3>: 
<Тип теста 3>: open 
<Ввод>: Мощный рывок для Вашего @бизнеса 
<Вывод>: nan 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: Я никогда не был #счастье1 #любовь123 #123_123 qwe#qwe 
<Вывод>: #счастье1, #любовь123, #123_123 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: 9 из 10 экспертов рекомендуют # наш #_1223 продукт #__ . 
<Вывод>: #, #_1223, #__ 
<Example 6>: 
<Тип теста 6>: closed 
<Ввод>: # #123 #qswr_1 @qws1 $1#qwd 1#123_qwe #0 #____ #$567123 
<Вывод>: #, #qswr_1, #____, #$567123 
<Решение студента>: logo = input()

res = []
for info in logo:
    if info.startswith('#') and info[1:].isdigit() == False:      
        res.append(info)
        
print(*res, sep=', ') 
<Идеальное решение>: logo = input()

res = []
for info in logo.split():
    if info.startswith('#') and info[1:].isdigit() == False:      
        res.append(info)
        
print(*res, sep=', ') 


<Комментарий эксперта>:"
34,47,3,"Реализуйте программу, которая напечатает хэштеги из фраз для лендинга сайта: 

В переменную logo считывается текст лендинга. Этот код уже написан.
Программа проверяет, есть ли в этом тексте хэштеги.  Хэштегами можно считать все элементы, которые начинаются со знака ""#"" и которые не состоят только из цифр (не включая знак ""#""). Гарантируется, что хэштеги отделены от другого текста пробелом. 
В конце программа печатает все хэштеги через запятую с пробелом. Хэштеги выводятся в том же порядке, в котором они идут в тексте.
Если знаков хэштегов в тексте нет, то программа ничего не печатает.","['Выучите китайский язык без усилий выполняя задания в приложении ( #the_best_app ) за #20 дней.', 'Ваш вопрос ( #question ) - наш ответ ( #answer ) ! Мы всегда с Вами yf #100 %', 'Мощный рывок для Вашего @бизнеса', 'Я никогда не был #счастье1 #любовь123 #123_123 qwe#qwe', '9 из 10 экспертов рекомендуют # наш #_1223 продукт #__ .', '# #123 #qswr_1 @qws1 $1#qwd 1#123_qwe #0 #____ #$567123']","['#the_best_app', '#question, #answer', nan, '#счастье1, #любовь123, #123_123', '#, #_1223, #__', '#, #qswr_1, #____, #$567123']","logo = input()

res = []
for info in logo.split:
    if info.startswith('#') and info[1:].isdigit() == False:      
        res.append(info)
        
print(*res, sep=', ')","logo = input()

res = []
for info in logo.split():
    if info.startswith('#') and info[1:].isdigit() == False:      
        res.append(info)
        
print(*res, sep=', ')",Вы забыли поставить скобки в методе .split().,"['open', 'open', 'open', 'closed', 'closed', 'closed']","<Task description>: Реализуйте программу, которая напечатает хэштеги из фраз для лендинга сайта: 

В переменную logo считывается текст лендинга. Этот код уже написан.
Программа проверяет, есть ли в этом тексте хэштеги.  Хэштегами можно считать все элементы, которые начинаются со знака ""#"" и которые не состоят только из цифр (не включая знак ""#""). Гарантируется, что хэштеги отделены от другого текста пробелом. 
В конце программа печатает все хэштеги через запятую с пробелом. Хэштеги выводятся в том же порядке, в котором они идут в тексте.
Если знаков хэштегов в тексте нет, то программа ничего не печатает. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: Выучите китайский язык без усилий выполняя задания в приложении ( #the_best_app ) за #20 дней. 
<Вывод>: #the_best_app 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: Ваш вопрос ( #question ) - наш ответ ( #answer ) ! Мы всегда с Вами yf #100 % 
<Вывод>: #question, #answer 
<Example 3>: 
<Тип теста 3>: open 
<Ввод>: Мощный рывок для Вашего @бизнеса 
<Вывод>: nan 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: Я никогда не был #счастье1 #любовь123 #123_123 qwe#qwe 
<Вывод>: #счастье1, #любовь123, #123_123 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: 9 из 10 экспертов рекомендуют # наш #_1223 продукт #__ . 
<Вывод>: #, #_1223, #__ 
<Example 6>: 
<Тип теста 6>: closed 
<Ввод>: # #123 #qswr_1 @qws1 $1#qwd 1#123_qwe #0 #____ #$567123 
<Вывод>: #, #qswr_1, #____, #$567123 
<Решение студента>: logo = input()

res = []
for info in logo.split:
    if info.startswith('#') and info[1:].isdigit() == False:      
        res.append(info)
        
print(*res, sep=', ') 
<Идеальное решение>: logo = input()

res = []
for info in logo.split():
    if info.startswith('#') and info[1:].isdigit() == False:      
        res.append(info)
        
print(*res, sep=', ') 


<Комментарий эксперта>:"
35,48,3,"Реализуйте программу, которая напечатает хэштеги из фраз для лендинга сайта: 

В переменную logo считывается текст лендинга. Этот код уже написан.
Программа проверяет, есть ли в этом тексте хэштеги.  Хэштегами можно считать все элементы, которые начинаются со знака ""#"" и которые не состоят только из цифр (не включая знак ""#""). Гарантируется, что хэштеги отделены от другого текста пробелом. 
В конце программа печатает все хэштеги через запятую с пробелом. Хэштеги выводятся в том же порядке, в котором они идут в тексте.
Если знаков хэштегов в тексте нет, то программа ничего не печатает.","['Выучите китайский язык без усилий выполняя задания в приложении ( #the_best_app ) за #20 дней.', 'Ваш вопрос ( #question ) - наш ответ ( #answer ) ! Мы всегда с Вами yf #100 %', 'Мощный рывок для Вашего @бизнеса', 'Я никогда не был #счастье1 #любовь123 #123_123 qwe#qwe', '9 из 10 экспертов рекомендуют # наш #_1223 продукт #__ .', '# #123 #qswr_1 @qws1 $1#qwd 1#123_qwe #0 #____ #$567123']","['#the_best_app', '#question, #answer', nan, '#счастье1, #любовь123, #123_123', '#, #_1223, #__', '#, #qswr_1, #____, #$567123']","logo = input()

res = []
for info in logo.split():
if info.startswith('#') and info[1:].isdigit() == False:      
    res.append(info)
        
print(*res, sep=', ')","logo = input()

res = []
for info in logo.split():
    if info.startswith('#') and info[1:].isdigit() == False:      
        res.append(info)
        
print(*res, sep=', ')",Обратите внимание на некорректную табуляцию условия if.,"['open', 'open', 'open', 'closed', 'closed', 'closed']","<Task description>: Реализуйте программу, которая напечатает хэштеги из фраз для лендинга сайта: 

В переменную logo считывается текст лендинга. Этот код уже написан.
Программа проверяет, есть ли в этом тексте хэштеги.  Хэштегами можно считать все элементы, которые начинаются со знака ""#"" и которые не состоят только из цифр (не включая знак ""#""). Гарантируется, что хэштеги отделены от другого текста пробелом. 
В конце программа печатает все хэштеги через запятую с пробелом. Хэштеги выводятся в том же порядке, в котором они идут в тексте.
Если знаков хэштегов в тексте нет, то программа ничего не печатает. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: Выучите китайский язык без усилий выполняя задания в приложении ( #the_best_app ) за #20 дней. 
<Вывод>: #the_best_app 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: Ваш вопрос ( #question ) - наш ответ ( #answer ) ! Мы всегда с Вами yf #100 % 
<Вывод>: #question, #answer 
<Example 3>: 
<Тип теста 3>: open 
<Ввод>: Мощный рывок для Вашего @бизнеса 
<Вывод>: nan 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: Я никогда не был #счастье1 #любовь123 #123_123 qwe#qwe 
<Вывод>: #счастье1, #любовь123, #123_123 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: 9 из 10 экспертов рекомендуют # наш #_1223 продукт #__ . 
<Вывод>: #, #_1223, #__ 
<Example 6>: 
<Тип теста 6>: closed 
<Ввод>: # #123 #qswr_1 @qws1 $1#qwd 1#123_qwe #0 #____ #$567123 
<Вывод>: #, #qswr_1, #____, #$567123 
<Решение студента>: logo = input()

res = []
for info in logo.split():
if info.startswith('#') and info[1:].isdigit() == False:      
    res.append(info)
        
print(*res, sep=', ') 
<Идеальное решение>: logo = input()

res = []
for info in logo.split():
    if info.startswith('#') and info[1:].isdigit() == False:      
        res.append(info)
        
print(*res, sep=', ') 


<Комментарий эксперта>:"
36,49,3,"Реализуйте программу, которая напечатает хэштеги из фраз для лендинга сайта: 

В переменную logo считывается текст лендинга. Этот код уже написан.
Программа проверяет, есть ли в этом тексте хэштеги.  Хэштегами можно считать все элементы, которые начинаются со знака ""#"" и которые не состоят только из цифр (не включая знак ""#""). Гарантируется, что хэштеги отделены от другого текста пробелом. 
В конце программа печатает все хэштеги через запятую с пробелом. Хэштеги выводятся в том же порядке, в котором они идут в тексте.
Если знаков хэштегов в тексте нет, то программа ничего не печатает.","['Выучите китайский язык без усилий выполняя задания в приложении ( #the_best_app ) за #20 дней.', 'Ваш вопрос ( #question ) - наш ответ ( #answer ) ! Мы всегда с Вами yf #100 %', 'Мощный рывок для Вашего @бизнеса', 'Я никогда не был #счастье1 #любовь123 #123_123 qwe#qwe', '9 из 10 экспертов рекомендуют # наш #_1223 продукт #__ .', '# #123 #qswr_1 @qws1 $1#qwd 1#123_qwe #0 #____ #$567123']","['#the_best_app', '#question, #answer', nan, '#счастье1, #любовь123, #123_123', '#, #_1223, #__', '#, #qswr_1, #____, #$567123']","logo = input()

res = []
for info in logo.split():
    if '#' in info and info[1:].isdigit() == False:      
        res.append(info)
        
print(*res, sep=', ')","logo = input()

res = []
for info in logo.split():
    if info.startswith('#') and info[1:].isdigit() == False:      
        res.append(info)
        
print(*res, sep=', ')","Ошибка в открытых и скрытых тестах. 

Ваш код некорректно проверяет условия задания. Например, он некорректно проверяет, начинаются лиэлементы со знака ""#"". Попробуйте изменить условие if, чтобы скорректировать ошибку.","['open', 'open', 'open', 'closed', 'closed', 'closed']","<Task description>: Реализуйте программу, которая напечатает хэштеги из фраз для лендинга сайта: 

В переменную logo считывается текст лендинга. Этот код уже написан.
Программа проверяет, есть ли в этом тексте хэштеги.  Хэштегами можно считать все элементы, которые начинаются со знака ""#"" и которые не состоят только из цифр (не включая знак ""#""). Гарантируется, что хэштеги отделены от другого текста пробелом. 
В конце программа печатает все хэштеги через запятую с пробелом. Хэштеги выводятся в том же порядке, в котором они идут в тексте.
Если знаков хэштегов в тексте нет, то программа ничего не печатает. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: Выучите китайский язык без усилий выполняя задания в приложении ( #the_best_app ) за #20 дней. 
<Вывод>: #the_best_app 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: Ваш вопрос ( #question ) - наш ответ ( #answer ) ! Мы всегда с Вами yf #100 % 
<Вывод>: #question, #answer 
<Example 3>: 
<Тип теста 3>: open 
<Ввод>: Мощный рывок для Вашего @бизнеса 
<Вывод>: nan 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: Я никогда не был #счастье1 #любовь123 #123_123 qwe#qwe 
<Вывод>: #счастье1, #любовь123, #123_123 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: 9 из 10 экспертов рекомендуют # наш #_1223 продукт #__ . 
<Вывод>: #, #_1223, #__ 
<Example 6>: 
<Тип теста 6>: closed 
<Ввод>: # #123 #qswr_1 @qws1 $1#qwd 1#123_qwe #0 #____ #$567123 
<Вывод>: #, #qswr_1, #____, #$567123 
<Решение студента>: logo = input()

res = []
for info in logo.split():
    if '#' in info and info[1:].isdigit() == False:      
        res.append(info)
        
print(*res, sep=', ') 
<Идеальное решение>: logo = input()

res = []
for info in logo.split():
    if info.startswith('#') and info[1:].isdigit() == False:      
        res.append(info)
        
print(*res, sep=', ') 


<Комментарий эксперта>:"
37,50,3,"Реализуйте программу, которая напечатает хэштеги из фраз для лендинга сайта: 

В переменную logo считывается текст лендинга. Этот код уже написан.
Программа проверяет, есть ли в этом тексте хэштеги.  Хэштегами можно считать все элементы, которые начинаются со знака ""#"" и которые не состоят только из цифр (не включая знак ""#""). Гарантируется, что хэштеги отделены от другого текста пробелом. 
В конце программа печатает все хэштеги через запятую с пробелом. Хэштеги выводятся в том же порядке, в котором они идут в тексте.
Если знаков хэштегов в тексте нет, то программа ничего не печатает.","['Выучите китайский язык без усилий выполняя задания в приложении ( #the_best_app ) за #20 дней.', 'Ваш вопрос ( #question ) - наш ответ ( #answer ) ! Мы всегда с Вами yf #100 %', 'Мощный рывок для Вашего @бизнеса', 'Я никогда не был #счастье1 #любовь123 #123_123 qwe#qwe', '9 из 10 экспертов рекомендуют # наш #_1223 продукт #__ .', '# #123 #qswr_1 @qws1 $1#qwd 1#123_qwe #0 #____ #$567123']","['#the_best_app', '#question, #answer', nan, '#счастье1, #любовь123, #123_123', '#, #_1223, #__', '#, #qswr_1, #____, #$567123']","logo = input()

res = []
for info in logo.split():
    if info.startswith('#'):      
        res.append(info)
        
print(*res, sep=', ')","logo = input()

res = []
for info in logo.split():
    if info.startswith('#') and info[1:].isdigit() == False:      
        res.append(info)
        
print(*res, sep=', ')","Ошибка в открытых и скрытых тестах. 

Ваш код не проверяет все условия задания. Например, он не проверяет, не состоят ли элементы только из цифр. Попробуйте изменить условие if, чтобы скорректировать ошибку.","['open', 'open', 'open', 'closed', 'closed', 'closed']","<Task description>: Реализуйте программу, которая напечатает хэштеги из фраз для лендинга сайта: 

В переменную logo считывается текст лендинга. Этот код уже написан.
Программа проверяет, есть ли в этом тексте хэштеги.  Хэштегами можно считать все элементы, которые начинаются со знака ""#"" и которые не состоят только из цифр (не включая знак ""#""). Гарантируется, что хэштеги отделены от другого текста пробелом. 
В конце программа печатает все хэштеги через запятую с пробелом. Хэштеги выводятся в том же порядке, в котором они идут в тексте.
Если знаков хэштегов в тексте нет, то программа ничего не печатает. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: Выучите китайский язык без усилий выполняя задания в приложении ( #the_best_app ) за #20 дней. 
<Вывод>: #the_best_app 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: Ваш вопрос ( #question ) - наш ответ ( #answer ) ! Мы всегда с Вами yf #100 % 
<Вывод>: #question, #answer 
<Example 3>: 
<Тип теста 3>: open 
<Ввод>: Мощный рывок для Вашего @бизнеса 
<Вывод>: nan 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: Я никогда не был #счастье1 #любовь123 #123_123 qwe#qwe 
<Вывод>: #счастье1, #любовь123, #123_123 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: 9 из 10 экспертов рекомендуют # наш #_1223 продукт #__ . 
<Вывод>: #, #_1223, #__ 
<Example 6>: 
<Тип теста 6>: closed 
<Ввод>: # #123 #qswr_1 @qws1 $1#qwd 1#123_qwe #0 #____ #$567123 
<Вывод>: #, #qswr_1, #____, #$567123 
<Решение студента>: logo = input()

res = []
for info in logo.split():
    if info.startswith('#'):      
        res.append(info)
        
print(*res, sep=', ') 
<Идеальное решение>: logo = input()

res = []
for info in logo.split():
    if info.startswith('#') and info[1:].isdigit() == False:      
        res.append(info)
        
print(*res, sep=', ') 


<Комментарий эксперта>:"
38,51,3,"Реализуйте программу, которая напечатает хэштеги из фраз для лендинга сайта: 

В переменную logo считывается текст лендинга. Этот код уже написан.
Программа проверяет, есть ли в этом тексте хэштеги.  Хэштегами можно считать все элементы, которые начинаются со знака ""#"" и которые не состоят только из цифр (не включая знак ""#""). Гарантируется, что хэштеги отделены от другого текста пробелом. 
В конце программа печатает все хэштеги через запятую с пробелом. Хэштеги выводятся в том же порядке, в котором они идут в тексте.
Если знаков хэштегов в тексте нет, то программа ничего не печатает.","['Выучите китайский язык без усилий выполняя задания в приложении ( #the_best_app ) за #20 дней.', 'Ваш вопрос ( #question ) - наш ответ ( #answer ) ! Мы всегда с Вами yf #100 %', 'Мощный рывок для Вашего @бизнеса', 'Я никогда не был #счастье1 #любовь123 #123_123 qwe#qwe', '9 из 10 экспертов рекомендуют # наш #_1223 продукт #__ .', '# #123 #qswr_1 @qws1 $1#qwd 1#123_qwe #0 #____ #$567123']","['#the_best_app', '#question, #answer', nan, '#счастье1, #любовь123, #123_123', '#, #_1223, #__', '#, #qswr_1, #____, #$567123']","logo = input()

res = []
for info in logo.split():
    if info.startswith('#'):      
        res.append(info)
    if info[1:].isdigit() == False:
        res.append(info)
        
print(*res, sep=', ')","logo = input()

res = []
for info in logo.split():
    if info.startswith('#') and info[1:].isdigit() == False:      
        res.append(info)
        
print(*res, sep=', ')","Ошибка в открытых и скрытых тестах. 

Обратите внимание, что вы должны проверить, что условия (""начинаются со знака ""#"" и которые не состоят только из цифр"") выполняются одновременно.","['open', 'open', 'open', 'closed', 'closed', 'closed']","<Task description>: Реализуйте программу, которая напечатает хэштеги из фраз для лендинга сайта: 

В переменную logo считывается текст лендинга. Этот код уже написан.
Программа проверяет, есть ли в этом тексте хэштеги.  Хэштегами можно считать все элементы, которые начинаются со знака ""#"" и которые не состоят только из цифр (не включая знак ""#""). Гарантируется, что хэштеги отделены от другого текста пробелом. 
В конце программа печатает все хэштеги через запятую с пробелом. Хэштеги выводятся в том же порядке, в котором они идут в тексте.
Если знаков хэштегов в тексте нет, то программа ничего не печатает. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: Выучите китайский язык без усилий выполняя задания в приложении ( #the_best_app ) за #20 дней. 
<Вывод>: #the_best_app 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: Ваш вопрос ( #question ) - наш ответ ( #answer ) ! Мы всегда с Вами yf #100 % 
<Вывод>: #question, #answer 
<Example 3>: 
<Тип теста 3>: open 
<Ввод>: Мощный рывок для Вашего @бизнеса 
<Вывод>: nan 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: Я никогда не был #счастье1 #любовь123 #123_123 qwe#qwe 
<Вывод>: #счастье1, #любовь123, #123_123 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: 9 из 10 экспертов рекомендуют # наш #_1223 продукт #__ . 
<Вывод>: #, #_1223, #__ 
<Example 6>: 
<Тип теста 6>: closed 
<Ввод>: # #123 #qswr_1 @qws1 $1#qwd 1#123_qwe #0 #____ #$567123 
<Вывод>: #, #qswr_1, #____, #$567123 
<Решение студента>: logo = input()

res = []
for info in logo.split():
    if info.startswith('#'):      
        res.append(info)
    if info[1:].isdigit() == False:
        res.append(info)
        
print(*res, sep=', ') 
<Идеальное решение>: logo = input()

res = []
for info in logo.split():
    if info.startswith('#') and info[1:].isdigit() == False:      
        res.append(info)
        
print(*res, sep=', ') 


<Комментарий эксперта>:"
39,52,3,"Реализуйте программу, которая напечатает хэштеги из фраз для лендинга сайта: 

В переменную logo считывается текст лендинга. Этот код уже написан.
Программа проверяет, есть ли в этом тексте хэштеги.  Хэштегами можно считать все элементы, которые начинаются со знака ""#"" и которые не состоят только из цифр (не включая знак ""#""). Гарантируется, что хэштеги отделены от другого текста пробелом. 
В конце программа печатает все хэштеги через запятую с пробелом. Хэштеги выводятся в том же порядке, в котором они идут в тексте.
Если знаков хэштегов в тексте нет, то программа ничего не печатает.","['Выучите китайский язык без усилий выполняя задания в приложении ( #the_best_app ) за #20 дней.', 'Ваш вопрос ( #question ) - наш ответ ( #answer ) ! Мы всегда с Вами yf #100 %', 'Мощный рывок для Вашего @бизнеса', 'Я никогда не был #счастье1 #любовь123 #123_123 qwe#qwe', '9 из 10 экспертов рекомендуют # наш #_1223 продукт #__ .', '# #123 #qswr_1 @qws1 $1#qwd 1#123_qwe #0 #____ #$567123']","['#the_best_app', '#question, #answer', nan, '#счастье1, #любовь123, #123_123', '#, #_1223, #__', '#, #qswr_1, #____, #$567123']","logo = input()

res = []
for info in logo.split():
    if info.startswith('#') and info.isdigit() == False:      
        res.append(info)
        
print(*res, sep=', ')","logo = input()

res = []
for info in logo.split():
    if info.startswith('#') and info[1:].isdigit() == False:      
        res.append(info)
        
print(*res, sep=', ')","Ошибка в открытых и скрытых тестах. 

Ваш код не проверяет все условия задания. Например, он некорректно проверяет, не состоят ли элементы только из цифр, не включая знак ""#"". Попробуйте изменить условие if, чтобы скорректировать ошибку.","['open', 'open', 'open', 'closed', 'closed', 'closed']","<Task description>: Реализуйте программу, которая напечатает хэштеги из фраз для лендинга сайта: 

В переменную logo считывается текст лендинга. Этот код уже написан.
Программа проверяет, есть ли в этом тексте хэштеги.  Хэштегами можно считать все элементы, которые начинаются со знака ""#"" и которые не состоят только из цифр (не включая знак ""#""). Гарантируется, что хэштеги отделены от другого текста пробелом. 
В конце программа печатает все хэштеги через запятую с пробелом. Хэштеги выводятся в том же порядке, в котором они идут в тексте.
Если знаков хэштегов в тексте нет, то программа ничего не печатает. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: Выучите китайский язык без усилий выполняя задания в приложении ( #the_best_app ) за #20 дней. 
<Вывод>: #the_best_app 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: Ваш вопрос ( #question ) - наш ответ ( #answer ) ! Мы всегда с Вами yf #100 % 
<Вывод>: #question, #answer 
<Example 3>: 
<Тип теста 3>: open 
<Ввод>: Мощный рывок для Вашего @бизнеса 
<Вывод>: nan 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: Я никогда не был #счастье1 #любовь123 #123_123 qwe#qwe 
<Вывод>: #счастье1, #любовь123, #123_123 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: 9 из 10 экспертов рекомендуют # наш #_1223 продукт #__ . 
<Вывод>: #, #_1223, #__ 
<Example 6>: 
<Тип теста 6>: closed 
<Ввод>: # #123 #qswr_1 @qws1 $1#qwd 1#123_qwe #0 #____ #$567123 
<Вывод>: #, #qswr_1, #____, #$567123 
<Решение студента>: logo = input()

res = []
for info in logo.split():
    if info.startswith('#') and info.isdigit() == False:      
        res.append(info)
        
print(*res, sep=', ') 
<Идеальное решение>: logo = input()

res = []
for info in logo.split():
    if info.startswith('#') and info[1:].isdigit() == False:      
        res.append(info)
        
print(*res, sep=', ') 


<Комментарий эксперта>:"
40,53,3,"Реализуйте программу, которая напечатает хэштеги из фраз для лендинга сайта: 

В переменную logo считывается текст лендинга. Этот код уже написан.
Программа проверяет, есть ли в этом тексте хэштеги.  Хэштегами можно считать все элементы, которые начинаются со знака ""#"" и которые не состоят только из цифр (не включая знак ""#""). Гарантируется, что хэштеги отделены от другого текста пробелом. 
В конце программа печатает все хэштеги через запятую с пробелом. Хэштеги выводятся в том же порядке, в котором они идут в тексте.
Если знаков хэштегов в тексте нет, то программа ничего не печатает.","['Выучите китайский язык без усилий выполняя задания в приложении ( #the_best_app ) за #20 дней.', 'Ваш вопрос ( #question ) - наш ответ ( #answer ) ! Мы всегда с Вами yf #100 %', 'Мощный рывок для Вашего @бизнеса', 'Я никогда не был #счастье1 #любовь123 #123_123 qwe#qwe', '9 из 10 экспертов рекомендуют # наш #_1223 продукт #__ .', '# #123 #qswr_1 @qws1 $1#qwd 1#123_qwe #0 #____ #$567123']","['#the_best_app', '#question, #answer', nan, '#счастье1, #любовь123, #123_123', '#, #_1223, #__', '#, #qswr_1, #____, #$567123']","logo = input()

res = []
for info in logo.split():
    if info.startswith('#') and info[1:].isdigit() == False:      
        res.add(info)
        
print(*res, sep=', ')","logo = input()

res = []
for info in logo.split():
    if info.startswith('#') and info[1:].isdigit() == False:      
        res.append(info)
        
print(*res, sep=', ')",Некорректно использован метод добавления элементов в список. Список не имеет метода .add().,"['open', 'open', 'open', 'closed', 'closed', 'closed']","<Task description>: Реализуйте программу, которая напечатает хэштеги из фраз для лендинга сайта: 

В переменную logo считывается текст лендинга. Этот код уже написан.
Программа проверяет, есть ли в этом тексте хэштеги.  Хэштегами можно считать все элементы, которые начинаются со знака ""#"" и которые не состоят только из цифр (не включая знак ""#""). Гарантируется, что хэштеги отделены от другого текста пробелом. 
В конце программа печатает все хэштеги через запятую с пробелом. Хэштеги выводятся в том же порядке, в котором они идут в тексте.
Если знаков хэштегов в тексте нет, то программа ничего не печатает. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: Выучите китайский язык без усилий выполняя задания в приложении ( #the_best_app ) за #20 дней. 
<Вывод>: #the_best_app 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: Ваш вопрос ( #question ) - наш ответ ( #answer ) ! Мы всегда с Вами yf #100 % 
<Вывод>: #question, #answer 
<Example 3>: 
<Тип теста 3>: open 
<Ввод>: Мощный рывок для Вашего @бизнеса 
<Вывод>: nan 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: Я никогда не был #счастье1 #любовь123 #123_123 qwe#qwe 
<Вывод>: #счастье1, #любовь123, #123_123 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: 9 из 10 экспертов рекомендуют # наш #_1223 продукт #__ . 
<Вывод>: #, #_1223, #__ 
<Example 6>: 
<Тип теста 6>: closed 
<Ввод>: # #123 #qswr_1 @qws1 $1#qwd 1#123_qwe #0 #____ #$567123 
<Вывод>: #, #qswr_1, #____, #$567123 
<Решение студента>: logo = input()

res = []
for info in logo.split():
    if info.startswith('#') and info[1:].isdigit() == False:      
        res.add(info)
        
print(*res, sep=', ') 
<Идеальное решение>: logo = input()

res = []
for info in logo.split():
    if info.startswith('#') and info[1:].isdigit() == False:      
        res.append(info)
        
print(*res, sep=', ') 


<Комментарий эксперта>:"
41,54,3,"Реализуйте программу, которая напечатает хэштеги из фраз для лендинга сайта: 

В переменную logo считывается текст лендинга. Этот код уже написан.
Программа проверяет, есть ли в этом тексте хэштеги.  Хэштегами можно считать все элементы, которые начинаются со знака ""#"" и которые не состоят только из цифр (не включая знак ""#""). Гарантируется, что хэштеги отделены от другого текста пробелом. 
В конце программа печатает все хэштеги через запятую с пробелом. Хэштеги выводятся в том же порядке, в котором они идут в тексте.
Если знаков хэштегов в тексте нет, то программа ничего не печатает.","['Выучите китайский язык без усилий выполняя задания в приложении ( #the_best_app ) за #20 дней.', 'Ваш вопрос ( #question ) - наш ответ ( #answer ) ! Мы всегда с Вами yf #100 %', 'Мощный рывок для Вашего @бизнеса', 'Я никогда не был #счастье1 #любовь123 #123_123 qwe#qwe', '9 из 10 экспертов рекомендуют # наш #_1223 продукт #__ .', '# #123 #qswr_1 @qws1 $1#qwd 1#123_qwe #0 #____ #$567123']","['#the_best_app', '#question, #answer', nan, '#счастье1, #любовь123, #123_123', '#, #_1223, #__', '#, #qswr_1, #____, #$567123']","logo = input()

res = []
for info in logo.split():
    if info.startswith('#') and info[1:].isdigit() == False:      
        res.append(info)
        
print(*res)","logo = input()

res = []
for info in logo.split():
    if info.startswith('#') and info[1:].isdigit() == False:      
        res.append(info)
        
print(*res, sep=', ')","Ошибка в открытых и скрытых тестах. 

Ваш код не проверяет все условия задания. Например, он некорректно выполняет условие ""В конце программа печатает все хэштеги через запятую с пробелом"". Дополните функцию print(), чтобы выполнить данное условие.","['open', 'open', 'open', 'closed', 'closed', 'closed']","<Task description>: Реализуйте программу, которая напечатает хэштеги из фраз для лендинга сайта: 

В переменную logo считывается текст лендинга. Этот код уже написан.
Программа проверяет, есть ли в этом тексте хэштеги.  Хэштегами можно считать все элементы, которые начинаются со знака ""#"" и которые не состоят только из цифр (не включая знак ""#""). Гарантируется, что хэштеги отделены от другого текста пробелом. 
В конце программа печатает все хэштеги через запятую с пробелом. Хэштеги выводятся в том же порядке, в котором они идут в тексте.
Если знаков хэштегов в тексте нет, то программа ничего не печатает. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: Выучите китайский язык без усилий выполняя задания в приложении ( #the_best_app ) за #20 дней. 
<Вывод>: #the_best_app 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: Ваш вопрос ( #question ) - наш ответ ( #answer ) ! Мы всегда с Вами yf #100 % 
<Вывод>: #question, #answer 
<Example 3>: 
<Тип теста 3>: open 
<Ввод>: Мощный рывок для Вашего @бизнеса 
<Вывод>: nan 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: Я никогда не был #счастье1 #любовь123 #123_123 qwe#qwe 
<Вывод>: #счастье1, #любовь123, #123_123 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: 9 из 10 экспертов рекомендуют # наш #_1223 продукт #__ . 
<Вывод>: #, #_1223, #__ 
<Example 6>: 
<Тип теста 6>: closed 
<Ввод>: # #123 #qswr_1 @qws1 $1#qwd 1#123_qwe #0 #____ #$567123 
<Вывод>: #, #qswr_1, #____, #$567123 
<Решение студента>: logo = input()

res = []
for info in logo.split():
    if info.startswith('#') and info[1:].isdigit() == False:      
        res.append(info)
        
print(*res) 
<Идеальное решение>: logo = input()

res = []
for info in logo.split():
    if info.startswith('#') and info[1:].isdigit() == False:      
        res.append(info)
        
print(*res, sep=', ') 


<Комментарий эксперта>:"
42,55,3,"Реализуйте программу, которая напечатает хэштеги из фраз для лендинга сайта: 

В переменную logo считывается текст лендинга. Этот код уже написан.
Программа проверяет, есть ли в этом тексте хэштеги.  Хэштегами можно считать все элементы, которые начинаются со знака ""#"" и которые не состоят только из цифр (не включая знак ""#""). Гарантируется, что хэштеги отделены от другого текста пробелом. 
В конце программа печатает все хэштеги через запятую с пробелом. Хэштеги выводятся в том же порядке, в котором они идут в тексте.
Если знаков хэштегов в тексте нет, то программа ничего не печатает.","['Выучите китайский язык без усилий выполняя задания в приложении ( #the_best_app ) за #20 дней.', 'Ваш вопрос ( #question ) - наш ответ ( #answer ) ! Мы всегда с Вами yf #100 %', 'Мощный рывок для Вашего @бизнеса', 'Я никогда не был #счастье1 #любовь123 #123_123 qwe#qwe', '9 из 10 экспертов рекомендуют # наш #_1223 продукт #__ .', '# #123 #qswr_1 @qws1 $1#qwd 1#123_qwe #0 #____ #$567123']","['#the_best_app', '#question, #answer', nan, '#счастье1, #любовь123, #123_123', '#, #_1223, #__', '#, #qswr_1, #____, #$567123']","logo = input()

res = []
for info in logo.split():
    if info.startswith('#') and info[1:].isdigit() == False:      
        res.append(info)
        
print(res)","logo = input()

res = []
for info in logo.split():
    if info.startswith('#') and info[1:].isdigit() == False:      
        res.append(info)
        
print(*res, sep=', ')","Ошибка в открытых и скрытых тестах. 

Ваш код не проверяет все условия задания. Например, он некорректно выполняет условие """"В конце программа печатает все хэштеги через запятую с пробелом"""". Дополните функцию print(), чтобы выполнить данное условие.","['open', 'open', 'open', 'closed', 'closed', 'closed']","<Task description>: Реализуйте программу, которая напечатает хэштеги из фраз для лендинга сайта: 

В переменную logo считывается текст лендинга. Этот код уже написан.
Программа проверяет, есть ли в этом тексте хэштеги.  Хэштегами можно считать все элементы, которые начинаются со знака ""#"" и которые не состоят только из цифр (не включая знак ""#""). Гарантируется, что хэштеги отделены от другого текста пробелом. 
В конце программа печатает все хэштеги через запятую с пробелом. Хэштеги выводятся в том же порядке, в котором они идут в тексте.
Если знаков хэштегов в тексте нет, то программа ничего не печатает. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: Выучите китайский язык без усилий выполняя задания в приложении ( #the_best_app ) за #20 дней. 
<Вывод>: #the_best_app 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: Ваш вопрос ( #question ) - наш ответ ( #answer ) ! Мы всегда с Вами yf #100 % 
<Вывод>: #question, #answer 
<Example 3>: 
<Тип теста 3>: open 
<Ввод>: Мощный рывок для Вашего @бизнеса 
<Вывод>: nan 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: Я никогда не был #счастье1 #любовь123 #123_123 qwe#qwe 
<Вывод>: #счастье1, #любовь123, #123_123 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: 9 из 10 экспертов рекомендуют # наш #_1223 продукт #__ . 
<Вывод>: #, #_1223, #__ 
<Example 6>: 
<Тип теста 6>: closed 
<Ввод>: # #123 #qswr_1 @qws1 $1#qwd 1#123_qwe #0 #____ #$567123 
<Вывод>: #, #qswr_1, #____, #$567123 
<Решение студента>: logo = input()

res = []
for info in logo.split():
    if info.startswith('#') and info[1:].isdigit() == False:      
        res.append(info)
        
print(res) 
<Идеальное решение>: logo = input()

res = []
for info in logo.split():
    if info.startswith('#') and info[1:].isdigit() == False:      
        res.append(info)
        
print(*res, sep=', ') 


<Комментарий эксперта>:"
43,56,3,"Реализуйте программу, которая напечатает хэштеги из фраз для лендинга сайта: 

В переменную logo считывается текст лендинга. Этот код уже написан.
Программа проверяет, есть ли в этом тексте хэштеги.  Хэштегами можно считать все элементы, которые начинаются со знака ""#"" и которые не состоят только из цифр (не включая знак ""#""). Гарантируется, что хэштеги отделены от другого текста пробелом. 
В конце программа печатает все хэштеги через запятую с пробелом. Хэштеги выводятся в том же порядке, в котором они идут в тексте.
Если знаков хэштегов в тексте нет, то программа ничего не печатает.","['Выучите китайский язык без усилий выполняя задания в приложении ( #the_best_app ) за #20 дней.', 'Ваш вопрос ( #question ) - наш ответ ( #answer ) ! Мы всегда с Вами yf #100 %', 'Мощный рывок для Вашего @бизнеса', 'Я никогда не был #счастье1 #любовь123 #123_123 qwe#qwe', '9 из 10 экспертов рекомендуют # наш #_1223 продукт #__ .', '# #123 #qswr_1 @qws1 $1#qwd 1#123_qwe #0 #____ #$567123']","['#the_best_app', '#question, #answer', nan, '#счастье1, #любовь123, #123_123', '#, #_1223, #__', '#, #qswr_1, #____, #$567123']","logo = input()

res = []
for info in logo.split():
    if info.startswith('#') and info[1:].isdigit() == False:      
        res.append(info)
        
print(*res, sep=',')","logo = input()

res = []
for info in logo.split():
    if info.startswith('#') and info[1:].isdigit() == False:      
        res.append(info)
        
print(*res, sep=', ')","Ошибка в открытых и скрытых тестах. 

Ваш код не проверяет все условия задания. Например, он некорректно выполняет условие """"В конце программа печатает все хэштеги через запятую с пробелом"""". Дополните функцию print(), чтобы выполнить данное условие.","['open', 'open', 'open', 'closed', 'closed', 'closed']","<Task description>: Реализуйте программу, которая напечатает хэштеги из фраз для лендинга сайта: 

В переменную logo считывается текст лендинга. Этот код уже написан.
Программа проверяет, есть ли в этом тексте хэштеги.  Хэштегами можно считать все элементы, которые начинаются со знака ""#"" и которые не состоят только из цифр (не включая знак ""#""). Гарантируется, что хэштеги отделены от другого текста пробелом. 
В конце программа печатает все хэштеги через запятую с пробелом. Хэштеги выводятся в том же порядке, в котором они идут в тексте.
Если знаков хэштегов в тексте нет, то программа ничего не печатает. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: Выучите китайский язык без усилий выполняя задания в приложении ( #the_best_app ) за #20 дней. 
<Вывод>: #the_best_app 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: Ваш вопрос ( #question ) - наш ответ ( #answer ) ! Мы всегда с Вами yf #100 % 
<Вывод>: #question, #answer 
<Example 3>: 
<Тип теста 3>: open 
<Ввод>: Мощный рывок для Вашего @бизнеса 
<Вывод>: nan 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: Я никогда не был #счастье1 #любовь123 #123_123 qwe#qwe 
<Вывод>: #счастье1, #любовь123, #123_123 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: 9 из 10 экспертов рекомендуют # наш #_1223 продукт #__ . 
<Вывод>: #, #_1223, #__ 
<Example 6>: 
<Тип теста 6>: closed 
<Ввод>: # #123 #qswr_1 @qws1 $1#qwd 1#123_qwe #0 #____ #$567123 
<Вывод>: #, #qswr_1, #____, #$567123 
<Решение студента>: logo = input()

res = []
for info in logo.split():
    if info.startswith('#') and info[1:].isdigit() == False:      
        res.append(info)
        
print(*res, sep=',') 
<Идеальное решение>: logo = input()

res = []
for info in logo.split():
    if info.startswith('#') and info[1:].isdigit() == False:      
        res.append(info)
        
print(*res, sep=', ') 


<Комментарий эксперта>:"
44,57,3,"Реализуйте программу, которая напечатает хэштеги из фраз для лендинга сайта: 

В переменную logo считывается текст лендинга. Этот код уже написан.
Программа проверяет, есть ли в этом тексте хэштеги.  Хэштегами можно считать все элементы, которые начинаются со знака ""#"" и которые не состоят только из цифр (не включая знак ""#""). Гарантируется, что хэштеги отделены от другого текста пробелом. 
В конце программа печатает все хэштеги через запятую с пробелом. Хэштеги выводятся в том же порядке, в котором они идут в тексте.
Если знаков хэштегов в тексте нет, то программа ничего не печатает.","['Выучите китайский язык без усилий выполняя задания в приложении ( #the_best_app ) за #20 дней.', 'Ваш вопрос ( #question ) - наш ответ ( #answer ) ! Мы всегда с Вами yf #100 %', 'Мощный рывок для Вашего @бизнеса', 'Я никогда не был #счастье1 #любовь123 #123_123 qwe#qwe', '9 из 10 экспертов рекомендуют # наш #_1223 продукт #__ .', '# #123 #qswr_1 @qws1 $1#qwd 1#123_qwe #0 #____ #$567123']","['#the_best_app', '#question, #answer', nan, '#счастье1, #любовь123, #123_123', '#, #_1223, #__', '#, #qswr_1, #____, #$567123']","logo = input()

res = []
for info in logo.split():
    if info.startswith('#') and info[1:].isdigit() == False:      
        res.append(logo)
        
print(*res, sep=', ')","logo = input()

res = []
for info in logo.split():
    if info.startswith('#') and info[1:].isdigit() == False:      
        res.append(info)
        
print(*res, sep=', ')",Некорректно использован метод добавления элементов в список. В список добавлена некорректная переменная.,"['open', 'open', 'open', 'closed', 'closed', 'closed']","<Task description>: Реализуйте программу, которая напечатает хэштеги из фраз для лендинга сайта: 

В переменную logo считывается текст лендинга. Этот код уже написан.
Программа проверяет, есть ли в этом тексте хэштеги.  Хэштегами можно считать все элементы, которые начинаются со знака ""#"" и которые не состоят только из цифр (не включая знак ""#""). Гарантируется, что хэштеги отделены от другого текста пробелом. 
В конце программа печатает все хэштеги через запятую с пробелом. Хэштеги выводятся в том же порядке, в котором они идут в тексте.
Если знаков хэштегов в тексте нет, то программа ничего не печатает. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: Выучите китайский язык без усилий выполняя задания в приложении ( #the_best_app ) за #20 дней. 
<Вывод>: #the_best_app 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: Ваш вопрос ( #question ) - наш ответ ( #answer ) ! Мы всегда с Вами yf #100 % 
<Вывод>: #question, #answer 
<Example 3>: 
<Тип теста 3>: open 
<Ввод>: Мощный рывок для Вашего @бизнеса 
<Вывод>: nan 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: Я никогда не был #счастье1 #любовь123 #123_123 qwe#qwe 
<Вывод>: #счастье1, #любовь123, #123_123 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: 9 из 10 экспертов рекомендуют # наш #_1223 продукт #__ . 
<Вывод>: #, #_1223, #__ 
<Example 6>: 
<Тип теста 6>: closed 
<Ввод>: # #123 #qswr_1 @qws1 $1#qwd 1#123_qwe #0 #____ #$567123 
<Вывод>: #, #qswr_1, #____, #$567123 
<Решение студента>: logo = input()

res = []
for info in logo.split():
    if info.startswith('#') and info[1:].isdigit() == False:      
        res.append(logo)
        
print(*res, sep=', ') 
<Идеальное решение>: logo = input()

res = []
for info in logo.split():
    if info.startswith('#') and info[1:].isdigit() == False:      
        res.append(info)
        
print(*res, sep=', ') 


<Комментарий эксперта>:"
45,58,3,"Реализуйте программу, которая напечатает хэштеги из фраз для лендинга сайта: 

В переменную logo считывается текст лендинга. Этот код уже написан.
Программа проверяет, есть ли в этом тексте хэштеги.  Хэштегами можно считать все элементы, которые начинаются со знака ""#"" и которые не состоят только из цифр (не включая знак ""#""). Гарантируется, что хэштеги отделены от другого текста пробелом. 
В конце программа печатает все хэштеги через запятую с пробелом. Хэштеги выводятся в том же порядке, в котором они идут в тексте.
Если знаков хэштегов в тексте нет, то программа ничего не печатает.","['Выучите китайский язык без усилий выполняя задания в приложении ( #the_best_app ) за #20 дней.', 'Ваш вопрос ( #question ) - наш ответ ( #answer ) ! Мы всегда с Вами yf #100 %', 'Мощный рывок для Вашего @бизнеса', 'Я никогда не был #счастье1 #любовь123 #123_123 qwe#qwe', '9 из 10 экспертов рекомендуют # наш #_1223 продукт #__ .', '# #123 #qswr_1 @qws1 $1#qwd 1#123_qwe #0 #____ #$567123']","['#the_best_app', '#question, #answer', nan, '#счастье1, #любовь123, #123_123', '#, #_1223, #__', '#, #qswr_1, #____, #$567123']","logo = input()

res = []
for info in logo.split():
    if info.startswith('#') and info[1:].isdigit() == False:      
        res.append(info)
        
print(logo)","logo = input()

res = []
for info in logo.split():
    if info.startswith('#') and info[1:].isdigit() == False:      
        res.append(info)
        
print(*res, sep=', ')","Ошибка в открытых и скрытых тестах. 

Ваш код выводит некорректную переменную.","['open', 'open', 'open', 'closed', 'closed', 'closed']","<Task description>: Реализуйте программу, которая напечатает хэштеги из фраз для лендинга сайта: 

В переменную logo считывается текст лендинга. Этот код уже написан.
Программа проверяет, есть ли в этом тексте хэштеги.  Хэштегами можно считать все элементы, которые начинаются со знака ""#"" и которые не состоят только из цифр (не включая знак ""#""). Гарантируется, что хэштеги отделены от другого текста пробелом. 
В конце программа печатает все хэштеги через запятую с пробелом. Хэштеги выводятся в том же порядке, в котором они идут в тексте.
Если знаков хэштегов в тексте нет, то программа ничего не печатает. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: Выучите китайский язык без усилий выполняя задания в приложении ( #the_best_app ) за #20 дней. 
<Вывод>: #the_best_app 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: Ваш вопрос ( #question ) - наш ответ ( #answer ) ! Мы всегда с Вами yf #100 % 
<Вывод>: #question, #answer 
<Example 3>: 
<Тип теста 3>: open 
<Ввод>: Мощный рывок для Вашего @бизнеса 
<Вывод>: nan 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: Я никогда не был #счастье1 #любовь123 #123_123 qwe#qwe 
<Вывод>: #счастье1, #любовь123, #123_123 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: 9 из 10 экспертов рекомендуют # наш #_1223 продукт #__ . 
<Вывод>: #, #_1223, #__ 
<Example 6>: 
<Тип теста 6>: closed 
<Ввод>: # #123 #qswr_1 @qws1 $1#qwd 1#123_qwe #0 #____ #$567123 
<Вывод>: #, #qswr_1, #____, #$567123 
<Решение студента>: logo = input()

res = []
for info in logo.split():
    if info.startswith('#') and info[1:].isdigit() == False:      
        res.append(info)
        
print(logo) 
<Идеальное решение>: logo = input()

res = []
for info in logo.split():
    if info.startswith('#') and info[1:].isdigit() == False:      
        res.append(info)
        
print(*res, sep=', ') 


<Комментарий эксперта>:"
46,59,3,"Реализуйте программу, которая напечатает хэштеги из фраз для лендинга сайта: 

В переменную logo считывается текст лендинга. Этот код уже написан.
Программа проверяет, есть ли в этом тексте хэштеги.  Хэштегами можно считать все элементы, которые начинаются со знака ""#"" и которые не состоят только из цифр (не включая знак ""#""). Гарантируется, что хэштеги отделены от другого текста пробелом. 
В конце программа печатает все хэштеги через запятую с пробелом. Хэштеги выводятся в том же порядке, в котором они идут в тексте.
Если знаков хэштегов в тексте нет, то программа ничего не печатает.","['Выучите китайский язык без усилий выполняя задания в приложении ( #the_best_app ) за #20 дней.', 'Ваш вопрос ( #question ) - наш ответ ( #answer ) ! Мы всегда с Вами yf #100 %', 'Мощный рывок для Вашего @бизнеса', 'Я никогда не был #счастье1 #любовь123 #123_123 qwe#qwe', '9 из 10 экспертов рекомендуют # наш #_1223 продукт #__ .', '# #123 #qswr_1 @qws1 $1#qwd 1#123_qwe #0 #____ #$567123']","['#the_best_app', '#question, #answer', nan, '#счастье1, #любовь123, #123_123', '#, #_1223, #__', '#, #qswr_1, #____, #$567123']","logo = input()

res = []
for info in logo.split():
    if info.startswith('#') and info[1:].isdigit() == False:      
        res.append(info)
        
    print(res)","logo = input()

res = []
for info in logo.split():
    if info.startswith('#') and info[1:].isdigit() == False:      
        res.append(info)
        
print(*res, sep=', ')",Обратите внимание на некорректную табуляцию функции print().,"['open', 'open', 'open', 'closed', 'closed', 'closed']","<Task description>: Реализуйте программу, которая напечатает хэштеги из фраз для лендинга сайта: 

В переменную logo считывается текст лендинга. Этот код уже написан.
Программа проверяет, есть ли в этом тексте хэштеги.  Хэштегами можно считать все элементы, которые начинаются со знака ""#"" и которые не состоят только из цифр (не включая знак ""#""). Гарантируется, что хэштеги отделены от другого текста пробелом. 
В конце программа печатает все хэштеги через запятую с пробелом. Хэштеги выводятся в том же порядке, в котором они идут в тексте.
Если знаков хэштегов в тексте нет, то программа ничего не печатает. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: Выучите китайский язык без усилий выполняя задания в приложении ( #the_best_app ) за #20 дней. 
<Вывод>: #the_best_app 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: Ваш вопрос ( #question ) - наш ответ ( #answer ) ! Мы всегда с Вами yf #100 % 
<Вывод>: #question, #answer 
<Example 3>: 
<Тип теста 3>: open 
<Ввод>: Мощный рывок для Вашего @бизнеса 
<Вывод>: nan 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: Я никогда не был #счастье1 #любовь123 #123_123 qwe#qwe 
<Вывод>: #счастье1, #любовь123, #123_123 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: 9 из 10 экспертов рекомендуют # наш #_1223 продукт #__ . 
<Вывод>: #, #_1223, #__ 
<Example 6>: 
<Тип теста 6>: closed 
<Ввод>: # #123 #qswr_1 @qws1 $1#qwd 1#123_qwe #0 #____ #$567123 
<Вывод>: #, #qswr_1, #____, #$567123 
<Решение студента>: logo = input()

res = []
for info in logo.split():
    if info.startswith('#') and info[1:].isdigit() == False:      
        res.append(info)
        
    print(res) 
<Идеальное решение>: logo = input()

res = []
for info in logo.split():
    if info.startswith('#') and info[1:].isdigit() == False:      
        res.append(info)
        
print(*res, sep=', ') 


<Комментарий эксперта>:"
47,90,6,"Напишите функцию, определяющую дизайнера, который работает над самым легким проектом.

Определите функцию designer, которая принимает на вход три списка:
в первом списке перечислены фамилии дизайнеров;
во втором списке перечислены размеры помещений (в кв. м.) (строки), для которых эти дизайнеры создают проекты интерьера соответственно.
в третьем списке перечислены города, в которых располагаются помещения.
Гарантируется, что фамилии дизайнеров не повторяются. При этом размеры помещений могут повторяться.
Самым легким считается проект, в котором площадь помещения минимальна и город, в котором находится помещение, над которым работает дизайнер, не Москва или Санкт-Петербург. Гарантируется, что такой проект только один.
Функция должна возвращать фамилию дизайнера, который работает над самым легким проектом. 
Важно! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке.","[""['Круглов', 'Квадратов', 'Иванов', 'Марков', 'Пеньков', 'Гуськов'], ['100', '60', '67', '120', '90', '32'], ['Москва', 'Санкт-Петербург', 'Пермь', 'Москва', 'Сочи', 'Иваново']"", ""['Елисеев', 'Краков'], ['67', '100'], ['Санкт-Петербург', 'Томск']"", ""['Петров', 'Иванов', 'Волков', 'Меньшов'], ['50', '109', '30', '40'], ['Сочи', 'Москва', 'Иркутск', 'Краснодар']"", ""['Елисеев', 'Воробьев', 'Стариков'], ['100', '100', '150'], ['Москва', 'Санкт-Петербург', 'Реутов']"", ""['Графов', 'Петров'], ['10', '10'], ['Санкт-Петербург', 'Омск']"", ""['Степанов'], ['100'], ['Новгород']""]","['Гуськов', 'Краков', 'Волков', 'Стариков', 'Петров', 'Степанов']","def designer (designers, sizes, towns)
    sizes = list(map(int, sizes))
    lst_of_des = []
    lst_of_siz = []
    for i in range(len(towns)):
        if towns[i] != ""Москва"" and towns[i] != ""Санкт-Петербург"":
            lst_of_des.append(designers[i])
            lst_of_siz.append(sizes[i])
    
    return lst_of_des[lst_of_siz.index(min(lst_of_siz))]","def designer (designers, sizes, towns):
    sizes = list(map(int, sizes))
    lst_of_des = []
    lst_of_siz = []
    for i in range(len(towns)):
        if towns[i] != ""Москва"" and towns[i] != ""Санкт-Петербург"":
            lst_of_des.append(designers[i])
            lst_of_siz.append(sizes[i])
    
    return lst_of_des[lst_of_siz.index(min(lst_of_siz))]",Вы забыли поставить двоеточие после определения функции.,"['open', 'open', 'closed', 'closed', 'closed', 'closed']","<Task description>: Напишите функцию, определяющую дизайнера, который работает над самым легким проектом.

Определите функцию designer, которая принимает на вход три списка:
в первом списке перечислены фамилии дизайнеров;
во втором списке перечислены размеры помещений (в кв. м.) (строки), для которых эти дизайнеры создают проекты интерьера соответственно.
в третьем списке перечислены города, в которых располагаются помещения.
Гарантируется, что фамилии дизайнеров не повторяются. При этом размеры помещений могут повторяться.
Самым легким считается проект, в котором площадь помещения минимальна и город, в котором находится помещение, над которым работает дизайнер, не Москва или Санкт-Петербург. Гарантируется, что такой проект только один.
Функция должна возвращать фамилию дизайнера, который работает над самым легким проектом. 
Важно! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: ['Круглов', 'Квадратов', 'Иванов', 'Марков', 'Пеньков', 'Гуськов'], ['100', '60', '67', '120', '90', '32'], ['Москва', 'Санкт-Петербург', 'Пермь', 'Москва', 'Сочи', 'Иваново'] 
<Вывод>: Гуськов 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: ['Елисеев', 'Краков'], ['67', '100'], ['Санкт-Петербург', 'Томск'] 
<Вывод>: Краков 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: ['Петров', 'Иванов', 'Волков', 'Меньшов'], ['50', '109', '30', '40'], ['Сочи', 'Москва', 'Иркутск', 'Краснодар'] 
<Вывод>: Волков 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: ['Елисеев', 'Воробьев', 'Стариков'], ['100', '100', '150'], ['Москва', 'Санкт-Петербург', 'Реутов'] 
<Вывод>: Стариков 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: ['Графов', 'Петров'], ['10', '10'], ['Санкт-Петербург', 'Омск'] 
<Вывод>: Петров 
<Example 6>: 
<Тип теста 6>: closed 
<Ввод>: ['Степанов'], ['100'], ['Новгород'] 
<Вывод>: Степанов 
<Решение студента>: def designer (designers, sizes, towns)
    sizes = list(map(int, sizes))
    lst_of_des = []
    lst_of_siz = []
    for i in range(len(towns)):
        if towns[i] != ""Москва"" and towns[i] != ""Санкт-Петербург"":
            lst_of_des.append(designers[i])
            lst_of_siz.append(sizes[i])
    
    return lst_of_des[lst_of_siz.index(min(lst_of_siz))] 
<Идеальное решение>: def designer (designers, sizes, towns):
    sizes = list(map(int, sizes))
    lst_of_des = []
    lst_of_siz = []
    for i in range(len(towns)):
        if towns[i] != ""Москва"" and towns[i] != ""Санкт-Петербург"":
            lst_of_des.append(designers[i])
            lst_of_siz.append(sizes[i])
    
    return lst_of_des[lst_of_siz.index(min(lst_of_siz))] 


<Комментарий эксперта>:"
48,91,6,"Напишите функцию, определяющую дизайнера, который работает над самым легким проектом.

Определите функцию designer, которая принимает на вход три списка:
в первом списке перечислены фамилии дизайнеров;
во втором списке перечислены размеры помещений (в кв. м.) (строки), для которых эти дизайнеры создают проекты интерьера соответственно.
в третьем списке перечислены города, в которых располагаются помещения.
Гарантируется, что фамилии дизайнеров не повторяются. При этом размеры помещений могут повторяться.
Самым легким считается проект, в котором площадь помещения минимальна и город, в котором находится помещение, над которым работает дизайнер, не Москва или Санкт-Петербург. Гарантируется, что такой проект только один.
Функция должна возвращать фамилию дизайнера, который работает над самым легким проектом. 
Важно! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке.","[""['Круглов', 'Квадратов', 'Иванов', 'Марков', 'Пеньков', 'Гуськов'], ['100', '60', '67', '120', '90', '32'], ['Москва', 'Санкт-Петербург', 'Пермь', 'Москва', 'Сочи', 'Иваново']"", ""['Елисеев', 'Краков'], ['67', '100'], ['Санкт-Петербург', 'Томск']"", ""['Петров', 'Иванов', 'Волков', 'Меньшов'], ['50', '109', '30', '40'], ['Сочи', 'Москва', 'Иркутск', 'Краснодар']"", ""['Елисеев', 'Воробьев', 'Стариков'], ['100', '100', '150'], ['Москва', 'Санкт-Петербург', 'Реутов']"", ""['Графов', 'Петров'], ['10', '10'], ['Санкт-Петербург', 'Омск']"", ""['Степанов'], ['100'], ['Новгород']""]","['Гуськов', 'Краков', 'Волков', 'Стариков', 'Петров', 'Степанов']","def designer():
    sizes = list(map(int, sizes))
    lst_of_des = []
    lst_of_siz = []
    for i in range(len(towns)):
        if towns[i] != ""Москва"" and towns[i] != ""Санкт-Петербург"":
            lst_of_des.append(designers[i])
            lst_of_siz.append(sizes[i])
    
    return lst_of_des[lst_of_siz.index(min(lst_of_siz))]","def designer (designers, sizes, towns):
    sizes = list(map(int, sizes))
    lst_of_des = []
    lst_of_siz = []
    for i in range(len(towns)):
        if towns[i] != ""Москва"" and towns[i] != ""Санкт-Петербург"":
            lst_of_des.append(designers[i])
            lst_of_siz.append(sizes[i])
    
    return lst_of_des[lst_of_siz.index(min(lst_of_siz))]","Вы не добавили переменные, которые функция будет принимать как аргументы.","['open', 'open', 'closed', 'closed', 'closed', 'closed']","<Task description>: Напишите функцию, определяющую дизайнера, который работает над самым легким проектом.

Определите функцию designer, которая принимает на вход три списка:
в первом списке перечислены фамилии дизайнеров;
во втором списке перечислены размеры помещений (в кв. м.) (строки), для которых эти дизайнеры создают проекты интерьера соответственно.
в третьем списке перечислены города, в которых располагаются помещения.
Гарантируется, что фамилии дизайнеров не повторяются. При этом размеры помещений могут повторяться.
Самым легким считается проект, в котором площадь помещения минимальна и город, в котором находится помещение, над которым работает дизайнер, не Москва или Санкт-Петербург. Гарантируется, что такой проект только один.
Функция должна возвращать фамилию дизайнера, который работает над самым легким проектом. 
Важно! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: ['Круглов', 'Квадратов', 'Иванов', 'Марков', 'Пеньков', 'Гуськов'], ['100', '60', '67', '120', '90', '32'], ['Москва', 'Санкт-Петербург', 'Пермь', 'Москва', 'Сочи', 'Иваново'] 
<Вывод>: Гуськов 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: ['Елисеев', 'Краков'], ['67', '100'], ['Санкт-Петербург', 'Томск'] 
<Вывод>: Краков 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: ['Петров', 'Иванов', 'Волков', 'Меньшов'], ['50', '109', '30', '40'], ['Сочи', 'Москва', 'Иркутск', 'Краснодар'] 
<Вывод>: Волков 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: ['Елисеев', 'Воробьев', 'Стариков'], ['100', '100', '150'], ['Москва', 'Санкт-Петербург', 'Реутов'] 
<Вывод>: Стариков 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: ['Графов', 'Петров'], ['10', '10'], ['Санкт-Петербург', 'Омск'] 
<Вывод>: Петров 
<Example 6>: 
<Тип теста 6>: closed 
<Ввод>: ['Степанов'], ['100'], ['Новгород'] 
<Вывод>: Степанов 
<Решение студента>: def designer():
    sizes = list(map(int, sizes))
    lst_of_des = []
    lst_of_siz = []
    for i in range(len(towns)):
        if towns[i] != ""Москва"" and towns[i] != ""Санкт-Петербург"":
            lst_of_des.append(designers[i])
            lst_of_siz.append(sizes[i])
    
    return lst_of_des[lst_of_siz.index(min(lst_of_siz))] 
<Идеальное решение>: def designer (designers, sizes, towns):
    sizes = list(map(int, sizes))
    lst_of_des = []
    lst_of_siz = []
    for i in range(len(towns)):
        if towns[i] != ""Москва"" and towns[i] != ""Санкт-Петербург"":
            lst_of_des.append(designers[i])
            lst_of_siz.append(sizes[i])
    
    return lst_of_des[lst_of_siz.index(min(lst_of_siz))] 


<Комментарий эксперта>:"
49,92,6,"Напишите функцию, определяющую дизайнера, который работает над самым легким проектом.

Определите функцию designer, которая принимает на вход три списка:
в первом списке перечислены фамилии дизайнеров;
во втором списке перечислены размеры помещений (в кв. м.) (строки), для которых эти дизайнеры создают проекты интерьера соответственно.
в третьем списке перечислены города, в которых располагаются помещения.
Гарантируется, что фамилии дизайнеров не повторяются. При этом размеры помещений могут повторяться.
Самым легким считается проект, в котором площадь помещения минимальна и город, в котором находится помещение, над которым работает дизайнер, не Москва или Санкт-Петербург. Гарантируется, что такой проект только один.
Функция должна возвращать фамилию дизайнера, который работает над самым легким проектом. 
Важно! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке.","[""['Круглов', 'Квадратов', 'Иванов', 'Марков', 'Пеньков', 'Гуськов'], ['100', '60', '67', '120', '90', '32'], ['Москва', 'Санкт-Петербург', 'Пермь', 'Москва', 'Сочи', 'Иваново']"", ""['Елисеев', 'Краков'], ['67', '100'], ['Санкт-Петербург', 'Томск']"", ""['Петров', 'Иванов', 'Волков', 'Меньшов'], ['50', '109', '30', '40'], ['Сочи', 'Москва', 'Иркутск', 'Краснодар']"", ""['Елисеев', 'Воробьев', 'Стариков'], ['100', '100', '150'], ['Москва', 'Санкт-Петербург', 'Реутов']"", ""['Графов', 'Петров'], ['10', '10'], ['Санкт-Петербург', 'Омск']"", ""['Степанов'], ['100'], ['Новгород']""]","['Гуськов', 'Краков', 'Волков', 'Стариков', 'Петров', 'Степанов']","def designer():
    designers = input()
    sizes = input( list(map(int, sizes)))
    towns = input()
    lst_of_des = []
    lst_of_siz = []
    for i in range(len(towns)):
        if towns[i] != ""Москва"" and towns[i] != ""Санкт-Петербург"":
            lst_of_des.append(designers[i])
            lst_of_siz.append(sizes[i])
    
    return lst_of_des[lst_of_siz.index(min(lst_of_siz))]","def designer (designers, sizes, towns):
    sizes = list(map(int, sizes))
    lst_of_des = []
    lst_of_siz = []
    for i in range(len(towns)):
        if towns[i] != ""Москва"" and towns[i] != ""Санкт-Петербург"":
            lst_of_des.append(designers[i])
            lst_of_siz.append(sizes[i])
    
    return lst_of_des[lst_of_siz.index(min(lst_of_siz))]",Вы задаете переменные внутри фнукции. Используйте переменные в качестве аргументов функции.,"['open', 'open', 'closed', 'closed', 'closed', 'closed']","<Task description>: Напишите функцию, определяющую дизайнера, который работает над самым легким проектом.

Определите функцию designer, которая принимает на вход три списка:
в первом списке перечислены фамилии дизайнеров;
во втором списке перечислены размеры помещений (в кв. м.) (строки), для которых эти дизайнеры создают проекты интерьера соответственно.
в третьем списке перечислены города, в которых располагаются помещения.
Гарантируется, что фамилии дизайнеров не повторяются. При этом размеры помещений могут повторяться.
Самым легким считается проект, в котором площадь помещения минимальна и город, в котором находится помещение, над которым работает дизайнер, не Москва или Санкт-Петербург. Гарантируется, что такой проект только один.
Функция должна возвращать фамилию дизайнера, который работает над самым легким проектом. 
Важно! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: ['Круглов', 'Квадратов', 'Иванов', 'Марков', 'Пеньков', 'Гуськов'], ['100', '60', '67', '120', '90', '32'], ['Москва', 'Санкт-Петербург', 'Пермь', 'Москва', 'Сочи', 'Иваново'] 
<Вывод>: Гуськов 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: ['Елисеев', 'Краков'], ['67', '100'], ['Санкт-Петербург', 'Томск'] 
<Вывод>: Краков 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: ['Петров', 'Иванов', 'Волков', 'Меньшов'], ['50', '109', '30', '40'], ['Сочи', 'Москва', 'Иркутск', 'Краснодар'] 
<Вывод>: Волков 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: ['Елисеев', 'Воробьев', 'Стариков'], ['100', '100', '150'], ['Москва', 'Санкт-Петербург', 'Реутов'] 
<Вывод>: Стариков 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: ['Графов', 'Петров'], ['10', '10'], ['Санкт-Петербург', 'Омск'] 
<Вывод>: Петров 
<Example 6>: 
<Тип теста 6>: closed 
<Ввод>: ['Степанов'], ['100'], ['Новгород'] 
<Вывод>: Степанов 
<Решение студента>: def designer():
    designers = input()
    sizes = input( list(map(int, sizes)))
    towns = input()
    lst_of_des = []
    lst_of_siz = []
    for i in range(len(towns)):
        if towns[i] != ""Москва"" and towns[i] != ""Санкт-Петербург"":
            lst_of_des.append(designers[i])
            lst_of_siz.append(sizes[i])
    
    return lst_of_des[lst_of_siz.index(min(lst_of_siz))] 
<Идеальное решение>: def designer (designers, sizes, towns):
    sizes = list(map(int, sizes))
    lst_of_des = []
    lst_of_siz = []
    for i in range(len(towns)):
        if towns[i] != ""Москва"" and towns[i] != ""Санкт-Петербург"":
            lst_of_des.append(designers[i])
            lst_of_siz.append(sizes[i])
    
    return lst_of_des[lst_of_siz.index(min(lst_of_siz))] 


<Комментарий эксперта>:"
50,93,6,"Напишите функцию, определяющую дизайнера, который работает над самым легким проектом.

Определите функцию designer, которая принимает на вход три списка:
в первом списке перечислены фамилии дизайнеров;
во втором списке перечислены размеры помещений (в кв. м.) (строки), для которых эти дизайнеры создают проекты интерьера соответственно.
в третьем списке перечислены города, в которых располагаются помещения.
Гарантируется, что фамилии дизайнеров не повторяются. При этом размеры помещений могут повторяться.
Самым легким считается проект, в котором площадь помещения минимальна и город, в котором находится помещение, над которым работает дизайнер, не Москва или Санкт-Петербург. Гарантируется, что такой проект только один.
Функция должна возвращать фамилию дизайнера, который работает над самым легким проектом. 
Важно! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке.","[""['Круглов', 'Квадратов', 'Иванов', 'Марков', 'Пеньков', 'Гуськов'], ['100', '60', '67', '120', '90', '32'], ['Москва', 'Санкт-Петербург', 'Пермь', 'Москва', 'Сочи', 'Иваново']"", ""['Елисеев', 'Краков'], ['67', '100'], ['Санкт-Петербург', 'Томск']"", ""['Петров', 'Иванов', 'Волков', 'Меньшов'], ['50', '109', '30', '40'], ['Сочи', 'Москва', 'Иркутск', 'Краснодар']"", ""['Елисеев', 'Воробьев', 'Стариков'], ['100', '100', '150'], ['Москва', 'Санкт-Петербург', 'Реутов']"", ""['Графов', 'Петров'], ['10', '10'], ['Санкт-Петербург', 'Омск']"", ""['Степанов'], ['100'], ['Новгород']""]","['Гуськов', 'Краков', 'Волков', 'Стариков', 'Петров', 'Степанов']","def designer (designers, sizes, towns):
    sizes =int(sizes)
    lst_of_des = []
    lst_of_siz = []
    for i in range(len(towns)):
        if towns[i] != ""Москва"" and towns[i] != ""Санкт-Петербург"":
            lst_of_des.append(designers[i])
            lst_of_siz.append(sizes[i])
    
    return lst_of_des[lst_of_siz.index(min(lst_of_siz))]","def designer (designers, sizes, towns):
    sizes = list(map(int, sizes))
    lst_of_des = []
    lst_of_siz = []
    for i in range(len(towns)):
        if towns[i] != ""Москва"" and towns[i] != ""Санкт-Петербург"":
            lst_of_des.append(designers[i])
            lst_of_siz.append(sizes[i])
    
    return lst_of_des[lst_of_siz.index(min(lst_of_siz))]",Ошибка при преобразовании переменной. int() не может применяться ко всему списку сразу. Примените int() к каждому элементу списка по отдельности.,"['open', 'open', 'closed', 'closed', 'closed', 'closed']","<Task description>: Напишите функцию, определяющую дизайнера, который работает над самым легким проектом.

Определите функцию designer, которая принимает на вход три списка:
в первом списке перечислены фамилии дизайнеров;
во втором списке перечислены размеры помещений (в кв. м.) (строки), для которых эти дизайнеры создают проекты интерьера соответственно.
в третьем списке перечислены города, в которых располагаются помещения.
Гарантируется, что фамилии дизайнеров не повторяются. При этом размеры помещений могут повторяться.
Самым легким считается проект, в котором площадь помещения минимальна и город, в котором находится помещение, над которым работает дизайнер, не Москва или Санкт-Петербург. Гарантируется, что такой проект только один.
Функция должна возвращать фамилию дизайнера, который работает над самым легким проектом. 
Важно! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: ['Круглов', 'Квадратов', 'Иванов', 'Марков', 'Пеньков', 'Гуськов'], ['100', '60', '67', '120', '90', '32'], ['Москва', 'Санкт-Петербург', 'Пермь', 'Москва', 'Сочи', 'Иваново'] 
<Вывод>: Гуськов 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: ['Елисеев', 'Краков'], ['67', '100'], ['Санкт-Петербург', 'Томск'] 
<Вывод>: Краков 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: ['Петров', 'Иванов', 'Волков', 'Меньшов'], ['50', '109', '30', '40'], ['Сочи', 'Москва', 'Иркутск', 'Краснодар'] 
<Вывод>: Волков 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: ['Елисеев', 'Воробьев', 'Стариков'], ['100', '100', '150'], ['Москва', 'Санкт-Петербург', 'Реутов'] 
<Вывод>: Стариков 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: ['Графов', 'Петров'], ['10', '10'], ['Санкт-Петербург', 'Омск'] 
<Вывод>: Петров 
<Example 6>: 
<Тип теста 6>: closed 
<Ввод>: ['Степанов'], ['100'], ['Новгород'] 
<Вывод>: Степанов 
<Решение студента>: def designer (designers, sizes, towns):
    sizes =int(sizes)
    lst_of_des = []
    lst_of_siz = []
    for i in range(len(towns)):
        if towns[i] != ""Москва"" and towns[i] != ""Санкт-Петербург"":
            lst_of_des.append(designers[i])
            lst_of_siz.append(sizes[i])
    
    return lst_of_des[lst_of_siz.index(min(lst_of_siz))] 
<Идеальное решение>: def designer (designers, sizes, towns):
    sizes = list(map(int, sizes))
    lst_of_des = []
    lst_of_siz = []
    for i in range(len(towns)):
        if towns[i] != ""Москва"" and towns[i] != ""Санкт-Петербург"":
            lst_of_des.append(designers[i])
            lst_of_siz.append(sizes[i])
    
    return lst_of_des[lst_of_siz.index(min(lst_of_siz))] 


<Комментарий эксперта>:"
51,94,6,"Напишите функцию, определяющую дизайнера, который работает над самым легким проектом.

Определите функцию designer, которая принимает на вход три списка:
в первом списке перечислены фамилии дизайнеров;
во втором списке перечислены размеры помещений (в кв. м.) (строки), для которых эти дизайнеры создают проекты интерьера соответственно.
в третьем списке перечислены города, в которых располагаются помещения.
Гарантируется, что фамилии дизайнеров не повторяются. При этом размеры помещений могут повторяться.
Самым легким считается проект, в котором площадь помещения минимальна и город, в котором находится помещение, над которым работает дизайнер, не Москва или Санкт-Петербург. Гарантируется, что такой проект только один.
Функция должна возвращать фамилию дизайнера, который работает над самым легким проектом. 
Важно! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке.","[""['Круглов', 'Квадратов', 'Иванов', 'Марков', 'Пеньков', 'Гуськов'], ['100', '60', '67', '120', '90', '32'], ['Москва', 'Санкт-Петербург', 'Пермь', 'Москва', 'Сочи', 'Иваново']"", ""['Елисеев', 'Краков'], ['67', '100'], ['Санкт-Петербург', 'Томск']"", ""['Петров', 'Иванов', 'Волков', 'Меньшов'], ['50', '109', '30', '40'], ['Сочи', 'Москва', 'Иркутск', 'Краснодар']"", ""['Елисеев', 'Воробьев', 'Стариков'], ['100', '100', '150'], ['Москва', 'Санкт-Петербург', 'Реутов']"", ""['Графов', 'Петров'], ['10', '10'], ['Санкт-Петербург', 'Омск']"", ""['Степанов'], ['100'], ['Новгород']""]","['Гуськов', 'Краков', 'Волков', 'Стариков', 'Петров', 'Степанов']","def designer (designers, sizes, towns):
    lst_of_des = []
    lst_of_siz = []
    for i in range(len(towns)):
        if towns[i] != ""Москва"" and towns[i] != ""Санкт-Петербург"":
            lst_of_des.append(designers[i])
            lst_of_siz.append(sizes[i])
    
    return lst_of_des[lst_of_siz.index(min(lst_of_siz))]","def designer (designers, sizes, towns):
    sizes = list(map(int, sizes))
    lst_of_des = []
    lst_of_siz = []
    for i in range(len(towns)):
        if towns[i] != ""Москва"" and towns[i] != ""Санкт-Петербург"":
            lst_of_des.append(designers[i])
            lst_of_siz.append(sizes[i])
    
    return lst_of_des[lst_of_siz.index(min(lst_of_siz))]",Ошибка при использовании функции min(). Функция не может применяться к объекту класса str.,"['open', 'open', 'closed', 'closed', 'closed', 'closed']","<Task description>: Напишите функцию, определяющую дизайнера, который работает над самым легким проектом.

Определите функцию designer, которая принимает на вход три списка:
в первом списке перечислены фамилии дизайнеров;
во втором списке перечислены размеры помещений (в кв. м.) (строки), для которых эти дизайнеры создают проекты интерьера соответственно.
в третьем списке перечислены города, в которых располагаются помещения.
Гарантируется, что фамилии дизайнеров не повторяются. При этом размеры помещений могут повторяться.
Самым легким считается проект, в котором площадь помещения минимальна и город, в котором находится помещение, над которым работает дизайнер, не Москва или Санкт-Петербург. Гарантируется, что такой проект только один.
Функция должна возвращать фамилию дизайнера, который работает над самым легким проектом. 
Важно! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: ['Круглов', 'Квадратов', 'Иванов', 'Марков', 'Пеньков', 'Гуськов'], ['100', '60', '67', '120', '90', '32'], ['Москва', 'Санкт-Петербург', 'Пермь', 'Москва', 'Сочи', 'Иваново'] 
<Вывод>: Гуськов 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: ['Елисеев', 'Краков'], ['67', '100'], ['Санкт-Петербург', 'Томск'] 
<Вывод>: Краков 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: ['Петров', 'Иванов', 'Волков', 'Меньшов'], ['50', '109', '30', '40'], ['Сочи', 'Москва', 'Иркутск', 'Краснодар'] 
<Вывод>: Волков 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: ['Елисеев', 'Воробьев', 'Стариков'], ['100', '100', '150'], ['Москва', 'Санкт-Петербург', 'Реутов'] 
<Вывод>: Стариков 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: ['Графов', 'Петров'], ['10', '10'], ['Санкт-Петербург', 'Омск'] 
<Вывод>: Петров 
<Example 6>: 
<Тип теста 6>: closed 
<Ввод>: ['Степанов'], ['100'], ['Новгород'] 
<Вывод>: Степанов 
<Решение студента>: def designer (designers, sizes, towns):
    lst_of_des = []
    lst_of_siz = []
    for i in range(len(towns)):
        if towns[i] != ""Москва"" and towns[i] != ""Санкт-Петербург"":
            lst_of_des.append(designers[i])
            lst_of_siz.append(sizes[i])
    
    return lst_of_des[lst_of_siz.index(min(lst_of_siz))] 
<Идеальное решение>: def designer (designers, sizes, towns):
    sizes = list(map(int, sizes))
    lst_of_des = []
    lst_of_siz = []
    for i in range(len(towns)):
        if towns[i] != ""Москва"" and towns[i] != ""Санкт-Петербург"":
            lst_of_des.append(designers[i])
            lst_of_siz.append(sizes[i])
    
    return lst_of_des[lst_of_siz.index(min(lst_of_siz))] 


<Комментарий эксперта>:"
52,95,6,"Напишите функцию, определяющую дизайнера, который работает над самым легким проектом.

Определите функцию designer, которая принимает на вход три списка:
в первом списке перечислены фамилии дизайнеров;
во втором списке перечислены размеры помещений (в кв. м.) (строки), для которых эти дизайнеры создают проекты интерьера соответственно.
в третьем списке перечислены города, в которых располагаются помещения.
Гарантируется, что фамилии дизайнеров не повторяются. При этом размеры помещений могут повторяться.
Самым легким считается проект, в котором площадь помещения минимальна и город, в котором находится помещение, над которым работает дизайнер, не Москва или Санкт-Петербург. Гарантируется, что такой проект только один.
Функция должна возвращать фамилию дизайнера, который работает над самым легким проектом. 
Важно! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке.","[""['Круглов', 'Квадратов', 'Иванов', 'Марков', 'Пеньков', 'Гуськов'], ['100', '60', '67', '120', '90', '32'], ['Москва', 'Санкт-Петербург', 'Пермь', 'Москва', 'Сочи', 'Иваново']"", ""['Елисеев', 'Краков'], ['67', '100'], ['Санкт-Петербург', 'Томск']"", ""['Петров', 'Иванов', 'Волков', 'Меньшов'], ['50', '109', '30', '40'], ['Сочи', 'Москва', 'Иркутск', 'Краснодар']"", ""['Елисеев', 'Воробьев', 'Стариков'], ['100', '100', '150'], ['Москва', 'Санкт-Петербург', 'Реутов']"", ""['Графов', 'Петров'], ['10', '10'], ['Санкт-Петербург', 'Омск']"", ""['Степанов'], ['100'], ['Новгород']""]","['Гуськов', 'Краков', 'Волков', 'Стариков', 'Петров', 'Степанов']","def designer (designers, sizes, towns):
    sizes = list(map(int, sizes))
    lst_of_des = []
    lst_of_siz = []
    for i in range(towns):
        if towns[i] != ""Москва"" and towns[i] != ""Санкт-Петербург"":
            lst_of_des.append(designers[i])
            lst_of_siz.append(sizes[i])
    
    return lst_of_des[lst_of_siz.index(min(lst_of_siz))]","def designer (designers, sizes, towns):
    sizes = list(map(int, sizes))
    lst_of_des = []
    lst_of_siz = []
    for i in range(len(towns)):
        if towns[i] != ""Москва"" and towns[i] != ""Санкт-Петербург"":
            lst_of_des.append(designers[i])
            lst_of_siz.append(sizes[i])
    
    return lst_of_des[lst_of_siz.index(min(lst_of_siz))]",Некорректно использована функция range(). Невозможно итерироваться на основе объекта класса str.,"['open', 'open', 'closed', 'closed', 'closed', 'closed']","<Task description>: Напишите функцию, определяющую дизайнера, который работает над самым легким проектом.

Определите функцию designer, которая принимает на вход три списка:
в первом списке перечислены фамилии дизайнеров;
во втором списке перечислены размеры помещений (в кв. м.) (строки), для которых эти дизайнеры создают проекты интерьера соответственно.
в третьем списке перечислены города, в которых располагаются помещения.
Гарантируется, что фамилии дизайнеров не повторяются. При этом размеры помещений могут повторяться.
Самым легким считается проект, в котором площадь помещения минимальна и город, в котором находится помещение, над которым работает дизайнер, не Москва или Санкт-Петербург. Гарантируется, что такой проект только один.
Функция должна возвращать фамилию дизайнера, который работает над самым легким проектом. 
Важно! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: ['Круглов', 'Квадратов', 'Иванов', 'Марков', 'Пеньков', 'Гуськов'], ['100', '60', '67', '120', '90', '32'], ['Москва', 'Санкт-Петербург', 'Пермь', 'Москва', 'Сочи', 'Иваново'] 
<Вывод>: Гуськов 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: ['Елисеев', 'Краков'], ['67', '100'], ['Санкт-Петербург', 'Томск'] 
<Вывод>: Краков 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: ['Петров', 'Иванов', 'Волков', 'Меньшов'], ['50', '109', '30', '40'], ['Сочи', 'Москва', 'Иркутск', 'Краснодар'] 
<Вывод>: Волков 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: ['Елисеев', 'Воробьев', 'Стариков'], ['100', '100', '150'], ['Москва', 'Санкт-Петербург', 'Реутов'] 
<Вывод>: Стариков 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: ['Графов', 'Петров'], ['10', '10'], ['Санкт-Петербург', 'Омск'] 
<Вывод>: Петров 
<Example 6>: 
<Тип теста 6>: closed 
<Ввод>: ['Степанов'], ['100'], ['Новгород'] 
<Вывод>: Степанов 
<Решение студента>: def designer (designers, sizes, towns):
    sizes = list(map(int, sizes))
    lst_of_des = []
    lst_of_siz = []
    for i in range(towns):
        if towns[i] != ""Москва"" and towns[i] != ""Санкт-Петербург"":
            lst_of_des.append(designers[i])
            lst_of_siz.append(sizes[i])
    
    return lst_of_des[lst_of_siz.index(min(lst_of_siz))] 
<Идеальное решение>: def designer (designers, sizes, towns):
    sizes = list(map(int, sizes))
    lst_of_des = []
    lst_of_siz = []
    for i in range(len(towns)):
        if towns[i] != ""Москва"" and towns[i] != ""Санкт-Петербург"":
            lst_of_des.append(designers[i])
            lst_of_siz.append(sizes[i])
    
    return lst_of_des[lst_of_siz.index(min(lst_of_siz))] 


<Комментарий эксперта>:"
53,96,6,"Напишите функцию, определяющую дизайнера, который работает над самым легким проектом.

Определите функцию designer, которая принимает на вход три списка:
в первом списке перечислены фамилии дизайнеров;
во втором списке перечислены размеры помещений (в кв. м.) (строки), для которых эти дизайнеры создают проекты интерьера соответственно.
в третьем списке перечислены города, в которых располагаются помещения.
Гарантируется, что фамилии дизайнеров не повторяются. При этом размеры помещений могут повторяться.
Самым легким считается проект, в котором площадь помещения минимальна и город, в котором находится помещение, над которым работает дизайнер, не Москва или Санкт-Петербург. Гарантируется, что такой проект только один.
Функция должна возвращать фамилию дизайнера, который работает над самым легким проектом. 
Важно! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке.","[""['Круглов', 'Квадратов', 'Иванов', 'Марков', 'Пеньков', 'Гуськов'], ['100', '60', '67', '120', '90', '32'], ['Москва', 'Санкт-Петербург', 'Пермь', 'Москва', 'Сочи', 'Иваново']"", ""['Елисеев', 'Краков'], ['67', '100'], ['Санкт-Петербург', 'Томск']"", ""['Петров', 'Иванов', 'Волков', 'Меньшов'], ['50', '109', '30', '40'], ['Сочи', 'Москва', 'Иркутск', 'Краснодар']"", ""['Елисеев', 'Воробьев', 'Стариков'], ['100', '100', '150'], ['Москва', 'Санкт-Петербург', 'Реутов']"", ""['Графов', 'Петров'], ['10', '10'], ['Санкт-Петербург', 'Омск']"", ""['Степанов'], ['100'], ['Новгород']""]","['Гуськов', 'Краков', 'Волков', 'Стариков', 'Петров', 'Степанов']","def designer (designers, sizes, towns):
    sizes = list(map(int, sizes))
    lst_of_des = []
    lst_of_siz = []
    for i in range(len(towns)):
        if towns[i] != Москва and towns[i] != Санкт-Петербург:
            lst_of_des.append(designers[i])
            lst_of_siz.append(sizes[i])
    
    return lst_of_des[lst_of_siz.index(min(lst_of_siz))]","def designer (designers, sizes, towns):
    sizes = list(map(int, sizes))
    lst_of_des = []
    lst_of_siz = []
    for i in range(len(towns)):
        if towns[i] != ""Москва"" and towns[i] != ""Санкт-Петербург"":
            lst_of_des.append(designers[i])
            lst_of_siz.append(sizes[i])
    
    return lst_of_des[lst_of_siz.index(min(lst_of_siz))]",Ошибка при выполнении условия. названия городов Москва и Санкт-Петербург должны содержаться в ковычках.,"['open', 'open', 'closed', 'closed', 'closed', 'closed']","<Task description>: Напишите функцию, определяющую дизайнера, который работает над самым легким проектом.

Определите функцию designer, которая принимает на вход три списка:
в первом списке перечислены фамилии дизайнеров;
во втором списке перечислены размеры помещений (в кв. м.) (строки), для которых эти дизайнеры создают проекты интерьера соответственно.
в третьем списке перечислены города, в которых располагаются помещения.
Гарантируется, что фамилии дизайнеров не повторяются. При этом размеры помещений могут повторяться.
Самым легким считается проект, в котором площадь помещения минимальна и город, в котором находится помещение, над которым работает дизайнер, не Москва или Санкт-Петербург. Гарантируется, что такой проект только один.
Функция должна возвращать фамилию дизайнера, который работает над самым легким проектом. 
Важно! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: ['Круглов', 'Квадратов', 'Иванов', 'Марков', 'Пеньков', 'Гуськов'], ['100', '60', '67', '120', '90', '32'], ['Москва', 'Санкт-Петербург', 'Пермь', 'Москва', 'Сочи', 'Иваново'] 
<Вывод>: Гуськов 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: ['Елисеев', 'Краков'], ['67', '100'], ['Санкт-Петербург', 'Томск'] 
<Вывод>: Краков 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: ['Петров', 'Иванов', 'Волков', 'Меньшов'], ['50', '109', '30', '40'], ['Сочи', 'Москва', 'Иркутск', 'Краснодар'] 
<Вывод>: Волков 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: ['Елисеев', 'Воробьев', 'Стариков'], ['100', '100', '150'], ['Москва', 'Санкт-Петербург', 'Реутов'] 
<Вывод>: Стариков 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: ['Графов', 'Петров'], ['10', '10'], ['Санкт-Петербург', 'Омск'] 
<Вывод>: Петров 
<Example 6>: 
<Тип теста 6>: closed 
<Ввод>: ['Степанов'], ['100'], ['Новгород'] 
<Вывод>: Степанов 
<Решение студента>: def designer (designers, sizes, towns):
    sizes = list(map(int, sizes))
    lst_of_des = []
    lst_of_siz = []
    for i in range(len(towns)):
        if towns[i] != Москва and towns[i] != Санкт-Петербург:
            lst_of_des.append(designers[i])
            lst_of_siz.append(sizes[i])
    
    return lst_of_des[lst_of_siz.index(min(lst_of_siz))] 
<Идеальное решение>: def designer (designers, sizes, towns):
    sizes = list(map(int, sizes))
    lst_of_des = []
    lst_of_siz = []
    for i in range(len(towns)):
        if towns[i] != ""Москва"" and towns[i] != ""Санкт-Петербург"":
            lst_of_des.append(designers[i])
            lst_of_siz.append(sizes[i])
    
    return lst_of_des[lst_of_siz.index(min(lst_of_siz))] 


<Комментарий эксперта>:"
54,97,6,"Напишите функцию, определяющую дизайнера, который работает над самым легким проектом.

Определите функцию designer, которая принимает на вход три списка:
в первом списке перечислены фамилии дизайнеров;
во втором списке перечислены размеры помещений (в кв. м.) (строки), для которых эти дизайнеры создают проекты интерьера соответственно.
в третьем списке перечислены города, в которых располагаются помещения.
Гарантируется, что фамилии дизайнеров не повторяются. При этом размеры помещений могут повторяться.
Самым легким считается проект, в котором площадь помещения минимальна и город, в котором находится помещение, над которым работает дизайнер, не Москва или Санкт-Петербург. Гарантируется, что такой проект только один.
Функция должна возвращать фамилию дизайнера, который работает над самым легким проектом. 
Важно! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке.","[""['Круглов', 'Квадратов', 'Иванов', 'Марков', 'Пеньков', 'Гуськов'], ['100', '60', '67', '120', '90', '32'], ['Москва', 'Санкт-Петербург', 'Пермь', 'Москва', 'Сочи', 'Иваново']"", ""['Елисеев', 'Краков'], ['67', '100'], ['Санкт-Петербург', 'Томск']"", ""['Петров', 'Иванов', 'Волков', 'Меньшов'], ['50', '109', '30', '40'], ['Сочи', 'Москва', 'Иркутск', 'Краснодар']"", ""['Елисеев', 'Воробьев', 'Стариков'], ['100', '100', '150'], ['Москва', 'Санкт-Петербург', 'Реутов']"", ""['Графов', 'Петров'], ['10', '10'], ['Санкт-Петербург', 'Омск']"", ""['Степанов'], ['100'], ['Новгород']""]","['Гуськов', 'Краков', 'Волков', 'Стариков', 'Петров', 'Степанов']","def designer (designers, sizes, towns):
    sizes = list(map(int, sizes))
    lst_of_des = []
    lst_of_siz = []
    for i in range(len(towns)):
        if towns[i] != ""Москва"":
            lst_of_des.append(designers[i])
            lst_of_siz.append(sizes[i])
       if towns[i] != ""Санкт-Петербург"":
            lst_of_des.append(designers[i])
            lst_of_siz.append(sizes[i])
    
    return lst_of_des[lst_of_siz.index(min(lst_of_siz))]","def designer (designers, sizes, towns):
    sizes = list(map(int, sizes))
    lst_of_des = []
    lst_of_siz = []
    for i in range(len(towns)):
        if towns[i] != ""Москва"" and towns[i] != ""Санкт-Петербург"":
            lst_of_des.append(designers[i])
            lst_of_siz.append(sizes[i])
    
    return lst_of_des[lst_of_siz.index(min(lst_of_siz))]","Ошибка в открытых и скрытых тестах. 

Ваш код некорректно выполняет условия задания. Так, он не выполянет условие ""не Москва или Санкт-Петербург"". Попробуйте изменить условие if, чтобы скорректировать ошибку.","['open', 'open', 'closed', 'closed', 'closed', 'closed']","<Task description>: Напишите функцию, определяющую дизайнера, который работает над самым легким проектом.

Определите функцию designer, которая принимает на вход три списка:
в первом списке перечислены фамилии дизайнеров;
во втором списке перечислены размеры помещений (в кв. м.) (строки), для которых эти дизайнеры создают проекты интерьера соответственно.
в третьем списке перечислены города, в которых располагаются помещения.
Гарантируется, что фамилии дизайнеров не повторяются. При этом размеры помещений могут повторяться.
Самым легким считается проект, в котором площадь помещения минимальна и город, в котором находится помещение, над которым работает дизайнер, не Москва или Санкт-Петербург. Гарантируется, что такой проект только один.
Функция должна возвращать фамилию дизайнера, который работает над самым легким проектом. 
Важно! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: ['Круглов', 'Квадратов', 'Иванов', 'Марков', 'Пеньков', 'Гуськов'], ['100', '60', '67', '120', '90', '32'], ['Москва', 'Санкт-Петербург', 'Пермь', 'Москва', 'Сочи', 'Иваново'] 
<Вывод>: Гуськов 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: ['Елисеев', 'Краков'], ['67', '100'], ['Санкт-Петербург', 'Томск'] 
<Вывод>: Краков 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: ['Петров', 'Иванов', 'Волков', 'Меньшов'], ['50', '109', '30', '40'], ['Сочи', 'Москва', 'Иркутск', 'Краснодар'] 
<Вывод>: Волков 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: ['Елисеев', 'Воробьев', 'Стариков'], ['100', '100', '150'], ['Москва', 'Санкт-Петербург', 'Реутов'] 
<Вывод>: Стариков 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: ['Графов', 'Петров'], ['10', '10'], ['Санкт-Петербург', 'Омск'] 
<Вывод>: Петров 
<Example 6>: 
<Тип теста 6>: closed 
<Ввод>: ['Степанов'], ['100'], ['Новгород'] 
<Вывод>: Степанов 
<Решение студента>: def designer (designers, sizes, towns):
    sizes = list(map(int, sizes))
    lst_of_des = []
    lst_of_siz = []
    for i in range(len(towns)):
        if towns[i] != ""Москва"":
            lst_of_des.append(designers[i])
            lst_of_siz.append(sizes[i])
       if towns[i] != ""Санкт-Петербург"":
            lst_of_des.append(designers[i])
            lst_of_siz.append(sizes[i])
    
    return lst_of_des[lst_of_siz.index(min(lst_of_siz))] 
<Идеальное решение>: def designer (designers, sizes, towns):
    sizes = list(map(int, sizes))
    lst_of_des = []
    lst_of_siz = []
    for i in range(len(towns)):
        if towns[i] != ""Москва"" and towns[i] != ""Санкт-Петербург"":
            lst_of_des.append(designers[i])
            lst_of_siz.append(sizes[i])
    
    return lst_of_des[lst_of_siz.index(min(lst_of_siz))] 


<Комментарий эксперта>:"
55,98,6,"Напишите функцию, определяющую дизайнера, который работает над самым легким проектом.

Определите функцию designer, которая принимает на вход три списка:
в первом списке перечислены фамилии дизайнеров;
во втором списке перечислены размеры помещений (в кв. м.) (строки), для которых эти дизайнеры создают проекты интерьера соответственно.
в третьем списке перечислены города, в которых располагаются помещения.
Гарантируется, что фамилии дизайнеров не повторяются. При этом размеры помещений могут повторяться.
Самым легким считается проект, в котором площадь помещения минимальна и город, в котором находится помещение, над которым работает дизайнер, не Москва или Санкт-Петербург. Гарантируется, что такой проект только один.
Функция должна возвращать фамилию дизайнера, который работает над самым легким проектом. 
Важно! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке.","[""['Круглов', 'Квадратов', 'Иванов', 'Марков', 'Пеньков', 'Гуськов'], ['100', '60', '67', '120', '90', '32'], ['Москва', 'Санкт-Петербург', 'Пермь', 'Москва', 'Сочи', 'Иваново']"", ""['Елисеев', 'Краков'], ['67', '100'], ['Санкт-Петербург', 'Томск']"", ""['Петров', 'Иванов', 'Волков', 'Меньшов'], ['50', '109', '30', '40'], ['Сочи', 'Москва', 'Иркутск', 'Краснодар']"", ""['Елисеев', 'Воробьев', 'Стариков'], ['100', '100', '150'], ['Москва', 'Санкт-Петербург', 'Реутов']"", ""['Графов', 'Петров'], ['10', '10'], ['Санкт-Петербург', 'Омск']"", ""['Степанов'], ['100'], ['Новгород']""]","['Гуськов', 'Краков', 'Волков', 'Стариков', 'Петров', 'Степанов']","def designer (designers, sizes, towns):
    sizes = list(map(int, sizes))
    lst_of_des = []
    lst_of_siz = []
    for i in range(len(towns)):
        if towns[i] != ""Москва"" and towns[i] != ""Санкт-Петербург"":
            lst_of_des.add(designers[i])
            lst_of_siz.add(sizes[i])
    
    return lst_of_des[lst_of_siz.index(min(lst_of_siz))]","def designer (designers, sizes, towns):
    sizes = list(map(int, sizes))
    lst_of_des = []
    lst_of_siz = []
    for i in range(len(towns)):
        if towns[i] != ""Москва"" and towns[i] != ""Санкт-Петербург"":
            lst_of_des.append(designers[i])
            lst_of_siz.append(sizes[i])
    
    return lst_of_des[lst_of_siz.index(min(lst_of_siz))]",Некорректно использован метод добавления элементов в список. Список не имеет метода .add().,"['open', 'open', 'closed', 'closed', 'closed', 'closed']","<Task description>: Напишите функцию, определяющую дизайнера, который работает над самым легким проектом.

Определите функцию designer, которая принимает на вход три списка:
в первом списке перечислены фамилии дизайнеров;
во втором списке перечислены размеры помещений (в кв. м.) (строки), для которых эти дизайнеры создают проекты интерьера соответственно.
в третьем списке перечислены города, в которых располагаются помещения.
Гарантируется, что фамилии дизайнеров не повторяются. При этом размеры помещений могут повторяться.
Самым легким считается проект, в котором площадь помещения минимальна и город, в котором находится помещение, над которым работает дизайнер, не Москва или Санкт-Петербург. Гарантируется, что такой проект только один.
Функция должна возвращать фамилию дизайнера, который работает над самым легким проектом. 
Важно! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: ['Круглов', 'Квадратов', 'Иванов', 'Марков', 'Пеньков', 'Гуськов'], ['100', '60', '67', '120', '90', '32'], ['Москва', 'Санкт-Петербург', 'Пермь', 'Москва', 'Сочи', 'Иваново'] 
<Вывод>: Гуськов 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: ['Елисеев', 'Краков'], ['67', '100'], ['Санкт-Петербург', 'Томск'] 
<Вывод>: Краков 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: ['Петров', 'Иванов', 'Волков', 'Меньшов'], ['50', '109', '30', '40'], ['Сочи', 'Москва', 'Иркутск', 'Краснодар'] 
<Вывод>: Волков 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: ['Елисеев', 'Воробьев', 'Стариков'], ['100', '100', '150'], ['Москва', 'Санкт-Петербург', 'Реутов'] 
<Вывод>: Стариков 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: ['Графов', 'Петров'], ['10', '10'], ['Санкт-Петербург', 'Омск'] 
<Вывод>: Петров 
<Example 6>: 
<Тип теста 6>: closed 
<Ввод>: ['Степанов'], ['100'], ['Новгород'] 
<Вывод>: Степанов 
<Решение студента>: def designer (designers, sizes, towns):
    sizes = list(map(int, sizes))
    lst_of_des = []
    lst_of_siz = []
    for i in range(len(towns)):
        if towns[i] != ""Москва"" and towns[i] != ""Санкт-Петербург"":
            lst_of_des.add(designers[i])
            lst_of_siz.add(sizes[i])
    
    return lst_of_des[lst_of_siz.index(min(lst_of_siz))] 
<Идеальное решение>: def designer (designers, sizes, towns):
    sizes = list(map(int, sizes))
    lst_of_des = []
    lst_of_siz = []
    for i in range(len(towns)):
        if towns[i] != ""Москва"" and towns[i] != ""Санкт-Петербург"":
            lst_of_des.append(designers[i])
            lst_of_siz.append(sizes[i])
    
    return lst_of_des[lst_of_siz.index(min(lst_of_siz))] 


<Комментарий эксперта>:"
56,99,6,"Напишите функцию, определяющую дизайнера, который работает над самым легким проектом.

Определите функцию designer, которая принимает на вход три списка:
в первом списке перечислены фамилии дизайнеров;
во втором списке перечислены размеры помещений (в кв. м.) (строки), для которых эти дизайнеры создают проекты интерьера соответственно.
в третьем списке перечислены города, в которых располагаются помещения.
Гарантируется, что фамилии дизайнеров не повторяются. При этом размеры помещений могут повторяться.
Самым легким считается проект, в котором площадь помещения минимальна и город, в котором находится помещение, над которым работает дизайнер, не Москва или Санкт-Петербург. Гарантируется, что такой проект только один.
Функция должна возвращать фамилию дизайнера, который работает над самым легким проектом. 
Важно! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке.","[""['Круглов', 'Квадратов', 'Иванов', 'Марков', 'Пеньков', 'Гуськов'], ['100', '60', '67', '120', '90', '32'], ['Москва', 'Санкт-Петербург', 'Пермь', 'Москва', 'Сочи', 'Иваново']"", ""['Елисеев', 'Краков'], ['67', '100'], ['Санкт-Петербург', 'Томск']"", ""['Петров', 'Иванов', 'Волков', 'Меньшов'], ['50', '109', '30', '40'], ['Сочи', 'Москва', 'Иркутск', 'Краснодар']"", ""['Елисеев', 'Воробьев', 'Стариков'], ['100', '100', '150'], ['Москва', 'Санкт-Петербург', 'Реутов']"", ""['Графов', 'Петров'], ['10', '10'], ['Санкт-Петербург', 'Омск']"", ""['Степанов'], ['100'], ['Новгород']""]","['Гуськов', 'Краков', 'Волков', 'Стариков', 'Петров', 'Степанов']","def designer (designers, sizes, towns):
    sizes = list(map(int, sizes))
    lst_of_des = []
    lst_of_siz = []
    for i in range(len(towns)):
        if towns[i] != ""Москва"" and towns[i] != ""Санкт-Петербург"":
            lst_of_des.append(designers[i])
            lst_of_siz.append(sizes[i])
    
    print(lst_of_des[lst_of_siz.index(min(lst_of_siz))])","def designer (designers, sizes, towns):
    sizes = list(map(int, sizes))
    lst_of_des = []
    lst_of_siz = []
    for i in range(len(towns)):
        if towns[i] != ""Москва"" and towns[i] != ""Санкт-Петербург"":
            lst_of_des.append(designers[i])
            lst_of_siz.append(sizes[i])
    
    return lst_of_des[lst_of_siz.index(min(lst_of_siz))]",Ошибка при возвращении данных функцией. Функция не должна использовать оператор print(). ,"['open', 'open', 'closed', 'closed', 'closed', 'closed']","<Task description>: Напишите функцию, определяющую дизайнера, который работает над самым легким проектом.

Определите функцию designer, которая принимает на вход три списка:
в первом списке перечислены фамилии дизайнеров;
во втором списке перечислены размеры помещений (в кв. м.) (строки), для которых эти дизайнеры создают проекты интерьера соответственно.
в третьем списке перечислены города, в которых располагаются помещения.
Гарантируется, что фамилии дизайнеров не повторяются. При этом размеры помещений могут повторяться.
Самым легким считается проект, в котором площадь помещения минимальна и город, в котором находится помещение, над которым работает дизайнер, не Москва или Санкт-Петербург. Гарантируется, что такой проект только один.
Функция должна возвращать фамилию дизайнера, который работает над самым легким проектом. 
Важно! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: ['Круглов', 'Квадратов', 'Иванов', 'Марков', 'Пеньков', 'Гуськов'], ['100', '60', '67', '120', '90', '32'], ['Москва', 'Санкт-Петербург', 'Пермь', 'Москва', 'Сочи', 'Иваново'] 
<Вывод>: Гуськов 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: ['Елисеев', 'Краков'], ['67', '100'], ['Санкт-Петербург', 'Томск'] 
<Вывод>: Краков 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: ['Петров', 'Иванов', 'Волков', 'Меньшов'], ['50', '109', '30', '40'], ['Сочи', 'Москва', 'Иркутск', 'Краснодар'] 
<Вывод>: Волков 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: ['Елисеев', 'Воробьев', 'Стариков'], ['100', '100', '150'], ['Москва', 'Санкт-Петербург', 'Реутов'] 
<Вывод>: Стариков 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: ['Графов', 'Петров'], ['10', '10'], ['Санкт-Петербург', 'Омск'] 
<Вывод>: Петров 
<Example 6>: 
<Тип теста 6>: closed 
<Ввод>: ['Степанов'], ['100'], ['Новгород'] 
<Вывод>: Степанов 
<Решение студента>: def designer (designers, sizes, towns):
    sizes = list(map(int, sizes))
    lst_of_des = []
    lst_of_siz = []
    for i in range(len(towns)):
        if towns[i] != ""Москва"" and towns[i] != ""Санкт-Петербург"":
            lst_of_des.append(designers[i])
            lst_of_siz.append(sizes[i])
    
    print(lst_of_des[lst_of_siz.index(min(lst_of_siz))]) 
<Идеальное решение>: def designer (designers, sizes, towns):
    sizes = list(map(int, sizes))
    lst_of_des = []
    lst_of_siz = []
    for i in range(len(towns)):
        if towns[i] != ""Москва"" and towns[i] != ""Санкт-Петербург"":
            lst_of_des.append(designers[i])
            lst_of_siz.append(sizes[i])
    
    return lst_of_des[lst_of_siz.index(min(lst_of_siz))] 


<Комментарий эксперта>:"
57,100,6,"Напишите функцию, определяющую дизайнера, который работает над самым легким проектом.

Определите функцию designer, которая принимает на вход три списка:
в первом списке перечислены фамилии дизайнеров;
во втором списке перечислены размеры помещений (в кв. м.) (строки), для которых эти дизайнеры создают проекты интерьера соответственно.
в третьем списке перечислены города, в которых располагаются помещения.
Гарантируется, что фамилии дизайнеров не повторяются. При этом размеры помещений могут повторяться.
Самым легким считается проект, в котором площадь помещения минимальна и город, в котором находится помещение, над которым работает дизайнер, не Москва или Санкт-Петербург. Гарантируется, что такой проект только один.
Функция должна возвращать фамилию дизайнера, который работает над самым легким проектом. 
Важно! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке.","[""['Круглов', 'Квадратов', 'Иванов', 'Марков', 'Пеньков', 'Гуськов'], ['100', '60', '67', '120', '90', '32'], ['Москва', 'Санкт-Петербург', 'Пермь', 'Москва', 'Сочи', 'Иваново']"", ""['Елисеев', 'Краков'], ['67', '100'], ['Санкт-Петербург', 'Томск']"", ""['Петров', 'Иванов', 'Волков', 'Меньшов'], ['50', '109', '30', '40'], ['Сочи', 'Москва', 'Иркутск', 'Краснодар']"", ""['Елисеев', 'Воробьев', 'Стариков'], ['100', '100', '150'], ['Москва', 'Санкт-Петербург', 'Реутов']"", ""['Графов', 'Петров'], ['10', '10'], ['Санкт-Петербург', 'Омск']"", ""['Степанов'], ['100'], ['Новгород']""]","['Гуськов', 'Краков', 'Волков', 'Стариков', 'Петров', 'Степанов']","def designer (designers, sizes, towns):
    sizes = list(map(int, sizes))
    lst_of_des = []
    lst_of_siz = []
    for i in range(len(towns)):
        if towns[i] != ""Москва"" and towns[i] != ""Санкт-Петербург"":
            lst_of_des.append(designers[i])
            lst_of_siz.append(sizes[i])
    
    return lst_of_des[min(lst_of_siz)]","def designer (designers, sizes, towns):
    sizes = list(map(int, sizes))
    lst_of_des = []
    lst_of_siz = []
    for i in range(len(towns)):
        if towns[i] != ""Москва"" and towns[i] != ""Санкт-Петербург"":
            lst_of_des.append(designers[i])
            lst_of_siz.append(sizes[i])
    
    return lst_of_des[lst_of_siz.index(min(lst_of_siz))]",Ошибка при возвращении данных функцией. Попробуйте обратиться к индексу минимального значения списка lst_of_siz.,"['open', 'open', 'closed', 'closed', 'closed', 'closed']","<Task description>: Напишите функцию, определяющую дизайнера, который работает над самым легким проектом.

Определите функцию designer, которая принимает на вход три списка:
в первом списке перечислены фамилии дизайнеров;
во втором списке перечислены размеры помещений (в кв. м.) (строки), для которых эти дизайнеры создают проекты интерьера соответственно.
в третьем списке перечислены города, в которых располагаются помещения.
Гарантируется, что фамилии дизайнеров не повторяются. При этом размеры помещений могут повторяться.
Самым легким считается проект, в котором площадь помещения минимальна и город, в котором находится помещение, над которым работает дизайнер, не Москва или Санкт-Петербург. Гарантируется, что такой проект только один.
Функция должна возвращать фамилию дизайнера, который работает над самым легким проектом. 
Важно! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: ['Круглов', 'Квадратов', 'Иванов', 'Марков', 'Пеньков', 'Гуськов'], ['100', '60', '67', '120', '90', '32'], ['Москва', 'Санкт-Петербург', 'Пермь', 'Москва', 'Сочи', 'Иваново'] 
<Вывод>: Гуськов 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: ['Елисеев', 'Краков'], ['67', '100'], ['Санкт-Петербург', 'Томск'] 
<Вывод>: Краков 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: ['Петров', 'Иванов', 'Волков', 'Меньшов'], ['50', '109', '30', '40'], ['Сочи', 'Москва', 'Иркутск', 'Краснодар'] 
<Вывод>: Волков 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: ['Елисеев', 'Воробьев', 'Стариков'], ['100', '100', '150'], ['Москва', 'Санкт-Петербург', 'Реутов'] 
<Вывод>: Стариков 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: ['Графов', 'Петров'], ['10', '10'], ['Санкт-Петербург', 'Омск'] 
<Вывод>: Петров 
<Example 6>: 
<Тип теста 6>: closed 
<Ввод>: ['Степанов'], ['100'], ['Новгород'] 
<Вывод>: Степанов 
<Решение студента>: def designer (designers, sizes, towns):
    sizes = list(map(int, sizes))
    lst_of_des = []
    lst_of_siz = []
    for i in range(len(towns)):
        if towns[i] != ""Москва"" and towns[i] != ""Санкт-Петербург"":
            lst_of_des.append(designers[i])
            lst_of_siz.append(sizes[i])
    
    return lst_of_des[min(lst_of_siz)] 
<Идеальное решение>: def designer (designers, sizes, towns):
    sizes = list(map(int, sizes))
    lst_of_des = []
    lst_of_siz = []
    for i in range(len(towns)):
        if towns[i] != ""Москва"" and towns[i] != ""Санкт-Петербург"":
            lst_of_des.append(designers[i])
            lst_of_siz.append(sizes[i])
    
    return lst_of_des[lst_of_siz.index(min(lst_of_siz))] 


<Комментарий эксперта>:"
58,101,6,"Напишите функцию, определяющую дизайнера, который работает над самым легким проектом.

Определите функцию designer, которая принимает на вход три списка:
в первом списке перечислены фамилии дизайнеров;
во втором списке перечислены размеры помещений (в кв. м.) (строки), для которых эти дизайнеры создают проекты интерьера соответственно.
в третьем списке перечислены города, в которых располагаются помещения.
Гарантируется, что фамилии дизайнеров не повторяются. При этом размеры помещений могут повторяться.
Самым легким считается проект, в котором площадь помещения минимальна и город, в котором находится помещение, над которым работает дизайнер, не Москва или Санкт-Петербург. Гарантируется, что такой проект только один.
Функция должна возвращать фамилию дизайнера, который работает над самым легким проектом. 
Важно! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке.","[""['Круглов', 'Квадратов', 'Иванов', 'Марков', 'Пеньков', 'Гуськов'], ['100', '60', '67', '120', '90', '32'], ['Москва', 'Санкт-Петербург', 'Пермь', 'Москва', 'Сочи', 'Иваново']"", ""['Елисеев', 'Краков'], ['67', '100'], ['Санкт-Петербург', 'Томск']"", ""['Петров', 'Иванов', 'Волков', 'Меньшов'], ['50', '109', '30', '40'], ['Сочи', 'Москва', 'Иркутск', 'Краснодар']"", ""['Елисеев', 'Воробьев', 'Стариков'], ['100', '100', '150'], ['Москва', 'Санкт-Петербург', 'Реутов']"", ""['Графов', 'Петров'], ['10', '10'], ['Санкт-Петербург', 'Омск']"", ""['Степанов'], ['100'], ['Новгород']""]","['Гуськов', 'Краков', 'Волков', 'Стариков', 'Петров', 'Степанов']","def designer (designers, sizes, towns):
    sizes = list(map(int, sizes))
    lst_of_des = []
    lst_of_siz = []
    for i in range(len(towns)):
        if towns[i] != ""Москва"" and towns[i] != ""Санкт-Петербург"":
            lst_of_des.append(designers[i])
            lst_of_siz.append(sizes[i])
    
    return lst_of_des[lst_of_siz.index(min(lst_of_des))]","def designer (designers, sizes, towns):
    sizes = list(map(int, sizes))
    lst_of_des = []
    lst_of_siz = []
    for i in range(len(towns)):
        if towns[i] != ""Москва"" and towns[i] != ""Санкт-Петербург"":
            lst_of_des.append(designers[i])
            lst_of_siz.append(sizes[i])
    
    return lst_of_des[lst_of_siz.index(min(lst_of_siz))]",Ошибка при возвращении данных функцией. Функция обращается к неверному словарю при попылке вернуть минимальное значение.,"['open', 'open', 'closed', 'closed', 'closed', 'closed']","<Task description>: Напишите функцию, определяющую дизайнера, который работает над самым легким проектом.

Определите функцию designer, которая принимает на вход три списка:
в первом списке перечислены фамилии дизайнеров;
во втором списке перечислены размеры помещений (в кв. м.) (строки), для которых эти дизайнеры создают проекты интерьера соответственно.
в третьем списке перечислены города, в которых располагаются помещения.
Гарантируется, что фамилии дизайнеров не повторяются. При этом размеры помещений могут повторяться.
Самым легким считается проект, в котором площадь помещения минимальна и город, в котором находится помещение, над которым работает дизайнер, не Москва или Санкт-Петербург. Гарантируется, что такой проект только один.
Функция должна возвращать фамилию дизайнера, который работает над самым легким проектом. 
Важно! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: ['Круглов', 'Квадратов', 'Иванов', 'Марков', 'Пеньков', 'Гуськов'], ['100', '60', '67', '120', '90', '32'], ['Москва', 'Санкт-Петербург', 'Пермь', 'Москва', 'Сочи', 'Иваново'] 
<Вывод>: Гуськов 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: ['Елисеев', 'Краков'], ['67', '100'], ['Санкт-Петербург', 'Томск'] 
<Вывод>: Краков 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: ['Петров', 'Иванов', 'Волков', 'Меньшов'], ['50', '109', '30', '40'], ['Сочи', 'Москва', 'Иркутск', 'Краснодар'] 
<Вывод>: Волков 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: ['Елисеев', 'Воробьев', 'Стариков'], ['100', '100', '150'], ['Москва', 'Санкт-Петербург', 'Реутов'] 
<Вывод>: Стариков 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: ['Графов', 'Петров'], ['10', '10'], ['Санкт-Петербург', 'Омск'] 
<Вывод>: Петров 
<Example 6>: 
<Тип теста 6>: closed 
<Ввод>: ['Степанов'], ['100'], ['Новгород'] 
<Вывод>: Степанов 
<Решение студента>: def designer (designers, sizes, towns):
    sizes = list(map(int, sizes))
    lst_of_des = []
    lst_of_siz = []
    for i in range(len(towns)):
        if towns[i] != ""Москва"" and towns[i] != ""Санкт-Петербург"":
            lst_of_des.append(designers[i])
            lst_of_siz.append(sizes[i])
    
    return lst_of_des[lst_of_siz.index(min(lst_of_des))] 
<Идеальное решение>: def designer (designers, sizes, towns):
    sizes = list(map(int, sizes))
    lst_of_des = []
    lst_of_siz = []
    for i in range(len(towns)):
        if towns[i] != ""Москва"" and towns[i] != ""Санкт-Петербург"":
            lst_of_des.append(designers[i])
            lst_of_siz.append(sizes[i])
    
    return lst_of_des[lst_of_siz.index(min(lst_of_siz))] 


<Комментарий эксперта>:"
59,102,6,"Напишите функцию, определяющую дизайнера, который работает над самым легким проектом.

Определите функцию designer, которая принимает на вход три списка:
в первом списке перечислены фамилии дизайнеров;
во втором списке перечислены размеры помещений (в кв. м.) (строки), для которых эти дизайнеры создают проекты интерьера соответственно.
в третьем списке перечислены города, в которых располагаются помещения.
Гарантируется, что фамилии дизайнеров не повторяются. При этом размеры помещений могут повторяться.
Самым легким считается проект, в котором площадь помещения минимальна и город, в котором находится помещение, над которым работает дизайнер, не Москва или Санкт-Петербург. Гарантируется, что такой проект только один.
Функция должна возвращать фамилию дизайнера, который работает над самым легким проектом. 
Важно! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке.","[""['Круглов', 'Квадратов', 'Иванов', 'Марков', 'Пеньков', 'Гуськов'], ['100', '60', '67', '120', '90', '32'], ['Москва', 'Санкт-Петербург', 'Пермь', 'Москва', 'Сочи', 'Иваново']"", ""['Елисеев', 'Краков'], ['67', '100'], ['Санкт-Петербург', 'Томск']"", ""['Петров', 'Иванов', 'Волков', 'Меньшов'], ['50', '109', '30', '40'], ['Сочи', 'Москва', 'Иркутск', 'Краснодар']"", ""['Елисеев', 'Воробьев', 'Стариков'], ['100', '100', '150'], ['Москва', 'Санкт-Петербург', 'Реутов']"", ""['Графов', 'Петров'], ['10', '10'], ['Санкт-Петербург', 'Омск']"", ""['Степанов'], ['100'], ['Новгород']""]","['Гуськов', 'Краков', 'Волков', 'Стариков', 'Петров', 'Степанов']","def designer (designers, sizes, towns):
    sizes = list(map(int, sizes))
    lst_of_des = []
    lst_of_siz = []
    for i in range(len(towns)):
        if towns[i] != ""Москва"" and towns[i] != ""Санкт-Петербург"":
            lst_of_des.append(designers[i])
            lst_of_siz.append(sizes[i])
    
    return lst_of_des[lst_of_siz.index(max(lst_of_siz))]","def designer (designers, sizes, towns):
    sizes = list(map(int, sizes))
    lst_of_des = []
    lst_of_siz = []
    for i in range(len(towns)):
        if towns[i] != ""Москва"" and towns[i] != ""Санкт-Петербург"":
            lst_of_des.append(designers[i])
            lst_of_siz.append(sizes[i])
    
    return lst_of_des[lst_of_siz.index(min(lst_of_siz))]","Ошибка в открытых и скрытых тестах. 

Ваш код не выполняет условия задания ""возвращать фамилию дизайнера, который работает над самым легким проектом"". Попробуйте изменить условие оператора return, чтобы скорректировать ошибку.","['open', 'open', 'closed', 'closed', 'closed', 'closed']","<Task description>: Напишите функцию, определяющую дизайнера, который работает над самым легким проектом.

Определите функцию designer, которая принимает на вход три списка:
в первом списке перечислены фамилии дизайнеров;
во втором списке перечислены размеры помещений (в кв. м.) (строки), для которых эти дизайнеры создают проекты интерьера соответственно.
в третьем списке перечислены города, в которых располагаются помещения.
Гарантируется, что фамилии дизайнеров не повторяются. При этом размеры помещений могут повторяться.
Самым легким считается проект, в котором площадь помещения минимальна и город, в котором находится помещение, над которым работает дизайнер, не Москва или Санкт-Петербург. Гарантируется, что такой проект только один.
Функция должна возвращать фамилию дизайнера, который работает над самым легким проектом. 
Важно! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: ['Круглов', 'Квадратов', 'Иванов', 'Марков', 'Пеньков', 'Гуськов'], ['100', '60', '67', '120', '90', '32'], ['Москва', 'Санкт-Петербург', 'Пермь', 'Москва', 'Сочи', 'Иваново'] 
<Вывод>: Гуськов 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: ['Елисеев', 'Краков'], ['67', '100'], ['Санкт-Петербург', 'Томск'] 
<Вывод>: Краков 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: ['Петров', 'Иванов', 'Волков', 'Меньшов'], ['50', '109', '30', '40'], ['Сочи', 'Москва', 'Иркутск', 'Краснодар'] 
<Вывод>: Волков 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: ['Елисеев', 'Воробьев', 'Стариков'], ['100', '100', '150'], ['Москва', 'Санкт-Петербург', 'Реутов'] 
<Вывод>: Стариков 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: ['Графов', 'Петров'], ['10', '10'], ['Санкт-Петербург', 'Омск'] 
<Вывод>: Петров 
<Example 6>: 
<Тип теста 6>: closed 
<Ввод>: ['Степанов'], ['100'], ['Новгород'] 
<Вывод>: Степанов 
<Решение студента>: def designer (designers, sizes, towns):
    sizes = list(map(int, sizes))
    lst_of_des = []
    lst_of_siz = []
    for i in range(len(towns)):
        if towns[i] != ""Москва"" and towns[i] != ""Санкт-Петербург"":
            lst_of_des.append(designers[i])
            lst_of_siz.append(sizes[i])
    
    return lst_of_des[lst_of_siz.index(max(lst_of_siz))] 
<Идеальное решение>: def designer (designers, sizes, towns):
    sizes = list(map(int, sizes))
    lst_of_des = []
    lst_of_siz = []
    for i in range(len(towns)):
        if towns[i] != ""Москва"" and towns[i] != ""Санкт-Петербург"":
            lst_of_des.append(designers[i])
            lst_of_siz.append(sizes[i])
    
    return lst_of_des[lst_of_siz.index(min(lst_of_siz))] 


<Комментарий эксперта>:"
60,103,6,"Напишите функцию, определяющую дизайнера, который работает над самым легким проектом.

Определите функцию designer, которая принимает на вход три списка:
в первом списке перечислены фамилии дизайнеров;
во втором списке перечислены размеры помещений (в кв. м.) (строки), для которых эти дизайнеры создают проекты интерьера соответственно.
в третьем списке перечислены города, в которых располагаются помещения.
Гарантируется, что фамилии дизайнеров не повторяются. При этом размеры помещений могут повторяться.
Самым легким считается проект, в котором площадь помещения минимальна и город, в котором находится помещение, над которым работает дизайнер, не Москва или Санкт-Петербург. Гарантируется, что такой проект только один.
Функция должна возвращать фамилию дизайнера, который работает над самым легким проектом. 
Важно! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке.","[""['Круглов', 'Квадратов', 'Иванов', 'Марков', 'Пеньков', 'Гуськов'], ['100', '60', '67', '120', '90', '32'], ['Москва', 'Санкт-Петербург', 'Пермь', 'Москва', 'Сочи', 'Иваново']"", ""['Елисеев', 'Краков'], ['67', '100'], ['Санкт-Петербург', 'Томск']"", ""['Петров', 'Иванов', 'Волков', 'Меньшов'], ['50', '109', '30', '40'], ['Сочи', 'Москва', 'Иркутск', 'Краснодар']"", ""['Елисеев', 'Воробьев', 'Стариков'], ['100', '100', '150'], ['Москва', 'Санкт-Петербург', 'Реутов']"", ""['Графов', 'Петров'], ['10', '10'], ['Санкт-Петербург', 'Омск']"", ""['Степанов'], ['100'], ['Новгород']""]","['Гуськов', 'Краков', 'Волков', 'Стариков', 'Петров', 'Степанов']","def designer (designers, sizes, towns):
    sizes = list(map(int, sizes))
    lst_of_des = []
    lst_of_siz = []
    for i in range(len(towns)):
        if towns[i] != ""Москва"" and towns[i] != ""Санкт-Петербург"":
            lst_of_des.append(designers[i])
            lst_of_siz.append(sizes[i])
    
return lst_of_des[lst_of_siz.index(min(lst_of_siz))]","def designer (designers, sizes, towns):
    sizes = list(map(int, sizes))
    lst_of_des = []
    lst_of_siz = []
    for i in range(len(towns)):
        if towns[i] != ""Москва"" and towns[i] != ""Санкт-Петербург"":
            lst_of_des.append(designers[i])
            lst_of_siz.append(sizes[i])
    
    return lst_of_des[lst_of_siz.index(min(lst_of_siz))]",Ошибка в табуляции оператора return.,"['open', 'open', 'closed', 'closed', 'closed', 'closed']","<Task description>: Напишите функцию, определяющую дизайнера, который работает над самым легким проектом.

Определите функцию designer, которая принимает на вход три списка:
в первом списке перечислены фамилии дизайнеров;
во втором списке перечислены размеры помещений (в кв. м.) (строки), для которых эти дизайнеры создают проекты интерьера соответственно.
в третьем списке перечислены города, в которых располагаются помещения.
Гарантируется, что фамилии дизайнеров не повторяются. При этом размеры помещений могут повторяться.
Самым легким считается проект, в котором площадь помещения минимальна и город, в котором находится помещение, над которым работает дизайнер, не Москва или Санкт-Петербург. Гарантируется, что такой проект только один.
Функция должна возвращать фамилию дизайнера, который работает над самым легким проектом. 
Важно! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: ['Круглов', 'Квадратов', 'Иванов', 'Марков', 'Пеньков', 'Гуськов'], ['100', '60', '67', '120', '90', '32'], ['Москва', 'Санкт-Петербург', 'Пермь', 'Москва', 'Сочи', 'Иваново'] 
<Вывод>: Гуськов 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: ['Елисеев', 'Краков'], ['67', '100'], ['Санкт-Петербург', 'Томск'] 
<Вывод>: Краков 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: ['Петров', 'Иванов', 'Волков', 'Меньшов'], ['50', '109', '30', '40'], ['Сочи', 'Москва', 'Иркутск', 'Краснодар'] 
<Вывод>: Волков 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: ['Елисеев', 'Воробьев', 'Стариков'], ['100', '100', '150'], ['Москва', 'Санкт-Петербург', 'Реутов'] 
<Вывод>: Стариков 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: ['Графов', 'Петров'], ['10', '10'], ['Санкт-Петербург', 'Омск'] 
<Вывод>: Петров 
<Example 6>: 
<Тип теста 6>: closed 
<Ввод>: ['Степанов'], ['100'], ['Новгород'] 
<Вывод>: Степанов 
<Решение студента>: def designer (designers, sizes, towns):
    sizes = list(map(int, sizes))
    lst_of_des = []
    lst_of_siz = []
    for i in range(len(towns)):
        if towns[i] != ""Москва"" and towns[i] != ""Санкт-Петербург"":
            lst_of_des.append(designers[i])
            lst_of_siz.append(sizes[i])
    
return lst_of_des[lst_of_siz.index(min(lst_of_siz))] 
<Идеальное решение>: def designer (designers, sizes, towns):
    sizes = list(map(int, sizes))
    lst_of_des = []
    lst_of_siz = []
    for i in range(len(towns)):
        if towns[i] != ""Москва"" and towns[i] != ""Санкт-Петербург"":
            lst_of_des.append(designers[i])
            lst_of_siz.append(sizes[i])
    
    return lst_of_des[lst_of_siz.index(min(lst_of_siz))] 


<Комментарий эксперта>:"
61,104,6,"Напишите функцию, определяющую дизайнера, который работает над самым легким проектом.

Определите функцию designer, которая принимает на вход три списка:
в первом списке перечислены фамилии дизайнеров;
во втором списке перечислены размеры помещений (в кв. м.) (строки), для которых эти дизайнеры создают проекты интерьера соответственно.
в третьем списке перечислены города, в которых располагаются помещения.
Гарантируется, что фамилии дизайнеров не повторяются. При этом размеры помещений могут повторяться.
Самым легким считается проект, в котором площадь помещения минимальна и город, в котором находится помещение, над которым работает дизайнер, не Москва или Санкт-Петербург. Гарантируется, что такой проект только один.
Функция должна возвращать фамилию дизайнера, который работает над самым легким проектом. 
Важно! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке.","[""['Круглов', 'Квадратов', 'Иванов', 'Марков', 'Пеньков', 'Гуськов'], ['100', '60', '67', '120', '90', '32'], ['Москва', 'Санкт-Петербург', 'Пермь', 'Москва', 'Сочи', 'Иваново']"", ""['Елисеев', 'Краков'], ['67', '100'], ['Санкт-Петербург', 'Томск']"", ""['Петров', 'Иванов', 'Волков', 'Меньшов'], ['50', '109', '30', '40'], ['Сочи', 'Москва', 'Иркутск', 'Краснодар']"", ""['Елисеев', 'Воробьев', 'Стариков'], ['100', '100', '150'], ['Москва', 'Санкт-Петербург', 'Реутов']"", ""['Графов', 'Петров'], ['10', '10'], ['Санкт-Петербург', 'Омск']"", ""['Степанов'], ['100'], ['Новгород']""]","['Гуськов', 'Краков', 'Волков', 'Стариков', 'Петров', 'Степанов']","def designer (designers, sizes, towns):
    sizes = list(map(int, sizes))
    lst_of_des = []
    lst_of_siz = []
    for i in range(len(towns)):
        if towns[i] != ""Москва"" and towns[i] != ""Санкт-Петербург"":
            lst_of_des.append(designers[i])
            lst_of_siz.append(sizes[i])
    
    return ans = lst_of_des[lst_of_siz.index(min(lst_of_siz))]","def designer (designers, sizes, towns):
    sizes = list(map(int, sizes))
    lst_of_des = []
    lst_of_siz = []
    for i in range(len(towns)):
        if towns[i] != ""Москва"" and towns[i] != ""Санкт-Петербург"":
            lst_of_des.append(designers[i])
            lst_of_siz.append(sizes[i])
    
    return lst_of_des[lst_of_siz.index(min(lst_of_siz))]",Ошибка в синтаксисе при попытке возвращения данных функции. Не определяйте дополнительные переменные в условии оператора return.,"['open', 'open', 'closed', 'closed', 'closed', 'closed']","<Task description>: Напишите функцию, определяющую дизайнера, который работает над самым легким проектом.

Определите функцию designer, которая принимает на вход три списка:
в первом списке перечислены фамилии дизайнеров;
во втором списке перечислены размеры помещений (в кв. м.) (строки), для которых эти дизайнеры создают проекты интерьера соответственно.
в третьем списке перечислены города, в которых располагаются помещения.
Гарантируется, что фамилии дизайнеров не повторяются. При этом размеры помещений могут повторяться.
Самым легким считается проект, в котором площадь помещения минимальна и город, в котором находится помещение, над которым работает дизайнер, не Москва или Санкт-Петербург. Гарантируется, что такой проект только один.
Функция должна возвращать фамилию дизайнера, который работает над самым легким проектом. 
Важно! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: ['Круглов', 'Квадратов', 'Иванов', 'Марков', 'Пеньков', 'Гуськов'], ['100', '60', '67', '120', '90', '32'], ['Москва', 'Санкт-Петербург', 'Пермь', 'Москва', 'Сочи', 'Иваново'] 
<Вывод>: Гуськов 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: ['Елисеев', 'Краков'], ['67', '100'], ['Санкт-Петербург', 'Томск'] 
<Вывод>: Краков 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: ['Петров', 'Иванов', 'Волков', 'Меньшов'], ['50', '109', '30', '40'], ['Сочи', 'Москва', 'Иркутск', 'Краснодар'] 
<Вывод>: Волков 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: ['Елисеев', 'Воробьев', 'Стариков'], ['100', '100', '150'], ['Москва', 'Санкт-Петербург', 'Реутов'] 
<Вывод>: Стариков 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: ['Графов', 'Петров'], ['10', '10'], ['Санкт-Петербург', 'Омск'] 
<Вывод>: Петров 
<Example 6>: 
<Тип теста 6>: closed 
<Ввод>: ['Степанов'], ['100'], ['Новгород'] 
<Вывод>: Степанов 
<Решение студента>: def designer (designers, sizes, towns):
    sizes = list(map(int, sizes))
    lst_of_des = []
    lst_of_siz = []
    for i in range(len(towns)):
        if towns[i] != ""Москва"" and towns[i] != ""Санкт-Петербург"":
            lst_of_des.append(designers[i])
            lst_of_siz.append(sizes[i])
    
    return ans = lst_of_des[lst_of_siz.index(min(lst_of_siz))] 
<Идеальное решение>: def designer (designers, sizes, towns):
    sizes = list(map(int, sizes))
    lst_of_des = []
    lst_of_siz = []
    for i in range(len(towns)):
        if towns[i] != ""Москва"" and towns[i] != ""Санкт-Петербург"":
            lst_of_des.append(designers[i])
            lst_of_siz.append(sizes[i])
    
    return lst_of_des[lst_of_siz.index(min(lst_of_siz))] 


<Комментарий эксперта>:"
62,105,6,"Напишите функцию, определяющую дизайнера, который работает над самым легким проектом.

Определите функцию designer, которая принимает на вход три списка:
в первом списке перечислены фамилии дизайнеров;
во втором списке перечислены размеры помещений (в кв. м.) (строки), для которых эти дизайнеры создают проекты интерьера соответственно.
в третьем списке перечислены города, в которых располагаются помещения.
Гарантируется, что фамилии дизайнеров не повторяются. При этом размеры помещений могут повторяться.
Самым легким считается проект, в котором площадь помещения минимальна и город, в котором находится помещение, над которым работает дизайнер, не Москва или Санкт-Петербург. Гарантируется, что такой проект только один.
Функция должна возвращать фамилию дизайнера, который работает над самым легким проектом. 
Важно! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке.","[""['Круглов', 'Квадратов', 'Иванов', 'Марков', 'Пеньков', 'Гуськов'], ['100', '60', '67', '120', '90', '32'], ['Москва', 'Санкт-Петербург', 'Пермь', 'Москва', 'Сочи', 'Иваново']"", ""['Елисеев', 'Краков'], ['67', '100'], ['Санкт-Петербург', 'Томск']"", ""['Петров', 'Иванов', 'Волков', 'Меньшов'], ['50', '109', '30', '40'], ['Сочи', 'Москва', 'Иркутск', 'Краснодар']"", ""['Елисеев', 'Воробьев', 'Стариков'], ['100', '100', '150'], ['Москва', 'Санкт-Петербург', 'Реутов']"", ""['Графов', 'Петров'], ['10', '10'], ['Санкт-Петербург', 'Омск']"", ""['Степанов'], ['100'], ['Новгород']""]","['Гуськов', 'Краков', 'Волков', 'Стариков', 'Петров', 'Степанов']","def designer (designers, sizes, towns):
    sizes = list(int(sizes))
    lst_of_des = []
    lst_of_siz = []
    for i in range(len(towns)):
        if towns[i] != ""Москва"" and towns[i] != ""Санкт-Петербург"":
            lst_of_des.append(designers[i])
            lst_of_siz.append(sizes[i])
    
    return lst_of_des[lst_of_siz.index(min(lst_of_siz))]","def designer (designers, sizes, towns):
    sizes = list(map(int, sizes))
    lst_of_des = []
    lst_of_siz = []
    for i in range(len(towns)):
        if towns[i] != ""Москва"" and towns[i] != ""Санкт-Петербург"":
            lst_of_des.append(designers[i])
            lst_of_siz.append(sizes[i])
    
    return lst_of_des[lst_of_siz.index(min(lst_of_siz))]",Ошибка при преобразовании переменной. int() не может применяться ко всему списку сразу. Примените int() к каждому элементу списка по отдельности.,"['open', 'open', 'closed', 'closed', 'closed', 'closed']","<Task description>: Напишите функцию, определяющую дизайнера, который работает над самым легким проектом.

Определите функцию designer, которая принимает на вход три списка:
в первом списке перечислены фамилии дизайнеров;
во втором списке перечислены размеры помещений (в кв. м.) (строки), для которых эти дизайнеры создают проекты интерьера соответственно.
в третьем списке перечислены города, в которых располагаются помещения.
Гарантируется, что фамилии дизайнеров не повторяются. При этом размеры помещений могут повторяться.
Самым легким считается проект, в котором площадь помещения минимальна и город, в котором находится помещение, над которым работает дизайнер, не Москва или Санкт-Петербург. Гарантируется, что такой проект только один.
Функция должна возвращать фамилию дизайнера, который работает над самым легким проектом. 
Важно! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: ['Круглов', 'Квадратов', 'Иванов', 'Марков', 'Пеньков', 'Гуськов'], ['100', '60', '67', '120', '90', '32'], ['Москва', 'Санкт-Петербург', 'Пермь', 'Москва', 'Сочи', 'Иваново'] 
<Вывод>: Гуськов 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: ['Елисеев', 'Краков'], ['67', '100'], ['Санкт-Петербург', 'Томск'] 
<Вывод>: Краков 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: ['Петров', 'Иванов', 'Волков', 'Меньшов'], ['50', '109', '30', '40'], ['Сочи', 'Москва', 'Иркутск', 'Краснодар'] 
<Вывод>: Волков 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: ['Елисеев', 'Воробьев', 'Стариков'], ['100', '100', '150'], ['Москва', 'Санкт-Петербург', 'Реутов'] 
<Вывод>: Стариков 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: ['Графов', 'Петров'], ['10', '10'], ['Санкт-Петербург', 'Омск'] 
<Вывод>: Петров 
<Example 6>: 
<Тип теста 6>: closed 
<Ввод>: ['Степанов'], ['100'], ['Новгород'] 
<Вывод>: Степанов 
<Решение студента>: def designer (designers, sizes, towns):
    sizes = list(int(sizes))
    lst_of_des = []
    lst_of_siz = []
    for i in range(len(towns)):
        if towns[i] != ""Москва"" and towns[i] != ""Санкт-Петербург"":
            lst_of_des.append(designers[i])
            lst_of_siz.append(sizes[i])
    
    return lst_of_des[lst_of_siz.index(min(lst_of_siz))] 
<Идеальное решение>: def designer (designers, sizes, towns):
    sizes = list(map(int, sizes))
    lst_of_des = []
    lst_of_siz = []
    for i in range(len(towns)):
        if towns[i] != ""Москва"" and towns[i] != ""Санкт-Петербург"":
            lst_of_des.append(designers[i])
            lst_of_siz.append(sizes[i])
    
    return lst_of_des[lst_of_siz.index(min(lst_of_siz))] 


<Комментарий эксперта>:"
63,106,6,"Напишите функцию, определяющую дизайнера, который работает над самым легким проектом.

Определите функцию designer, которая принимает на вход три списка:
в первом списке перечислены фамилии дизайнеров;
во втором списке перечислены размеры помещений (в кв. м.) (строки), для которых эти дизайнеры создают проекты интерьера соответственно.
в третьем списке перечислены города, в которых располагаются помещения.
Гарантируется, что фамилии дизайнеров не повторяются. При этом размеры помещений могут повторяться.
Самым легким считается проект, в котором площадь помещения минимальна и город, в котором находится помещение, над которым работает дизайнер, не Москва или Санкт-Петербург. Гарантируется, что такой проект только один.
Функция должна возвращать фамилию дизайнера, который работает над самым легким проектом. 
Важно! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке.","[""['Круглов', 'Квадратов', 'Иванов', 'Марков', 'Пеньков', 'Гуськов'], ['100', '60', '67', '120', '90', '32'], ['Москва', 'Санкт-Петербург', 'Пермь', 'Москва', 'Сочи', 'Иваново']"", ""['Елисеев', 'Краков'], ['67', '100'], ['Санкт-Петербург', 'Томск']"", ""['Петров', 'Иванов', 'Волков', 'Меньшов'], ['50', '109', '30', '40'], ['Сочи', 'Москва', 'Иркутск', 'Краснодар']"", ""['Елисеев', 'Воробьев', 'Стариков'], ['100', '100', '150'], ['Москва', 'Санкт-Петербург', 'Реутов']"", ""['Графов', 'Петров'], ['10', '10'], ['Санкт-Петербург', 'Омск']"", ""['Степанов'], ['100'], ['Новгород']""]","['Гуськов', 'Краков', 'Волков', 'Стариков', 'Петров', 'Степанов']","def designer (designers, sizes, towns):
    sizes = list(map(int, sizes))
    lst_of_des = []
    lst_of_siz = []
    for i in range(len(towns)):
        if towns[i] == ""Москва"" and towns[i] == ""Санкт-Петербург"":
            lst_of_des.append(designers[i])
            lst_of_siz.append(sizes[i])
    
    return lst_of_des[lst_of_siz.index(min(lst_of_siz))]","def designer (designers, sizes, towns):
    sizes = list(map(int, sizes))
    lst_of_des = []
    lst_of_siz = []
    for i in range(len(towns)):
        if towns[i] != ""Москва"" and towns[i] != ""Санкт-Петербург"":
            lst_of_des.append(designers[i])
            lst_of_siz.append(sizes[i])
    
    return lst_of_des[lst_of_siz.index(min(lst_of_siz))]","Ошибка в открытых и скрытых тестах. 

Ваш код некорректно выполняет условия задания ""не Москва или Санкт-Петербург"". Попробуйте изменить условие if, чтобы скорректировать ошибку.","['open', 'open', 'closed', 'closed', 'closed', 'closed']","<Task description>: Напишите функцию, определяющую дизайнера, который работает над самым легким проектом.

Определите функцию designer, которая принимает на вход три списка:
в первом списке перечислены фамилии дизайнеров;
во втором списке перечислены размеры помещений (в кв. м.) (строки), для которых эти дизайнеры создают проекты интерьера соответственно.
в третьем списке перечислены города, в которых располагаются помещения.
Гарантируется, что фамилии дизайнеров не повторяются. При этом размеры помещений могут повторяться.
Самым легким считается проект, в котором площадь помещения минимальна и город, в котором находится помещение, над которым работает дизайнер, не Москва или Санкт-Петербург. Гарантируется, что такой проект только один.
Функция должна возвращать фамилию дизайнера, который работает над самым легким проектом. 
Важно! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: ['Круглов', 'Квадратов', 'Иванов', 'Марков', 'Пеньков', 'Гуськов'], ['100', '60', '67', '120', '90', '32'], ['Москва', 'Санкт-Петербург', 'Пермь', 'Москва', 'Сочи', 'Иваново'] 
<Вывод>: Гуськов 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: ['Елисеев', 'Краков'], ['67', '100'], ['Санкт-Петербург', 'Томск'] 
<Вывод>: Краков 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: ['Петров', 'Иванов', 'Волков', 'Меньшов'], ['50', '109', '30', '40'], ['Сочи', 'Москва', 'Иркутск', 'Краснодар'] 
<Вывод>: Волков 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: ['Елисеев', 'Воробьев', 'Стариков'], ['100', '100', '150'], ['Москва', 'Санкт-Петербург', 'Реутов'] 
<Вывод>: Стариков 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: ['Графов', 'Петров'], ['10', '10'], ['Санкт-Петербург', 'Омск'] 
<Вывод>: Петров 
<Example 6>: 
<Тип теста 6>: closed 
<Ввод>: ['Степанов'], ['100'], ['Новгород'] 
<Вывод>: Степанов 
<Решение студента>: def designer (designers, sizes, towns):
    sizes = list(map(int, sizes))
    lst_of_des = []
    lst_of_siz = []
    for i in range(len(towns)):
        if towns[i] == ""Москва"" and towns[i] == ""Санкт-Петербург"":
            lst_of_des.append(designers[i])
            lst_of_siz.append(sizes[i])
    
    return lst_of_des[lst_of_siz.index(min(lst_of_siz))] 
<Идеальное решение>: def designer (designers, sizes, towns):
    sizes = list(map(int, sizes))
    lst_of_des = []
    lst_of_siz = []
    for i in range(len(towns)):
        if towns[i] != ""Москва"" and towns[i] != ""Санкт-Петербург"":
            lst_of_des.append(designers[i])
            lst_of_siz.append(sizes[i])
    
    return lst_of_des[lst_of_siz.index(min(lst_of_siz))] 


<Комментарий эксперта>:"
64,107,7,"Ксения анализирует реализованные дизайн-проекты, которые собраны в файле формата csv. Напишите программу, которая выводит все строки, соответствующие реализованным в определенный период проектам, стоимость которых была не более 500 тыс. руб..

Программа должна открывать структурированный текстовый файл projects_file.csv, в кодировке utf-8, где на каждой строке записана следующая информация о дизайн-проекте: год, стоимость проекта, количество недель, за сколько был реализован проект. Например, строка ""2019,200 тыс. руб.,10 недель"" означает, что в 2019 году проект стоимостью 200 тыс. руб. был реализован за 10 недель.
Гарантируется, что стоимость реализованного проекта всегда записана в формате ""<целое число> тыс. руб."".
Гарантируется, что срок реализации проекта всегда записан в формате ""<целое число> недель"".
Разделителями данных в файле служат запятые.
Гарантируется, что в файле есть как минимум одна строка с данными. 
С клавиатуры вводится строка — год.
Программа должна выводить строки из оригинального файла, которые соответствуют проектам, реализованным не позднее, чем в указанном году, со стоимостью не более 500. тыс. руб. (не забудьте удалить символы конца строки!).
Если подходящих под условие строк в файле нет, то программа ничего не выводит.
ДОПОЛНИТЕЛЬНО
Ваше решение будет проверяться на закрытых тестах. Ваш код должен считывать файл projects_file.csv без дополнительных указаний (например, пути к файлу на вашем компьютере).
В открытом тесте используется файл projects_file.csv. Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.","['2019', '2018', '2015', '2019', '1990']","['2018,253 тыс. руб.,45 недель\n2018,340 тыс. руб.,34 недель\n2019,263 тыс. руб.,90 недель\n2019,320 тыс. руб.,31 недель\n2019,478 тыс. руб.,85 недель\n2018,324 тыс. руб.,18 недель\n2019,186 тыс. руб.,82 недель\n2018,349 тыс. руб.,95 недель\n2019,479 тыс. руб.,31 недель\n2019,192 тыс. руб.,36 недель\n2018,393 тыс. руб.,90 недель\n2019,206 тыс. руб.,70 недель\n2019,185 тыс. руб.,27 недель\n2019,396 тыс. руб.,36 недель\n2018,445 тыс. руб.,6 недель\n2019,492 тыс. руб.,77 недель\n2018,267 тыс. руб.,38 недель\n2018,260 тыс. руб.,79 недель\n2018,214 тыс. руб.,47 недель\n2018,151 тыс. руб.,70 недель\n2019,116 тыс. руб.,25 недель\n2019,178 тыс. руб.,9 недель\n2019,100 тыс. руб.,24 недель\n2019,112 тыс. руб.,91 недель\n2019,369 тыс. руб.,24 недель\n2019,166 тыс. руб.,67 недель\n2019,498 тыс. руб.,83 недель\n2018,276 тыс. руб.,48 недель\n2019,493 тыс. руб.,20 недель\n2019,358 тыс. руб.,27 недель\n2019,394 тыс. руб.,49 недель\n2019,429 тыс. руб.,77 недель\n2019,375 тыс. руб.,44 недель\n2019,245 тыс. руб.,74 недель\n2018,313 тыс. руб.,5 недель\n2018,244 тыс. руб.,26 недель\n2018,432 тыс. руб.,87 недель\n2019,291 тыс. руб.,96 недель\n2018,355 тыс. руб.,100 недель\n2019,377 тыс. руб.,39 недель', '2018,240 тыс. руб.,86 недель\n2018,491 тыс. руб.,75 недель\n2018,310 тыс. руб.,29 недель\n2018,111 тыс. руб.,60 недель\n2018,252 тыс. руб.,81 недель\n2018,448 тыс. руб.,55 недель\n2018,397 тыс. руб.,73 недель\n2018,472 тыс. руб.,74 недель\n2018,357 тыс. руб.,17 недель\n2018,364 тыс. руб.,82 недель\n2018,187 тыс. руб.,89 недель\n2018,267 тыс. руб.,57 недель\n2018,254 тыс. руб.,18 недель\n2018,330 тыс. руб.,95 недель\n2018,488 тыс. руб.,64 недель\n2018,167 тыс. руб.,29 недель\n2018,327 тыс. руб.,27 недель\n2018,275 тыс. руб.,13 недель\n2018,205 тыс. руб.,93 недель\n2018,354 тыс. руб.,38 недель', '2015,497 тыс. руб.,82 недель\n2015,391 тыс. руб.,81 недель\n2015,488 тыс. руб.,72 недель\n2015,188 тыс. руб.,72 недель\n2015,320 тыс. руб.,57 недель\n2015,251 тыс. руб.,36 недель\n2015,488 тыс. руб.,96 недель\n2015,379 тыс. руб.,14 недель\n2015,305 тыс. руб.,90 недель\n2015,284 тыс. руб.,33 недель\n2015,180 тыс. руб.,15 недель\n2015,328 тыс. руб.,50 недель\n2015,355 тыс. руб.,84 недель\n2015,426 тыс. руб.,63 недель\n2015,294 тыс. руб.,15 недель\n2015,327 тыс. руб.,72 недель\n2015,452 тыс. руб.,71 недель\n2015,240 тыс. руб.,88 недель', '2019,255 тыс. руб.,56 недель\n2017,280 тыс. руб.,80 недель\n2019,111 тыс. руб.,49 недель\n2015,497 тыс. руб.,82 недель\n2015,391 тыс. руб.,81 недель\n2015,488 тыс. руб.,72 недель\n2016,219 тыс. руб.,11 недель\n2015,188 тыс. руб.,72 недель\n2016,439 тыс. руб.,82 недель\n2016,410 тыс. руб.,26 недель\n2017,166 тыс. руб.,100 недель\n2019,449 тыс. руб.,100 недель\n2019,148 тыс. руб.,51 недель\n2018,246 тыс. руб.,59 недель\n2018,307 тыс. руб.,20 недель\n2019,113 тыс. руб.,41 недель\n2017,278 тыс. руб.,40 недель\n2015,320 тыс. руб.,57 недель\n2016,195 тыс. руб.,37 недель\n2019,330 тыс. руб.,69 недель\n2015,251 тыс. руб.,36 недель\n2015,488 тыс. руб.,96 недель\n2017,215 тыс. руб.,22 недель\n2017,151 тыс. руб.,93 недель\n2016,470 тыс. руб.,84 недель\n2018,376 тыс. руб.,53 недель\n2018,488 тыс. руб.,13 недель\n2017,164 тыс. руб.,15 недель\n2016,226 тыс. руб.,51 недель\n2015,379 тыс. руб.,14 недель\n2015,305 тыс. руб.,90 недель\n2015,284 тыс. руб.,33 недель\n2016,158 тыс. руб.,55 недель\n2016,257 тыс. руб.,14 недель\n2015,180 тыс. руб.,15 недель\n2017,262 тыс. руб.,73 недель\n2019,245 тыс. руб.,99 недель\n2015,328 тыс. руб.,50 недель\n2015,355 тыс. руб.,84 недель\n2016,358 тыс. руб.,70 недель\n2017,463 тыс. руб.,33 недель\n2015,426 тыс. руб.,63 недель\n2016,153 тыс. руб.,19 недель\n2015,294 тыс. руб.,15 недель\n2016,190 тыс. руб.,61 недель\n2019,256 тыс. руб.,16 недель\n2015,327 тыс. руб.,72 недель\n2017,499 тыс. руб.,41 недель\n2015,452 тыс. руб.,71 недель\n2018,142 тыс. руб.,57 недель\n2019,452 тыс. руб.,100 недель\n2015,240 тыс. руб.,88 недель\n2017,141 тыс. руб.,72 недель\n2018,215 тыс. руб.,40 недель\n2019,177 тыс. руб.,75 недель\n2019,115 тыс. руб.,15 недель\n2017,148 тыс. руб.,95 недель\n2019,125 тыс. руб.,24 недель\n2019,434 тыс. руб.,88 недель\n2016,348 тыс. руб.,83 недель\n2017,127 тыс. руб.,68 недель\n2018,145 тыс. руб.,41 недель', nan]","year = input()

with open('projects_file.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        info = line.split(',')
        if info[0] <= year and int(info[-2].split()[0]) <= 500:
            print(line)","year = input()

with open('projects_file.csv', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        info = line.split(',')
        if info[0] <= year and int(info[-2].split()[0]) <= 500:
            print(line)",Вы использовали некорректный формат файла для чтения.,"['open', 'closed', 'closed', 'closed', 'closed']","<Task description>: Ксения анализирует реализованные дизайн-проекты, которые собраны в файле формата csv. Напишите программу, которая выводит все строки, соответствующие реализованным в определенный период проектам, стоимость которых была не более 500 тыс. руб..

Программа должна открывать структурированный текстовый файл projects_file.csv, в кодировке utf-8, где на каждой строке записана следующая информация о дизайн-проекте: год, стоимость проекта, количество недель, за сколько был реализован проект. Например, строка ""2019,200 тыс. руб.,10 недель"" означает, что в 2019 году проект стоимостью 200 тыс. руб. был реализован за 10 недель.
Гарантируется, что стоимость реализованного проекта всегда записана в формате ""<целое число> тыс. руб."".
Гарантируется, что срок реализации проекта всегда записан в формате ""<целое число> недель"".
Разделителями данных в файле служат запятые.
Гарантируется, что в файле есть как минимум одна строка с данными. 
С клавиатуры вводится строка — год.
Программа должна выводить строки из оригинального файла, которые соответствуют проектам, реализованным не позднее, чем в указанном году, со стоимостью не более 500. тыс. руб. (не забудьте удалить символы конца строки!).
Если подходящих под условие строк в файле нет, то программа ничего не выводит.
ДОПОЛНИТЕЛЬНО
Ваше решение будет проверяться на закрытых тестах. Ваш код должен считывать файл projects_file.csv без дополнительных указаний (например, пути к файлу на вашем компьютере).
В открытом тесте используется файл projects_file.csv. Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: 2019 
<Вывод>: 2018,253 тыс. руб.,45 недель
2018,340 тыс. руб.,34 недель
2019,263 тыс. руб.,90 недель
2019,320 тыс. руб.,31 недель
2019,478 тыс. руб.,85 недель
2018,324 тыс. руб.,18 недель
2019,186 тыс. руб.,82 недель
2018,349 тыс. руб.,95 недель
2019,479 тыс. руб.,31 недель
2019,192 тыс. руб.,36 недель
2018,393 тыс. руб.,90 недель
2019,206 тыс. руб.,70 недель
2019,185 тыс. руб.,27 недель
2019,396 тыс. руб.,36 недель
2018,445 тыс. руб.,6 недель
2019,492 тыс. руб.,77 недель
2018,267 тыс. руб.,38 недель
2018,260 тыс. руб.,79 недель
2018,214 тыс. руб.,47 недель
2018,151 тыс. руб.,70 недель
2019,116 тыс. руб.,25 недель
2019,178 тыс. руб.,9 недель
2019,100 тыс. руб.,24 недель
2019,112 тыс. руб.,91 недель
2019,369 тыс. руб.,24 недель
2019,166 тыс. руб.,67 недель
2019,498 тыс. руб.,83 недель
2018,276 тыс. руб.,48 недель
2019,493 тыс. руб.,20 недель
2019,358 тыс. руб.,27 недель
2019,394 тыс. руб.,49 недель
2019,429 тыс. руб.,77 недель
2019,375 тыс. руб.,44 недель
2019,245 тыс. руб.,74 недель
2018,313 тыс. руб.,5 недель
2018,244 тыс. руб.,26 недель
2018,432 тыс. руб.,87 недель
2019,291 тыс. руб.,96 недель
2018,355 тыс. руб.,100 недель
2019,377 тыс. руб.,39 недель 
<Example 2>: 
<Тип теста 2>: closed 
<Ввод>: 2018 
<Вывод>: 2018,240 тыс. руб.,86 недель
2018,491 тыс. руб.,75 недель
2018,310 тыс. руб.,29 недель
2018,111 тыс. руб.,60 недель
2018,252 тыс. руб.,81 недель
2018,448 тыс. руб.,55 недель
2018,397 тыс. руб.,73 недель
2018,472 тыс. руб.,74 недель
2018,357 тыс. руб.,17 недель
2018,364 тыс. руб.,82 недель
2018,187 тыс. руб.,89 недель
2018,267 тыс. руб.,57 недель
2018,254 тыс. руб.,18 недель
2018,330 тыс. руб.,95 недель
2018,488 тыс. руб.,64 недель
2018,167 тыс. руб.,29 недель
2018,327 тыс. руб.,27 недель
2018,275 тыс. руб.,13 недель
2018,205 тыс. руб.,93 недель
2018,354 тыс. руб.,38 недель 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: 2015 
<Вывод>: 2015,497 тыс. руб.,82 недель
2015,391 тыс. руб.,81 недель
2015,488 тыс. руб.,72 недель
2015,188 тыс. руб.,72 недель
2015,320 тыс. руб.,57 недель
2015,251 тыс. руб.,36 недель
2015,488 тыс. руб.,96 недель
2015,379 тыс. руб.,14 недель
2015,305 тыс. руб.,90 недель
2015,284 тыс. руб.,33 недель
2015,180 тыс. руб.,15 недель
2015,328 тыс. руб.,50 недель
2015,355 тыс. руб.,84 недель
2015,426 тыс. руб.,63 недель
2015,294 тыс. руб.,15 недель
2015,327 тыс. руб.,72 недель
2015,452 тыс. руб.,71 недель
2015,240 тыс. руб.,88 недель 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: 2019 
<Вывод>: 2019,255 тыс. руб.,56 недель
2017,280 тыс. руб.,80 недель
2019,111 тыс. руб.,49 недель
2015,497 тыс. руб.,82 недель
2015,391 тыс. руб.,81 недель
2015,488 тыс. руб.,72 недель
2016,219 тыс. руб.,11 недель
2015,188 тыс. руб.,72 недель
2016,439 тыс. руб.,82 недель
2016,410 тыс. руб.,26 недель
2017,166 тыс. руб.,100 недель
2019,449 тыс. руб.,100 недель
2019,148 тыс. руб.,51 недель
2018,246 тыс. руб.,59 недель
2018,307 тыс. руб.,20 недель
2019,113 тыс. руб.,41 недель
2017,278 тыс. руб.,40 недель
2015,320 тыс. руб.,57 недель
2016,195 тыс. руб.,37 недель
2019,330 тыс. руб.,69 недель
2015,251 тыс. руб.,36 недель
2015,488 тыс. руб.,96 недель
2017,215 тыс. руб.,22 недель
2017,151 тыс. руб.,93 недель
2016,470 тыс. руб.,84 недель
2018,376 тыс. руб.,53 недель
2018,488 тыс. руб.,13 недель
2017,164 тыс. руб.,15 недель
2016,226 тыс. руб.,51 недель
2015,379 тыс. руб.,14 недель
2015,305 тыс. руб.,90 недель
2015,284 тыс. руб.,33 недель
2016,158 тыс. руб.,55 недель
2016,257 тыс. руб.,14 недель
2015,180 тыс. руб.,15 недель
2017,262 тыс. руб.,73 недель
2019,245 тыс. руб.,99 недель
2015,328 тыс. руб.,50 недель
2015,355 тыс. руб.,84 недель
2016,358 тыс. руб.,70 недель
2017,463 тыс. руб.,33 недель
2015,426 тыс. руб.,63 недель
2016,153 тыс. руб.,19 недель
2015,294 тыс. руб.,15 недель
2016,190 тыс. руб.,61 недель
2019,256 тыс. руб.,16 недель
2015,327 тыс. руб.,72 недель
2017,499 тыс. руб.,41 недель
2015,452 тыс. руб.,71 недель
2018,142 тыс. руб.,57 недель
2019,452 тыс. руб.,100 недель
2015,240 тыс. руб.,88 недель
2017,141 тыс. руб.,72 недель
2018,215 тыс. руб.,40 недель
2019,177 тыс. руб.,75 недель
2019,115 тыс. руб.,15 недель
2017,148 тыс. руб.,95 недель
2019,125 тыс. руб.,24 недель
2019,434 тыс. руб.,88 недель
2016,348 тыс. руб.,83 недель
2017,127 тыс. руб.,68 недель
2018,145 тыс. руб.,41 недель 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: 1990 
<Вывод>: nan 
<Решение студента>: year = input()

with open('projects_file.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        info = line.split(',')
        if info[0] <= year and int(info[-2].split()[0]) <= 500:
            print(line) 
<Идеальное решение>: year = input()

with open('projects_file.csv', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        info = line.split(',')
        if info[0] <= year and int(info[-2].split()[0]) <= 500:
            print(line) 


<Комментарий эксперта>:"
65,108,7,"Ксения анализирует реализованные дизайн-проекты, которые собраны в файле формата csv. Напишите программу, которая выводит все строки, соответствующие реализованным в определенный период проектам, стоимость которых была не более 500 тыс. руб..

Программа должна открывать структурированный текстовый файл projects_file.csv, в кодировке utf-8, где на каждой строке записана следующая информация о дизайн-проекте: год, стоимость проекта, количество недель, за сколько был реализован проект. Например, строка ""2019,200 тыс. руб.,10 недель"" означает, что в 2019 году проект стоимостью 200 тыс. руб. был реализован за 10 недель.
Гарантируется, что стоимость реализованного проекта всегда записана в формате ""<целое число> тыс. руб."".
Гарантируется, что срок реализации проекта всегда записан в формате ""<целое число> недель"".
Разделителями данных в файле служат запятые.
Гарантируется, что в файле есть как минимум одна строка с данными. 
С клавиатуры вводится строка — год.
Программа должна выводить строки из оригинального файла, которые соответствуют проектам, реализованным не позднее, чем в указанном году, со стоимостью не более 500. тыс. руб. (не забудьте удалить символы конца строки!).
Если подходящих под условие строк в файле нет, то программа ничего не выводит.
ДОПОЛНИТЕЛЬНО
Ваше решение будет проверяться на закрытых тестах. Ваш код должен считывать файл projects_file.csv без дополнительных указаний (например, пути к файлу на вашем компьютере).
В открытом тесте используется файл projects_file.csv. Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.","['2019', '2018', '2015', '2019', '1990']","['2018,253 тыс. руб.,45 недель\n2018,340 тыс. руб.,34 недель\n2019,263 тыс. руб.,90 недель\n2019,320 тыс. руб.,31 недель\n2019,478 тыс. руб.,85 недель\n2018,324 тыс. руб.,18 недель\n2019,186 тыс. руб.,82 недель\n2018,349 тыс. руб.,95 недель\n2019,479 тыс. руб.,31 недель\n2019,192 тыс. руб.,36 недель\n2018,393 тыс. руб.,90 недель\n2019,206 тыс. руб.,70 недель\n2019,185 тыс. руб.,27 недель\n2019,396 тыс. руб.,36 недель\n2018,445 тыс. руб.,6 недель\n2019,492 тыс. руб.,77 недель\n2018,267 тыс. руб.,38 недель\n2018,260 тыс. руб.,79 недель\n2018,214 тыс. руб.,47 недель\n2018,151 тыс. руб.,70 недель\n2019,116 тыс. руб.,25 недель\n2019,178 тыс. руб.,9 недель\n2019,100 тыс. руб.,24 недель\n2019,112 тыс. руб.,91 недель\n2019,369 тыс. руб.,24 недель\n2019,166 тыс. руб.,67 недель\n2019,498 тыс. руб.,83 недель\n2018,276 тыс. руб.,48 недель\n2019,493 тыс. руб.,20 недель\n2019,358 тыс. руб.,27 недель\n2019,394 тыс. руб.,49 недель\n2019,429 тыс. руб.,77 недель\n2019,375 тыс. руб.,44 недель\n2019,245 тыс. руб.,74 недель\n2018,313 тыс. руб.,5 недель\n2018,244 тыс. руб.,26 недель\n2018,432 тыс. руб.,87 недель\n2019,291 тыс. руб.,96 недель\n2018,355 тыс. руб.,100 недель\n2019,377 тыс. руб.,39 недель', '2018,240 тыс. руб.,86 недель\n2018,491 тыс. руб.,75 недель\n2018,310 тыс. руб.,29 недель\n2018,111 тыс. руб.,60 недель\n2018,252 тыс. руб.,81 недель\n2018,448 тыс. руб.,55 недель\n2018,397 тыс. руб.,73 недель\n2018,472 тыс. руб.,74 недель\n2018,357 тыс. руб.,17 недель\n2018,364 тыс. руб.,82 недель\n2018,187 тыс. руб.,89 недель\n2018,267 тыс. руб.,57 недель\n2018,254 тыс. руб.,18 недель\n2018,330 тыс. руб.,95 недель\n2018,488 тыс. руб.,64 недель\n2018,167 тыс. руб.,29 недель\n2018,327 тыс. руб.,27 недель\n2018,275 тыс. руб.,13 недель\n2018,205 тыс. руб.,93 недель\n2018,354 тыс. руб.,38 недель', '2015,497 тыс. руб.,82 недель\n2015,391 тыс. руб.,81 недель\n2015,488 тыс. руб.,72 недель\n2015,188 тыс. руб.,72 недель\n2015,320 тыс. руб.,57 недель\n2015,251 тыс. руб.,36 недель\n2015,488 тыс. руб.,96 недель\n2015,379 тыс. руб.,14 недель\n2015,305 тыс. руб.,90 недель\n2015,284 тыс. руб.,33 недель\n2015,180 тыс. руб.,15 недель\n2015,328 тыс. руб.,50 недель\n2015,355 тыс. руб.,84 недель\n2015,426 тыс. руб.,63 недель\n2015,294 тыс. руб.,15 недель\n2015,327 тыс. руб.,72 недель\n2015,452 тыс. руб.,71 недель\n2015,240 тыс. руб.,88 недель', '2019,255 тыс. руб.,56 недель\n2017,280 тыс. руб.,80 недель\n2019,111 тыс. руб.,49 недель\n2015,497 тыс. руб.,82 недель\n2015,391 тыс. руб.,81 недель\n2015,488 тыс. руб.,72 недель\n2016,219 тыс. руб.,11 недель\n2015,188 тыс. руб.,72 недель\n2016,439 тыс. руб.,82 недель\n2016,410 тыс. руб.,26 недель\n2017,166 тыс. руб.,100 недель\n2019,449 тыс. руб.,100 недель\n2019,148 тыс. руб.,51 недель\n2018,246 тыс. руб.,59 недель\n2018,307 тыс. руб.,20 недель\n2019,113 тыс. руб.,41 недель\n2017,278 тыс. руб.,40 недель\n2015,320 тыс. руб.,57 недель\n2016,195 тыс. руб.,37 недель\n2019,330 тыс. руб.,69 недель\n2015,251 тыс. руб.,36 недель\n2015,488 тыс. руб.,96 недель\n2017,215 тыс. руб.,22 недель\n2017,151 тыс. руб.,93 недель\n2016,470 тыс. руб.,84 недель\n2018,376 тыс. руб.,53 недель\n2018,488 тыс. руб.,13 недель\n2017,164 тыс. руб.,15 недель\n2016,226 тыс. руб.,51 недель\n2015,379 тыс. руб.,14 недель\n2015,305 тыс. руб.,90 недель\n2015,284 тыс. руб.,33 недель\n2016,158 тыс. руб.,55 недель\n2016,257 тыс. руб.,14 недель\n2015,180 тыс. руб.,15 недель\n2017,262 тыс. руб.,73 недель\n2019,245 тыс. руб.,99 недель\n2015,328 тыс. руб.,50 недель\n2015,355 тыс. руб.,84 недель\n2016,358 тыс. руб.,70 недель\n2017,463 тыс. руб.,33 недель\n2015,426 тыс. руб.,63 недель\n2016,153 тыс. руб.,19 недель\n2015,294 тыс. руб.,15 недель\n2016,190 тыс. руб.,61 недель\n2019,256 тыс. руб.,16 недель\n2015,327 тыс. руб.,72 недель\n2017,499 тыс. руб.,41 недель\n2015,452 тыс. руб.,71 недель\n2018,142 тыс. руб.,57 недель\n2019,452 тыс. руб.,100 недель\n2015,240 тыс. руб.,88 недель\n2017,141 тыс. руб.,72 недель\n2018,215 тыс. руб.,40 недель\n2019,177 тыс. руб.,75 недель\n2019,115 тыс. руб.,15 недель\n2017,148 тыс. руб.,95 недель\n2019,125 тыс. руб.,24 недель\n2019,434 тыс. руб.,88 недель\n2016,348 тыс. руб.,83 недель\n2017,127 тыс. руб.,68 недель\n2018,145 тыс. руб.,41 недель', nan]","year = input()

with open('projects_file.csv', 'r', encoding='utf-8') as my_file:
    for line in file:
        line = line.strip()
        info = line.split(',')
        if info[0] <= year and int(info[-2].split()[0]) <= 500:
            print(line)","year = input()

with open('projects_file.csv', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        info = line.split(',')
        if info[0] <= year and int(info[-2].split()[0]) <= 500:
            print(line)","Вы использовали переменную, которая не была задана ранее. Проверьте, что все переменные используются корректно.","['open', 'closed', 'closed', 'closed', 'closed']","<Task description>: Ксения анализирует реализованные дизайн-проекты, которые собраны в файле формата csv. Напишите программу, которая выводит все строки, соответствующие реализованным в определенный период проектам, стоимость которых была не более 500 тыс. руб..

Программа должна открывать структурированный текстовый файл projects_file.csv, в кодировке utf-8, где на каждой строке записана следующая информация о дизайн-проекте: год, стоимость проекта, количество недель, за сколько был реализован проект. Например, строка ""2019,200 тыс. руб.,10 недель"" означает, что в 2019 году проект стоимостью 200 тыс. руб. был реализован за 10 недель.
Гарантируется, что стоимость реализованного проекта всегда записана в формате ""<целое число> тыс. руб."".
Гарантируется, что срок реализации проекта всегда записан в формате ""<целое число> недель"".
Разделителями данных в файле служат запятые.
Гарантируется, что в файле есть как минимум одна строка с данными. 
С клавиатуры вводится строка — год.
Программа должна выводить строки из оригинального файла, которые соответствуют проектам, реализованным не позднее, чем в указанном году, со стоимостью не более 500. тыс. руб. (не забудьте удалить символы конца строки!).
Если подходящих под условие строк в файле нет, то программа ничего не выводит.
ДОПОЛНИТЕЛЬНО
Ваше решение будет проверяться на закрытых тестах. Ваш код должен считывать файл projects_file.csv без дополнительных указаний (например, пути к файлу на вашем компьютере).
В открытом тесте используется файл projects_file.csv. Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: 2019 
<Вывод>: 2018,253 тыс. руб.,45 недель
2018,340 тыс. руб.,34 недель
2019,263 тыс. руб.,90 недель
2019,320 тыс. руб.,31 недель
2019,478 тыс. руб.,85 недель
2018,324 тыс. руб.,18 недель
2019,186 тыс. руб.,82 недель
2018,349 тыс. руб.,95 недель
2019,479 тыс. руб.,31 недель
2019,192 тыс. руб.,36 недель
2018,393 тыс. руб.,90 недель
2019,206 тыс. руб.,70 недель
2019,185 тыс. руб.,27 недель
2019,396 тыс. руб.,36 недель
2018,445 тыс. руб.,6 недель
2019,492 тыс. руб.,77 недель
2018,267 тыс. руб.,38 недель
2018,260 тыс. руб.,79 недель
2018,214 тыс. руб.,47 недель
2018,151 тыс. руб.,70 недель
2019,116 тыс. руб.,25 недель
2019,178 тыс. руб.,9 недель
2019,100 тыс. руб.,24 недель
2019,112 тыс. руб.,91 недель
2019,369 тыс. руб.,24 недель
2019,166 тыс. руб.,67 недель
2019,498 тыс. руб.,83 недель
2018,276 тыс. руб.,48 недель
2019,493 тыс. руб.,20 недель
2019,358 тыс. руб.,27 недель
2019,394 тыс. руб.,49 недель
2019,429 тыс. руб.,77 недель
2019,375 тыс. руб.,44 недель
2019,245 тыс. руб.,74 недель
2018,313 тыс. руб.,5 недель
2018,244 тыс. руб.,26 недель
2018,432 тыс. руб.,87 недель
2019,291 тыс. руб.,96 недель
2018,355 тыс. руб.,100 недель
2019,377 тыс. руб.,39 недель 
<Example 2>: 
<Тип теста 2>: closed 
<Ввод>: 2018 
<Вывод>: 2018,240 тыс. руб.,86 недель
2018,491 тыс. руб.,75 недель
2018,310 тыс. руб.,29 недель
2018,111 тыс. руб.,60 недель
2018,252 тыс. руб.,81 недель
2018,448 тыс. руб.,55 недель
2018,397 тыс. руб.,73 недель
2018,472 тыс. руб.,74 недель
2018,357 тыс. руб.,17 недель
2018,364 тыс. руб.,82 недель
2018,187 тыс. руб.,89 недель
2018,267 тыс. руб.,57 недель
2018,254 тыс. руб.,18 недель
2018,330 тыс. руб.,95 недель
2018,488 тыс. руб.,64 недель
2018,167 тыс. руб.,29 недель
2018,327 тыс. руб.,27 недель
2018,275 тыс. руб.,13 недель
2018,205 тыс. руб.,93 недель
2018,354 тыс. руб.,38 недель 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: 2015 
<Вывод>: 2015,497 тыс. руб.,82 недель
2015,391 тыс. руб.,81 недель
2015,488 тыс. руб.,72 недель
2015,188 тыс. руб.,72 недель
2015,320 тыс. руб.,57 недель
2015,251 тыс. руб.,36 недель
2015,488 тыс. руб.,96 недель
2015,379 тыс. руб.,14 недель
2015,305 тыс. руб.,90 недель
2015,284 тыс. руб.,33 недель
2015,180 тыс. руб.,15 недель
2015,328 тыс. руб.,50 недель
2015,355 тыс. руб.,84 недель
2015,426 тыс. руб.,63 недель
2015,294 тыс. руб.,15 недель
2015,327 тыс. руб.,72 недель
2015,452 тыс. руб.,71 недель
2015,240 тыс. руб.,88 недель 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: 2019 
<Вывод>: 2019,255 тыс. руб.,56 недель
2017,280 тыс. руб.,80 недель
2019,111 тыс. руб.,49 недель
2015,497 тыс. руб.,82 недель
2015,391 тыс. руб.,81 недель
2015,488 тыс. руб.,72 недель
2016,219 тыс. руб.,11 недель
2015,188 тыс. руб.,72 недель
2016,439 тыс. руб.,82 недель
2016,410 тыс. руб.,26 недель
2017,166 тыс. руб.,100 недель
2019,449 тыс. руб.,100 недель
2019,148 тыс. руб.,51 недель
2018,246 тыс. руб.,59 недель
2018,307 тыс. руб.,20 недель
2019,113 тыс. руб.,41 недель
2017,278 тыс. руб.,40 недель
2015,320 тыс. руб.,57 недель
2016,195 тыс. руб.,37 недель
2019,330 тыс. руб.,69 недель
2015,251 тыс. руб.,36 недель
2015,488 тыс. руб.,96 недель
2017,215 тыс. руб.,22 недель
2017,151 тыс. руб.,93 недель
2016,470 тыс. руб.,84 недель
2018,376 тыс. руб.,53 недель
2018,488 тыс. руб.,13 недель
2017,164 тыс. руб.,15 недель
2016,226 тыс. руб.,51 недель
2015,379 тыс. руб.,14 недель
2015,305 тыс. руб.,90 недель
2015,284 тыс. руб.,33 недель
2016,158 тыс. руб.,55 недель
2016,257 тыс. руб.,14 недель
2015,180 тыс. руб.,15 недель
2017,262 тыс. руб.,73 недель
2019,245 тыс. руб.,99 недель
2015,328 тыс. руб.,50 недель
2015,355 тыс. руб.,84 недель
2016,358 тыс. руб.,70 недель
2017,463 тыс. руб.,33 недель
2015,426 тыс. руб.,63 недель
2016,153 тыс. руб.,19 недель
2015,294 тыс. руб.,15 недель
2016,190 тыс. руб.,61 недель
2019,256 тыс. руб.,16 недель
2015,327 тыс. руб.,72 недель
2017,499 тыс. руб.,41 недель
2015,452 тыс. руб.,71 недель
2018,142 тыс. руб.,57 недель
2019,452 тыс. руб.,100 недель
2015,240 тыс. руб.,88 недель
2017,141 тыс. руб.,72 недель
2018,215 тыс. руб.,40 недель
2019,177 тыс. руб.,75 недель
2019,115 тыс. руб.,15 недель
2017,148 тыс. руб.,95 недель
2019,125 тыс. руб.,24 недель
2019,434 тыс. руб.,88 недель
2016,348 тыс. руб.,83 недель
2017,127 тыс. руб.,68 недель
2018,145 тыс. руб.,41 недель 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: 1990 
<Вывод>: nan 
<Решение студента>: year = input()

with open('projects_file.csv', 'r', encoding='utf-8') as my_file:
    for line in file:
        line = line.strip()
        info = line.split(',')
        if info[0] <= year and int(info[-2].split()[0]) <= 500:
            print(line) 
<Идеальное решение>: year = input()

with open('projects_file.csv', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        info = line.split(',')
        if info[0] <= year and int(info[-2].split()[0]) <= 500:
            print(line) 


<Комментарий эксперта>:"
66,109,7,"Ксения анализирует реализованные дизайн-проекты, которые собраны в файле формата csv. Напишите программу, которая выводит все строки, соответствующие реализованным в определенный период проектам, стоимость которых была не более 500 тыс. руб..

Программа должна открывать структурированный текстовый файл projects_file.csv, в кодировке utf-8, где на каждой строке записана следующая информация о дизайн-проекте: год, стоимость проекта, количество недель, за сколько был реализован проект. Например, строка ""2019,200 тыс. руб.,10 недель"" означает, что в 2019 году проект стоимостью 200 тыс. руб. был реализован за 10 недель.
Гарантируется, что стоимость реализованного проекта всегда записана в формате ""<целое число> тыс. руб."".
Гарантируется, что срок реализации проекта всегда записан в формате ""<целое число> недель"".
Разделителями данных в файле служат запятые.
Гарантируется, что в файле есть как минимум одна строка с данными. 
С клавиатуры вводится строка — год.
Программа должна выводить строки из оригинального файла, которые соответствуют проектам, реализованным не позднее, чем в указанном году, со стоимостью не более 500. тыс. руб. (не забудьте удалить символы конца строки!).
Если подходящих под условие строк в файле нет, то программа ничего не выводит.
ДОПОЛНИТЕЛЬНО
Ваше решение будет проверяться на закрытых тестах. Ваш код должен считывать файл projects_file.csv без дополнительных указаний (например, пути к файлу на вашем компьютере).
В открытом тесте используется файл projects_file.csv. Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.","['2019', '2018', '2015', '2019', '1990']","['2018,253 тыс. руб.,45 недель\n2018,340 тыс. руб.,34 недель\n2019,263 тыс. руб.,90 недель\n2019,320 тыс. руб.,31 недель\n2019,478 тыс. руб.,85 недель\n2018,324 тыс. руб.,18 недель\n2019,186 тыс. руб.,82 недель\n2018,349 тыс. руб.,95 недель\n2019,479 тыс. руб.,31 недель\n2019,192 тыс. руб.,36 недель\n2018,393 тыс. руб.,90 недель\n2019,206 тыс. руб.,70 недель\n2019,185 тыс. руб.,27 недель\n2019,396 тыс. руб.,36 недель\n2018,445 тыс. руб.,6 недель\n2019,492 тыс. руб.,77 недель\n2018,267 тыс. руб.,38 недель\n2018,260 тыс. руб.,79 недель\n2018,214 тыс. руб.,47 недель\n2018,151 тыс. руб.,70 недель\n2019,116 тыс. руб.,25 недель\n2019,178 тыс. руб.,9 недель\n2019,100 тыс. руб.,24 недель\n2019,112 тыс. руб.,91 недель\n2019,369 тыс. руб.,24 недель\n2019,166 тыс. руб.,67 недель\n2019,498 тыс. руб.,83 недель\n2018,276 тыс. руб.,48 недель\n2019,493 тыс. руб.,20 недель\n2019,358 тыс. руб.,27 недель\n2019,394 тыс. руб.,49 недель\n2019,429 тыс. руб.,77 недель\n2019,375 тыс. руб.,44 недель\n2019,245 тыс. руб.,74 недель\n2018,313 тыс. руб.,5 недель\n2018,244 тыс. руб.,26 недель\n2018,432 тыс. руб.,87 недель\n2019,291 тыс. руб.,96 недель\n2018,355 тыс. руб.,100 недель\n2019,377 тыс. руб.,39 недель', '2018,240 тыс. руб.,86 недель\n2018,491 тыс. руб.,75 недель\n2018,310 тыс. руб.,29 недель\n2018,111 тыс. руб.,60 недель\n2018,252 тыс. руб.,81 недель\n2018,448 тыс. руб.,55 недель\n2018,397 тыс. руб.,73 недель\n2018,472 тыс. руб.,74 недель\n2018,357 тыс. руб.,17 недель\n2018,364 тыс. руб.,82 недель\n2018,187 тыс. руб.,89 недель\n2018,267 тыс. руб.,57 недель\n2018,254 тыс. руб.,18 недель\n2018,330 тыс. руб.,95 недель\n2018,488 тыс. руб.,64 недель\n2018,167 тыс. руб.,29 недель\n2018,327 тыс. руб.,27 недель\n2018,275 тыс. руб.,13 недель\n2018,205 тыс. руб.,93 недель\n2018,354 тыс. руб.,38 недель', '2015,497 тыс. руб.,82 недель\n2015,391 тыс. руб.,81 недель\n2015,488 тыс. руб.,72 недель\n2015,188 тыс. руб.,72 недель\n2015,320 тыс. руб.,57 недель\n2015,251 тыс. руб.,36 недель\n2015,488 тыс. руб.,96 недель\n2015,379 тыс. руб.,14 недель\n2015,305 тыс. руб.,90 недель\n2015,284 тыс. руб.,33 недель\n2015,180 тыс. руб.,15 недель\n2015,328 тыс. руб.,50 недель\n2015,355 тыс. руб.,84 недель\n2015,426 тыс. руб.,63 недель\n2015,294 тыс. руб.,15 недель\n2015,327 тыс. руб.,72 недель\n2015,452 тыс. руб.,71 недель\n2015,240 тыс. руб.,88 недель', '2019,255 тыс. руб.,56 недель\n2017,280 тыс. руб.,80 недель\n2019,111 тыс. руб.,49 недель\n2015,497 тыс. руб.,82 недель\n2015,391 тыс. руб.,81 недель\n2015,488 тыс. руб.,72 недель\n2016,219 тыс. руб.,11 недель\n2015,188 тыс. руб.,72 недель\n2016,439 тыс. руб.,82 недель\n2016,410 тыс. руб.,26 недель\n2017,166 тыс. руб.,100 недель\n2019,449 тыс. руб.,100 недель\n2019,148 тыс. руб.,51 недель\n2018,246 тыс. руб.,59 недель\n2018,307 тыс. руб.,20 недель\n2019,113 тыс. руб.,41 недель\n2017,278 тыс. руб.,40 недель\n2015,320 тыс. руб.,57 недель\n2016,195 тыс. руб.,37 недель\n2019,330 тыс. руб.,69 недель\n2015,251 тыс. руб.,36 недель\n2015,488 тыс. руб.,96 недель\n2017,215 тыс. руб.,22 недель\n2017,151 тыс. руб.,93 недель\n2016,470 тыс. руб.,84 недель\n2018,376 тыс. руб.,53 недель\n2018,488 тыс. руб.,13 недель\n2017,164 тыс. руб.,15 недель\n2016,226 тыс. руб.,51 недель\n2015,379 тыс. руб.,14 недель\n2015,305 тыс. руб.,90 недель\n2015,284 тыс. руб.,33 недель\n2016,158 тыс. руб.,55 недель\n2016,257 тыс. руб.,14 недель\n2015,180 тыс. руб.,15 недель\n2017,262 тыс. руб.,73 недель\n2019,245 тыс. руб.,99 недель\n2015,328 тыс. руб.,50 недель\n2015,355 тыс. руб.,84 недель\n2016,358 тыс. руб.,70 недель\n2017,463 тыс. руб.,33 недель\n2015,426 тыс. руб.,63 недель\n2016,153 тыс. руб.,19 недель\n2015,294 тыс. руб.,15 недель\n2016,190 тыс. руб.,61 недель\n2019,256 тыс. руб.,16 недель\n2015,327 тыс. руб.,72 недель\n2017,499 тыс. руб.,41 недель\n2015,452 тыс. руб.,71 недель\n2018,142 тыс. руб.,57 недель\n2019,452 тыс. руб.,100 недель\n2015,240 тыс. руб.,88 недель\n2017,141 тыс. руб.,72 недель\n2018,215 тыс. руб.,40 недель\n2019,177 тыс. руб.,75 недель\n2019,115 тыс. руб.,15 недель\n2017,148 тыс. руб.,95 недель\n2019,125 тыс. руб.,24 недель\n2019,434 тыс. руб.,88 недель\n2016,348 тыс. руб.,83 недель\n2017,127 тыс. руб.,68 недель\n2018,145 тыс. руб.,41 недель', nan]","year = input()

with open('projects_file.csv', 'r', encoding='utf-8') as my_file:
    for line in my_file
        line = line.strip()
        info = line.split(',')
        if info[0] <= year and int(info[-2].split()[0]) <= 500:
            print(line)","year = input()

with open('projects_file.csv', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        info = line.split(',')
        if info[0] <= year and int(info[-2].split()[0]) <= 500:
            print(line)",Вы забыли поставить двоеточие после цикла for.,"['open', 'closed', 'closed', 'closed', 'closed']","<Task description>: Ксения анализирует реализованные дизайн-проекты, которые собраны в файле формата csv. Напишите программу, которая выводит все строки, соответствующие реализованным в определенный период проектам, стоимость которых была не более 500 тыс. руб..

Программа должна открывать структурированный текстовый файл projects_file.csv, в кодировке utf-8, где на каждой строке записана следующая информация о дизайн-проекте: год, стоимость проекта, количество недель, за сколько был реализован проект. Например, строка ""2019,200 тыс. руб.,10 недель"" означает, что в 2019 году проект стоимостью 200 тыс. руб. был реализован за 10 недель.
Гарантируется, что стоимость реализованного проекта всегда записана в формате ""<целое число> тыс. руб."".
Гарантируется, что срок реализации проекта всегда записан в формате ""<целое число> недель"".
Разделителями данных в файле служат запятые.
Гарантируется, что в файле есть как минимум одна строка с данными. 
С клавиатуры вводится строка — год.
Программа должна выводить строки из оригинального файла, которые соответствуют проектам, реализованным не позднее, чем в указанном году, со стоимостью не более 500. тыс. руб. (не забудьте удалить символы конца строки!).
Если подходящих под условие строк в файле нет, то программа ничего не выводит.
ДОПОЛНИТЕЛЬНО
Ваше решение будет проверяться на закрытых тестах. Ваш код должен считывать файл projects_file.csv без дополнительных указаний (например, пути к файлу на вашем компьютере).
В открытом тесте используется файл projects_file.csv. Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: 2019 
<Вывод>: 2018,253 тыс. руб.,45 недель
2018,340 тыс. руб.,34 недель
2019,263 тыс. руб.,90 недель
2019,320 тыс. руб.,31 недель
2019,478 тыс. руб.,85 недель
2018,324 тыс. руб.,18 недель
2019,186 тыс. руб.,82 недель
2018,349 тыс. руб.,95 недель
2019,479 тыс. руб.,31 недель
2019,192 тыс. руб.,36 недель
2018,393 тыс. руб.,90 недель
2019,206 тыс. руб.,70 недель
2019,185 тыс. руб.,27 недель
2019,396 тыс. руб.,36 недель
2018,445 тыс. руб.,6 недель
2019,492 тыс. руб.,77 недель
2018,267 тыс. руб.,38 недель
2018,260 тыс. руб.,79 недель
2018,214 тыс. руб.,47 недель
2018,151 тыс. руб.,70 недель
2019,116 тыс. руб.,25 недель
2019,178 тыс. руб.,9 недель
2019,100 тыс. руб.,24 недель
2019,112 тыс. руб.,91 недель
2019,369 тыс. руб.,24 недель
2019,166 тыс. руб.,67 недель
2019,498 тыс. руб.,83 недель
2018,276 тыс. руб.,48 недель
2019,493 тыс. руб.,20 недель
2019,358 тыс. руб.,27 недель
2019,394 тыс. руб.,49 недель
2019,429 тыс. руб.,77 недель
2019,375 тыс. руб.,44 недель
2019,245 тыс. руб.,74 недель
2018,313 тыс. руб.,5 недель
2018,244 тыс. руб.,26 недель
2018,432 тыс. руб.,87 недель
2019,291 тыс. руб.,96 недель
2018,355 тыс. руб.,100 недель
2019,377 тыс. руб.,39 недель 
<Example 2>: 
<Тип теста 2>: closed 
<Ввод>: 2018 
<Вывод>: 2018,240 тыс. руб.,86 недель
2018,491 тыс. руб.,75 недель
2018,310 тыс. руб.,29 недель
2018,111 тыс. руб.,60 недель
2018,252 тыс. руб.,81 недель
2018,448 тыс. руб.,55 недель
2018,397 тыс. руб.,73 недель
2018,472 тыс. руб.,74 недель
2018,357 тыс. руб.,17 недель
2018,364 тыс. руб.,82 недель
2018,187 тыс. руб.,89 недель
2018,267 тыс. руб.,57 недель
2018,254 тыс. руб.,18 недель
2018,330 тыс. руб.,95 недель
2018,488 тыс. руб.,64 недель
2018,167 тыс. руб.,29 недель
2018,327 тыс. руб.,27 недель
2018,275 тыс. руб.,13 недель
2018,205 тыс. руб.,93 недель
2018,354 тыс. руб.,38 недель 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: 2015 
<Вывод>: 2015,497 тыс. руб.,82 недель
2015,391 тыс. руб.,81 недель
2015,488 тыс. руб.,72 недель
2015,188 тыс. руб.,72 недель
2015,320 тыс. руб.,57 недель
2015,251 тыс. руб.,36 недель
2015,488 тыс. руб.,96 недель
2015,379 тыс. руб.,14 недель
2015,305 тыс. руб.,90 недель
2015,284 тыс. руб.,33 недель
2015,180 тыс. руб.,15 недель
2015,328 тыс. руб.,50 недель
2015,355 тыс. руб.,84 недель
2015,426 тыс. руб.,63 недель
2015,294 тыс. руб.,15 недель
2015,327 тыс. руб.,72 недель
2015,452 тыс. руб.,71 недель
2015,240 тыс. руб.,88 недель 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: 2019 
<Вывод>: 2019,255 тыс. руб.,56 недель
2017,280 тыс. руб.,80 недель
2019,111 тыс. руб.,49 недель
2015,497 тыс. руб.,82 недель
2015,391 тыс. руб.,81 недель
2015,488 тыс. руб.,72 недель
2016,219 тыс. руб.,11 недель
2015,188 тыс. руб.,72 недель
2016,439 тыс. руб.,82 недель
2016,410 тыс. руб.,26 недель
2017,166 тыс. руб.,100 недель
2019,449 тыс. руб.,100 недель
2019,148 тыс. руб.,51 недель
2018,246 тыс. руб.,59 недель
2018,307 тыс. руб.,20 недель
2019,113 тыс. руб.,41 недель
2017,278 тыс. руб.,40 недель
2015,320 тыс. руб.,57 недель
2016,195 тыс. руб.,37 недель
2019,330 тыс. руб.,69 недель
2015,251 тыс. руб.,36 недель
2015,488 тыс. руб.,96 недель
2017,215 тыс. руб.,22 недель
2017,151 тыс. руб.,93 недель
2016,470 тыс. руб.,84 недель
2018,376 тыс. руб.,53 недель
2018,488 тыс. руб.,13 недель
2017,164 тыс. руб.,15 недель
2016,226 тыс. руб.,51 недель
2015,379 тыс. руб.,14 недель
2015,305 тыс. руб.,90 недель
2015,284 тыс. руб.,33 недель
2016,158 тыс. руб.,55 недель
2016,257 тыс. руб.,14 недель
2015,180 тыс. руб.,15 недель
2017,262 тыс. руб.,73 недель
2019,245 тыс. руб.,99 недель
2015,328 тыс. руб.,50 недель
2015,355 тыс. руб.,84 недель
2016,358 тыс. руб.,70 недель
2017,463 тыс. руб.,33 недель
2015,426 тыс. руб.,63 недель
2016,153 тыс. руб.,19 недель
2015,294 тыс. руб.,15 недель
2016,190 тыс. руб.,61 недель
2019,256 тыс. руб.,16 недель
2015,327 тыс. руб.,72 недель
2017,499 тыс. руб.,41 недель
2015,452 тыс. руб.,71 недель
2018,142 тыс. руб.,57 недель
2019,452 тыс. руб.,100 недель
2015,240 тыс. руб.,88 недель
2017,141 тыс. руб.,72 недель
2018,215 тыс. руб.,40 недель
2019,177 тыс. руб.,75 недель
2019,115 тыс. руб.,15 недель
2017,148 тыс. руб.,95 недель
2019,125 тыс. руб.,24 недель
2019,434 тыс. руб.,88 недель
2016,348 тыс. руб.,83 недель
2017,127 тыс. руб.,68 недель
2018,145 тыс. руб.,41 недель 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: 1990 
<Вывод>: nan 
<Решение студента>: year = input()

with open('projects_file.csv', 'r', encoding='utf-8') as my_file:
    for line in my_file
        line = line.strip()
        info = line.split(',')
        if info[0] <= year and int(info[-2].split()[0]) <= 500:
            print(line) 
<Идеальное решение>: year = input()

with open('projects_file.csv', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        info = line.split(',')
        if info[0] <= year and int(info[-2].split()[0]) <= 500:
            print(line) 


<Комментарий эксперта>:"
67,110,7,"Ксения анализирует реализованные дизайн-проекты, которые собраны в файле формата csv. Напишите программу, которая выводит все строки, соответствующие реализованным в определенный период проектам, стоимость которых была не более 500 тыс. руб..

Программа должна открывать структурированный текстовый файл projects_file.csv, в кодировке utf-8, где на каждой строке записана следующая информация о дизайн-проекте: год, стоимость проекта, количество недель, за сколько был реализован проект. Например, строка ""2019,200 тыс. руб.,10 недель"" означает, что в 2019 году проект стоимостью 200 тыс. руб. был реализован за 10 недель.
Гарантируется, что стоимость реализованного проекта всегда записана в формате ""<целое число> тыс. руб."".
Гарантируется, что срок реализации проекта всегда записан в формате ""<целое число> недель"".
Разделителями данных в файле служат запятые.
Гарантируется, что в файле есть как минимум одна строка с данными. 
С клавиатуры вводится строка — год.
Программа должна выводить строки из оригинального файла, которые соответствуют проектам, реализованным не позднее, чем в указанном году, со стоимостью не более 500. тыс. руб. (не забудьте удалить символы конца строки!).
Если подходящих под условие строк в файле нет, то программа ничего не выводит.
ДОПОЛНИТЕЛЬНО
Ваше решение будет проверяться на закрытых тестах. Ваш код должен считывать файл projects_file.csv без дополнительных указаний (например, пути к файлу на вашем компьютере).
В открытом тесте используется файл projects_file.csv. Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.","['2019', '2018', '2015', '2019', '1990']","['2018,253 тыс. руб.,45 недель\n2018,340 тыс. руб.,34 недель\n2019,263 тыс. руб.,90 недель\n2019,320 тыс. руб.,31 недель\n2019,478 тыс. руб.,85 недель\n2018,324 тыс. руб.,18 недель\n2019,186 тыс. руб.,82 недель\n2018,349 тыс. руб.,95 недель\n2019,479 тыс. руб.,31 недель\n2019,192 тыс. руб.,36 недель\n2018,393 тыс. руб.,90 недель\n2019,206 тыс. руб.,70 недель\n2019,185 тыс. руб.,27 недель\n2019,396 тыс. руб.,36 недель\n2018,445 тыс. руб.,6 недель\n2019,492 тыс. руб.,77 недель\n2018,267 тыс. руб.,38 недель\n2018,260 тыс. руб.,79 недель\n2018,214 тыс. руб.,47 недель\n2018,151 тыс. руб.,70 недель\n2019,116 тыс. руб.,25 недель\n2019,178 тыс. руб.,9 недель\n2019,100 тыс. руб.,24 недель\n2019,112 тыс. руб.,91 недель\n2019,369 тыс. руб.,24 недель\n2019,166 тыс. руб.,67 недель\n2019,498 тыс. руб.,83 недель\n2018,276 тыс. руб.,48 недель\n2019,493 тыс. руб.,20 недель\n2019,358 тыс. руб.,27 недель\n2019,394 тыс. руб.,49 недель\n2019,429 тыс. руб.,77 недель\n2019,375 тыс. руб.,44 недель\n2019,245 тыс. руб.,74 недель\n2018,313 тыс. руб.,5 недель\n2018,244 тыс. руб.,26 недель\n2018,432 тыс. руб.,87 недель\n2019,291 тыс. руб.,96 недель\n2018,355 тыс. руб.,100 недель\n2019,377 тыс. руб.,39 недель', '2018,240 тыс. руб.,86 недель\n2018,491 тыс. руб.,75 недель\n2018,310 тыс. руб.,29 недель\n2018,111 тыс. руб.,60 недель\n2018,252 тыс. руб.,81 недель\n2018,448 тыс. руб.,55 недель\n2018,397 тыс. руб.,73 недель\n2018,472 тыс. руб.,74 недель\n2018,357 тыс. руб.,17 недель\n2018,364 тыс. руб.,82 недель\n2018,187 тыс. руб.,89 недель\n2018,267 тыс. руб.,57 недель\n2018,254 тыс. руб.,18 недель\n2018,330 тыс. руб.,95 недель\n2018,488 тыс. руб.,64 недель\n2018,167 тыс. руб.,29 недель\n2018,327 тыс. руб.,27 недель\n2018,275 тыс. руб.,13 недель\n2018,205 тыс. руб.,93 недель\n2018,354 тыс. руб.,38 недель', '2015,497 тыс. руб.,82 недель\n2015,391 тыс. руб.,81 недель\n2015,488 тыс. руб.,72 недель\n2015,188 тыс. руб.,72 недель\n2015,320 тыс. руб.,57 недель\n2015,251 тыс. руб.,36 недель\n2015,488 тыс. руб.,96 недель\n2015,379 тыс. руб.,14 недель\n2015,305 тыс. руб.,90 недель\n2015,284 тыс. руб.,33 недель\n2015,180 тыс. руб.,15 недель\n2015,328 тыс. руб.,50 недель\n2015,355 тыс. руб.,84 недель\n2015,426 тыс. руб.,63 недель\n2015,294 тыс. руб.,15 недель\n2015,327 тыс. руб.,72 недель\n2015,452 тыс. руб.,71 недель\n2015,240 тыс. руб.,88 недель', '2019,255 тыс. руб.,56 недель\n2017,280 тыс. руб.,80 недель\n2019,111 тыс. руб.,49 недель\n2015,497 тыс. руб.,82 недель\n2015,391 тыс. руб.,81 недель\n2015,488 тыс. руб.,72 недель\n2016,219 тыс. руб.,11 недель\n2015,188 тыс. руб.,72 недель\n2016,439 тыс. руб.,82 недель\n2016,410 тыс. руб.,26 недель\n2017,166 тыс. руб.,100 недель\n2019,449 тыс. руб.,100 недель\n2019,148 тыс. руб.,51 недель\n2018,246 тыс. руб.,59 недель\n2018,307 тыс. руб.,20 недель\n2019,113 тыс. руб.,41 недель\n2017,278 тыс. руб.,40 недель\n2015,320 тыс. руб.,57 недель\n2016,195 тыс. руб.,37 недель\n2019,330 тыс. руб.,69 недель\n2015,251 тыс. руб.,36 недель\n2015,488 тыс. руб.,96 недель\n2017,215 тыс. руб.,22 недель\n2017,151 тыс. руб.,93 недель\n2016,470 тыс. руб.,84 недель\n2018,376 тыс. руб.,53 недель\n2018,488 тыс. руб.,13 недель\n2017,164 тыс. руб.,15 недель\n2016,226 тыс. руб.,51 недель\n2015,379 тыс. руб.,14 недель\n2015,305 тыс. руб.,90 недель\n2015,284 тыс. руб.,33 недель\n2016,158 тыс. руб.,55 недель\n2016,257 тыс. руб.,14 недель\n2015,180 тыс. руб.,15 недель\n2017,262 тыс. руб.,73 недель\n2019,245 тыс. руб.,99 недель\n2015,328 тыс. руб.,50 недель\n2015,355 тыс. руб.,84 недель\n2016,358 тыс. руб.,70 недель\n2017,463 тыс. руб.,33 недель\n2015,426 тыс. руб.,63 недель\n2016,153 тыс. руб.,19 недель\n2015,294 тыс. руб.,15 недель\n2016,190 тыс. руб.,61 недель\n2019,256 тыс. руб.,16 недель\n2015,327 тыс. руб.,72 недель\n2017,499 тыс. руб.,41 недель\n2015,452 тыс. руб.,71 недель\n2018,142 тыс. руб.,57 недель\n2019,452 тыс. руб.,100 недель\n2015,240 тыс. руб.,88 недель\n2017,141 тыс. руб.,72 недель\n2018,215 тыс. руб.,40 недель\n2019,177 тыс. руб.,75 недель\n2019,115 тыс. руб.,15 недель\n2017,148 тыс. руб.,95 недель\n2019,125 тыс. руб.,24 недель\n2019,434 тыс. руб.,88 недель\n2016,348 тыс. руб.,83 недель\n2017,127 тыс. руб.,68 недель\n2018,145 тыс. руб.,41 недель', nan]","year = input()

with open('projects_file.csv', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        info = line.split(',')
        if info[0] <= year and int(info[-2].split()[0]) <= 500:
            print(line)","year = input()

with open('projects_file.csv', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        info = line.split(',')
        if info[0] <= year and int(info[-2].split()[0]) <= 500:
            print(line)","Ошибка в открытых и скрытых тестах. 

Ваш код некорректно выводит данные. Присутствуют дополнительные знаки переноса строки. Попробуйте изменить переменную line, чтобы скорректировать ошибку.","['open', 'closed', 'closed', 'closed', 'closed']","<Task description>: Ксения анализирует реализованные дизайн-проекты, которые собраны в файле формата csv. Напишите программу, которая выводит все строки, соответствующие реализованным в определенный период проектам, стоимость которых была не более 500 тыс. руб..

Программа должна открывать структурированный текстовый файл projects_file.csv, в кодировке utf-8, где на каждой строке записана следующая информация о дизайн-проекте: год, стоимость проекта, количество недель, за сколько был реализован проект. Например, строка ""2019,200 тыс. руб.,10 недель"" означает, что в 2019 году проект стоимостью 200 тыс. руб. был реализован за 10 недель.
Гарантируется, что стоимость реализованного проекта всегда записана в формате ""<целое число> тыс. руб."".
Гарантируется, что срок реализации проекта всегда записан в формате ""<целое число> недель"".
Разделителями данных в файле служат запятые.
Гарантируется, что в файле есть как минимум одна строка с данными. 
С клавиатуры вводится строка — год.
Программа должна выводить строки из оригинального файла, которые соответствуют проектам, реализованным не позднее, чем в указанном году, со стоимостью не более 500. тыс. руб. (не забудьте удалить символы конца строки!).
Если подходящих под условие строк в файле нет, то программа ничего не выводит.
ДОПОЛНИТЕЛЬНО
Ваше решение будет проверяться на закрытых тестах. Ваш код должен считывать файл projects_file.csv без дополнительных указаний (например, пути к файлу на вашем компьютере).
В открытом тесте используется файл projects_file.csv. Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: 2019 
<Вывод>: 2018,253 тыс. руб.,45 недель
2018,340 тыс. руб.,34 недель
2019,263 тыс. руб.,90 недель
2019,320 тыс. руб.,31 недель
2019,478 тыс. руб.,85 недель
2018,324 тыс. руб.,18 недель
2019,186 тыс. руб.,82 недель
2018,349 тыс. руб.,95 недель
2019,479 тыс. руб.,31 недель
2019,192 тыс. руб.,36 недель
2018,393 тыс. руб.,90 недель
2019,206 тыс. руб.,70 недель
2019,185 тыс. руб.,27 недель
2019,396 тыс. руб.,36 недель
2018,445 тыс. руб.,6 недель
2019,492 тыс. руб.,77 недель
2018,267 тыс. руб.,38 недель
2018,260 тыс. руб.,79 недель
2018,214 тыс. руб.,47 недель
2018,151 тыс. руб.,70 недель
2019,116 тыс. руб.,25 недель
2019,178 тыс. руб.,9 недель
2019,100 тыс. руб.,24 недель
2019,112 тыс. руб.,91 недель
2019,369 тыс. руб.,24 недель
2019,166 тыс. руб.,67 недель
2019,498 тыс. руб.,83 недель
2018,276 тыс. руб.,48 недель
2019,493 тыс. руб.,20 недель
2019,358 тыс. руб.,27 недель
2019,394 тыс. руб.,49 недель
2019,429 тыс. руб.,77 недель
2019,375 тыс. руб.,44 недель
2019,245 тыс. руб.,74 недель
2018,313 тыс. руб.,5 недель
2018,244 тыс. руб.,26 недель
2018,432 тыс. руб.,87 недель
2019,291 тыс. руб.,96 недель
2018,355 тыс. руб.,100 недель
2019,377 тыс. руб.,39 недель 
<Example 2>: 
<Тип теста 2>: closed 
<Ввод>: 2018 
<Вывод>: 2018,240 тыс. руб.,86 недель
2018,491 тыс. руб.,75 недель
2018,310 тыс. руб.,29 недель
2018,111 тыс. руб.,60 недель
2018,252 тыс. руб.,81 недель
2018,448 тыс. руб.,55 недель
2018,397 тыс. руб.,73 недель
2018,472 тыс. руб.,74 недель
2018,357 тыс. руб.,17 недель
2018,364 тыс. руб.,82 недель
2018,187 тыс. руб.,89 недель
2018,267 тыс. руб.,57 недель
2018,254 тыс. руб.,18 недель
2018,330 тыс. руб.,95 недель
2018,488 тыс. руб.,64 недель
2018,167 тыс. руб.,29 недель
2018,327 тыс. руб.,27 недель
2018,275 тыс. руб.,13 недель
2018,205 тыс. руб.,93 недель
2018,354 тыс. руб.,38 недель 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: 2015 
<Вывод>: 2015,497 тыс. руб.,82 недель
2015,391 тыс. руб.,81 недель
2015,488 тыс. руб.,72 недель
2015,188 тыс. руб.,72 недель
2015,320 тыс. руб.,57 недель
2015,251 тыс. руб.,36 недель
2015,488 тыс. руб.,96 недель
2015,379 тыс. руб.,14 недель
2015,305 тыс. руб.,90 недель
2015,284 тыс. руб.,33 недель
2015,180 тыс. руб.,15 недель
2015,328 тыс. руб.,50 недель
2015,355 тыс. руб.,84 недель
2015,426 тыс. руб.,63 недель
2015,294 тыс. руб.,15 недель
2015,327 тыс. руб.,72 недель
2015,452 тыс. руб.,71 недель
2015,240 тыс. руб.,88 недель 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: 2019 
<Вывод>: 2019,255 тыс. руб.,56 недель
2017,280 тыс. руб.,80 недель
2019,111 тыс. руб.,49 недель
2015,497 тыс. руб.,82 недель
2015,391 тыс. руб.,81 недель
2015,488 тыс. руб.,72 недель
2016,219 тыс. руб.,11 недель
2015,188 тыс. руб.,72 недель
2016,439 тыс. руб.,82 недель
2016,410 тыс. руб.,26 недель
2017,166 тыс. руб.,100 недель
2019,449 тыс. руб.,100 недель
2019,148 тыс. руб.,51 недель
2018,246 тыс. руб.,59 недель
2018,307 тыс. руб.,20 недель
2019,113 тыс. руб.,41 недель
2017,278 тыс. руб.,40 недель
2015,320 тыс. руб.,57 недель
2016,195 тыс. руб.,37 недель
2019,330 тыс. руб.,69 недель
2015,251 тыс. руб.,36 недель
2015,488 тыс. руб.,96 недель
2017,215 тыс. руб.,22 недель
2017,151 тыс. руб.,93 недель
2016,470 тыс. руб.,84 недель
2018,376 тыс. руб.,53 недель
2018,488 тыс. руб.,13 недель
2017,164 тыс. руб.,15 недель
2016,226 тыс. руб.,51 недель
2015,379 тыс. руб.,14 недель
2015,305 тыс. руб.,90 недель
2015,284 тыс. руб.,33 недель
2016,158 тыс. руб.,55 недель
2016,257 тыс. руб.,14 недель
2015,180 тыс. руб.,15 недель
2017,262 тыс. руб.,73 недель
2019,245 тыс. руб.,99 недель
2015,328 тыс. руб.,50 недель
2015,355 тыс. руб.,84 недель
2016,358 тыс. руб.,70 недель
2017,463 тыс. руб.,33 недель
2015,426 тыс. руб.,63 недель
2016,153 тыс. руб.,19 недель
2015,294 тыс. руб.,15 недель
2016,190 тыс. руб.,61 недель
2019,256 тыс. руб.,16 недель
2015,327 тыс. руб.,72 недель
2017,499 тыс. руб.,41 недель
2015,452 тыс. руб.,71 недель
2018,142 тыс. руб.,57 недель
2019,452 тыс. руб.,100 недель
2015,240 тыс. руб.,88 недель
2017,141 тыс. руб.,72 недель
2018,215 тыс. руб.,40 недель
2019,177 тыс. руб.,75 недель
2019,115 тыс. руб.,15 недель
2017,148 тыс. руб.,95 недель
2019,125 тыс. руб.,24 недель
2019,434 тыс. руб.,88 недель
2016,348 тыс. руб.,83 недель
2017,127 тыс. руб.,68 недель
2018,145 тыс. руб.,41 недель 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: 1990 
<Вывод>: nan 
<Решение студента>: year = input()

with open('projects_file.csv', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        info = line.split(',')
        if info[0] <= year and int(info[-2].split()[0]) <= 500:
            print(line) 
<Идеальное решение>: year = input()

with open('projects_file.csv', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        info = line.split(',')
        if info[0] <= year and int(info[-2].split()[0]) <= 500:
            print(line) 


<Комментарий эксперта>:"
68,111,7,"Ксения анализирует реализованные дизайн-проекты, которые собраны в файле формата csv. Напишите программу, которая выводит все строки, соответствующие реализованным в определенный период проектам, стоимость которых была не более 500 тыс. руб..

Программа должна открывать структурированный текстовый файл projects_file.csv, в кодировке utf-8, где на каждой строке записана следующая информация о дизайн-проекте: год, стоимость проекта, количество недель, за сколько был реализован проект. Например, строка ""2019,200 тыс. руб.,10 недель"" означает, что в 2019 году проект стоимостью 200 тыс. руб. был реализован за 10 недель.
Гарантируется, что стоимость реализованного проекта всегда записана в формате ""<целое число> тыс. руб."".
Гарантируется, что срок реализации проекта всегда записан в формате ""<целое число> недель"".
Разделителями данных в файле служат запятые.
Гарантируется, что в файле есть как минимум одна строка с данными. 
С клавиатуры вводится строка — год.
Программа должна выводить строки из оригинального файла, которые соответствуют проектам, реализованным не позднее, чем в указанном году, со стоимостью не более 500. тыс. руб. (не забудьте удалить символы конца строки!).
Если подходящих под условие строк в файле нет, то программа ничего не выводит.
ДОПОЛНИТЕЛЬНО
Ваше решение будет проверяться на закрытых тестах. Ваш код должен считывать файл projects_file.csv без дополнительных указаний (например, пути к файлу на вашем компьютере).
В открытом тесте используется файл projects_file.csv. Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.","['2019', '2018', '2015', '2019', '1990']","['2018,253 тыс. руб.,45 недель\n2018,340 тыс. руб.,34 недель\n2019,263 тыс. руб.,90 недель\n2019,320 тыс. руб.,31 недель\n2019,478 тыс. руб.,85 недель\n2018,324 тыс. руб.,18 недель\n2019,186 тыс. руб.,82 недель\n2018,349 тыс. руб.,95 недель\n2019,479 тыс. руб.,31 недель\n2019,192 тыс. руб.,36 недель\n2018,393 тыс. руб.,90 недель\n2019,206 тыс. руб.,70 недель\n2019,185 тыс. руб.,27 недель\n2019,396 тыс. руб.,36 недель\n2018,445 тыс. руб.,6 недель\n2019,492 тыс. руб.,77 недель\n2018,267 тыс. руб.,38 недель\n2018,260 тыс. руб.,79 недель\n2018,214 тыс. руб.,47 недель\n2018,151 тыс. руб.,70 недель\n2019,116 тыс. руб.,25 недель\n2019,178 тыс. руб.,9 недель\n2019,100 тыс. руб.,24 недель\n2019,112 тыс. руб.,91 недель\n2019,369 тыс. руб.,24 недель\n2019,166 тыс. руб.,67 недель\n2019,498 тыс. руб.,83 недель\n2018,276 тыс. руб.,48 недель\n2019,493 тыс. руб.,20 недель\n2019,358 тыс. руб.,27 недель\n2019,394 тыс. руб.,49 недель\n2019,429 тыс. руб.,77 недель\n2019,375 тыс. руб.,44 недель\n2019,245 тыс. руб.,74 недель\n2018,313 тыс. руб.,5 недель\n2018,244 тыс. руб.,26 недель\n2018,432 тыс. руб.,87 недель\n2019,291 тыс. руб.,96 недель\n2018,355 тыс. руб.,100 недель\n2019,377 тыс. руб.,39 недель', '2018,240 тыс. руб.,86 недель\n2018,491 тыс. руб.,75 недель\n2018,310 тыс. руб.,29 недель\n2018,111 тыс. руб.,60 недель\n2018,252 тыс. руб.,81 недель\n2018,448 тыс. руб.,55 недель\n2018,397 тыс. руб.,73 недель\n2018,472 тыс. руб.,74 недель\n2018,357 тыс. руб.,17 недель\n2018,364 тыс. руб.,82 недель\n2018,187 тыс. руб.,89 недель\n2018,267 тыс. руб.,57 недель\n2018,254 тыс. руб.,18 недель\n2018,330 тыс. руб.,95 недель\n2018,488 тыс. руб.,64 недель\n2018,167 тыс. руб.,29 недель\n2018,327 тыс. руб.,27 недель\n2018,275 тыс. руб.,13 недель\n2018,205 тыс. руб.,93 недель\n2018,354 тыс. руб.,38 недель', '2015,497 тыс. руб.,82 недель\n2015,391 тыс. руб.,81 недель\n2015,488 тыс. руб.,72 недель\n2015,188 тыс. руб.,72 недель\n2015,320 тыс. руб.,57 недель\n2015,251 тыс. руб.,36 недель\n2015,488 тыс. руб.,96 недель\n2015,379 тыс. руб.,14 недель\n2015,305 тыс. руб.,90 недель\n2015,284 тыс. руб.,33 недель\n2015,180 тыс. руб.,15 недель\n2015,328 тыс. руб.,50 недель\n2015,355 тыс. руб.,84 недель\n2015,426 тыс. руб.,63 недель\n2015,294 тыс. руб.,15 недель\n2015,327 тыс. руб.,72 недель\n2015,452 тыс. руб.,71 недель\n2015,240 тыс. руб.,88 недель', '2019,255 тыс. руб.,56 недель\n2017,280 тыс. руб.,80 недель\n2019,111 тыс. руб.,49 недель\n2015,497 тыс. руб.,82 недель\n2015,391 тыс. руб.,81 недель\n2015,488 тыс. руб.,72 недель\n2016,219 тыс. руб.,11 недель\n2015,188 тыс. руб.,72 недель\n2016,439 тыс. руб.,82 недель\n2016,410 тыс. руб.,26 недель\n2017,166 тыс. руб.,100 недель\n2019,449 тыс. руб.,100 недель\n2019,148 тыс. руб.,51 недель\n2018,246 тыс. руб.,59 недель\n2018,307 тыс. руб.,20 недель\n2019,113 тыс. руб.,41 недель\n2017,278 тыс. руб.,40 недель\n2015,320 тыс. руб.,57 недель\n2016,195 тыс. руб.,37 недель\n2019,330 тыс. руб.,69 недель\n2015,251 тыс. руб.,36 недель\n2015,488 тыс. руб.,96 недель\n2017,215 тыс. руб.,22 недель\n2017,151 тыс. руб.,93 недель\n2016,470 тыс. руб.,84 недель\n2018,376 тыс. руб.,53 недель\n2018,488 тыс. руб.,13 недель\n2017,164 тыс. руб.,15 недель\n2016,226 тыс. руб.,51 недель\n2015,379 тыс. руб.,14 недель\n2015,305 тыс. руб.,90 недель\n2015,284 тыс. руб.,33 недель\n2016,158 тыс. руб.,55 недель\n2016,257 тыс. руб.,14 недель\n2015,180 тыс. руб.,15 недель\n2017,262 тыс. руб.,73 недель\n2019,245 тыс. руб.,99 недель\n2015,328 тыс. руб.,50 недель\n2015,355 тыс. руб.,84 недель\n2016,358 тыс. руб.,70 недель\n2017,463 тыс. руб.,33 недель\n2015,426 тыс. руб.,63 недель\n2016,153 тыс. руб.,19 недель\n2015,294 тыс. руб.,15 недель\n2016,190 тыс. руб.,61 недель\n2019,256 тыс. руб.,16 недель\n2015,327 тыс. руб.,72 недель\n2017,499 тыс. руб.,41 недель\n2015,452 тыс. руб.,71 недель\n2018,142 тыс. руб.,57 недель\n2019,452 тыс. руб.,100 недель\n2015,240 тыс. руб.,88 недель\n2017,141 тыс. руб.,72 недель\n2018,215 тыс. руб.,40 недель\n2019,177 тыс. руб.,75 недель\n2019,115 тыс. руб.,15 недель\n2017,148 тыс. руб.,95 недель\n2019,125 тыс. руб.,24 недель\n2019,434 тыс. руб.,88 недель\n2016,348 тыс. руб.,83 недель\n2017,127 тыс. руб.,68 недель\n2018,145 тыс. руб.,41 недель', nan]","year = input()

with open('projects_file.csv', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        info = line.split(', ')
        if info[0] <= year and int(info[-2].split()[0]) <= 500:
            print(line)","year = input()

with open('projects_file.csv', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        info = line.split(',')
        if info[0] <= year and int(info[-2].split()[0]) <= 500:
            print(line)",Ошибка при использовании метода split(). Функция получила некорректный параметр для разделения элементов строки. ,"['open', 'closed', 'closed', 'closed', 'closed']","<Task description>: Ксения анализирует реализованные дизайн-проекты, которые собраны в файле формата csv. Напишите программу, которая выводит все строки, соответствующие реализованным в определенный период проектам, стоимость которых была не более 500 тыс. руб..

Программа должна открывать структурированный текстовый файл projects_file.csv, в кодировке utf-8, где на каждой строке записана следующая информация о дизайн-проекте: год, стоимость проекта, количество недель, за сколько был реализован проект. Например, строка ""2019,200 тыс. руб.,10 недель"" означает, что в 2019 году проект стоимостью 200 тыс. руб. был реализован за 10 недель.
Гарантируется, что стоимость реализованного проекта всегда записана в формате ""<целое число> тыс. руб."".
Гарантируется, что срок реализации проекта всегда записан в формате ""<целое число> недель"".
Разделителями данных в файле служат запятые.
Гарантируется, что в файле есть как минимум одна строка с данными. 
С клавиатуры вводится строка — год.
Программа должна выводить строки из оригинального файла, которые соответствуют проектам, реализованным не позднее, чем в указанном году, со стоимостью не более 500. тыс. руб. (не забудьте удалить символы конца строки!).
Если подходящих под условие строк в файле нет, то программа ничего не выводит.
ДОПОЛНИТЕЛЬНО
Ваше решение будет проверяться на закрытых тестах. Ваш код должен считывать файл projects_file.csv без дополнительных указаний (например, пути к файлу на вашем компьютере).
В открытом тесте используется файл projects_file.csv. Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: 2019 
<Вывод>: 2018,253 тыс. руб.,45 недель
2018,340 тыс. руб.,34 недель
2019,263 тыс. руб.,90 недель
2019,320 тыс. руб.,31 недель
2019,478 тыс. руб.,85 недель
2018,324 тыс. руб.,18 недель
2019,186 тыс. руб.,82 недель
2018,349 тыс. руб.,95 недель
2019,479 тыс. руб.,31 недель
2019,192 тыс. руб.,36 недель
2018,393 тыс. руб.,90 недель
2019,206 тыс. руб.,70 недель
2019,185 тыс. руб.,27 недель
2019,396 тыс. руб.,36 недель
2018,445 тыс. руб.,6 недель
2019,492 тыс. руб.,77 недель
2018,267 тыс. руб.,38 недель
2018,260 тыс. руб.,79 недель
2018,214 тыс. руб.,47 недель
2018,151 тыс. руб.,70 недель
2019,116 тыс. руб.,25 недель
2019,178 тыс. руб.,9 недель
2019,100 тыс. руб.,24 недель
2019,112 тыс. руб.,91 недель
2019,369 тыс. руб.,24 недель
2019,166 тыс. руб.,67 недель
2019,498 тыс. руб.,83 недель
2018,276 тыс. руб.,48 недель
2019,493 тыс. руб.,20 недель
2019,358 тыс. руб.,27 недель
2019,394 тыс. руб.,49 недель
2019,429 тыс. руб.,77 недель
2019,375 тыс. руб.,44 недель
2019,245 тыс. руб.,74 недель
2018,313 тыс. руб.,5 недель
2018,244 тыс. руб.,26 недель
2018,432 тыс. руб.,87 недель
2019,291 тыс. руб.,96 недель
2018,355 тыс. руб.,100 недель
2019,377 тыс. руб.,39 недель 
<Example 2>: 
<Тип теста 2>: closed 
<Ввод>: 2018 
<Вывод>: 2018,240 тыс. руб.,86 недель
2018,491 тыс. руб.,75 недель
2018,310 тыс. руб.,29 недель
2018,111 тыс. руб.,60 недель
2018,252 тыс. руб.,81 недель
2018,448 тыс. руб.,55 недель
2018,397 тыс. руб.,73 недель
2018,472 тыс. руб.,74 недель
2018,357 тыс. руб.,17 недель
2018,364 тыс. руб.,82 недель
2018,187 тыс. руб.,89 недель
2018,267 тыс. руб.,57 недель
2018,254 тыс. руб.,18 недель
2018,330 тыс. руб.,95 недель
2018,488 тыс. руб.,64 недель
2018,167 тыс. руб.,29 недель
2018,327 тыс. руб.,27 недель
2018,275 тыс. руб.,13 недель
2018,205 тыс. руб.,93 недель
2018,354 тыс. руб.,38 недель 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: 2015 
<Вывод>: 2015,497 тыс. руб.,82 недель
2015,391 тыс. руб.,81 недель
2015,488 тыс. руб.,72 недель
2015,188 тыс. руб.,72 недель
2015,320 тыс. руб.,57 недель
2015,251 тыс. руб.,36 недель
2015,488 тыс. руб.,96 недель
2015,379 тыс. руб.,14 недель
2015,305 тыс. руб.,90 недель
2015,284 тыс. руб.,33 недель
2015,180 тыс. руб.,15 недель
2015,328 тыс. руб.,50 недель
2015,355 тыс. руб.,84 недель
2015,426 тыс. руб.,63 недель
2015,294 тыс. руб.,15 недель
2015,327 тыс. руб.,72 недель
2015,452 тыс. руб.,71 недель
2015,240 тыс. руб.,88 недель 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: 2019 
<Вывод>: 2019,255 тыс. руб.,56 недель
2017,280 тыс. руб.,80 недель
2019,111 тыс. руб.,49 недель
2015,497 тыс. руб.,82 недель
2015,391 тыс. руб.,81 недель
2015,488 тыс. руб.,72 недель
2016,219 тыс. руб.,11 недель
2015,188 тыс. руб.,72 недель
2016,439 тыс. руб.,82 недель
2016,410 тыс. руб.,26 недель
2017,166 тыс. руб.,100 недель
2019,449 тыс. руб.,100 недель
2019,148 тыс. руб.,51 недель
2018,246 тыс. руб.,59 недель
2018,307 тыс. руб.,20 недель
2019,113 тыс. руб.,41 недель
2017,278 тыс. руб.,40 недель
2015,320 тыс. руб.,57 недель
2016,195 тыс. руб.,37 недель
2019,330 тыс. руб.,69 недель
2015,251 тыс. руб.,36 недель
2015,488 тыс. руб.,96 недель
2017,215 тыс. руб.,22 недель
2017,151 тыс. руб.,93 недель
2016,470 тыс. руб.,84 недель
2018,376 тыс. руб.,53 недель
2018,488 тыс. руб.,13 недель
2017,164 тыс. руб.,15 недель
2016,226 тыс. руб.,51 недель
2015,379 тыс. руб.,14 недель
2015,305 тыс. руб.,90 недель
2015,284 тыс. руб.,33 недель
2016,158 тыс. руб.,55 недель
2016,257 тыс. руб.,14 недель
2015,180 тыс. руб.,15 недель
2017,262 тыс. руб.,73 недель
2019,245 тыс. руб.,99 недель
2015,328 тыс. руб.,50 недель
2015,355 тыс. руб.,84 недель
2016,358 тыс. руб.,70 недель
2017,463 тыс. руб.,33 недель
2015,426 тыс. руб.,63 недель
2016,153 тыс. руб.,19 недель
2015,294 тыс. руб.,15 недель
2016,190 тыс. руб.,61 недель
2019,256 тыс. руб.,16 недель
2015,327 тыс. руб.,72 недель
2017,499 тыс. руб.,41 недель
2015,452 тыс. руб.,71 недель
2018,142 тыс. руб.,57 недель
2019,452 тыс. руб.,100 недель
2015,240 тыс. руб.,88 недель
2017,141 тыс. руб.,72 недель
2018,215 тыс. руб.,40 недель
2019,177 тыс. руб.,75 недель
2019,115 тыс. руб.,15 недель
2017,148 тыс. руб.,95 недель
2019,125 тыс. руб.,24 недель
2019,434 тыс. руб.,88 недель
2016,348 тыс. руб.,83 недель
2017,127 тыс. руб.,68 недель
2018,145 тыс. руб.,41 недель 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: 1990 
<Вывод>: nan 
<Решение студента>: year = input()

with open('projects_file.csv', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        info = line.split(', ')
        if info[0] <= year and int(info[-2].split()[0]) <= 500:
            print(line) 
<Идеальное решение>: year = input()

with open('projects_file.csv', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        info = line.split(',')
        if info[0] <= year and int(info[-2].split()[0]) <= 500:
            print(line) 


<Комментарий эксперта>:"
69,112,7,"Ксения анализирует реализованные дизайн-проекты, которые собраны в файле формата csv. Напишите программу, которая выводит все строки, соответствующие реализованным в определенный период проектам, стоимость которых была не более 500 тыс. руб..

Программа должна открывать структурированный текстовый файл projects_file.csv, в кодировке utf-8, где на каждой строке записана следующая информация о дизайн-проекте: год, стоимость проекта, количество недель, за сколько был реализован проект. Например, строка ""2019,200 тыс. руб.,10 недель"" означает, что в 2019 году проект стоимостью 200 тыс. руб. был реализован за 10 недель.
Гарантируется, что стоимость реализованного проекта всегда записана в формате ""<целое число> тыс. руб."".
Гарантируется, что срок реализации проекта всегда записан в формате ""<целое число> недель"".
Разделителями данных в файле служат запятые.
Гарантируется, что в файле есть как минимум одна строка с данными. 
С клавиатуры вводится строка — год.
Программа должна выводить строки из оригинального файла, которые соответствуют проектам, реализованным не позднее, чем в указанном году, со стоимостью не более 500. тыс. руб. (не забудьте удалить символы конца строки!).
Если подходящих под условие строк в файле нет, то программа ничего не выводит.
ДОПОЛНИТЕЛЬНО
Ваше решение будет проверяться на закрытых тестах. Ваш код должен считывать файл projects_file.csv без дополнительных указаний (например, пути к файлу на вашем компьютере).
В открытом тесте используется файл projects_file.csv. Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.","['2019', '2018', '2015', '2019', '1990']","['2018,253 тыс. руб.,45 недель\n2018,340 тыс. руб.,34 недель\n2019,263 тыс. руб.,90 недель\n2019,320 тыс. руб.,31 недель\n2019,478 тыс. руб.,85 недель\n2018,324 тыс. руб.,18 недель\n2019,186 тыс. руб.,82 недель\n2018,349 тыс. руб.,95 недель\n2019,479 тыс. руб.,31 недель\n2019,192 тыс. руб.,36 недель\n2018,393 тыс. руб.,90 недель\n2019,206 тыс. руб.,70 недель\n2019,185 тыс. руб.,27 недель\n2019,396 тыс. руб.,36 недель\n2018,445 тыс. руб.,6 недель\n2019,492 тыс. руб.,77 недель\n2018,267 тыс. руб.,38 недель\n2018,260 тыс. руб.,79 недель\n2018,214 тыс. руб.,47 недель\n2018,151 тыс. руб.,70 недель\n2019,116 тыс. руб.,25 недель\n2019,178 тыс. руб.,9 недель\n2019,100 тыс. руб.,24 недель\n2019,112 тыс. руб.,91 недель\n2019,369 тыс. руб.,24 недель\n2019,166 тыс. руб.,67 недель\n2019,498 тыс. руб.,83 недель\n2018,276 тыс. руб.,48 недель\n2019,493 тыс. руб.,20 недель\n2019,358 тыс. руб.,27 недель\n2019,394 тыс. руб.,49 недель\n2019,429 тыс. руб.,77 недель\n2019,375 тыс. руб.,44 недель\n2019,245 тыс. руб.,74 недель\n2018,313 тыс. руб.,5 недель\n2018,244 тыс. руб.,26 недель\n2018,432 тыс. руб.,87 недель\n2019,291 тыс. руб.,96 недель\n2018,355 тыс. руб.,100 недель\n2019,377 тыс. руб.,39 недель', '2018,240 тыс. руб.,86 недель\n2018,491 тыс. руб.,75 недель\n2018,310 тыс. руб.,29 недель\n2018,111 тыс. руб.,60 недель\n2018,252 тыс. руб.,81 недель\n2018,448 тыс. руб.,55 недель\n2018,397 тыс. руб.,73 недель\n2018,472 тыс. руб.,74 недель\n2018,357 тыс. руб.,17 недель\n2018,364 тыс. руб.,82 недель\n2018,187 тыс. руб.,89 недель\n2018,267 тыс. руб.,57 недель\n2018,254 тыс. руб.,18 недель\n2018,330 тыс. руб.,95 недель\n2018,488 тыс. руб.,64 недель\n2018,167 тыс. руб.,29 недель\n2018,327 тыс. руб.,27 недель\n2018,275 тыс. руб.,13 недель\n2018,205 тыс. руб.,93 недель\n2018,354 тыс. руб.,38 недель', '2015,497 тыс. руб.,82 недель\n2015,391 тыс. руб.,81 недель\n2015,488 тыс. руб.,72 недель\n2015,188 тыс. руб.,72 недель\n2015,320 тыс. руб.,57 недель\n2015,251 тыс. руб.,36 недель\n2015,488 тыс. руб.,96 недель\n2015,379 тыс. руб.,14 недель\n2015,305 тыс. руб.,90 недель\n2015,284 тыс. руб.,33 недель\n2015,180 тыс. руб.,15 недель\n2015,328 тыс. руб.,50 недель\n2015,355 тыс. руб.,84 недель\n2015,426 тыс. руб.,63 недель\n2015,294 тыс. руб.,15 недель\n2015,327 тыс. руб.,72 недель\n2015,452 тыс. руб.,71 недель\n2015,240 тыс. руб.,88 недель', '2019,255 тыс. руб.,56 недель\n2017,280 тыс. руб.,80 недель\n2019,111 тыс. руб.,49 недель\n2015,497 тыс. руб.,82 недель\n2015,391 тыс. руб.,81 недель\n2015,488 тыс. руб.,72 недель\n2016,219 тыс. руб.,11 недель\n2015,188 тыс. руб.,72 недель\n2016,439 тыс. руб.,82 недель\n2016,410 тыс. руб.,26 недель\n2017,166 тыс. руб.,100 недель\n2019,449 тыс. руб.,100 недель\n2019,148 тыс. руб.,51 недель\n2018,246 тыс. руб.,59 недель\n2018,307 тыс. руб.,20 недель\n2019,113 тыс. руб.,41 недель\n2017,278 тыс. руб.,40 недель\n2015,320 тыс. руб.,57 недель\n2016,195 тыс. руб.,37 недель\n2019,330 тыс. руб.,69 недель\n2015,251 тыс. руб.,36 недель\n2015,488 тыс. руб.,96 недель\n2017,215 тыс. руб.,22 недель\n2017,151 тыс. руб.,93 недель\n2016,470 тыс. руб.,84 недель\n2018,376 тыс. руб.,53 недель\n2018,488 тыс. руб.,13 недель\n2017,164 тыс. руб.,15 недель\n2016,226 тыс. руб.,51 недель\n2015,379 тыс. руб.,14 недель\n2015,305 тыс. руб.,90 недель\n2015,284 тыс. руб.,33 недель\n2016,158 тыс. руб.,55 недель\n2016,257 тыс. руб.,14 недель\n2015,180 тыс. руб.,15 недель\n2017,262 тыс. руб.,73 недель\n2019,245 тыс. руб.,99 недель\n2015,328 тыс. руб.,50 недель\n2015,355 тыс. руб.,84 недель\n2016,358 тыс. руб.,70 недель\n2017,463 тыс. руб.,33 недель\n2015,426 тыс. руб.,63 недель\n2016,153 тыс. руб.,19 недель\n2015,294 тыс. руб.,15 недель\n2016,190 тыс. руб.,61 недель\n2019,256 тыс. руб.,16 недель\n2015,327 тыс. руб.,72 недель\n2017,499 тыс. руб.,41 недель\n2015,452 тыс. руб.,71 недель\n2018,142 тыс. руб.,57 недель\n2019,452 тыс. руб.,100 недель\n2015,240 тыс. руб.,88 недель\n2017,141 тыс. руб.,72 недель\n2018,215 тыс. руб.,40 недель\n2019,177 тыс. руб.,75 недель\n2019,115 тыс. руб.,15 недель\n2017,148 тыс. руб.,95 недель\n2019,125 тыс. руб.,24 недель\n2019,434 тыс. руб.,88 недель\n2016,348 тыс. руб.,83 недель\n2017,127 тыс. руб.,68 недель\n2018,145 тыс. руб.,41 недель', nan]","year = input()

with open('projects_file.csv', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        info = line.split(',')
        if info[0] < year and int(info[-2].split()[0]) <= 500:
            print(line)","year = input()

with open('projects_file.csv', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        info = line.split(',')
        if info[0] <= year and int(info[-2].split()[0]) <= 500:
            print(line)","Ошибка в открытых и скрытых тестах. 

Ваш код некорректно выполняет условия задания. Так, он неправильно выполянет условие ""проекты, реализованные не позднее, чем в указанном году"". Попробуйте изменить условие if, чтобы скорректировать ошибку.","['open', 'closed', 'closed', 'closed', 'closed']","<Task description>: Ксения анализирует реализованные дизайн-проекты, которые собраны в файле формата csv. Напишите программу, которая выводит все строки, соответствующие реализованным в определенный период проектам, стоимость которых была не более 500 тыс. руб..

Программа должна открывать структурированный текстовый файл projects_file.csv, в кодировке utf-8, где на каждой строке записана следующая информация о дизайн-проекте: год, стоимость проекта, количество недель, за сколько был реализован проект. Например, строка ""2019,200 тыс. руб.,10 недель"" означает, что в 2019 году проект стоимостью 200 тыс. руб. был реализован за 10 недель.
Гарантируется, что стоимость реализованного проекта всегда записана в формате ""<целое число> тыс. руб."".
Гарантируется, что срок реализации проекта всегда записан в формате ""<целое число> недель"".
Разделителями данных в файле служат запятые.
Гарантируется, что в файле есть как минимум одна строка с данными. 
С клавиатуры вводится строка — год.
Программа должна выводить строки из оригинального файла, которые соответствуют проектам, реализованным не позднее, чем в указанном году, со стоимостью не более 500. тыс. руб. (не забудьте удалить символы конца строки!).
Если подходящих под условие строк в файле нет, то программа ничего не выводит.
ДОПОЛНИТЕЛЬНО
Ваше решение будет проверяться на закрытых тестах. Ваш код должен считывать файл projects_file.csv без дополнительных указаний (например, пути к файлу на вашем компьютере).
В открытом тесте используется файл projects_file.csv. Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: 2019 
<Вывод>: 2018,253 тыс. руб.,45 недель
2018,340 тыс. руб.,34 недель
2019,263 тыс. руб.,90 недель
2019,320 тыс. руб.,31 недель
2019,478 тыс. руб.,85 недель
2018,324 тыс. руб.,18 недель
2019,186 тыс. руб.,82 недель
2018,349 тыс. руб.,95 недель
2019,479 тыс. руб.,31 недель
2019,192 тыс. руб.,36 недель
2018,393 тыс. руб.,90 недель
2019,206 тыс. руб.,70 недель
2019,185 тыс. руб.,27 недель
2019,396 тыс. руб.,36 недель
2018,445 тыс. руб.,6 недель
2019,492 тыс. руб.,77 недель
2018,267 тыс. руб.,38 недель
2018,260 тыс. руб.,79 недель
2018,214 тыс. руб.,47 недель
2018,151 тыс. руб.,70 недель
2019,116 тыс. руб.,25 недель
2019,178 тыс. руб.,9 недель
2019,100 тыс. руб.,24 недель
2019,112 тыс. руб.,91 недель
2019,369 тыс. руб.,24 недель
2019,166 тыс. руб.,67 недель
2019,498 тыс. руб.,83 недель
2018,276 тыс. руб.,48 недель
2019,493 тыс. руб.,20 недель
2019,358 тыс. руб.,27 недель
2019,394 тыс. руб.,49 недель
2019,429 тыс. руб.,77 недель
2019,375 тыс. руб.,44 недель
2019,245 тыс. руб.,74 недель
2018,313 тыс. руб.,5 недель
2018,244 тыс. руб.,26 недель
2018,432 тыс. руб.,87 недель
2019,291 тыс. руб.,96 недель
2018,355 тыс. руб.,100 недель
2019,377 тыс. руб.,39 недель 
<Example 2>: 
<Тип теста 2>: closed 
<Ввод>: 2018 
<Вывод>: 2018,240 тыс. руб.,86 недель
2018,491 тыс. руб.,75 недель
2018,310 тыс. руб.,29 недель
2018,111 тыс. руб.,60 недель
2018,252 тыс. руб.,81 недель
2018,448 тыс. руб.,55 недель
2018,397 тыс. руб.,73 недель
2018,472 тыс. руб.,74 недель
2018,357 тыс. руб.,17 недель
2018,364 тыс. руб.,82 недель
2018,187 тыс. руб.,89 недель
2018,267 тыс. руб.,57 недель
2018,254 тыс. руб.,18 недель
2018,330 тыс. руб.,95 недель
2018,488 тыс. руб.,64 недель
2018,167 тыс. руб.,29 недель
2018,327 тыс. руб.,27 недель
2018,275 тыс. руб.,13 недель
2018,205 тыс. руб.,93 недель
2018,354 тыс. руб.,38 недель 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: 2015 
<Вывод>: 2015,497 тыс. руб.,82 недель
2015,391 тыс. руб.,81 недель
2015,488 тыс. руб.,72 недель
2015,188 тыс. руб.,72 недель
2015,320 тыс. руб.,57 недель
2015,251 тыс. руб.,36 недель
2015,488 тыс. руб.,96 недель
2015,379 тыс. руб.,14 недель
2015,305 тыс. руб.,90 недель
2015,284 тыс. руб.,33 недель
2015,180 тыс. руб.,15 недель
2015,328 тыс. руб.,50 недель
2015,355 тыс. руб.,84 недель
2015,426 тыс. руб.,63 недель
2015,294 тыс. руб.,15 недель
2015,327 тыс. руб.,72 недель
2015,452 тыс. руб.,71 недель
2015,240 тыс. руб.,88 недель 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: 2019 
<Вывод>: 2019,255 тыс. руб.,56 недель
2017,280 тыс. руб.,80 недель
2019,111 тыс. руб.,49 недель
2015,497 тыс. руб.,82 недель
2015,391 тыс. руб.,81 недель
2015,488 тыс. руб.,72 недель
2016,219 тыс. руб.,11 недель
2015,188 тыс. руб.,72 недель
2016,439 тыс. руб.,82 недель
2016,410 тыс. руб.,26 недель
2017,166 тыс. руб.,100 недель
2019,449 тыс. руб.,100 недель
2019,148 тыс. руб.,51 недель
2018,246 тыс. руб.,59 недель
2018,307 тыс. руб.,20 недель
2019,113 тыс. руб.,41 недель
2017,278 тыс. руб.,40 недель
2015,320 тыс. руб.,57 недель
2016,195 тыс. руб.,37 недель
2019,330 тыс. руб.,69 недель
2015,251 тыс. руб.,36 недель
2015,488 тыс. руб.,96 недель
2017,215 тыс. руб.,22 недель
2017,151 тыс. руб.,93 недель
2016,470 тыс. руб.,84 недель
2018,376 тыс. руб.,53 недель
2018,488 тыс. руб.,13 недель
2017,164 тыс. руб.,15 недель
2016,226 тыс. руб.,51 недель
2015,379 тыс. руб.,14 недель
2015,305 тыс. руб.,90 недель
2015,284 тыс. руб.,33 недель
2016,158 тыс. руб.,55 недель
2016,257 тыс. руб.,14 недель
2015,180 тыс. руб.,15 недель
2017,262 тыс. руб.,73 недель
2019,245 тыс. руб.,99 недель
2015,328 тыс. руб.,50 недель
2015,355 тыс. руб.,84 недель
2016,358 тыс. руб.,70 недель
2017,463 тыс. руб.,33 недель
2015,426 тыс. руб.,63 недель
2016,153 тыс. руб.,19 недель
2015,294 тыс. руб.,15 недель
2016,190 тыс. руб.,61 недель
2019,256 тыс. руб.,16 недель
2015,327 тыс. руб.,72 недель
2017,499 тыс. руб.,41 недель
2015,452 тыс. руб.,71 недель
2018,142 тыс. руб.,57 недель
2019,452 тыс. руб.,100 недель
2015,240 тыс. руб.,88 недель
2017,141 тыс. руб.,72 недель
2018,215 тыс. руб.,40 недель
2019,177 тыс. руб.,75 недель
2019,115 тыс. руб.,15 недель
2017,148 тыс. руб.,95 недель
2019,125 тыс. руб.,24 недель
2019,434 тыс. руб.,88 недель
2016,348 тыс. руб.,83 недель
2017,127 тыс. руб.,68 недель
2018,145 тыс. руб.,41 недель 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: 1990 
<Вывод>: nan 
<Решение студента>: year = input()

with open('projects_file.csv', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        info = line.split(',')
        if info[0] < year and int(info[-2].split()[0]) <= 500:
            print(line) 
<Идеальное решение>: year = input()

with open('projects_file.csv', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        info = line.split(',')
        if info[0] <= year and int(info[-2].split()[0]) <= 500:
            print(line) 


<Комментарий эксперта>:"
70,113,7,"Ксения анализирует реализованные дизайн-проекты, которые собраны в файле формата csv. Напишите программу, которая выводит все строки, соответствующие реализованным в определенный период проектам, стоимость которых была не более 500 тыс. руб..

Программа должна открывать структурированный текстовый файл projects_file.csv, в кодировке utf-8, где на каждой строке записана следующая информация о дизайн-проекте: год, стоимость проекта, количество недель, за сколько был реализован проект. Например, строка ""2019,200 тыс. руб.,10 недель"" означает, что в 2019 году проект стоимостью 200 тыс. руб. был реализован за 10 недель.
Гарантируется, что стоимость реализованного проекта всегда записана в формате ""<целое число> тыс. руб."".
Гарантируется, что срок реализации проекта всегда записан в формате ""<целое число> недель"".
Разделителями данных в файле служат запятые.
Гарантируется, что в файле есть как минимум одна строка с данными. 
С клавиатуры вводится строка — год.
Программа должна выводить строки из оригинального файла, которые соответствуют проектам, реализованным не позднее, чем в указанном году, со стоимостью не более 500. тыс. руб. (не забудьте удалить символы конца строки!).
Если подходящих под условие строк в файле нет, то программа ничего не выводит.
ДОПОЛНИТЕЛЬНО
Ваше решение будет проверяться на закрытых тестах. Ваш код должен считывать файл projects_file.csv без дополнительных указаний (например, пути к файлу на вашем компьютере).
В открытом тесте используется файл projects_file.csv. Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.","['2019', '2018', '2015', '2019', '1990']","['2018,253 тыс. руб.,45 недель\n2018,340 тыс. руб.,34 недель\n2019,263 тыс. руб.,90 недель\n2019,320 тыс. руб.,31 недель\n2019,478 тыс. руб.,85 недель\n2018,324 тыс. руб.,18 недель\n2019,186 тыс. руб.,82 недель\n2018,349 тыс. руб.,95 недель\n2019,479 тыс. руб.,31 недель\n2019,192 тыс. руб.,36 недель\n2018,393 тыс. руб.,90 недель\n2019,206 тыс. руб.,70 недель\n2019,185 тыс. руб.,27 недель\n2019,396 тыс. руб.,36 недель\n2018,445 тыс. руб.,6 недель\n2019,492 тыс. руб.,77 недель\n2018,267 тыс. руб.,38 недель\n2018,260 тыс. руб.,79 недель\n2018,214 тыс. руб.,47 недель\n2018,151 тыс. руб.,70 недель\n2019,116 тыс. руб.,25 недель\n2019,178 тыс. руб.,9 недель\n2019,100 тыс. руб.,24 недель\n2019,112 тыс. руб.,91 недель\n2019,369 тыс. руб.,24 недель\n2019,166 тыс. руб.,67 недель\n2019,498 тыс. руб.,83 недель\n2018,276 тыс. руб.,48 недель\n2019,493 тыс. руб.,20 недель\n2019,358 тыс. руб.,27 недель\n2019,394 тыс. руб.,49 недель\n2019,429 тыс. руб.,77 недель\n2019,375 тыс. руб.,44 недель\n2019,245 тыс. руб.,74 недель\n2018,313 тыс. руб.,5 недель\n2018,244 тыс. руб.,26 недель\n2018,432 тыс. руб.,87 недель\n2019,291 тыс. руб.,96 недель\n2018,355 тыс. руб.,100 недель\n2019,377 тыс. руб.,39 недель', '2018,240 тыс. руб.,86 недель\n2018,491 тыс. руб.,75 недель\n2018,310 тыс. руб.,29 недель\n2018,111 тыс. руб.,60 недель\n2018,252 тыс. руб.,81 недель\n2018,448 тыс. руб.,55 недель\n2018,397 тыс. руб.,73 недель\n2018,472 тыс. руб.,74 недель\n2018,357 тыс. руб.,17 недель\n2018,364 тыс. руб.,82 недель\n2018,187 тыс. руб.,89 недель\n2018,267 тыс. руб.,57 недель\n2018,254 тыс. руб.,18 недель\n2018,330 тыс. руб.,95 недель\n2018,488 тыс. руб.,64 недель\n2018,167 тыс. руб.,29 недель\n2018,327 тыс. руб.,27 недель\n2018,275 тыс. руб.,13 недель\n2018,205 тыс. руб.,93 недель\n2018,354 тыс. руб.,38 недель', '2015,497 тыс. руб.,82 недель\n2015,391 тыс. руб.,81 недель\n2015,488 тыс. руб.,72 недель\n2015,188 тыс. руб.,72 недель\n2015,320 тыс. руб.,57 недель\n2015,251 тыс. руб.,36 недель\n2015,488 тыс. руб.,96 недель\n2015,379 тыс. руб.,14 недель\n2015,305 тыс. руб.,90 недель\n2015,284 тыс. руб.,33 недель\n2015,180 тыс. руб.,15 недель\n2015,328 тыс. руб.,50 недель\n2015,355 тыс. руб.,84 недель\n2015,426 тыс. руб.,63 недель\n2015,294 тыс. руб.,15 недель\n2015,327 тыс. руб.,72 недель\n2015,452 тыс. руб.,71 недель\n2015,240 тыс. руб.,88 недель', '2019,255 тыс. руб.,56 недель\n2017,280 тыс. руб.,80 недель\n2019,111 тыс. руб.,49 недель\n2015,497 тыс. руб.,82 недель\n2015,391 тыс. руб.,81 недель\n2015,488 тыс. руб.,72 недель\n2016,219 тыс. руб.,11 недель\n2015,188 тыс. руб.,72 недель\n2016,439 тыс. руб.,82 недель\n2016,410 тыс. руб.,26 недель\n2017,166 тыс. руб.,100 недель\n2019,449 тыс. руб.,100 недель\n2019,148 тыс. руб.,51 недель\n2018,246 тыс. руб.,59 недель\n2018,307 тыс. руб.,20 недель\n2019,113 тыс. руб.,41 недель\n2017,278 тыс. руб.,40 недель\n2015,320 тыс. руб.,57 недель\n2016,195 тыс. руб.,37 недель\n2019,330 тыс. руб.,69 недель\n2015,251 тыс. руб.,36 недель\n2015,488 тыс. руб.,96 недель\n2017,215 тыс. руб.,22 недель\n2017,151 тыс. руб.,93 недель\n2016,470 тыс. руб.,84 недель\n2018,376 тыс. руб.,53 недель\n2018,488 тыс. руб.,13 недель\n2017,164 тыс. руб.,15 недель\n2016,226 тыс. руб.,51 недель\n2015,379 тыс. руб.,14 недель\n2015,305 тыс. руб.,90 недель\n2015,284 тыс. руб.,33 недель\n2016,158 тыс. руб.,55 недель\n2016,257 тыс. руб.,14 недель\n2015,180 тыс. руб.,15 недель\n2017,262 тыс. руб.,73 недель\n2019,245 тыс. руб.,99 недель\n2015,328 тыс. руб.,50 недель\n2015,355 тыс. руб.,84 недель\n2016,358 тыс. руб.,70 недель\n2017,463 тыс. руб.,33 недель\n2015,426 тыс. руб.,63 недель\n2016,153 тыс. руб.,19 недель\n2015,294 тыс. руб.,15 недель\n2016,190 тыс. руб.,61 недель\n2019,256 тыс. руб.,16 недель\n2015,327 тыс. руб.,72 недель\n2017,499 тыс. руб.,41 недель\n2015,452 тыс. руб.,71 недель\n2018,142 тыс. руб.,57 недель\n2019,452 тыс. руб.,100 недель\n2015,240 тыс. руб.,88 недель\n2017,141 тыс. руб.,72 недель\n2018,215 тыс. руб.,40 недель\n2019,177 тыс. руб.,75 недель\n2019,115 тыс. руб.,15 недель\n2017,148 тыс. руб.,95 недель\n2019,125 тыс. руб.,24 недель\n2019,434 тыс. руб.,88 недель\n2016,348 тыс. руб.,83 недель\n2017,127 тыс. руб.,68 недель\n2018,145 тыс. руб.,41 недель', nan]","year = input()

with open('projects_file.csv', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        info = line.split(',')
        if info[0] <= year and int(info[-2].split()[0]) < 500:
            print(line)","year = input()

with open('projects_file.csv', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        info = line.split(',')
        if info[0] <= year and int(info[-2].split()[0]) <= 500:
            print(line)","Ошибка в открытых и скрытых тестах. 

Ваш код некорректно выполняет условия задания. Так, он неправильно выполянет условие ""со стоимостью не более 500. тыс. руб."". Попробуйте изменить условие if, чтобы скорректировать ошибку.","['open', 'closed', 'closed', 'closed', 'closed']","<Task description>: Ксения анализирует реализованные дизайн-проекты, которые собраны в файле формата csv. Напишите программу, которая выводит все строки, соответствующие реализованным в определенный период проектам, стоимость которых была не более 500 тыс. руб..

Программа должна открывать структурированный текстовый файл projects_file.csv, в кодировке utf-8, где на каждой строке записана следующая информация о дизайн-проекте: год, стоимость проекта, количество недель, за сколько был реализован проект. Например, строка ""2019,200 тыс. руб.,10 недель"" означает, что в 2019 году проект стоимостью 200 тыс. руб. был реализован за 10 недель.
Гарантируется, что стоимость реализованного проекта всегда записана в формате ""<целое число> тыс. руб."".
Гарантируется, что срок реализации проекта всегда записан в формате ""<целое число> недель"".
Разделителями данных в файле служат запятые.
Гарантируется, что в файле есть как минимум одна строка с данными. 
С клавиатуры вводится строка — год.
Программа должна выводить строки из оригинального файла, которые соответствуют проектам, реализованным не позднее, чем в указанном году, со стоимостью не более 500. тыс. руб. (не забудьте удалить символы конца строки!).
Если подходящих под условие строк в файле нет, то программа ничего не выводит.
ДОПОЛНИТЕЛЬНО
Ваше решение будет проверяться на закрытых тестах. Ваш код должен считывать файл projects_file.csv без дополнительных указаний (например, пути к файлу на вашем компьютере).
В открытом тесте используется файл projects_file.csv. Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: 2019 
<Вывод>: 2018,253 тыс. руб.,45 недель
2018,340 тыс. руб.,34 недель
2019,263 тыс. руб.,90 недель
2019,320 тыс. руб.,31 недель
2019,478 тыс. руб.,85 недель
2018,324 тыс. руб.,18 недель
2019,186 тыс. руб.,82 недель
2018,349 тыс. руб.,95 недель
2019,479 тыс. руб.,31 недель
2019,192 тыс. руб.,36 недель
2018,393 тыс. руб.,90 недель
2019,206 тыс. руб.,70 недель
2019,185 тыс. руб.,27 недель
2019,396 тыс. руб.,36 недель
2018,445 тыс. руб.,6 недель
2019,492 тыс. руб.,77 недель
2018,267 тыс. руб.,38 недель
2018,260 тыс. руб.,79 недель
2018,214 тыс. руб.,47 недель
2018,151 тыс. руб.,70 недель
2019,116 тыс. руб.,25 недель
2019,178 тыс. руб.,9 недель
2019,100 тыс. руб.,24 недель
2019,112 тыс. руб.,91 недель
2019,369 тыс. руб.,24 недель
2019,166 тыс. руб.,67 недель
2019,498 тыс. руб.,83 недель
2018,276 тыс. руб.,48 недель
2019,493 тыс. руб.,20 недель
2019,358 тыс. руб.,27 недель
2019,394 тыс. руб.,49 недель
2019,429 тыс. руб.,77 недель
2019,375 тыс. руб.,44 недель
2019,245 тыс. руб.,74 недель
2018,313 тыс. руб.,5 недель
2018,244 тыс. руб.,26 недель
2018,432 тыс. руб.,87 недель
2019,291 тыс. руб.,96 недель
2018,355 тыс. руб.,100 недель
2019,377 тыс. руб.,39 недель 
<Example 2>: 
<Тип теста 2>: closed 
<Ввод>: 2018 
<Вывод>: 2018,240 тыс. руб.,86 недель
2018,491 тыс. руб.,75 недель
2018,310 тыс. руб.,29 недель
2018,111 тыс. руб.,60 недель
2018,252 тыс. руб.,81 недель
2018,448 тыс. руб.,55 недель
2018,397 тыс. руб.,73 недель
2018,472 тыс. руб.,74 недель
2018,357 тыс. руб.,17 недель
2018,364 тыс. руб.,82 недель
2018,187 тыс. руб.,89 недель
2018,267 тыс. руб.,57 недель
2018,254 тыс. руб.,18 недель
2018,330 тыс. руб.,95 недель
2018,488 тыс. руб.,64 недель
2018,167 тыс. руб.,29 недель
2018,327 тыс. руб.,27 недель
2018,275 тыс. руб.,13 недель
2018,205 тыс. руб.,93 недель
2018,354 тыс. руб.,38 недель 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: 2015 
<Вывод>: 2015,497 тыс. руб.,82 недель
2015,391 тыс. руб.,81 недель
2015,488 тыс. руб.,72 недель
2015,188 тыс. руб.,72 недель
2015,320 тыс. руб.,57 недель
2015,251 тыс. руб.,36 недель
2015,488 тыс. руб.,96 недель
2015,379 тыс. руб.,14 недель
2015,305 тыс. руб.,90 недель
2015,284 тыс. руб.,33 недель
2015,180 тыс. руб.,15 недель
2015,328 тыс. руб.,50 недель
2015,355 тыс. руб.,84 недель
2015,426 тыс. руб.,63 недель
2015,294 тыс. руб.,15 недель
2015,327 тыс. руб.,72 недель
2015,452 тыс. руб.,71 недель
2015,240 тыс. руб.,88 недель 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: 2019 
<Вывод>: 2019,255 тыс. руб.,56 недель
2017,280 тыс. руб.,80 недель
2019,111 тыс. руб.,49 недель
2015,497 тыс. руб.,82 недель
2015,391 тыс. руб.,81 недель
2015,488 тыс. руб.,72 недель
2016,219 тыс. руб.,11 недель
2015,188 тыс. руб.,72 недель
2016,439 тыс. руб.,82 недель
2016,410 тыс. руб.,26 недель
2017,166 тыс. руб.,100 недель
2019,449 тыс. руб.,100 недель
2019,148 тыс. руб.,51 недель
2018,246 тыс. руб.,59 недель
2018,307 тыс. руб.,20 недель
2019,113 тыс. руб.,41 недель
2017,278 тыс. руб.,40 недель
2015,320 тыс. руб.,57 недель
2016,195 тыс. руб.,37 недель
2019,330 тыс. руб.,69 недель
2015,251 тыс. руб.,36 недель
2015,488 тыс. руб.,96 недель
2017,215 тыс. руб.,22 недель
2017,151 тыс. руб.,93 недель
2016,470 тыс. руб.,84 недель
2018,376 тыс. руб.,53 недель
2018,488 тыс. руб.,13 недель
2017,164 тыс. руб.,15 недель
2016,226 тыс. руб.,51 недель
2015,379 тыс. руб.,14 недель
2015,305 тыс. руб.,90 недель
2015,284 тыс. руб.,33 недель
2016,158 тыс. руб.,55 недель
2016,257 тыс. руб.,14 недель
2015,180 тыс. руб.,15 недель
2017,262 тыс. руб.,73 недель
2019,245 тыс. руб.,99 недель
2015,328 тыс. руб.,50 недель
2015,355 тыс. руб.,84 недель
2016,358 тыс. руб.,70 недель
2017,463 тыс. руб.,33 недель
2015,426 тыс. руб.,63 недель
2016,153 тыс. руб.,19 недель
2015,294 тыс. руб.,15 недель
2016,190 тыс. руб.,61 недель
2019,256 тыс. руб.,16 недель
2015,327 тыс. руб.,72 недель
2017,499 тыс. руб.,41 недель
2015,452 тыс. руб.,71 недель
2018,142 тыс. руб.,57 недель
2019,452 тыс. руб.,100 недель
2015,240 тыс. руб.,88 недель
2017,141 тыс. руб.,72 недель
2018,215 тыс. руб.,40 недель
2019,177 тыс. руб.,75 недель
2019,115 тыс. руб.,15 недель
2017,148 тыс. руб.,95 недель
2019,125 тыс. руб.,24 недель
2019,434 тыс. руб.,88 недель
2016,348 тыс. руб.,83 недель
2017,127 тыс. руб.,68 недель
2018,145 тыс. руб.,41 недель 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: 1990 
<Вывод>: nan 
<Решение студента>: year = input()

with open('projects_file.csv', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        info = line.split(',')
        if info[0] <= year and int(info[-2].split()[0]) < 500:
            print(line) 
<Идеальное решение>: year = input()

with open('projects_file.csv', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        info = line.split(',')
        if info[0] <= year and int(info[-2].split()[0]) <= 500:
            print(line) 


<Комментарий эксперта>:"
71,114,7,"Ксения анализирует реализованные дизайн-проекты, которые собраны в файле формата csv. Напишите программу, которая выводит все строки, соответствующие реализованным в определенный период проектам, стоимость которых была не более 500 тыс. руб..

Программа должна открывать структурированный текстовый файл projects_file.csv, в кодировке utf-8, где на каждой строке записана следующая информация о дизайн-проекте: год, стоимость проекта, количество недель, за сколько был реализован проект. Например, строка ""2019,200 тыс. руб.,10 недель"" означает, что в 2019 году проект стоимостью 200 тыс. руб. был реализован за 10 недель.
Гарантируется, что стоимость реализованного проекта всегда записана в формате ""<целое число> тыс. руб."".
Гарантируется, что срок реализации проекта всегда записан в формате ""<целое число> недель"".
Разделителями данных в файле служат запятые.
Гарантируется, что в файле есть как минимум одна строка с данными. 
С клавиатуры вводится строка — год.
Программа должна выводить строки из оригинального файла, которые соответствуют проектам, реализованным не позднее, чем в указанном году, со стоимостью не более 500. тыс. руб. (не забудьте удалить символы конца строки!).
Если подходящих под условие строк в файле нет, то программа ничего не выводит.
ДОПОЛНИТЕЛЬНО
Ваше решение будет проверяться на закрытых тестах. Ваш код должен считывать файл projects_file.csv без дополнительных указаний (например, пути к файлу на вашем компьютере).
В открытом тесте используется файл projects_file.csv. Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.","['2019', '2018', '2015', '2019', '1990']","['2018,253 тыс. руб.,45 недель\n2018,340 тыс. руб.,34 недель\n2019,263 тыс. руб.,90 недель\n2019,320 тыс. руб.,31 недель\n2019,478 тыс. руб.,85 недель\n2018,324 тыс. руб.,18 недель\n2019,186 тыс. руб.,82 недель\n2018,349 тыс. руб.,95 недель\n2019,479 тыс. руб.,31 недель\n2019,192 тыс. руб.,36 недель\n2018,393 тыс. руб.,90 недель\n2019,206 тыс. руб.,70 недель\n2019,185 тыс. руб.,27 недель\n2019,396 тыс. руб.,36 недель\n2018,445 тыс. руб.,6 недель\n2019,492 тыс. руб.,77 недель\n2018,267 тыс. руб.,38 недель\n2018,260 тыс. руб.,79 недель\n2018,214 тыс. руб.,47 недель\n2018,151 тыс. руб.,70 недель\n2019,116 тыс. руб.,25 недель\n2019,178 тыс. руб.,9 недель\n2019,100 тыс. руб.,24 недель\n2019,112 тыс. руб.,91 недель\n2019,369 тыс. руб.,24 недель\n2019,166 тыс. руб.,67 недель\n2019,498 тыс. руб.,83 недель\n2018,276 тыс. руб.,48 недель\n2019,493 тыс. руб.,20 недель\n2019,358 тыс. руб.,27 недель\n2019,394 тыс. руб.,49 недель\n2019,429 тыс. руб.,77 недель\n2019,375 тыс. руб.,44 недель\n2019,245 тыс. руб.,74 недель\n2018,313 тыс. руб.,5 недель\n2018,244 тыс. руб.,26 недель\n2018,432 тыс. руб.,87 недель\n2019,291 тыс. руб.,96 недель\n2018,355 тыс. руб.,100 недель\n2019,377 тыс. руб.,39 недель', '2018,240 тыс. руб.,86 недель\n2018,491 тыс. руб.,75 недель\n2018,310 тыс. руб.,29 недель\n2018,111 тыс. руб.,60 недель\n2018,252 тыс. руб.,81 недель\n2018,448 тыс. руб.,55 недель\n2018,397 тыс. руб.,73 недель\n2018,472 тыс. руб.,74 недель\n2018,357 тыс. руб.,17 недель\n2018,364 тыс. руб.,82 недель\n2018,187 тыс. руб.,89 недель\n2018,267 тыс. руб.,57 недель\n2018,254 тыс. руб.,18 недель\n2018,330 тыс. руб.,95 недель\n2018,488 тыс. руб.,64 недель\n2018,167 тыс. руб.,29 недель\n2018,327 тыс. руб.,27 недель\n2018,275 тыс. руб.,13 недель\n2018,205 тыс. руб.,93 недель\n2018,354 тыс. руб.,38 недель', '2015,497 тыс. руб.,82 недель\n2015,391 тыс. руб.,81 недель\n2015,488 тыс. руб.,72 недель\n2015,188 тыс. руб.,72 недель\n2015,320 тыс. руб.,57 недель\n2015,251 тыс. руб.,36 недель\n2015,488 тыс. руб.,96 недель\n2015,379 тыс. руб.,14 недель\n2015,305 тыс. руб.,90 недель\n2015,284 тыс. руб.,33 недель\n2015,180 тыс. руб.,15 недель\n2015,328 тыс. руб.,50 недель\n2015,355 тыс. руб.,84 недель\n2015,426 тыс. руб.,63 недель\n2015,294 тыс. руб.,15 недель\n2015,327 тыс. руб.,72 недель\n2015,452 тыс. руб.,71 недель\n2015,240 тыс. руб.,88 недель', '2019,255 тыс. руб.,56 недель\n2017,280 тыс. руб.,80 недель\n2019,111 тыс. руб.,49 недель\n2015,497 тыс. руб.,82 недель\n2015,391 тыс. руб.,81 недель\n2015,488 тыс. руб.,72 недель\n2016,219 тыс. руб.,11 недель\n2015,188 тыс. руб.,72 недель\n2016,439 тыс. руб.,82 недель\n2016,410 тыс. руб.,26 недель\n2017,166 тыс. руб.,100 недель\n2019,449 тыс. руб.,100 недель\n2019,148 тыс. руб.,51 недель\n2018,246 тыс. руб.,59 недель\n2018,307 тыс. руб.,20 недель\n2019,113 тыс. руб.,41 недель\n2017,278 тыс. руб.,40 недель\n2015,320 тыс. руб.,57 недель\n2016,195 тыс. руб.,37 недель\n2019,330 тыс. руб.,69 недель\n2015,251 тыс. руб.,36 недель\n2015,488 тыс. руб.,96 недель\n2017,215 тыс. руб.,22 недель\n2017,151 тыс. руб.,93 недель\n2016,470 тыс. руб.,84 недель\n2018,376 тыс. руб.,53 недель\n2018,488 тыс. руб.,13 недель\n2017,164 тыс. руб.,15 недель\n2016,226 тыс. руб.,51 недель\n2015,379 тыс. руб.,14 недель\n2015,305 тыс. руб.,90 недель\n2015,284 тыс. руб.,33 недель\n2016,158 тыс. руб.,55 недель\n2016,257 тыс. руб.,14 недель\n2015,180 тыс. руб.,15 недель\n2017,262 тыс. руб.,73 недель\n2019,245 тыс. руб.,99 недель\n2015,328 тыс. руб.,50 недель\n2015,355 тыс. руб.,84 недель\n2016,358 тыс. руб.,70 недель\n2017,463 тыс. руб.,33 недель\n2015,426 тыс. руб.,63 недель\n2016,153 тыс. руб.,19 недель\n2015,294 тыс. руб.,15 недель\n2016,190 тыс. руб.,61 недель\n2019,256 тыс. руб.,16 недель\n2015,327 тыс. руб.,72 недель\n2017,499 тыс. руб.,41 недель\n2015,452 тыс. руб.,71 недель\n2018,142 тыс. руб.,57 недель\n2019,452 тыс. руб.,100 недель\n2015,240 тыс. руб.,88 недель\n2017,141 тыс. руб.,72 недель\n2018,215 тыс. руб.,40 недель\n2019,177 тыс. руб.,75 недель\n2019,115 тыс. руб.,15 недель\n2017,148 тыс. руб.,95 недель\n2019,125 тыс. руб.,24 недель\n2019,434 тыс. руб.,88 недель\n2016,348 тыс. руб.,83 недель\n2017,127 тыс. руб.,68 недель\n2018,145 тыс. руб.,41 недель', nan]","year = input()

with open('projects_file.csv', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        info = line.split(',')
        if info[0] <= year or int(info[-2].split()[0]) <= 500:
            print(line)","year = input()

with open('projects_file.csv', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        info = line.split(',')
        if info[0] <= year and int(info[-2].split()[0]) <= 500:
            print(line)","Ошибка в открытых и скрытых тестах. 

Ваш код некорректно выполняет условия задания. Так, он неправильно выполянет условие ""реализованные не позднее, чем в указанном году, со стоимостью не более 500. тыс. руб."". Попробуйте изменить условие if, чтобы скорректировать ошибку.","['open', 'closed', 'closed', 'closed', 'closed']","<Task description>: Ксения анализирует реализованные дизайн-проекты, которые собраны в файле формата csv. Напишите программу, которая выводит все строки, соответствующие реализованным в определенный период проектам, стоимость которых была не более 500 тыс. руб..

Программа должна открывать структурированный текстовый файл projects_file.csv, в кодировке utf-8, где на каждой строке записана следующая информация о дизайн-проекте: год, стоимость проекта, количество недель, за сколько был реализован проект. Например, строка ""2019,200 тыс. руб.,10 недель"" означает, что в 2019 году проект стоимостью 200 тыс. руб. был реализован за 10 недель.
Гарантируется, что стоимость реализованного проекта всегда записана в формате ""<целое число> тыс. руб."".
Гарантируется, что срок реализации проекта всегда записан в формате ""<целое число> недель"".
Разделителями данных в файле служат запятые.
Гарантируется, что в файле есть как минимум одна строка с данными. 
С клавиатуры вводится строка — год.
Программа должна выводить строки из оригинального файла, которые соответствуют проектам, реализованным не позднее, чем в указанном году, со стоимостью не более 500. тыс. руб. (не забудьте удалить символы конца строки!).
Если подходящих под условие строк в файле нет, то программа ничего не выводит.
ДОПОЛНИТЕЛЬНО
Ваше решение будет проверяться на закрытых тестах. Ваш код должен считывать файл projects_file.csv без дополнительных указаний (например, пути к файлу на вашем компьютере).
В открытом тесте используется файл projects_file.csv. Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: 2019 
<Вывод>: 2018,253 тыс. руб.,45 недель
2018,340 тыс. руб.,34 недель
2019,263 тыс. руб.,90 недель
2019,320 тыс. руб.,31 недель
2019,478 тыс. руб.,85 недель
2018,324 тыс. руб.,18 недель
2019,186 тыс. руб.,82 недель
2018,349 тыс. руб.,95 недель
2019,479 тыс. руб.,31 недель
2019,192 тыс. руб.,36 недель
2018,393 тыс. руб.,90 недель
2019,206 тыс. руб.,70 недель
2019,185 тыс. руб.,27 недель
2019,396 тыс. руб.,36 недель
2018,445 тыс. руб.,6 недель
2019,492 тыс. руб.,77 недель
2018,267 тыс. руб.,38 недель
2018,260 тыс. руб.,79 недель
2018,214 тыс. руб.,47 недель
2018,151 тыс. руб.,70 недель
2019,116 тыс. руб.,25 недель
2019,178 тыс. руб.,9 недель
2019,100 тыс. руб.,24 недель
2019,112 тыс. руб.,91 недель
2019,369 тыс. руб.,24 недель
2019,166 тыс. руб.,67 недель
2019,498 тыс. руб.,83 недель
2018,276 тыс. руб.,48 недель
2019,493 тыс. руб.,20 недель
2019,358 тыс. руб.,27 недель
2019,394 тыс. руб.,49 недель
2019,429 тыс. руб.,77 недель
2019,375 тыс. руб.,44 недель
2019,245 тыс. руб.,74 недель
2018,313 тыс. руб.,5 недель
2018,244 тыс. руб.,26 недель
2018,432 тыс. руб.,87 недель
2019,291 тыс. руб.,96 недель
2018,355 тыс. руб.,100 недель
2019,377 тыс. руб.,39 недель 
<Example 2>: 
<Тип теста 2>: closed 
<Ввод>: 2018 
<Вывод>: 2018,240 тыс. руб.,86 недель
2018,491 тыс. руб.,75 недель
2018,310 тыс. руб.,29 недель
2018,111 тыс. руб.,60 недель
2018,252 тыс. руб.,81 недель
2018,448 тыс. руб.,55 недель
2018,397 тыс. руб.,73 недель
2018,472 тыс. руб.,74 недель
2018,357 тыс. руб.,17 недель
2018,364 тыс. руб.,82 недель
2018,187 тыс. руб.,89 недель
2018,267 тыс. руб.,57 недель
2018,254 тыс. руб.,18 недель
2018,330 тыс. руб.,95 недель
2018,488 тыс. руб.,64 недель
2018,167 тыс. руб.,29 недель
2018,327 тыс. руб.,27 недель
2018,275 тыс. руб.,13 недель
2018,205 тыс. руб.,93 недель
2018,354 тыс. руб.,38 недель 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: 2015 
<Вывод>: 2015,497 тыс. руб.,82 недель
2015,391 тыс. руб.,81 недель
2015,488 тыс. руб.,72 недель
2015,188 тыс. руб.,72 недель
2015,320 тыс. руб.,57 недель
2015,251 тыс. руб.,36 недель
2015,488 тыс. руб.,96 недель
2015,379 тыс. руб.,14 недель
2015,305 тыс. руб.,90 недель
2015,284 тыс. руб.,33 недель
2015,180 тыс. руб.,15 недель
2015,328 тыс. руб.,50 недель
2015,355 тыс. руб.,84 недель
2015,426 тыс. руб.,63 недель
2015,294 тыс. руб.,15 недель
2015,327 тыс. руб.,72 недель
2015,452 тыс. руб.,71 недель
2015,240 тыс. руб.,88 недель 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: 2019 
<Вывод>: 2019,255 тыс. руб.,56 недель
2017,280 тыс. руб.,80 недель
2019,111 тыс. руб.,49 недель
2015,497 тыс. руб.,82 недель
2015,391 тыс. руб.,81 недель
2015,488 тыс. руб.,72 недель
2016,219 тыс. руб.,11 недель
2015,188 тыс. руб.,72 недель
2016,439 тыс. руб.,82 недель
2016,410 тыс. руб.,26 недель
2017,166 тыс. руб.,100 недель
2019,449 тыс. руб.,100 недель
2019,148 тыс. руб.,51 недель
2018,246 тыс. руб.,59 недель
2018,307 тыс. руб.,20 недель
2019,113 тыс. руб.,41 недель
2017,278 тыс. руб.,40 недель
2015,320 тыс. руб.,57 недель
2016,195 тыс. руб.,37 недель
2019,330 тыс. руб.,69 недель
2015,251 тыс. руб.,36 недель
2015,488 тыс. руб.,96 недель
2017,215 тыс. руб.,22 недель
2017,151 тыс. руб.,93 недель
2016,470 тыс. руб.,84 недель
2018,376 тыс. руб.,53 недель
2018,488 тыс. руб.,13 недель
2017,164 тыс. руб.,15 недель
2016,226 тыс. руб.,51 недель
2015,379 тыс. руб.,14 недель
2015,305 тыс. руб.,90 недель
2015,284 тыс. руб.,33 недель
2016,158 тыс. руб.,55 недель
2016,257 тыс. руб.,14 недель
2015,180 тыс. руб.,15 недель
2017,262 тыс. руб.,73 недель
2019,245 тыс. руб.,99 недель
2015,328 тыс. руб.,50 недель
2015,355 тыс. руб.,84 недель
2016,358 тыс. руб.,70 недель
2017,463 тыс. руб.,33 недель
2015,426 тыс. руб.,63 недель
2016,153 тыс. руб.,19 недель
2015,294 тыс. руб.,15 недель
2016,190 тыс. руб.,61 недель
2019,256 тыс. руб.,16 недель
2015,327 тыс. руб.,72 недель
2017,499 тыс. руб.,41 недель
2015,452 тыс. руб.,71 недель
2018,142 тыс. руб.,57 недель
2019,452 тыс. руб.,100 недель
2015,240 тыс. руб.,88 недель
2017,141 тыс. руб.,72 недель
2018,215 тыс. руб.,40 недель
2019,177 тыс. руб.,75 недель
2019,115 тыс. руб.,15 недель
2017,148 тыс. руб.,95 недель
2019,125 тыс. руб.,24 недель
2019,434 тыс. руб.,88 недель
2016,348 тыс. руб.,83 недель
2017,127 тыс. руб.,68 недель
2018,145 тыс. руб.,41 недель 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: 1990 
<Вывод>: nan 
<Решение студента>: year = input()

with open('projects_file.csv', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        info = line.split(',')
        if info[0] <= year or int(info[-2].split()[0]) <= 500:
            print(line) 
<Идеальное решение>: year = input()

with open('projects_file.csv', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        info = line.split(',')
        if info[0] <= year and int(info[-2].split()[0]) <= 500:
            print(line) 


<Комментарий эксперта>:"
72,115,7,"Ксения анализирует реализованные дизайн-проекты, которые собраны в файле формата csv. Напишите программу, которая выводит все строки, соответствующие реализованным в определенный период проектам, стоимость которых была не более 500 тыс. руб..

Программа должна открывать структурированный текстовый файл projects_file.csv, в кодировке utf-8, где на каждой строке записана следующая информация о дизайн-проекте: год, стоимость проекта, количество недель, за сколько был реализован проект. Например, строка ""2019,200 тыс. руб.,10 недель"" означает, что в 2019 году проект стоимостью 200 тыс. руб. был реализован за 10 недель.
Гарантируется, что стоимость реализованного проекта всегда записана в формате ""<целое число> тыс. руб."".
Гарантируется, что срок реализации проекта всегда записан в формате ""<целое число> недель"".
Разделителями данных в файле служат запятые.
Гарантируется, что в файле есть как минимум одна строка с данными. 
С клавиатуры вводится строка — год.
Программа должна выводить строки из оригинального файла, которые соответствуют проектам, реализованным не позднее, чем в указанном году, со стоимостью не более 500. тыс. руб. (не забудьте удалить символы конца строки!).
Если подходящих под условие строк в файле нет, то программа ничего не выводит.
ДОПОЛНИТЕЛЬНО
Ваше решение будет проверяться на закрытых тестах. Ваш код должен считывать файл projects_file.csv без дополнительных указаний (например, пути к файлу на вашем компьютере).
В открытом тесте используется файл projects_file.csv. Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.","['2019', '2018', '2015', '2019', '1990']","['2018,253 тыс. руб.,45 недель\n2018,340 тыс. руб.,34 недель\n2019,263 тыс. руб.,90 недель\n2019,320 тыс. руб.,31 недель\n2019,478 тыс. руб.,85 недель\n2018,324 тыс. руб.,18 недель\n2019,186 тыс. руб.,82 недель\n2018,349 тыс. руб.,95 недель\n2019,479 тыс. руб.,31 недель\n2019,192 тыс. руб.,36 недель\n2018,393 тыс. руб.,90 недель\n2019,206 тыс. руб.,70 недель\n2019,185 тыс. руб.,27 недель\n2019,396 тыс. руб.,36 недель\n2018,445 тыс. руб.,6 недель\n2019,492 тыс. руб.,77 недель\n2018,267 тыс. руб.,38 недель\n2018,260 тыс. руб.,79 недель\n2018,214 тыс. руб.,47 недель\n2018,151 тыс. руб.,70 недель\n2019,116 тыс. руб.,25 недель\n2019,178 тыс. руб.,9 недель\n2019,100 тыс. руб.,24 недель\n2019,112 тыс. руб.,91 недель\n2019,369 тыс. руб.,24 недель\n2019,166 тыс. руб.,67 недель\n2019,498 тыс. руб.,83 недель\n2018,276 тыс. руб.,48 недель\n2019,493 тыс. руб.,20 недель\n2019,358 тыс. руб.,27 недель\n2019,394 тыс. руб.,49 недель\n2019,429 тыс. руб.,77 недель\n2019,375 тыс. руб.,44 недель\n2019,245 тыс. руб.,74 недель\n2018,313 тыс. руб.,5 недель\n2018,244 тыс. руб.,26 недель\n2018,432 тыс. руб.,87 недель\n2019,291 тыс. руб.,96 недель\n2018,355 тыс. руб.,100 недель\n2019,377 тыс. руб.,39 недель', '2018,240 тыс. руб.,86 недель\n2018,491 тыс. руб.,75 недель\n2018,310 тыс. руб.,29 недель\n2018,111 тыс. руб.,60 недель\n2018,252 тыс. руб.,81 недель\n2018,448 тыс. руб.,55 недель\n2018,397 тыс. руб.,73 недель\n2018,472 тыс. руб.,74 недель\n2018,357 тыс. руб.,17 недель\n2018,364 тыс. руб.,82 недель\n2018,187 тыс. руб.,89 недель\n2018,267 тыс. руб.,57 недель\n2018,254 тыс. руб.,18 недель\n2018,330 тыс. руб.,95 недель\n2018,488 тыс. руб.,64 недель\n2018,167 тыс. руб.,29 недель\n2018,327 тыс. руб.,27 недель\n2018,275 тыс. руб.,13 недель\n2018,205 тыс. руб.,93 недель\n2018,354 тыс. руб.,38 недель', '2015,497 тыс. руб.,82 недель\n2015,391 тыс. руб.,81 недель\n2015,488 тыс. руб.,72 недель\n2015,188 тыс. руб.,72 недель\n2015,320 тыс. руб.,57 недель\n2015,251 тыс. руб.,36 недель\n2015,488 тыс. руб.,96 недель\n2015,379 тыс. руб.,14 недель\n2015,305 тыс. руб.,90 недель\n2015,284 тыс. руб.,33 недель\n2015,180 тыс. руб.,15 недель\n2015,328 тыс. руб.,50 недель\n2015,355 тыс. руб.,84 недель\n2015,426 тыс. руб.,63 недель\n2015,294 тыс. руб.,15 недель\n2015,327 тыс. руб.,72 недель\n2015,452 тыс. руб.,71 недель\n2015,240 тыс. руб.,88 недель', '2019,255 тыс. руб.,56 недель\n2017,280 тыс. руб.,80 недель\n2019,111 тыс. руб.,49 недель\n2015,497 тыс. руб.,82 недель\n2015,391 тыс. руб.,81 недель\n2015,488 тыс. руб.,72 недель\n2016,219 тыс. руб.,11 недель\n2015,188 тыс. руб.,72 недель\n2016,439 тыс. руб.,82 недель\n2016,410 тыс. руб.,26 недель\n2017,166 тыс. руб.,100 недель\n2019,449 тыс. руб.,100 недель\n2019,148 тыс. руб.,51 недель\n2018,246 тыс. руб.,59 недель\n2018,307 тыс. руб.,20 недель\n2019,113 тыс. руб.,41 недель\n2017,278 тыс. руб.,40 недель\n2015,320 тыс. руб.,57 недель\n2016,195 тыс. руб.,37 недель\n2019,330 тыс. руб.,69 недель\n2015,251 тыс. руб.,36 недель\n2015,488 тыс. руб.,96 недель\n2017,215 тыс. руб.,22 недель\n2017,151 тыс. руб.,93 недель\n2016,470 тыс. руб.,84 недель\n2018,376 тыс. руб.,53 недель\n2018,488 тыс. руб.,13 недель\n2017,164 тыс. руб.,15 недель\n2016,226 тыс. руб.,51 недель\n2015,379 тыс. руб.,14 недель\n2015,305 тыс. руб.,90 недель\n2015,284 тыс. руб.,33 недель\n2016,158 тыс. руб.,55 недель\n2016,257 тыс. руб.,14 недель\n2015,180 тыс. руб.,15 недель\n2017,262 тыс. руб.,73 недель\n2019,245 тыс. руб.,99 недель\n2015,328 тыс. руб.,50 недель\n2015,355 тыс. руб.,84 недель\n2016,358 тыс. руб.,70 недель\n2017,463 тыс. руб.,33 недель\n2015,426 тыс. руб.,63 недель\n2016,153 тыс. руб.,19 недель\n2015,294 тыс. руб.,15 недель\n2016,190 тыс. руб.,61 недель\n2019,256 тыс. руб.,16 недель\n2015,327 тыс. руб.,72 недель\n2017,499 тыс. руб.,41 недель\n2015,452 тыс. руб.,71 недель\n2018,142 тыс. руб.,57 недель\n2019,452 тыс. руб.,100 недель\n2015,240 тыс. руб.,88 недель\n2017,141 тыс. руб.,72 недель\n2018,215 тыс. руб.,40 недель\n2019,177 тыс. руб.,75 недель\n2019,115 тыс. руб.,15 недель\n2017,148 тыс. руб.,95 недель\n2019,125 тыс. руб.,24 недель\n2019,434 тыс. руб.,88 недель\n2016,348 тыс. руб.,83 недель\n2017,127 тыс. руб.,68 недель\n2018,145 тыс. руб.,41 недель', nan]","year = input()

with open('projects_file.csv', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        info = line.split(',')
        if info[0] <= year and info[-2].split()[0] <= 500:
            print(line)","year = input()

with open('projects_file.csv', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        info = line.split(',')
        if info[0] <= year and int(info[-2].split()[0]) <= 500:
            print(line)","Ошибка при использовании оператора <=. Сравнивать можно только переменные типа int. Скорректируйте условие if, для исправления ошибки.","['open', 'closed', 'closed', 'closed', 'closed']","<Task description>: Ксения анализирует реализованные дизайн-проекты, которые собраны в файле формата csv. Напишите программу, которая выводит все строки, соответствующие реализованным в определенный период проектам, стоимость которых была не более 500 тыс. руб..

Программа должна открывать структурированный текстовый файл projects_file.csv, в кодировке utf-8, где на каждой строке записана следующая информация о дизайн-проекте: год, стоимость проекта, количество недель, за сколько был реализован проект. Например, строка ""2019,200 тыс. руб.,10 недель"" означает, что в 2019 году проект стоимостью 200 тыс. руб. был реализован за 10 недель.
Гарантируется, что стоимость реализованного проекта всегда записана в формате ""<целое число> тыс. руб."".
Гарантируется, что срок реализации проекта всегда записан в формате ""<целое число> недель"".
Разделителями данных в файле служат запятые.
Гарантируется, что в файле есть как минимум одна строка с данными. 
С клавиатуры вводится строка — год.
Программа должна выводить строки из оригинального файла, которые соответствуют проектам, реализованным не позднее, чем в указанном году, со стоимостью не более 500. тыс. руб. (не забудьте удалить символы конца строки!).
Если подходящих под условие строк в файле нет, то программа ничего не выводит.
ДОПОЛНИТЕЛЬНО
Ваше решение будет проверяться на закрытых тестах. Ваш код должен считывать файл projects_file.csv без дополнительных указаний (например, пути к файлу на вашем компьютере).
В открытом тесте используется файл projects_file.csv. Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: 2019 
<Вывод>: 2018,253 тыс. руб.,45 недель
2018,340 тыс. руб.,34 недель
2019,263 тыс. руб.,90 недель
2019,320 тыс. руб.,31 недель
2019,478 тыс. руб.,85 недель
2018,324 тыс. руб.,18 недель
2019,186 тыс. руб.,82 недель
2018,349 тыс. руб.,95 недель
2019,479 тыс. руб.,31 недель
2019,192 тыс. руб.,36 недель
2018,393 тыс. руб.,90 недель
2019,206 тыс. руб.,70 недель
2019,185 тыс. руб.,27 недель
2019,396 тыс. руб.,36 недель
2018,445 тыс. руб.,6 недель
2019,492 тыс. руб.,77 недель
2018,267 тыс. руб.,38 недель
2018,260 тыс. руб.,79 недель
2018,214 тыс. руб.,47 недель
2018,151 тыс. руб.,70 недель
2019,116 тыс. руб.,25 недель
2019,178 тыс. руб.,9 недель
2019,100 тыс. руб.,24 недель
2019,112 тыс. руб.,91 недель
2019,369 тыс. руб.,24 недель
2019,166 тыс. руб.,67 недель
2019,498 тыс. руб.,83 недель
2018,276 тыс. руб.,48 недель
2019,493 тыс. руб.,20 недель
2019,358 тыс. руб.,27 недель
2019,394 тыс. руб.,49 недель
2019,429 тыс. руб.,77 недель
2019,375 тыс. руб.,44 недель
2019,245 тыс. руб.,74 недель
2018,313 тыс. руб.,5 недель
2018,244 тыс. руб.,26 недель
2018,432 тыс. руб.,87 недель
2019,291 тыс. руб.,96 недель
2018,355 тыс. руб.,100 недель
2019,377 тыс. руб.,39 недель 
<Example 2>: 
<Тип теста 2>: closed 
<Ввод>: 2018 
<Вывод>: 2018,240 тыс. руб.,86 недель
2018,491 тыс. руб.,75 недель
2018,310 тыс. руб.,29 недель
2018,111 тыс. руб.,60 недель
2018,252 тыс. руб.,81 недель
2018,448 тыс. руб.,55 недель
2018,397 тыс. руб.,73 недель
2018,472 тыс. руб.,74 недель
2018,357 тыс. руб.,17 недель
2018,364 тыс. руб.,82 недель
2018,187 тыс. руб.,89 недель
2018,267 тыс. руб.,57 недель
2018,254 тыс. руб.,18 недель
2018,330 тыс. руб.,95 недель
2018,488 тыс. руб.,64 недель
2018,167 тыс. руб.,29 недель
2018,327 тыс. руб.,27 недель
2018,275 тыс. руб.,13 недель
2018,205 тыс. руб.,93 недель
2018,354 тыс. руб.,38 недель 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: 2015 
<Вывод>: 2015,497 тыс. руб.,82 недель
2015,391 тыс. руб.,81 недель
2015,488 тыс. руб.,72 недель
2015,188 тыс. руб.,72 недель
2015,320 тыс. руб.,57 недель
2015,251 тыс. руб.,36 недель
2015,488 тыс. руб.,96 недель
2015,379 тыс. руб.,14 недель
2015,305 тыс. руб.,90 недель
2015,284 тыс. руб.,33 недель
2015,180 тыс. руб.,15 недель
2015,328 тыс. руб.,50 недель
2015,355 тыс. руб.,84 недель
2015,426 тыс. руб.,63 недель
2015,294 тыс. руб.,15 недель
2015,327 тыс. руб.,72 недель
2015,452 тыс. руб.,71 недель
2015,240 тыс. руб.,88 недель 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: 2019 
<Вывод>: 2019,255 тыс. руб.,56 недель
2017,280 тыс. руб.,80 недель
2019,111 тыс. руб.,49 недель
2015,497 тыс. руб.,82 недель
2015,391 тыс. руб.,81 недель
2015,488 тыс. руб.,72 недель
2016,219 тыс. руб.,11 недель
2015,188 тыс. руб.,72 недель
2016,439 тыс. руб.,82 недель
2016,410 тыс. руб.,26 недель
2017,166 тыс. руб.,100 недель
2019,449 тыс. руб.,100 недель
2019,148 тыс. руб.,51 недель
2018,246 тыс. руб.,59 недель
2018,307 тыс. руб.,20 недель
2019,113 тыс. руб.,41 недель
2017,278 тыс. руб.,40 недель
2015,320 тыс. руб.,57 недель
2016,195 тыс. руб.,37 недель
2019,330 тыс. руб.,69 недель
2015,251 тыс. руб.,36 недель
2015,488 тыс. руб.,96 недель
2017,215 тыс. руб.,22 недель
2017,151 тыс. руб.,93 недель
2016,470 тыс. руб.,84 недель
2018,376 тыс. руб.,53 недель
2018,488 тыс. руб.,13 недель
2017,164 тыс. руб.,15 недель
2016,226 тыс. руб.,51 недель
2015,379 тыс. руб.,14 недель
2015,305 тыс. руб.,90 недель
2015,284 тыс. руб.,33 недель
2016,158 тыс. руб.,55 недель
2016,257 тыс. руб.,14 недель
2015,180 тыс. руб.,15 недель
2017,262 тыс. руб.,73 недель
2019,245 тыс. руб.,99 недель
2015,328 тыс. руб.,50 недель
2015,355 тыс. руб.,84 недель
2016,358 тыс. руб.,70 недель
2017,463 тыс. руб.,33 недель
2015,426 тыс. руб.,63 недель
2016,153 тыс. руб.,19 недель
2015,294 тыс. руб.,15 недель
2016,190 тыс. руб.,61 недель
2019,256 тыс. руб.,16 недель
2015,327 тыс. руб.,72 недель
2017,499 тыс. руб.,41 недель
2015,452 тыс. руб.,71 недель
2018,142 тыс. руб.,57 недель
2019,452 тыс. руб.,100 недель
2015,240 тыс. руб.,88 недель
2017,141 тыс. руб.,72 недель
2018,215 тыс. руб.,40 недель
2019,177 тыс. руб.,75 недель
2019,115 тыс. руб.,15 недель
2017,148 тыс. руб.,95 недель
2019,125 тыс. руб.,24 недель
2019,434 тыс. руб.,88 недель
2016,348 тыс. руб.,83 недель
2017,127 тыс. руб.,68 недель
2018,145 тыс. руб.,41 недель 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: 1990 
<Вывод>: nan 
<Решение студента>: year = input()

with open('projects_file.csv', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        info = line.split(',')
        if info[0] <= year and info[-2].split()[0] <= 500:
            print(line) 
<Идеальное решение>: year = input()

with open('projects_file.csv', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        info = line.split(',')
        if info[0] <= year and int(info[-2].split()[0]) <= 500:
            print(line) 


<Комментарий эксперта>:"
73,116,7,"Ксения анализирует реализованные дизайн-проекты, которые собраны в файле формата csv. Напишите программу, которая выводит все строки, соответствующие реализованным в определенный период проектам, стоимость которых была не более 500 тыс. руб..

Программа должна открывать структурированный текстовый файл projects_file.csv, в кодировке utf-8, где на каждой строке записана следующая информация о дизайн-проекте: год, стоимость проекта, количество недель, за сколько был реализован проект. Например, строка ""2019,200 тыс. руб.,10 недель"" означает, что в 2019 году проект стоимостью 200 тыс. руб. был реализован за 10 недель.
Гарантируется, что стоимость реализованного проекта всегда записана в формате ""<целое число> тыс. руб."".
Гарантируется, что срок реализации проекта всегда записан в формате ""<целое число> недель"".
Разделителями данных в файле служат запятые.
Гарантируется, что в файле есть как минимум одна строка с данными. 
С клавиатуры вводится строка — год.
Программа должна выводить строки из оригинального файла, которые соответствуют проектам, реализованным не позднее, чем в указанном году, со стоимостью не более 500. тыс. руб. (не забудьте удалить символы конца строки!).
Если подходящих под условие строк в файле нет, то программа ничего не выводит.
ДОПОЛНИТЕЛЬНО
Ваше решение будет проверяться на закрытых тестах. Ваш код должен считывать файл projects_file.csv без дополнительных указаний (например, пути к файлу на вашем компьютере).
В открытом тесте используется файл projects_file.csv. Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.","['2019', '2018', '2015', '2019', '1990']","['2018,253 тыс. руб.,45 недель\n2018,340 тыс. руб.,34 недель\n2019,263 тыс. руб.,90 недель\n2019,320 тыс. руб.,31 недель\n2019,478 тыс. руб.,85 недель\n2018,324 тыс. руб.,18 недель\n2019,186 тыс. руб.,82 недель\n2018,349 тыс. руб.,95 недель\n2019,479 тыс. руб.,31 недель\n2019,192 тыс. руб.,36 недель\n2018,393 тыс. руб.,90 недель\n2019,206 тыс. руб.,70 недель\n2019,185 тыс. руб.,27 недель\n2019,396 тыс. руб.,36 недель\n2018,445 тыс. руб.,6 недель\n2019,492 тыс. руб.,77 недель\n2018,267 тыс. руб.,38 недель\n2018,260 тыс. руб.,79 недель\n2018,214 тыс. руб.,47 недель\n2018,151 тыс. руб.,70 недель\n2019,116 тыс. руб.,25 недель\n2019,178 тыс. руб.,9 недель\n2019,100 тыс. руб.,24 недель\n2019,112 тыс. руб.,91 недель\n2019,369 тыс. руб.,24 недель\n2019,166 тыс. руб.,67 недель\n2019,498 тыс. руб.,83 недель\n2018,276 тыс. руб.,48 недель\n2019,493 тыс. руб.,20 недель\n2019,358 тыс. руб.,27 недель\n2019,394 тыс. руб.,49 недель\n2019,429 тыс. руб.,77 недель\n2019,375 тыс. руб.,44 недель\n2019,245 тыс. руб.,74 недель\n2018,313 тыс. руб.,5 недель\n2018,244 тыс. руб.,26 недель\n2018,432 тыс. руб.,87 недель\n2019,291 тыс. руб.,96 недель\n2018,355 тыс. руб.,100 недель\n2019,377 тыс. руб.,39 недель', '2018,240 тыс. руб.,86 недель\n2018,491 тыс. руб.,75 недель\n2018,310 тыс. руб.,29 недель\n2018,111 тыс. руб.,60 недель\n2018,252 тыс. руб.,81 недель\n2018,448 тыс. руб.,55 недель\n2018,397 тыс. руб.,73 недель\n2018,472 тыс. руб.,74 недель\n2018,357 тыс. руб.,17 недель\n2018,364 тыс. руб.,82 недель\n2018,187 тыс. руб.,89 недель\n2018,267 тыс. руб.,57 недель\n2018,254 тыс. руб.,18 недель\n2018,330 тыс. руб.,95 недель\n2018,488 тыс. руб.,64 недель\n2018,167 тыс. руб.,29 недель\n2018,327 тыс. руб.,27 недель\n2018,275 тыс. руб.,13 недель\n2018,205 тыс. руб.,93 недель\n2018,354 тыс. руб.,38 недель', '2015,497 тыс. руб.,82 недель\n2015,391 тыс. руб.,81 недель\n2015,488 тыс. руб.,72 недель\n2015,188 тыс. руб.,72 недель\n2015,320 тыс. руб.,57 недель\n2015,251 тыс. руб.,36 недель\n2015,488 тыс. руб.,96 недель\n2015,379 тыс. руб.,14 недель\n2015,305 тыс. руб.,90 недель\n2015,284 тыс. руб.,33 недель\n2015,180 тыс. руб.,15 недель\n2015,328 тыс. руб.,50 недель\n2015,355 тыс. руб.,84 недель\n2015,426 тыс. руб.,63 недель\n2015,294 тыс. руб.,15 недель\n2015,327 тыс. руб.,72 недель\n2015,452 тыс. руб.,71 недель\n2015,240 тыс. руб.,88 недель', '2019,255 тыс. руб.,56 недель\n2017,280 тыс. руб.,80 недель\n2019,111 тыс. руб.,49 недель\n2015,497 тыс. руб.,82 недель\n2015,391 тыс. руб.,81 недель\n2015,488 тыс. руб.,72 недель\n2016,219 тыс. руб.,11 недель\n2015,188 тыс. руб.,72 недель\n2016,439 тыс. руб.,82 недель\n2016,410 тыс. руб.,26 недель\n2017,166 тыс. руб.,100 недель\n2019,449 тыс. руб.,100 недель\n2019,148 тыс. руб.,51 недель\n2018,246 тыс. руб.,59 недель\n2018,307 тыс. руб.,20 недель\n2019,113 тыс. руб.,41 недель\n2017,278 тыс. руб.,40 недель\n2015,320 тыс. руб.,57 недель\n2016,195 тыс. руб.,37 недель\n2019,330 тыс. руб.,69 недель\n2015,251 тыс. руб.,36 недель\n2015,488 тыс. руб.,96 недель\n2017,215 тыс. руб.,22 недель\n2017,151 тыс. руб.,93 недель\n2016,470 тыс. руб.,84 недель\n2018,376 тыс. руб.,53 недель\n2018,488 тыс. руб.,13 недель\n2017,164 тыс. руб.,15 недель\n2016,226 тыс. руб.,51 недель\n2015,379 тыс. руб.,14 недель\n2015,305 тыс. руб.,90 недель\n2015,284 тыс. руб.,33 недель\n2016,158 тыс. руб.,55 недель\n2016,257 тыс. руб.,14 недель\n2015,180 тыс. руб.,15 недель\n2017,262 тыс. руб.,73 недель\n2019,245 тыс. руб.,99 недель\n2015,328 тыс. руб.,50 недель\n2015,355 тыс. руб.,84 недель\n2016,358 тыс. руб.,70 недель\n2017,463 тыс. руб.,33 недель\n2015,426 тыс. руб.,63 недель\n2016,153 тыс. руб.,19 недель\n2015,294 тыс. руб.,15 недель\n2016,190 тыс. руб.,61 недель\n2019,256 тыс. руб.,16 недель\n2015,327 тыс. руб.,72 недель\n2017,499 тыс. руб.,41 недель\n2015,452 тыс. руб.,71 недель\n2018,142 тыс. руб.,57 недель\n2019,452 тыс. руб.,100 недель\n2015,240 тыс. руб.,88 недель\n2017,141 тыс. руб.,72 недель\n2018,215 тыс. руб.,40 недель\n2019,177 тыс. руб.,75 недель\n2019,115 тыс. руб.,15 недель\n2017,148 тыс. руб.,95 недель\n2019,125 тыс. руб.,24 недель\n2019,434 тыс. руб.,88 недель\n2016,348 тыс. руб.,83 недель\n2017,127 тыс. руб.,68 недель\n2018,145 тыс. руб.,41 недель', nan]","year = input()

with open('projects_file.csv', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        info = line.split(',')
        if info[0] <= year:
            print(line)
        if int(info[-2].split()[0]) <= 500:
            print(line)","year = input()

with open('projects_file.csv', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        info = line.split(',')
        if info[0] <= year and int(info[-2].split()[0]) <= 500:
            print(line)","Ошибка в открытых и скрытых тестах. 

Ваш код некорректно выполняет условия задания. Так, он неправильно выполянет условие ""реализованные не позднее, чем в указанном году, со стоимостью не более 500. тыс. руб."". Попробуйте изменить условие if, чтобы скорректировать ошибку.","['open', 'closed', 'closed', 'closed', 'closed']","<Task description>: Ксения анализирует реализованные дизайн-проекты, которые собраны в файле формата csv. Напишите программу, которая выводит все строки, соответствующие реализованным в определенный период проектам, стоимость которых была не более 500 тыс. руб..

Программа должна открывать структурированный текстовый файл projects_file.csv, в кодировке utf-8, где на каждой строке записана следующая информация о дизайн-проекте: год, стоимость проекта, количество недель, за сколько был реализован проект. Например, строка ""2019,200 тыс. руб.,10 недель"" означает, что в 2019 году проект стоимостью 200 тыс. руб. был реализован за 10 недель.
Гарантируется, что стоимость реализованного проекта всегда записана в формате ""<целое число> тыс. руб."".
Гарантируется, что срок реализации проекта всегда записан в формате ""<целое число> недель"".
Разделителями данных в файле служат запятые.
Гарантируется, что в файле есть как минимум одна строка с данными. 
С клавиатуры вводится строка — год.
Программа должна выводить строки из оригинального файла, которые соответствуют проектам, реализованным не позднее, чем в указанном году, со стоимостью не более 500. тыс. руб. (не забудьте удалить символы конца строки!).
Если подходящих под условие строк в файле нет, то программа ничего не выводит.
ДОПОЛНИТЕЛЬНО
Ваше решение будет проверяться на закрытых тестах. Ваш код должен считывать файл projects_file.csv без дополнительных указаний (например, пути к файлу на вашем компьютере).
В открытом тесте используется файл projects_file.csv. Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: 2019 
<Вывод>: 2018,253 тыс. руб.,45 недель
2018,340 тыс. руб.,34 недель
2019,263 тыс. руб.,90 недель
2019,320 тыс. руб.,31 недель
2019,478 тыс. руб.,85 недель
2018,324 тыс. руб.,18 недель
2019,186 тыс. руб.,82 недель
2018,349 тыс. руб.,95 недель
2019,479 тыс. руб.,31 недель
2019,192 тыс. руб.,36 недель
2018,393 тыс. руб.,90 недель
2019,206 тыс. руб.,70 недель
2019,185 тыс. руб.,27 недель
2019,396 тыс. руб.,36 недель
2018,445 тыс. руб.,6 недель
2019,492 тыс. руб.,77 недель
2018,267 тыс. руб.,38 недель
2018,260 тыс. руб.,79 недель
2018,214 тыс. руб.,47 недель
2018,151 тыс. руб.,70 недель
2019,116 тыс. руб.,25 недель
2019,178 тыс. руб.,9 недель
2019,100 тыс. руб.,24 недель
2019,112 тыс. руб.,91 недель
2019,369 тыс. руб.,24 недель
2019,166 тыс. руб.,67 недель
2019,498 тыс. руб.,83 недель
2018,276 тыс. руб.,48 недель
2019,493 тыс. руб.,20 недель
2019,358 тыс. руб.,27 недель
2019,394 тыс. руб.,49 недель
2019,429 тыс. руб.,77 недель
2019,375 тыс. руб.,44 недель
2019,245 тыс. руб.,74 недель
2018,313 тыс. руб.,5 недель
2018,244 тыс. руб.,26 недель
2018,432 тыс. руб.,87 недель
2019,291 тыс. руб.,96 недель
2018,355 тыс. руб.,100 недель
2019,377 тыс. руб.,39 недель 
<Example 2>: 
<Тип теста 2>: closed 
<Ввод>: 2018 
<Вывод>: 2018,240 тыс. руб.,86 недель
2018,491 тыс. руб.,75 недель
2018,310 тыс. руб.,29 недель
2018,111 тыс. руб.,60 недель
2018,252 тыс. руб.,81 недель
2018,448 тыс. руб.,55 недель
2018,397 тыс. руб.,73 недель
2018,472 тыс. руб.,74 недель
2018,357 тыс. руб.,17 недель
2018,364 тыс. руб.,82 недель
2018,187 тыс. руб.,89 недель
2018,267 тыс. руб.,57 недель
2018,254 тыс. руб.,18 недель
2018,330 тыс. руб.,95 недель
2018,488 тыс. руб.,64 недель
2018,167 тыс. руб.,29 недель
2018,327 тыс. руб.,27 недель
2018,275 тыс. руб.,13 недель
2018,205 тыс. руб.,93 недель
2018,354 тыс. руб.,38 недель 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: 2015 
<Вывод>: 2015,497 тыс. руб.,82 недель
2015,391 тыс. руб.,81 недель
2015,488 тыс. руб.,72 недель
2015,188 тыс. руб.,72 недель
2015,320 тыс. руб.,57 недель
2015,251 тыс. руб.,36 недель
2015,488 тыс. руб.,96 недель
2015,379 тыс. руб.,14 недель
2015,305 тыс. руб.,90 недель
2015,284 тыс. руб.,33 недель
2015,180 тыс. руб.,15 недель
2015,328 тыс. руб.,50 недель
2015,355 тыс. руб.,84 недель
2015,426 тыс. руб.,63 недель
2015,294 тыс. руб.,15 недель
2015,327 тыс. руб.,72 недель
2015,452 тыс. руб.,71 недель
2015,240 тыс. руб.,88 недель 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: 2019 
<Вывод>: 2019,255 тыс. руб.,56 недель
2017,280 тыс. руб.,80 недель
2019,111 тыс. руб.,49 недель
2015,497 тыс. руб.,82 недель
2015,391 тыс. руб.,81 недель
2015,488 тыс. руб.,72 недель
2016,219 тыс. руб.,11 недель
2015,188 тыс. руб.,72 недель
2016,439 тыс. руб.,82 недель
2016,410 тыс. руб.,26 недель
2017,166 тыс. руб.,100 недель
2019,449 тыс. руб.,100 недель
2019,148 тыс. руб.,51 недель
2018,246 тыс. руб.,59 недель
2018,307 тыс. руб.,20 недель
2019,113 тыс. руб.,41 недель
2017,278 тыс. руб.,40 недель
2015,320 тыс. руб.,57 недель
2016,195 тыс. руб.,37 недель
2019,330 тыс. руб.,69 недель
2015,251 тыс. руб.,36 недель
2015,488 тыс. руб.,96 недель
2017,215 тыс. руб.,22 недель
2017,151 тыс. руб.,93 недель
2016,470 тыс. руб.,84 недель
2018,376 тыс. руб.,53 недель
2018,488 тыс. руб.,13 недель
2017,164 тыс. руб.,15 недель
2016,226 тыс. руб.,51 недель
2015,379 тыс. руб.,14 недель
2015,305 тыс. руб.,90 недель
2015,284 тыс. руб.,33 недель
2016,158 тыс. руб.,55 недель
2016,257 тыс. руб.,14 недель
2015,180 тыс. руб.,15 недель
2017,262 тыс. руб.,73 недель
2019,245 тыс. руб.,99 недель
2015,328 тыс. руб.,50 недель
2015,355 тыс. руб.,84 недель
2016,358 тыс. руб.,70 недель
2017,463 тыс. руб.,33 недель
2015,426 тыс. руб.,63 недель
2016,153 тыс. руб.,19 недель
2015,294 тыс. руб.,15 недель
2016,190 тыс. руб.,61 недель
2019,256 тыс. руб.,16 недель
2015,327 тыс. руб.,72 недель
2017,499 тыс. руб.,41 недель
2015,452 тыс. руб.,71 недель
2018,142 тыс. руб.,57 недель
2019,452 тыс. руб.,100 недель
2015,240 тыс. руб.,88 недель
2017,141 тыс. руб.,72 недель
2018,215 тыс. руб.,40 недель
2019,177 тыс. руб.,75 недель
2019,115 тыс. руб.,15 недель
2017,148 тыс. руб.,95 недель
2019,125 тыс. руб.,24 недель
2019,434 тыс. руб.,88 недель
2016,348 тыс. руб.,83 недель
2017,127 тыс. руб.,68 недель
2018,145 тыс. руб.,41 недель 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: 1990 
<Вывод>: nan 
<Решение студента>: year = input()

with open('projects_file.csv', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        info = line.split(',')
        if info[0] <= year:
            print(line)
        if int(info[-2].split()[0]) <= 500:
            print(line) 
<Идеальное решение>: year = input()

with open('projects_file.csv', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        info = line.split(',')
        if info[0] <= year and int(info[-2].split()[0]) <= 500:
            print(line) 


<Комментарий эксперта>:"
74,117,7,"Ксения анализирует реализованные дизайн-проекты, которые собраны в файле формата csv. Напишите программу, которая выводит все строки, соответствующие реализованным в определенный период проектам, стоимость которых была не более 500 тыс. руб..

Программа должна открывать структурированный текстовый файл projects_file.csv, в кодировке utf-8, где на каждой строке записана следующая информация о дизайн-проекте: год, стоимость проекта, количество недель, за сколько был реализован проект. Например, строка ""2019,200 тыс. руб.,10 недель"" означает, что в 2019 году проект стоимостью 200 тыс. руб. был реализован за 10 недель.
Гарантируется, что стоимость реализованного проекта всегда записана в формате ""<целое число> тыс. руб."".
Гарантируется, что срок реализации проекта всегда записан в формате ""<целое число> недель"".
Разделителями данных в файле служат запятые.
Гарантируется, что в файле есть как минимум одна строка с данными. 
С клавиатуры вводится строка — год.
Программа должна выводить строки из оригинального файла, которые соответствуют проектам, реализованным не позднее, чем в указанном году, со стоимостью не более 500. тыс. руб. (не забудьте удалить символы конца строки!).
Если подходящих под условие строк в файле нет, то программа ничего не выводит.
ДОПОЛНИТЕЛЬНО
Ваше решение будет проверяться на закрытых тестах. Ваш код должен считывать файл projects_file.csv без дополнительных указаний (например, пути к файлу на вашем компьютере).
В открытом тесте используется файл projects_file.csv. Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.","['2019', '2018', '2015', '2019', '1990']","['2018,253 тыс. руб.,45 недель\n2018,340 тыс. руб.,34 недель\n2019,263 тыс. руб.,90 недель\n2019,320 тыс. руб.,31 недель\n2019,478 тыс. руб.,85 недель\n2018,324 тыс. руб.,18 недель\n2019,186 тыс. руб.,82 недель\n2018,349 тыс. руб.,95 недель\n2019,479 тыс. руб.,31 недель\n2019,192 тыс. руб.,36 недель\n2018,393 тыс. руб.,90 недель\n2019,206 тыс. руб.,70 недель\n2019,185 тыс. руб.,27 недель\n2019,396 тыс. руб.,36 недель\n2018,445 тыс. руб.,6 недель\n2019,492 тыс. руб.,77 недель\n2018,267 тыс. руб.,38 недель\n2018,260 тыс. руб.,79 недель\n2018,214 тыс. руб.,47 недель\n2018,151 тыс. руб.,70 недель\n2019,116 тыс. руб.,25 недель\n2019,178 тыс. руб.,9 недель\n2019,100 тыс. руб.,24 недель\n2019,112 тыс. руб.,91 недель\n2019,369 тыс. руб.,24 недель\n2019,166 тыс. руб.,67 недель\n2019,498 тыс. руб.,83 недель\n2018,276 тыс. руб.,48 недель\n2019,493 тыс. руб.,20 недель\n2019,358 тыс. руб.,27 недель\n2019,394 тыс. руб.,49 недель\n2019,429 тыс. руб.,77 недель\n2019,375 тыс. руб.,44 недель\n2019,245 тыс. руб.,74 недель\n2018,313 тыс. руб.,5 недель\n2018,244 тыс. руб.,26 недель\n2018,432 тыс. руб.,87 недель\n2019,291 тыс. руб.,96 недель\n2018,355 тыс. руб.,100 недель\n2019,377 тыс. руб.,39 недель', '2018,240 тыс. руб.,86 недель\n2018,491 тыс. руб.,75 недель\n2018,310 тыс. руб.,29 недель\n2018,111 тыс. руб.,60 недель\n2018,252 тыс. руб.,81 недель\n2018,448 тыс. руб.,55 недель\n2018,397 тыс. руб.,73 недель\n2018,472 тыс. руб.,74 недель\n2018,357 тыс. руб.,17 недель\n2018,364 тыс. руб.,82 недель\n2018,187 тыс. руб.,89 недель\n2018,267 тыс. руб.,57 недель\n2018,254 тыс. руб.,18 недель\n2018,330 тыс. руб.,95 недель\n2018,488 тыс. руб.,64 недель\n2018,167 тыс. руб.,29 недель\n2018,327 тыс. руб.,27 недель\n2018,275 тыс. руб.,13 недель\n2018,205 тыс. руб.,93 недель\n2018,354 тыс. руб.,38 недель', '2015,497 тыс. руб.,82 недель\n2015,391 тыс. руб.,81 недель\n2015,488 тыс. руб.,72 недель\n2015,188 тыс. руб.,72 недель\n2015,320 тыс. руб.,57 недель\n2015,251 тыс. руб.,36 недель\n2015,488 тыс. руб.,96 недель\n2015,379 тыс. руб.,14 недель\n2015,305 тыс. руб.,90 недель\n2015,284 тыс. руб.,33 недель\n2015,180 тыс. руб.,15 недель\n2015,328 тыс. руб.,50 недель\n2015,355 тыс. руб.,84 недель\n2015,426 тыс. руб.,63 недель\n2015,294 тыс. руб.,15 недель\n2015,327 тыс. руб.,72 недель\n2015,452 тыс. руб.,71 недель\n2015,240 тыс. руб.,88 недель', '2019,255 тыс. руб.,56 недель\n2017,280 тыс. руб.,80 недель\n2019,111 тыс. руб.,49 недель\n2015,497 тыс. руб.,82 недель\n2015,391 тыс. руб.,81 недель\n2015,488 тыс. руб.,72 недель\n2016,219 тыс. руб.,11 недель\n2015,188 тыс. руб.,72 недель\n2016,439 тыс. руб.,82 недель\n2016,410 тыс. руб.,26 недель\n2017,166 тыс. руб.,100 недель\n2019,449 тыс. руб.,100 недель\n2019,148 тыс. руб.,51 недель\n2018,246 тыс. руб.,59 недель\n2018,307 тыс. руб.,20 недель\n2019,113 тыс. руб.,41 недель\n2017,278 тыс. руб.,40 недель\n2015,320 тыс. руб.,57 недель\n2016,195 тыс. руб.,37 недель\n2019,330 тыс. руб.,69 недель\n2015,251 тыс. руб.,36 недель\n2015,488 тыс. руб.,96 недель\n2017,215 тыс. руб.,22 недель\n2017,151 тыс. руб.,93 недель\n2016,470 тыс. руб.,84 недель\n2018,376 тыс. руб.,53 недель\n2018,488 тыс. руб.,13 недель\n2017,164 тыс. руб.,15 недель\n2016,226 тыс. руб.,51 недель\n2015,379 тыс. руб.,14 недель\n2015,305 тыс. руб.,90 недель\n2015,284 тыс. руб.,33 недель\n2016,158 тыс. руб.,55 недель\n2016,257 тыс. руб.,14 недель\n2015,180 тыс. руб.,15 недель\n2017,262 тыс. руб.,73 недель\n2019,245 тыс. руб.,99 недель\n2015,328 тыс. руб.,50 недель\n2015,355 тыс. руб.,84 недель\n2016,358 тыс. руб.,70 недель\n2017,463 тыс. руб.,33 недель\n2015,426 тыс. руб.,63 недель\n2016,153 тыс. руб.,19 недель\n2015,294 тыс. руб.,15 недель\n2016,190 тыс. руб.,61 недель\n2019,256 тыс. руб.,16 недель\n2015,327 тыс. руб.,72 недель\n2017,499 тыс. руб.,41 недель\n2015,452 тыс. руб.,71 недель\n2018,142 тыс. руб.,57 недель\n2019,452 тыс. руб.,100 недель\n2015,240 тыс. руб.,88 недель\n2017,141 тыс. руб.,72 недель\n2018,215 тыс. руб.,40 недель\n2019,177 тыс. руб.,75 недель\n2019,115 тыс. руб.,15 недель\n2017,148 тыс. руб.,95 недель\n2019,125 тыс. руб.,24 недель\n2019,434 тыс. руб.,88 недель\n2016,348 тыс. руб.,83 недель\n2017,127 тыс. руб.,68 недель\n2018,145 тыс. руб.,41 недель', nan]","year = input()

with open('projects_file.csv', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        info = line.split(',')
        if info[0] <= year and int(info[-2].split()[0]) <= 500:
        print(line)","year = input()

with open('projects_file.csv', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        info = line.split(',')
        if info[0] <= year and int(info[-2].split()[0]) <= 500:
            print(line)",Ошибка в табуляции print().,"['open', 'closed', 'closed', 'closed', 'closed']","<Task description>: Ксения анализирует реализованные дизайн-проекты, которые собраны в файле формата csv. Напишите программу, которая выводит все строки, соответствующие реализованным в определенный период проектам, стоимость которых была не более 500 тыс. руб..

Программа должна открывать структурированный текстовый файл projects_file.csv, в кодировке utf-8, где на каждой строке записана следующая информация о дизайн-проекте: год, стоимость проекта, количество недель, за сколько был реализован проект. Например, строка ""2019,200 тыс. руб.,10 недель"" означает, что в 2019 году проект стоимостью 200 тыс. руб. был реализован за 10 недель.
Гарантируется, что стоимость реализованного проекта всегда записана в формате ""<целое число> тыс. руб."".
Гарантируется, что срок реализации проекта всегда записан в формате ""<целое число> недель"".
Разделителями данных в файле служат запятые.
Гарантируется, что в файле есть как минимум одна строка с данными. 
С клавиатуры вводится строка — год.
Программа должна выводить строки из оригинального файла, которые соответствуют проектам, реализованным не позднее, чем в указанном году, со стоимостью не более 500. тыс. руб. (не забудьте удалить символы конца строки!).
Если подходящих под условие строк в файле нет, то программа ничего не выводит.
ДОПОЛНИТЕЛЬНО
Ваше решение будет проверяться на закрытых тестах. Ваш код должен считывать файл projects_file.csv без дополнительных указаний (например, пути к файлу на вашем компьютере).
В открытом тесте используется файл projects_file.csv. Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: 2019 
<Вывод>: 2018,253 тыс. руб.,45 недель
2018,340 тыс. руб.,34 недель
2019,263 тыс. руб.,90 недель
2019,320 тыс. руб.,31 недель
2019,478 тыс. руб.,85 недель
2018,324 тыс. руб.,18 недель
2019,186 тыс. руб.,82 недель
2018,349 тыс. руб.,95 недель
2019,479 тыс. руб.,31 недель
2019,192 тыс. руб.,36 недель
2018,393 тыс. руб.,90 недель
2019,206 тыс. руб.,70 недель
2019,185 тыс. руб.,27 недель
2019,396 тыс. руб.,36 недель
2018,445 тыс. руб.,6 недель
2019,492 тыс. руб.,77 недель
2018,267 тыс. руб.,38 недель
2018,260 тыс. руб.,79 недель
2018,214 тыс. руб.,47 недель
2018,151 тыс. руб.,70 недель
2019,116 тыс. руб.,25 недель
2019,178 тыс. руб.,9 недель
2019,100 тыс. руб.,24 недель
2019,112 тыс. руб.,91 недель
2019,369 тыс. руб.,24 недель
2019,166 тыс. руб.,67 недель
2019,498 тыс. руб.,83 недель
2018,276 тыс. руб.,48 недель
2019,493 тыс. руб.,20 недель
2019,358 тыс. руб.,27 недель
2019,394 тыс. руб.,49 недель
2019,429 тыс. руб.,77 недель
2019,375 тыс. руб.,44 недель
2019,245 тыс. руб.,74 недель
2018,313 тыс. руб.,5 недель
2018,244 тыс. руб.,26 недель
2018,432 тыс. руб.,87 недель
2019,291 тыс. руб.,96 недель
2018,355 тыс. руб.,100 недель
2019,377 тыс. руб.,39 недель 
<Example 2>: 
<Тип теста 2>: closed 
<Ввод>: 2018 
<Вывод>: 2018,240 тыс. руб.,86 недель
2018,491 тыс. руб.,75 недель
2018,310 тыс. руб.,29 недель
2018,111 тыс. руб.,60 недель
2018,252 тыс. руб.,81 недель
2018,448 тыс. руб.,55 недель
2018,397 тыс. руб.,73 недель
2018,472 тыс. руб.,74 недель
2018,357 тыс. руб.,17 недель
2018,364 тыс. руб.,82 недель
2018,187 тыс. руб.,89 недель
2018,267 тыс. руб.,57 недель
2018,254 тыс. руб.,18 недель
2018,330 тыс. руб.,95 недель
2018,488 тыс. руб.,64 недель
2018,167 тыс. руб.,29 недель
2018,327 тыс. руб.,27 недель
2018,275 тыс. руб.,13 недель
2018,205 тыс. руб.,93 недель
2018,354 тыс. руб.,38 недель 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: 2015 
<Вывод>: 2015,497 тыс. руб.,82 недель
2015,391 тыс. руб.,81 недель
2015,488 тыс. руб.,72 недель
2015,188 тыс. руб.,72 недель
2015,320 тыс. руб.,57 недель
2015,251 тыс. руб.,36 недель
2015,488 тыс. руб.,96 недель
2015,379 тыс. руб.,14 недель
2015,305 тыс. руб.,90 недель
2015,284 тыс. руб.,33 недель
2015,180 тыс. руб.,15 недель
2015,328 тыс. руб.,50 недель
2015,355 тыс. руб.,84 недель
2015,426 тыс. руб.,63 недель
2015,294 тыс. руб.,15 недель
2015,327 тыс. руб.,72 недель
2015,452 тыс. руб.,71 недель
2015,240 тыс. руб.,88 недель 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: 2019 
<Вывод>: 2019,255 тыс. руб.,56 недель
2017,280 тыс. руб.,80 недель
2019,111 тыс. руб.,49 недель
2015,497 тыс. руб.,82 недель
2015,391 тыс. руб.,81 недель
2015,488 тыс. руб.,72 недель
2016,219 тыс. руб.,11 недель
2015,188 тыс. руб.,72 недель
2016,439 тыс. руб.,82 недель
2016,410 тыс. руб.,26 недель
2017,166 тыс. руб.,100 недель
2019,449 тыс. руб.,100 недель
2019,148 тыс. руб.,51 недель
2018,246 тыс. руб.,59 недель
2018,307 тыс. руб.,20 недель
2019,113 тыс. руб.,41 недель
2017,278 тыс. руб.,40 недель
2015,320 тыс. руб.,57 недель
2016,195 тыс. руб.,37 недель
2019,330 тыс. руб.,69 недель
2015,251 тыс. руб.,36 недель
2015,488 тыс. руб.,96 недель
2017,215 тыс. руб.,22 недель
2017,151 тыс. руб.,93 недель
2016,470 тыс. руб.,84 недель
2018,376 тыс. руб.,53 недель
2018,488 тыс. руб.,13 недель
2017,164 тыс. руб.,15 недель
2016,226 тыс. руб.,51 недель
2015,379 тыс. руб.,14 недель
2015,305 тыс. руб.,90 недель
2015,284 тыс. руб.,33 недель
2016,158 тыс. руб.,55 недель
2016,257 тыс. руб.,14 недель
2015,180 тыс. руб.,15 недель
2017,262 тыс. руб.,73 недель
2019,245 тыс. руб.,99 недель
2015,328 тыс. руб.,50 недель
2015,355 тыс. руб.,84 недель
2016,358 тыс. руб.,70 недель
2017,463 тыс. руб.,33 недель
2015,426 тыс. руб.,63 недель
2016,153 тыс. руб.,19 недель
2015,294 тыс. руб.,15 недель
2016,190 тыс. руб.,61 недель
2019,256 тыс. руб.,16 недель
2015,327 тыс. руб.,72 недель
2017,499 тыс. руб.,41 недель
2015,452 тыс. руб.,71 недель
2018,142 тыс. руб.,57 недель
2019,452 тыс. руб.,100 недель
2015,240 тыс. руб.,88 недель
2017,141 тыс. руб.,72 недель
2018,215 тыс. руб.,40 недель
2019,177 тыс. руб.,75 недель
2019,115 тыс. руб.,15 недель
2017,148 тыс. руб.,95 недель
2019,125 тыс. руб.,24 недель
2019,434 тыс. руб.,88 недель
2016,348 тыс. руб.,83 недель
2017,127 тыс. руб.,68 недель
2018,145 тыс. руб.,41 недель 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: 1990 
<Вывод>: nan 
<Решение студента>: year = input()

with open('projects_file.csv', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        info = line.split(',')
        if info[0] <= year and int(info[-2].split()[0]) <= 500:
        print(line) 
<Идеальное решение>: year = input()

with open('projects_file.csv', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        info = line.split(',')
        if info[0] <= year and int(info[-2].split()[0]) <= 500:
            print(line) 


<Комментарий эксперта>:"
75,118,7,"Ксения анализирует реализованные дизайн-проекты, которые собраны в файле формата csv. Напишите программу, которая выводит все строки, соответствующие реализованным в определенный период проектам, стоимость которых была не более 500 тыс. руб..

Программа должна открывать структурированный текстовый файл projects_file.csv, в кодировке utf-8, где на каждой строке записана следующая информация о дизайн-проекте: год, стоимость проекта, количество недель, за сколько был реализован проект. Например, строка ""2019,200 тыс. руб.,10 недель"" означает, что в 2019 году проект стоимостью 200 тыс. руб. был реализован за 10 недель.
Гарантируется, что стоимость реализованного проекта всегда записана в формате ""<целое число> тыс. руб."".
Гарантируется, что срок реализации проекта всегда записан в формате ""<целое число> недель"".
Разделителями данных в файле служат запятые.
Гарантируется, что в файле есть как минимум одна строка с данными. 
С клавиатуры вводится строка — год.
Программа должна выводить строки из оригинального файла, которые соответствуют проектам, реализованным не позднее, чем в указанном году, со стоимостью не более 500. тыс. руб. (не забудьте удалить символы конца строки!).
Если подходящих под условие строк в файле нет, то программа ничего не выводит.
ДОПОЛНИТЕЛЬНО
Ваше решение будет проверяться на закрытых тестах. Ваш код должен считывать файл projects_file.csv без дополнительных указаний (например, пути к файлу на вашем компьютере).
В открытом тесте используется файл projects_file.csv. Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.","['2019', '2018', '2015', '2019', '1990']","['2018,253 тыс. руб.,45 недель\n2018,340 тыс. руб.,34 недель\n2019,263 тыс. руб.,90 недель\n2019,320 тыс. руб.,31 недель\n2019,478 тыс. руб.,85 недель\n2018,324 тыс. руб.,18 недель\n2019,186 тыс. руб.,82 недель\n2018,349 тыс. руб.,95 недель\n2019,479 тыс. руб.,31 недель\n2019,192 тыс. руб.,36 недель\n2018,393 тыс. руб.,90 недель\n2019,206 тыс. руб.,70 недель\n2019,185 тыс. руб.,27 недель\n2019,396 тыс. руб.,36 недель\n2018,445 тыс. руб.,6 недель\n2019,492 тыс. руб.,77 недель\n2018,267 тыс. руб.,38 недель\n2018,260 тыс. руб.,79 недель\n2018,214 тыс. руб.,47 недель\n2018,151 тыс. руб.,70 недель\n2019,116 тыс. руб.,25 недель\n2019,178 тыс. руб.,9 недель\n2019,100 тыс. руб.,24 недель\n2019,112 тыс. руб.,91 недель\n2019,369 тыс. руб.,24 недель\n2019,166 тыс. руб.,67 недель\n2019,498 тыс. руб.,83 недель\n2018,276 тыс. руб.,48 недель\n2019,493 тыс. руб.,20 недель\n2019,358 тыс. руб.,27 недель\n2019,394 тыс. руб.,49 недель\n2019,429 тыс. руб.,77 недель\n2019,375 тыс. руб.,44 недель\n2019,245 тыс. руб.,74 недель\n2018,313 тыс. руб.,5 недель\n2018,244 тыс. руб.,26 недель\n2018,432 тыс. руб.,87 недель\n2019,291 тыс. руб.,96 недель\n2018,355 тыс. руб.,100 недель\n2019,377 тыс. руб.,39 недель', '2018,240 тыс. руб.,86 недель\n2018,491 тыс. руб.,75 недель\n2018,310 тыс. руб.,29 недель\n2018,111 тыс. руб.,60 недель\n2018,252 тыс. руб.,81 недель\n2018,448 тыс. руб.,55 недель\n2018,397 тыс. руб.,73 недель\n2018,472 тыс. руб.,74 недель\n2018,357 тыс. руб.,17 недель\n2018,364 тыс. руб.,82 недель\n2018,187 тыс. руб.,89 недель\n2018,267 тыс. руб.,57 недель\n2018,254 тыс. руб.,18 недель\n2018,330 тыс. руб.,95 недель\n2018,488 тыс. руб.,64 недель\n2018,167 тыс. руб.,29 недель\n2018,327 тыс. руб.,27 недель\n2018,275 тыс. руб.,13 недель\n2018,205 тыс. руб.,93 недель\n2018,354 тыс. руб.,38 недель', '2015,497 тыс. руб.,82 недель\n2015,391 тыс. руб.,81 недель\n2015,488 тыс. руб.,72 недель\n2015,188 тыс. руб.,72 недель\n2015,320 тыс. руб.,57 недель\n2015,251 тыс. руб.,36 недель\n2015,488 тыс. руб.,96 недель\n2015,379 тыс. руб.,14 недель\n2015,305 тыс. руб.,90 недель\n2015,284 тыс. руб.,33 недель\n2015,180 тыс. руб.,15 недель\n2015,328 тыс. руб.,50 недель\n2015,355 тыс. руб.,84 недель\n2015,426 тыс. руб.,63 недель\n2015,294 тыс. руб.,15 недель\n2015,327 тыс. руб.,72 недель\n2015,452 тыс. руб.,71 недель\n2015,240 тыс. руб.,88 недель', '2019,255 тыс. руб.,56 недель\n2017,280 тыс. руб.,80 недель\n2019,111 тыс. руб.,49 недель\n2015,497 тыс. руб.,82 недель\n2015,391 тыс. руб.,81 недель\n2015,488 тыс. руб.,72 недель\n2016,219 тыс. руб.,11 недель\n2015,188 тыс. руб.,72 недель\n2016,439 тыс. руб.,82 недель\n2016,410 тыс. руб.,26 недель\n2017,166 тыс. руб.,100 недель\n2019,449 тыс. руб.,100 недель\n2019,148 тыс. руб.,51 недель\n2018,246 тыс. руб.,59 недель\n2018,307 тыс. руб.,20 недель\n2019,113 тыс. руб.,41 недель\n2017,278 тыс. руб.,40 недель\n2015,320 тыс. руб.,57 недель\n2016,195 тыс. руб.,37 недель\n2019,330 тыс. руб.,69 недель\n2015,251 тыс. руб.,36 недель\n2015,488 тыс. руб.,96 недель\n2017,215 тыс. руб.,22 недель\n2017,151 тыс. руб.,93 недель\n2016,470 тыс. руб.,84 недель\n2018,376 тыс. руб.,53 недель\n2018,488 тыс. руб.,13 недель\n2017,164 тыс. руб.,15 недель\n2016,226 тыс. руб.,51 недель\n2015,379 тыс. руб.,14 недель\n2015,305 тыс. руб.,90 недель\n2015,284 тыс. руб.,33 недель\n2016,158 тыс. руб.,55 недель\n2016,257 тыс. руб.,14 недель\n2015,180 тыс. руб.,15 недель\n2017,262 тыс. руб.,73 недель\n2019,245 тыс. руб.,99 недель\n2015,328 тыс. руб.,50 недель\n2015,355 тыс. руб.,84 недель\n2016,358 тыс. руб.,70 недель\n2017,463 тыс. руб.,33 недель\n2015,426 тыс. руб.,63 недель\n2016,153 тыс. руб.,19 недель\n2015,294 тыс. руб.,15 недель\n2016,190 тыс. руб.,61 недель\n2019,256 тыс. руб.,16 недель\n2015,327 тыс. руб.,72 недель\n2017,499 тыс. руб.,41 недель\n2015,452 тыс. руб.,71 недель\n2018,142 тыс. руб.,57 недель\n2019,452 тыс. руб.,100 недель\n2015,240 тыс. руб.,88 недель\n2017,141 тыс. руб.,72 недель\n2018,215 тыс. руб.,40 недель\n2019,177 тыс. руб.,75 недель\n2019,115 тыс. руб.,15 недель\n2017,148 тыс. руб.,95 недель\n2019,125 тыс. руб.,24 недель\n2019,434 тыс. руб.,88 недель\n2016,348 тыс. руб.,83 недель\n2017,127 тыс. руб.,68 недель\n2018,145 тыс. руб.,41 недель', nan]","year = input()
ans = []

with open('projects_file.csv', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        info = line.split(',')
        if info[0] <= year and int(info[-2].split()[0]) <= 500:
            ans.append(line)

print(*ans)","year = input()

with open('projects_file.csv', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        info = line.split(',')
        if info[0] <= year and int(info[-2].split()[0]) <= 500:
            print(line)","Ошибка в открытых и скрытых тестах. 

Ваш код должен печатать каждую строчку с отдельной строки.","['open', 'closed', 'closed', 'closed', 'closed']","<Task description>: Ксения анализирует реализованные дизайн-проекты, которые собраны в файле формата csv. Напишите программу, которая выводит все строки, соответствующие реализованным в определенный период проектам, стоимость которых была не более 500 тыс. руб..

Программа должна открывать структурированный текстовый файл projects_file.csv, в кодировке utf-8, где на каждой строке записана следующая информация о дизайн-проекте: год, стоимость проекта, количество недель, за сколько был реализован проект. Например, строка ""2019,200 тыс. руб.,10 недель"" означает, что в 2019 году проект стоимостью 200 тыс. руб. был реализован за 10 недель.
Гарантируется, что стоимость реализованного проекта всегда записана в формате ""<целое число> тыс. руб."".
Гарантируется, что срок реализации проекта всегда записан в формате ""<целое число> недель"".
Разделителями данных в файле служат запятые.
Гарантируется, что в файле есть как минимум одна строка с данными. 
С клавиатуры вводится строка — год.
Программа должна выводить строки из оригинального файла, которые соответствуют проектам, реализованным не позднее, чем в указанном году, со стоимостью не более 500. тыс. руб. (не забудьте удалить символы конца строки!).
Если подходящих под условие строк в файле нет, то программа ничего не выводит.
ДОПОЛНИТЕЛЬНО
Ваше решение будет проверяться на закрытых тестах. Ваш код должен считывать файл projects_file.csv без дополнительных указаний (например, пути к файлу на вашем компьютере).
В открытом тесте используется файл projects_file.csv. Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: 2019 
<Вывод>: 2018,253 тыс. руб.,45 недель
2018,340 тыс. руб.,34 недель
2019,263 тыс. руб.,90 недель
2019,320 тыс. руб.,31 недель
2019,478 тыс. руб.,85 недель
2018,324 тыс. руб.,18 недель
2019,186 тыс. руб.,82 недель
2018,349 тыс. руб.,95 недель
2019,479 тыс. руб.,31 недель
2019,192 тыс. руб.,36 недель
2018,393 тыс. руб.,90 недель
2019,206 тыс. руб.,70 недель
2019,185 тыс. руб.,27 недель
2019,396 тыс. руб.,36 недель
2018,445 тыс. руб.,6 недель
2019,492 тыс. руб.,77 недель
2018,267 тыс. руб.,38 недель
2018,260 тыс. руб.,79 недель
2018,214 тыс. руб.,47 недель
2018,151 тыс. руб.,70 недель
2019,116 тыс. руб.,25 недель
2019,178 тыс. руб.,9 недель
2019,100 тыс. руб.,24 недель
2019,112 тыс. руб.,91 недель
2019,369 тыс. руб.,24 недель
2019,166 тыс. руб.,67 недель
2019,498 тыс. руб.,83 недель
2018,276 тыс. руб.,48 недель
2019,493 тыс. руб.,20 недель
2019,358 тыс. руб.,27 недель
2019,394 тыс. руб.,49 недель
2019,429 тыс. руб.,77 недель
2019,375 тыс. руб.,44 недель
2019,245 тыс. руб.,74 недель
2018,313 тыс. руб.,5 недель
2018,244 тыс. руб.,26 недель
2018,432 тыс. руб.,87 недель
2019,291 тыс. руб.,96 недель
2018,355 тыс. руб.,100 недель
2019,377 тыс. руб.,39 недель 
<Example 2>: 
<Тип теста 2>: closed 
<Ввод>: 2018 
<Вывод>: 2018,240 тыс. руб.,86 недель
2018,491 тыс. руб.,75 недель
2018,310 тыс. руб.,29 недель
2018,111 тыс. руб.,60 недель
2018,252 тыс. руб.,81 недель
2018,448 тыс. руб.,55 недель
2018,397 тыс. руб.,73 недель
2018,472 тыс. руб.,74 недель
2018,357 тыс. руб.,17 недель
2018,364 тыс. руб.,82 недель
2018,187 тыс. руб.,89 недель
2018,267 тыс. руб.,57 недель
2018,254 тыс. руб.,18 недель
2018,330 тыс. руб.,95 недель
2018,488 тыс. руб.,64 недель
2018,167 тыс. руб.,29 недель
2018,327 тыс. руб.,27 недель
2018,275 тыс. руб.,13 недель
2018,205 тыс. руб.,93 недель
2018,354 тыс. руб.,38 недель 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: 2015 
<Вывод>: 2015,497 тыс. руб.,82 недель
2015,391 тыс. руб.,81 недель
2015,488 тыс. руб.,72 недель
2015,188 тыс. руб.,72 недель
2015,320 тыс. руб.,57 недель
2015,251 тыс. руб.,36 недель
2015,488 тыс. руб.,96 недель
2015,379 тыс. руб.,14 недель
2015,305 тыс. руб.,90 недель
2015,284 тыс. руб.,33 недель
2015,180 тыс. руб.,15 недель
2015,328 тыс. руб.,50 недель
2015,355 тыс. руб.,84 недель
2015,426 тыс. руб.,63 недель
2015,294 тыс. руб.,15 недель
2015,327 тыс. руб.,72 недель
2015,452 тыс. руб.,71 недель
2015,240 тыс. руб.,88 недель 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: 2019 
<Вывод>: 2019,255 тыс. руб.,56 недель
2017,280 тыс. руб.,80 недель
2019,111 тыс. руб.,49 недель
2015,497 тыс. руб.,82 недель
2015,391 тыс. руб.,81 недель
2015,488 тыс. руб.,72 недель
2016,219 тыс. руб.,11 недель
2015,188 тыс. руб.,72 недель
2016,439 тыс. руб.,82 недель
2016,410 тыс. руб.,26 недель
2017,166 тыс. руб.,100 недель
2019,449 тыс. руб.,100 недель
2019,148 тыс. руб.,51 недель
2018,246 тыс. руб.,59 недель
2018,307 тыс. руб.,20 недель
2019,113 тыс. руб.,41 недель
2017,278 тыс. руб.,40 недель
2015,320 тыс. руб.,57 недель
2016,195 тыс. руб.,37 недель
2019,330 тыс. руб.,69 недель
2015,251 тыс. руб.,36 недель
2015,488 тыс. руб.,96 недель
2017,215 тыс. руб.,22 недель
2017,151 тыс. руб.,93 недель
2016,470 тыс. руб.,84 недель
2018,376 тыс. руб.,53 недель
2018,488 тыс. руб.,13 недель
2017,164 тыс. руб.,15 недель
2016,226 тыс. руб.,51 недель
2015,379 тыс. руб.,14 недель
2015,305 тыс. руб.,90 недель
2015,284 тыс. руб.,33 недель
2016,158 тыс. руб.,55 недель
2016,257 тыс. руб.,14 недель
2015,180 тыс. руб.,15 недель
2017,262 тыс. руб.,73 недель
2019,245 тыс. руб.,99 недель
2015,328 тыс. руб.,50 недель
2015,355 тыс. руб.,84 недель
2016,358 тыс. руб.,70 недель
2017,463 тыс. руб.,33 недель
2015,426 тыс. руб.,63 недель
2016,153 тыс. руб.,19 недель
2015,294 тыс. руб.,15 недель
2016,190 тыс. руб.,61 недель
2019,256 тыс. руб.,16 недель
2015,327 тыс. руб.,72 недель
2017,499 тыс. руб.,41 недель
2015,452 тыс. руб.,71 недель
2018,142 тыс. руб.,57 недель
2019,452 тыс. руб.,100 недель
2015,240 тыс. руб.,88 недель
2017,141 тыс. руб.,72 недель
2018,215 тыс. руб.,40 недель
2019,177 тыс. руб.,75 недель
2019,115 тыс. руб.,15 недель
2017,148 тыс. руб.,95 недель
2019,125 тыс. руб.,24 недель
2019,434 тыс. руб.,88 недель
2016,348 тыс. руб.,83 недель
2017,127 тыс. руб.,68 недель
2018,145 тыс. руб.,41 недель 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: 1990 
<Вывод>: nan 
<Решение студента>: year = input()
ans = []

with open('projects_file.csv', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        info = line.split(',')
        if info[0] <= year and int(info[-2].split()[0]) <= 500:
            ans.append(line)

print(*ans) 
<Идеальное решение>: year = input()

with open('projects_file.csv', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        info = line.split(',')
        if info[0] <= year and int(info[-2].split()[0]) <= 500:
            print(line) 


<Комментарий эксперта>:"
76,119,7,"Ксения анализирует реализованные дизайн-проекты, которые собраны в файле формата csv. Напишите программу, которая выводит все строки, соответствующие реализованным в определенный период проектам, стоимость которых была не более 500 тыс. руб..

Программа должна открывать структурированный текстовый файл projects_file.csv, в кодировке utf-8, где на каждой строке записана следующая информация о дизайн-проекте: год, стоимость проекта, количество недель, за сколько был реализован проект. Например, строка ""2019,200 тыс. руб.,10 недель"" означает, что в 2019 году проект стоимостью 200 тыс. руб. был реализован за 10 недель.
Гарантируется, что стоимость реализованного проекта всегда записана в формате ""<целое число> тыс. руб."".
Гарантируется, что срок реализации проекта всегда записан в формате ""<целое число> недель"".
Разделителями данных в файле служат запятые.
Гарантируется, что в файле есть как минимум одна строка с данными. 
С клавиатуры вводится строка — год.
Программа должна выводить строки из оригинального файла, которые соответствуют проектам, реализованным не позднее, чем в указанном году, со стоимостью не более 500. тыс. руб. (не забудьте удалить символы конца строки!).
Если подходящих под условие строк в файле нет, то программа ничего не выводит.
ДОПОЛНИТЕЛЬНО
Ваше решение будет проверяться на закрытых тестах. Ваш код должен считывать файл projects_file.csv без дополнительных указаний (например, пути к файлу на вашем компьютере).
В открытом тесте используется файл projects_file.csv. Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.","['2019', '2018', '2015', '2019', '1990']","['2018,253 тыс. руб.,45 недель\n2018,340 тыс. руб.,34 недель\n2019,263 тыс. руб.,90 недель\n2019,320 тыс. руб.,31 недель\n2019,478 тыс. руб.,85 недель\n2018,324 тыс. руб.,18 недель\n2019,186 тыс. руб.,82 недель\n2018,349 тыс. руб.,95 недель\n2019,479 тыс. руб.,31 недель\n2019,192 тыс. руб.,36 недель\n2018,393 тыс. руб.,90 недель\n2019,206 тыс. руб.,70 недель\n2019,185 тыс. руб.,27 недель\n2019,396 тыс. руб.,36 недель\n2018,445 тыс. руб.,6 недель\n2019,492 тыс. руб.,77 недель\n2018,267 тыс. руб.,38 недель\n2018,260 тыс. руб.,79 недель\n2018,214 тыс. руб.,47 недель\n2018,151 тыс. руб.,70 недель\n2019,116 тыс. руб.,25 недель\n2019,178 тыс. руб.,9 недель\n2019,100 тыс. руб.,24 недель\n2019,112 тыс. руб.,91 недель\n2019,369 тыс. руб.,24 недель\n2019,166 тыс. руб.,67 недель\n2019,498 тыс. руб.,83 недель\n2018,276 тыс. руб.,48 недель\n2019,493 тыс. руб.,20 недель\n2019,358 тыс. руб.,27 недель\n2019,394 тыс. руб.,49 недель\n2019,429 тыс. руб.,77 недель\n2019,375 тыс. руб.,44 недель\n2019,245 тыс. руб.,74 недель\n2018,313 тыс. руб.,5 недель\n2018,244 тыс. руб.,26 недель\n2018,432 тыс. руб.,87 недель\n2019,291 тыс. руб.,96 недель\n2018,355 тыс. руб.,100 недель\n2019,377 тыс. руб.,39 недель', '2018,240 тыс. руб.,86 недель\n2018,491 тыс. руб.,75 недель\n2018,310 тыс. руб.,29 недель\n2018,111 тыс. руб.,60 недель\n2018,252 тыс. руб.,81 недель\n2018,448 тыс. руб.,55 недель\n2018,397 тыс. руб.,73 недель\n2018,472 тыс. руб.,74 недель\n2018,357 тыс. руб.,17 недель\n2018,364 тыс. руб.,82 недель\n2018,187 тыс. руб.,89 недель\n2018,267 тыс. руб.,57 недель\n2018,254 тыс. руб.,18 недель\n2018,330 тыс. руб.,95 недель\n2018,488 тыс. руб.,64 недель\n2018,167 тыс. руб.,29 недель\n2018,327 тыс. руб.,27 недель\n2018,275 тыс. руб.,13 недель\n2018,205 тыс. руб.,93 недель\n2018,354 тыс. руб.,38 недель', '2015,497 тыс. руб.,82 недель\n2015,391 тыс. руб.,81 недель\n2015,488 тыс. руб.,72 недель\n2015,188 тыс. руб.,72 недель\n2015,320 тыс. руб.,57 недель\n2015,251 тыс. руб.,36 недель\n2015,488 тыс. руб.,96 недель\n2015,379 тыс. руб.,14 недель\n2015,305 тыс. руб.,90 недель\n2015,284 тыс. руб.,33 недель\n2015,180 тыс. руб.,15 недель\n2015,328 тыс. руб.,50 недель\n2015,355 тыс. руб.,84 недель\n2015,426 тыс. руб.,63 недель\n2015,294 тыс. руб.,15 недель\n2015,327 тыс. руб.,72 недель\n2015,452 тыс. руб.,71 недель\n2015,240 тыс. руб.,88 недель', '2019,255 тыс. руб.,56 недель\n2017,280 тыс. руб.,80 недель\n2019,111 тыс. руб.,49 недель\n2015,497 тыс. руб.,82 недель\n2015,391 тыс. руб.,81 недель\n2015,488 тыс. руб.,72 недель\n2016,219 тыс. руб.,11 недель\n2015,188 тыс. руб.,72 недель\n2016,439 тыс. руб.,82 недель\n2016,410 тыс. руб.,26 недель\n2017,166 тыс. руб.,100 недель\n2019,449 тыс. руб.,100 недель\n2019,148 тыс. руб.,51 недель\n2018,246 тыс. руб.,59 недель\n2018,307 тыс. руб.,20 недель\n2019,113 тыс. руб.,41 недель\n2017,278 тыс. руб.,40 недель\n2015,320 тыс. руб.,57 недель\n2016,195 тыс. руб.,37 недель\n2019,330 тыс. руб.,69 недель\n2015,251 тыс. руб.,36 недель\n2015,488 тыс. руб.,96 недель\n2017,215 тыс. руб.,22 недель\n2017,151 тыс. руб.,93 недель\n2016,470 тыс. руб.,84 недель\n2018,376 тыс. руб.,53 недель\n2018,488 тыс. руб.,13 недель\n2017,164 тыс. руб.,15 недель\n2016,226 тыс. руб.,51 недель\n2015,379 тыс. руб.,14 недель\n2015,305 тыс. руб.,90 недель\n2015,284 тыс. руб.,33 недель\n2016,158 тыс. руб.,55 недель\n2016,257 тыс. руб.,14 недель\n2015,180 тыс. руб.,15 недель\n2017,262 тыс. руб.,73 недель\n2019,245 тыс. руб.,99 недель\n2015,328 тыс. руб.,50 недель\n2015,355 тыс. руб.,84 недель\n2016,358 тыс. руб.,70 недель\n2017,463 тыс. руб.,33 недель\n2015,426 тыс. руб.,63 недель\n2016,153 тыс. руб.,19 недель\n2015,294 тыс. руб.,15 недель\n2016,190 тыс. руб.,61 недель\n2019,256 тыс. руб.,16 недель\n2015,327 тыс. руб.,72 недель\n2017,499 тыс. руб.,41 недель\n2015,452 тыс. руб.,71 недель\n2018,142 тыс. руб.,57 недель\n2019,452 тыс. руб.,100 недель\n2015,240 тыс. руб.,88 недель\n2017,141 тыс. руб.,72 недель\n2018,215 тыс. руб.,40 недель\n2019,177 тыс. руб.,75 недель\n2019,115 тыс. руб.,15 недель\n2017,148 тыс. руб.,95 недель\n2019,125 тыс. руб.,24 недель\n2019,434 тыс. руб.,88 недель\n2016,348 тыс. руб.,83 недель\n2017,127 тыс. руб.,68 недель\n2018,145 тыс. руб.,41 недель', nan]","year = input()

with open('projects_file.csv', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        info = line.split(',')
        if info[0] <= year and int(info[2].split()[0]) <= 500:
            print(line)","year = input()

with open('projects_file.csv', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        info = line.split(',')
        if info[0] <= year and int(info[-2].split()[0]) <= 500:
            print(line)","Ошибка в открытых и скрытых тестах. 

Ваш код некорректно обрабатывает данные каждой строки. Происходит обращение к некорректному элементу переменной info.","['open', 'closed', 'closed', 'closed', 'closed']","<Task description>: Ксения анализирует реализованные дизайн-проекты, которые собраны в файле формата csv. Напишите программу, которая выводит все строки, соответствующие реализованным в определенный период проектам, стоимость которых была не более 500 тыс. руб..

Программа должна открывать структурированный текстовый файл projects_file.csv, в кодировке utf-8, где на каждой строке записана следующая информация о дизайн-проекте: год, стоимость проекта, количество недель, за сколько был реализован проект. Например, строка ""2019,200 тыс. руб.,10 недель"" означает, что в 2019 году проект стоимостью 200 тыс. руб. был реализован за 10 недель.
Гарантируется, что стоимость реализованного проекта всегда записана в формате ""<целое число> тыс. руб."".
Гарантируется, что срок реализации проекта всегда записан в формате ""<целое число> недель"".
Разделителями данных в файле служат запятые.
Гарантируется, что в файле есть как минимум одна строка с данными. 
С клавиатуры вводится строка — год.
Программа должна выводить строки из оригинального файла, которые соответствуют проектам, реализованным не позднее, чем в указанном году, со стоимостью не более 500. тыс. руб. (не забудьте удалить символы конца строки!).
Если подходящих под условие строк в файле нет, то программа ничего не выводит.
ДОПОЛНИТЕЛЬНО
Ваше решение будет проверяться на закрытых тестах. Ваш код должен считывать файл projects_file.csv без дополнительных указаний (например, пути к файлу на вашем компьютере).
В открытом тесте используется файл projects_file.csv. Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: 2019 
<Вывод>: 2018,253 тыс. руб.,45 недель
2018,340 тыс. руб.,34 недель
2019,263 тыс. руб.,90 недель
2019,320 тыс. руб.,31 недель
2019,478 тыс. руб.,85 недель
2018,324 тыс. руб.,18 недель
2019,186 тыс. руб.,82 недель
2018,349 тыс. руб.,95 недель
2019,479 тыс. руб.,31 недель
2019,192 тыс. руб.,36 недель
2018,393 тыс. руб.,90 недель
2019,206 тыс. руб.,70 недель
2019,185 тыс. руб.,27 недель
2019,396 тыс. руб.,36 недель
2018,445 тыс. руб.,6 недель
2019,492 тыс. руб.,77 недель
2018,267 тыс. руб.,38 недель
2018,260 тыс. руб.,79 недель
2018,214 тыс. руб.,47 недель
2018,151 тыс. руб.,70 недель
2019,116 тыс. руб.,25 недель
2019,178 тыс. руб.,9 недель
2019,100 тыс. руб.,24 недель
2019,112 тыс. руб.,91 недель
2019,369 тыс. руб.,24 недель
2019,166 тыс. руб.,67 недель
2019,498 тыс. руб.,83 недель
2018,276 тыс. руб.,48 недель
2019,493 тыс. руб.,20 недель
2019,358 тыс. руб.,27 недель
2019,394 тыс. руб.,49 недель
2019,429 тыс. руб.,77 недель
2019,375 тыс. руб.,44 недель
2019,245 тыс. руб.,74 недель
2018,313 тыс. руб.,5 недель
2018,244 тыс. руб.,26 недель
2018,432 тыс. руб.,87 недель
2019,291 тыс. руб.,96 недель
2018,355 тыс. руб.,100 недель
2019,377 тыс. руб.,39 недель 
<Example 2>: 
<Тип теста 2>: closed 
<Ввод>: 2018 
<Вывод>: 2018,240 тыс. руб.,86 недель
2018,491 тыс. руб.,75 недель
2018,310 тыс. руб.,29 недель
2018,111 тыс. руб.,60 недель
2018,252 тыс. руб.,81 недель
2018,448 тыс. руб.,55 недель
2018,397 тыс. руб.,73 недель
2018,472 тыс. руб.,74 недель
2018,357 тыс. руб.,17 недель
2018,364 тыс. руб.,82 недель
2018,187 тыс. руб.,89 недель
2018,267 тыс. руб.,57 недель
2018,254 тыс. руб.,18 недель
2018,330 тыс. руб.,95 недель
2018,488 тыс. руб.,64 недель
2018,167 тыс. руб.,29 недель
2018,327 тыс. руб.,27 недель
2018,275 тыс. руб.,13 недель
2018,205 тыс. руб.,93 недель
2018,354 тыс. руб.,38 недель 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: 2015 
<Вывод>: 2015,497 тыс. руб.,82 недель
2015,391 тыс. руб.,81 недель
2015,488 тыс. руб.,72 недель
2015,188 тыс. руб.,72 недель
2015,320 тыс. руб.,57 недель
2015,251 тыс. руб.,36 недель
2015,488 тыс. руб.,96 недель
2015,379 тыс. руб.,14 недель
2015,305 тыс. руб.,90 недель
2015,284 тыс. руб.,33 недель
2015,180 тыс. руб.,15 недель
2015,328 тыс. руб.,50 недель
2015,355 тыс. руб.,84 недель
2015,426 тыс. руб.,63 недель
2015,294 тыс. руб.,15 недель
2015,327 тыс. руб.,72 недель
2015,452 тыс. руб.,71 недель
2015,240 тыс. руб.,88 недель 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: 2019 
<Вывод>: 2019,255 тыс. руб.,56 недель
2017,280 тыс. руб.,80 недель
2019,111 тыс. руб.,49 недель
2015,497 тыс. руб.,82 недель
2015,391 тыс. руб.,81 недель
2015,488 тыс. руб.,72 недель
2016,219 тыс. руб.,11 недель
2015,188 тыс. руб.,72 недель
2016,439 тыс. руб.,82 недель
2016,410 тыс. руб.,26 недель
2017,166 тыс. руб.,100 недель
2019,449 тыс. руб.,100 недель
2019,148 тыс. руб.,51 недель
2018,246 тыс. руб.,59 недель
2018,307 тыс. руб.,20 недель
2019,113 тыс. руб.,41 недель
2017,278 тыс. руб.,40 недель
2015,320 тыс. руб.,57 недель
2016,195 тыс. руб.,37 недель
2019,330 тыс. руб.,69 недель
2015,251 тыс. руб.,36 недель
2015,488 тыс. руб.,96 недель
2017,215 тыс. руб.,22 недель
2017,151 тыс. руб.,93 недель
2016,470 тыс. руб.,84 недель
2018,376 тыс. руб.,53 недель
2018,488 тыс. руб.,13 недель
2017,164 тыс. руб.,15 недель
2016,226 тыс. руб.,51 недель
2015,379 тыс. руб.,14 недель
2015,305 тыс. руб.,90 недель
2015,284 тыс. руб.,33 недель
2016,158 тыс. руб.,55 недель
2016,257 тыс. руб.,14 недель
2015,180 тыс. руб.,15 недель
2017,262 тыс. руб.,73 недель
2019,245 тыс. руб.,99 недель
2015,328 тыс. руб.,50 недель
2015,355 тыс. руб.,84 недель
2016,358 тыс. руб.,70 недель
2017,463 тыс. руб.,33 недель
2015,426 тыс. руб.,63 недель
2016,153 тыс. руб.,19 недель
2015,294 тыс. руб.,15 недель
2016,190 тыс. руб.,61 недель
2019,256 тыс. руб.,16 недель
2015,327 тыс. руб.,72 недель
2017,499 тыс. руб.,41 недель
2015,452 тыс. руб.,71 недель
2018,142 тыс. руб.,57 недель
2019,452 тыс. руб.,100 недель
2015,240 тыс. руб.,88 недель
2017,141 тыс. руб.,72 недель
2018,215 тыс. руб.,40 недель
2019,177 тыс. руб.,75 недель
2019,115 тыс. руб.,15 недель
2017,148 тыс. руб.,95 недель
2019,125 тыс. руб.,24 недель
2019,434 тыс. руб.,88 недель
2016,348 тыс. руб.,83 недель
2017,127 тыс. руб.,68 недель
2018,145 тыс. руб.,41 недель 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: 1990 
<Вывод>: nan 
<Решение студента>: year = input()

with open('projects_file.csv', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        info = line.split(',')
        if info[0] <= year and int(info[2].split()[0]) <= 500:
            print(line) 
<Идеальное решение>: year = input()

with open('projects_file.csv', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        info = line.split(',')
        if info[0] <= year and int(info[-2].split()[0]) <= 500:
            print(line) 


<Комментарий эксперта>:"
77,120,7,"Ксения анализирует реализованные дизайн-проекты, которые собраны в файле формата csv. Напишите программу, которая выводит все строки, соответствующие реализованным в определенный период проектам, стоимость которых была не более 500 тыс. руб..

Программа должна открывать структурированный текстовый файл projects_file.csv, в кодировке utf-8, где на каждой строке записана следующая информация о дизайн-проекте: год, стоимость проекта, количество недель, за сколько был реализован проект. Например, строка ""2019,200 тыс. руб.,10 недель"" означает, что в 2019 году проект стоимостью 200 тыс. руб. был реализован за 10 недель.
Гарантируется, что стоимость реализованного проекта всегда записана в формате ""<целое число> тыс. руб."".
Гарантируется, что срок реализации проекта всегда записан в формате ""<целое число> недель"".
Разделителями данных в файле служат запятые.
Гарантируется, что в файле есть как минимум одна строка с данными. 
С клавиатуры вводится строка — год.
Программа должна выводить строки из оригинального файла, которые соответствуют проектам, реализованным не позднее, чем в указанном году, со стоимостью не более 500. тыс. руб. (не забудьте удалить символы конца строки!).
Если подходящих под условие строк в файле нет, то программа ничего не выводит.
ДОПОЛНИТЕЛЬНО
Ваше решение будет проверяться на закрытых тестах. Ваш код должен считывать файл projects_file.csv без дополнительных указаний (например, пути к файлу на вашем компьютере).
В открытом тесте используется файл projects_file.csv. Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.","['2019', '2018', '2015', '2019', '1990']","['2018,253 тыс. руб.,45 недель\n2018,340 тыс. руб.,34 недель\n2019,263 тыс. руб.,90 недель\n2019,320 тыс. руб.,31 недель\n2019,478 тыс. руб.,85 недель\n2018,324 тыс. руб.,18 недель\n2019,186 тыс. руб.,82 недель\n2018,349 тыс. руб.,95 недель\n2019,479 тыс. руб.,31 недель\n2019,192 тыс. руб.,36 недель\n2018,393 тыс. руб.,90 недель\n2019,206 тыс. руб.,70 недель\n2019,185 тыс. руб.,27 недель\n2019,396 тыс. руб.,36 недель\n2018,445 тыс. руб.,6 недель\n2019,492 тыс. руб.,77 недель\n2018,267 тыс. руб.,38 недель\n2018,260 тыс. руб.,79 недель\n2018,214 тыс. руб.,47 недель\n2018,151 тыс. руб.,70 недель\n2019,116 тыс. руб.,25 недель\n2019,178 тыс. руб.,9 недель\n2019,100 тыс. руб.,24 недель\n2019,112 тыс. руб.,91 недель\n2019,369 тыс. руб.,24 недель\n2019,166 тыс. руб.,67 недель\n2019,498 тыс. руб.,83 недель\n2018,276 тыс. руб.,48 недель\n2019,493 тыс. руб.,20 недель\n2019,358 тыс. руб.,27 недель\n2019,394 тыс. руб.,49 недель\n2019,429 тыс. руб.,77 недель\n2019,375 тыс. руб.,44 недель\n2019,245 тыс. руб.,74 недель\n2018,313 тыс. руб.,5 недель\n2018,244 тыс. руб.,26 недель\n2018,432 тыс. руб.,87 недель\n2019,291 тыс. руб.,96 недель\n2018,355 тыс. руб.,100 недель\n2019,377 тыс. руб.,39 недель', '2018,240 тыс. руб.,86 недель\n2018,491 тыс. руб.,75 недель\n2018,310 тыс. руб.,29 недель\n2018,111 тыс. руб.,60 недель\n2018,252 тыс. руб.,81 недель\n2018,448 тыс. руб.,55 недель\n2018,397 тыс. руб.,73 недель\n2018,472 тыс. руб.,74 недель\n2018,357 тыс. руб.,17 недель\n2018,364 тыс. руб.,82 недель\n2018,187 тыс. руб.,89 недель\n2018,267 тыс. руб.,57 недель\n2018,254 тыс. руб.,18 недель\n2018,330 тыс. руб.,95 недель\n2018,488 тыс. руб.,64 недель\n2018,167 тыс. руб.,29 недель\n2018,327 тыс. руб.,27 недель\n2018,275 тыс. руб.,13 недель\n2018,205 тыс. руб.,93 недель\n2018,354 тыс. руб.,38 недель', '2015,497 тыс. руб.,82 недель\n2015,391 тыс. руб.,81 недель\n2015,488 тыс. руб.,72 недель\n2015,188 тыс. руб.,72 недель\n2015,320 тыс. руб.,57 недель\n2015,251 тыс. руб.,36 недель\n2015,488 тыс. руб.,96 недель\n2015,379 тыс. руб.,14 недель\n2015,305 тыс. руб.,90 недель\n2015,284 тыс. руб.,33 недель\n2015,180 тыс. руб.,15 недель\n2015,328 тыс. руб.,50 недель\n2015,355 тыс. руб.,84 недель\n2015,426 тыс. руб.,63 недель\n2015,294 тыс. руб.,15 недель\n2015,327 тыс. руб.,72 недель\n2015,452 тыс. руб.,71 недель\n2015,240 тыс. руб.,88 недель', '2019,255 тыс. руб.,56 недель\n2017,280 тыс. руб.,80 недель\n2019,111 тыс. руб.,49 недель\n2015,497 тыс. руб.,82 недель\n2015,391 тыс. руб.,81 недель\n2015,488 тыс. руб.,72 недель\n2016,219 тыс. руб.,11 недель\n2015,188 тыс. руб.,72 недель\n2016,439 тыс. руб.,82 недель\n2016,410 тыс. руб.,26 недель\n2017,166 тыс. руб.,100 недель\n2019,449 тыс. руб.,100 недель\n2019,148 тыс. руб.,51 недель\n2018,246 тыс. руб.,59 недель\n2018,307 тыс. руб.,20 недель\n2019,113 тыс. руб.,41 недель\n2017,278 тыс. руб.,40 недель\n2015,320 тыс. руб.,57 недель\n2016,195 тыс. руб.,37 недель\n2019,330 тыс. руб.,69 недель\n2015,251 тыс. руб.,36 недель\n2015,488 тыс. руб.,96 недель\n2017,215 тыс. руб.,22 недель\n2017,151 тыс. руб.,93 недель\n2016,470 тыс. руб.,84 недель\n2018,376 тыс. руб.,53 недель\n2018,488 тыс. руб.,13 недель\n2017,164 тыс. руб.,15 недель\n2016,226 тыс. руб.,51 недель\n2015,379 тыс. руб.,14 недель\n2015,305 тыс. руб.,90 недель\n2015,284 тыс. руб.,33 недель\n2016,158 тыс. руб.,55 недель\n2016,257 тыс. руб.,14 недель\n2015,180 тыс. руб.,15 недель\n2017,262 тыс. руб.,73 недель\n2019,245 тыс. руб.,99 недель\n2015,328 тыс. руб.,50 недель\n2015,355 тыс. руб.,84 недель\n2016,358 тыс. руб.,70 недель\n2017,463 тыс. руб.,33 недель\n2015,426 тыс. руб.,63 недель\n2016,153 тыс. руб.,19 недель\n2015,294 тыс. руб.,15 недель\n2016,190 тыс. руб.,61 недель\n2019,256 тыс. руб.,16 недель\n2015,327 тыс. руб.,72 недель\n2017,499 тыс. руб.,41 недель\n2015,452 тыс. руб.,71 недель\n2018,142 тыс. руб.,57 недель\n2019,452 тыс. руб.,100 недель\n2015,240 тыс. руб.,88 недель\n2017,141 тыс. руб.,72 недель\n2018,215 тыс. руб.,40 недель\n2019,177 тыс. руб.,75 недель\n2019,115 тыс. руб.,15 недель\n2017,148 тыс. руб.,95 недель\n2019,125 тыс. руб.,24 недель\n2019,434 тыс. руб.,88 недель\n2016,348 тыс. руб.,83 недель\n2017,127 тыс. руб.,68 недель\n2018,145 тыс. руб.,41 недель', nan]","year = input()

with open('projects_file.csv', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        info = line.split(',')
        if info[1] <= year and int(info[-2].split()[0]) <= 500:
            print(line)","year = input()

with open('projects_file.csv', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        info = line.split(',')
        if info[0] <= year and int(info[-2].split()[0]) <= 500:
            print(line)","Ошибка в открытых и скрытых тестах. 

Ваш код некорректно обрабатывает данные каждой строки. Происходит обращение к некорректному элементу переменной info.","['open', 'closed', 'closed', 'closed', 'closed']","<Task description>: Ксения анализирует реализованные дизайн-проекты, которые собраны в файле формата csv. Напишите программу, которая выводит все строки, соответствующие реализованным в определенный период проектам, стоимость которых была не более 500 тыс. руб..

Программа должна открывать структурированный текстовый файл projects_file.csv, в кодировке utf-8, где на каждой строке записана следующая информация о дизайн-проекте: год, стоимость проекта, количество недель, за сколько был реализован проект. Например, строка ""2019,200 тыс. руб.,10 недель"" означает, что в 2019 году проект стоимостью 200 тыс. руб. был реализован за 10 недель.
Гарантируется, что стоимость реализованного проекта всегда записана в формате ""<целое число> тыс. руб."".
Гарантируется, что срок реализации проекта всегда записан в формате ""<целое число> недель"".
Разделителями данных в файле служат запятые.
Гарантируется, что в файле есть как минимум одна строка с данными. 
С клавиатуры вводится строка — год.
Программа должна выводить строки из оригинального файла, которые соответствуют проектам, реализованным не позднее, чем в указанном году, со стоимостью не более 500. тыс. руб. (не забудьте удалить символы конца строки!).
Если подходящих под условие строк в файле нет, то программа ничего не выводит.
ДОПОЛНИТЕЛЬНО
Ваше решение будет проверяться на закрытых тестах. Ваш код должен считывать файл projects_file.csv без дополнительных указаний (например, пути к файлу на вашем компьютере).
В открытом тесте используется файл projects_file.csv. Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: 2019 
<Вывод>: 2018,253 тыс. руб.,45 недель
2018,340 тыс. руб.,34 недель
2019,263 тыс. руб.,90 недель
2019,320 тыс. руб.,31 недель
2019,478 тыс. руб.,85 недель
2018,324 тыс. руб.,18 недель
2019,186 тыс. руб.,82 недель
2018,349 тыс. руб.,95 недель
2019,479 тыс. руб.,31 недель
2019,192 тыс. руб.,36 недель
2018,393 тыс. руб.,90 недель
2019,206 тыс. руб.,70 недель
2019,185 тыс. руб.,27 недель
2019,396 тыс. руб.,36 недель
2018,445 тыс. руб.,6 недель
2019,492 тыс. руб.,77 недель
2018,267 тыс. руб.,38 недель
2018,260 тыс. руб.,79 недель
2018,214 тыс. руб.,47 недель
2018,151 тыс. руб.,70 недель
2019,116 тыс. руб.,25 недель
2019,178 тыс. руб.,9 недель
2019,100 тыс. руб.,24 недель
2019,112 тыс. руб.,91 недель
2019,369 тыс. руб.,24 недель
2019,166 тыс. руб.,67 недель
2019,498 тыс. руб.,83 недель
2018,276 тыс. руб.,48 недель
2019,493 тыс. руб.,20 недель
2019,358 тыс. руб.,27 недель
2019,394 тыс. руб.,49 недель
2019,429 тыс. руб.,77 недель
2019,375 тыс. руб.,44 недель
2019,245 тыс. руб.,74 недель
2018,313 тыс. руб.,5 недель
2018,244 тыс. руб.,26 недель
2018,432 тыс. руб.,87 недель
2019,291 тыс. руб.,96 недель
2018,355 тыс. руб.,100 недель
2019,377 тыс. руб.,39 недель 
<Example 2>: 
<Тип теста 2>: closed 
<Ввод>: 2018 
<Вывод>: 2018,240 тыс. руб.,86 недель
2018,491 тыс. руб.,75 недель
2018,310 тыс. руб.,29 недель
2018,111 тыс. руб.,60 недель
2018,252 тыс. руб.,81 недель
2018,448 тыс. руб.,55 недель
2018,397 тыс. руб.,73 недель
2018,472 тыс. руб.,74 недель
2018,357 тыс. руб.,17 недель
2018,364 тыс. руб.,82 недель
2018,187 тыс. руб.,89 недель
2018,267 тыс. руб.,57 недель
2018,254 тыс. руб.,18 недель
2018,330 тыс. руб.,95 недель
2018,488 тыс. руб.,64 недель
2018,167 тыс. руб.,29 недель
2018,327 тыс. руб.,27 недель
2018,275 тыс. руб.,13 недель
2018,205 тыс. руб.,93 недель
2018,354 тыс. руб.,38 недель 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: 2015 
<Вывод>: 2015,497 тыс. руб.,82 недель
2015,391 тыс. руб.,81 недель
2015,488 тыс. руб.,72 недель
2015,188 тыс. руб.,72 недель
2015,320 тыс. руб.,57 недель
2015,251 тыс. руб.,36 недель
2015,488 тыс. руб.,96 недель
2015,379 тыс. руб.,14 недель
2015,305 тыс. руб.,90 недель
2015,284 тыс. руб.,33 недель
2015,180 тыс. руб.,15 недель
2015,328 тыс. руб.,50 недель
2015,355 тыс. руб.,84 недель
2015,426 тыс. руб.,63 недель
2015,294 тыс. руб.,15 недель
2015,327 тыс. руб.,72 недель
2015,452 тыс. руб.,71 недель
2015,240 тыс. руб.,88 недель 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: 2019 
<Вывод>: 2019,255 тыс. руб.,56 недель
2017,280 тыс. руб.,80 недель
2019,111 тыс. руб.,49 недель
2015,497 тыс. руб.,82 недель
2015,391 тыс. руб.,81 недель
2015,488 тыс. руб.,72 недель
2016,219 тыс. руб.,11 недель
2015,188 тыс. руб.,72 недель
2016,439 тыс. руб.,82 недель
2016,410 тыс. руб.,26 недель
2017,166 тыс. руб.,100 недель
2019,449 тыс. руб.,100 недель
2019,148 тыс. руб.,51 недель
2018,246 тыс. руб.,59 недель
2018,307 тыс. руб.,20 недель
2019,113 тыс. руб.,41 недель
2017,278 тыс. руб.,40 недель
2015,320 тыс. руб.,57 недель
2016,195 тыс. руб.,37 недель
2019,330 тыс. руб.,69 недель
2015,251 тыс. руб.,36 недель
2015,488 тыс. руб.,96 недель
2017,215 тыс. руб.,22 недель
2017,151 тыс. руб.,93 недель
2016,470 тыс. руб.,84 недель
2018,376 тыс. руб.,53 недель
2018,488 тыс. руб.,13 недель
2017,164 тыс. руб.,15 недель
2016,226 тыс. руб.,51 недель
2015,379 тыс. руб.,14 недель
2015,305 тыс. руб.,90 недель
2015,284 тыс. руб.,33 недель
2016,158 тыс. руб.,55 недель
2016,257 тыс. руб.,14 недель
2015,180 тыс. руб.,15 недель
2017,262 тыс. руб.,73 недель
2019,245 тыс. руб.,99 недель
2015,328 тыс. руб.,50 недель
2015,355 тыс. руб.,84 недель
2016,358 тыс. руб.,70 недель
2017,463 тыс. руб.,33 недель
2015,426 тыс. руб.,63 недель
2016,153 тыс. руб.,19 недель
2015,294 тыс. руб.,15 недель
2016,190 тыс. руб.,61 недель
2019,256 тыс. руб.,16 недель
2015,327 тыс. руб.,72 недель
2017,499 тыс. руб.,41 недель
2015,452 тыс. руб.,71 недель
2018,142 тыс. руб.,57 недель
2019,452 тыс. руб.,100 недель
2015,240 тыс. руб.,88 недель
2017,141 тыс. руб.,72 недель
2018,215 тыс. руб.,40 недель
2019,177 тыс. руб.,75 недель
2019,115 тыс. руб.,15 недель
2017,148 тыс. руб.,95 недель
2019,125 тыс. руб.,24 недель
2019,434 тыс. руб.,88 недель
2016,348 тыс. руб.,83 недель
2017,127 тыс. руб.,68 недель
2018,145 тыс. руб.,41 недель 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: 1990 
<Вывод>: nan 
<Решение студента>: year = input()

with open('projects_file.csv', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        info = line.split(',')
        if info[1] <= year and int(info[-2].split()[0]) <= 500:
            print(line) 
<Идеальное решение>: year = input()

with open('projects_file.csv', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        info = line.split(',')
        if info[0] <= year and int(info[-2].split()[0]) <= 500:
            print(line) 


<Комментарий эксперта>:"
78,121,7,"Ксения анализирует реализованные дизайн-проекты, которые собраны в файле формата csv. Напишите программу, которая выводит все строки, соответствующие реализованным в определенный период проектам, стоимость которых была не более 500 тыс. руб..

Программа должна открывать структурированный текстовый файл projects_file.csv, в кодировке utf-8, где на каждой строке записана следующая информация о дизайн-проекте: год, стоимость проекта, количество недель, за сколько был реализован проект. Например, строка ""2019,200 тыс. руб.,10 недель"" означает, что в 2019 году проект стоимостью 200 тыс. руб. был реализован за 10 недель.
Гарантируется, что стоимость реализованного проекта всегда записана в формате ""<целое число> тыс. руб."".
Гарантируется, что срок реализации проекта всегда записан в формате ""<целое число> недель"".
Разделителями данных в файле служат запятые.
Гарантируется, что в файле есть как минимум одна строка с данными. 
С клавиатуры вводится строка — год.
Программа должна выводить строки из оригинального файла, которые соответствуют проектам, реализованным не позднее, чем в указанном году, со стоимостью не более 500. тыс. руб. (не забудьте удалить символы конца строки!).
Если подходящих под условие строк в файле нет, то программа ничего не выводит.
ДОПОЛНИТЕЛЬНО
Ваше решение будет проверяться на закрытых тестах. Ваш код должен считывать файл projects_file.csv без дополнительных указаний (например, пути к файлу на вашем компьютере).
В открытом тесте используется файл projects_file.csv. Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.","['2019', '2018', '2015', '2019', '1990']","['2018,253 тыс. руб.,45 недель\n2018,340 тыс. руб.,34 недель\n2019,263 тыс. руб.,90 недель\n2019,320 тыс. руб.,31 недель\n2019,478 тыс. руб.,85 недель\n2018,324 тыс. руб.,18 недель\n2019,186 тыс. руб.,82 недель\n2018,349 тыс. руб.,95 недель\n2019,479 тыс. руб.,31 недель\n2019,192 тыс. руб.,36 недель\n2018,393 тыс. руб.,90 недель\n2019,206 тыс. руб.,70 недель\n2019,185 тыс. руб.,27 недель\n2019,396 тыс. руб.,36 недель\n2018,445 тыс. руб.,6 недель\n2019,492 тыс. руб.,77 недель\n2018,267 тыс. руб.,38 недель\n2018,260 тыс. руб.,79 недель\n2018,214 тыс. руб.,47 недель\n2018,151 тыс. руб.,70 недель\n2019,116 тыс. руб.,25 недель\n2019,178 тыс. руб.,9 недель\n2019,100 тыс. руб.,24 недель\n2019,112 тыс. руб.,91 недель\n2019,369 тыс. руб.,24 недель\n2019,166 тыс. руб.,67 недель\n2019,498 тыс. руб.,83 недель\n2018,276 тыс. руб.,48 недель\n2019,493 тыс. руб.,20 недель\n2019,358 тыс. руб.,27 недель\n2019,394 тыс. руб.,49 недель\n2019,429 тыс. руб.,77 недель\n2019,375 тыс. руб.,44 недель\n2019,245 тыс. руб.,74 недель\n2018,313 тыс. руб.,5 недель\n2018,244 тыс. руб.,26 недель\n2018,432 тыс. руб.,87 недель\n2019,291 тыс. руб.,96 недель\n2018,355 тыс. руб.,100 недель\n2019,377 тыс. руб.,39 недель', '2018,240 тыс. руб.,86 недель\n2018,491 тыс. руб.,75 недель\n2018,310 тыс. руб.,29 недель\n2018,111 тыс. руб.,60 недель\n2018,252 тыс. руб.,81 недель\n2018,448 тыс. руб.,55 недель\n2018,397 тыс. руб.,73 недель\n2018,472 тыс. руб.,74 недель\n2018,357 тыс. руб.,17 недель\n2018,364 тыс. руб.,82 недель\n2018,187 тыс. руб.,89 недель\n2018,267 тыс. руб.,57 недель\n2018,254 тыс. руб.,18 недель\n2018,330 тыс. руб.,95 недель\n2018,488 тыс. руб.,64 недель\n2018,167 тыс. руб.,29 недель\n2018,327 тыс. руб.,27 недель\n2018,275 тыс. руб.,13 недель\n2018,205 тыс. руб.,93 недель\n2018,354 тыс. руб.,38 недель', '2015,497 тыс. руб.,82 недель\n2015,391 тыс. руб.,81 недель\n2015,488 тыс. руб.,72 недель\n2015,188 тыс. руб.,72 недель\n2015,320 тыс. руб.,57 недель\n2015,251 тыс. руб.,36 недель\n2015,488 тыс. руб.,96 недель\n2015,379 тыс. руб.,14 недель\n2015,305 тыс. руб.,90 недель\n2015,284 тыс. руб.,33 недель\n2015,180 тыс. руб.,15 недель\n2015,328 тыс. руб.,50 недель\n2015,355 тыс. руб.,84 недель\n2015,426 тыс. руб.,63 недель\n2015,294 тыс. руб.,15 недель\n2015,327 тыс. руб.,72 недель\n2015,452 тыс. руб.,71 недель\n2015,240 тыс. руб.,88 недель', '2019,255 тыс. руб.,56 недель\n2017,280 тыс. руб.,80 недель\n2019,111 тыс. руб.,49 недель\n2015,497 тыс. руб.,82 недель\n2015,391 тыс. руб.,81 недель\n2015,488 тыс. руб.,72 недель\n2016,219 тыс. руб.,11 недель\n2015,188 тыс. руб.,72 недель\n2016,439 тыс. руб.,82 недель\n2016,410 тыс. руб.,26 недель\n2017,166 тыс. руб.,100 недель\n2019,449 тыс. руб.,100 недель\n2019,148 тыс. руб.,51 недель\n2018,246 тыс. руб.,59 недель\n2018,307 тыс. руб.,20 недель\n2019,113 тыс. руб.,41 недель\n2017,278 тыс. руб.,40 недель\n2015,320 тыс. руб.,57 недель\n2016,195 тыс. руб.,37 недель\n2019,330 тыс. руб.,69 недель\n2015,251 тыс. руб.,36 недель\n2015,488 тыс. руб.,96 недель\n2017,215 тыс. руб.,22 недель\n2017,151 тыс. руб.,93 недель\n2016,470 тыс. руб.,84 недель\n2018,376 тыс. руб.,53 недель\n2018,488 тыс. руб.,13 недель\n2017,164 тыс. руб.,15 недель\n2016,226 тыс. руб.,51 недель\n2015,379 тыс. руб.,14 недель\n2015,305 тыс. руб.,90 недель\n2015,284 тыс. руб.,33 недель\n2016,158 тыс. руб.,55 недель\n2016,257 тыс. руб.,14 недель\n2015,180 тыс. руб.,15 недель\n2017,262 тыс. руб.,73 недель\n2019,245 тыс. руб.,99 недель\n2015,328 тыс. руб.,50 недель\n2015,355 тыс. руб.,84 недель\n2016,358 тыс. руб.,70 недель\n2017,463 тыс. руб.,33 недель\n2015,426 тыс. руб.,63 недель\n2016,153 тыс. руб.,19 недель\n2015,294 тыс. руб.,15 недель\n2016,190 тыс. руб.,61 недель\n2019,256 тыс. руб.,16 недель\n2015,327 тыс. руб.,72 недель\n2017,499 тыс. руб.,41 недель\n2015,452 тыс. руб.,71 недель\n2018,142 тыс. руб.,57 недель\n2019,452 тыс. руб.,100 недель\n2015,240 тыс. руб.,88 недель\n2017,141 тыс. руб.,72 недель\n2018,215 тыс. руб.,40 недель\n2019,177 тыс. руб.,75 недель\n2019,115 тыс. руб.,15 недель\n2017,148 тыс. руб.,95 недель\n2019,125 тыс. руб.,24 недель\n2019,434 тыс. руб.,88 недель\n2016,348 тыс. руб.,83 недель\n2017,127 тыс. руб.,68 недель\n2018,145 тыс. руб.,41 недель', nan]","year = input()

with open('projects_file.csv', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        info = line.split(',')
        if info[0] <= year and int(info[-2].split()[0]) <= 500:
            print(year)","year = input()

with open('projects_file.csv', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        info = line.split(',')
        if info[0] <= year and int(info[-2].split()[0]) <= 500:
            print(line)","Ошибка в открытых и скрытых тестах. 

Ваш код выводит некорректную переменную. ","['open', 'closed', 'closed', 'closed', 'closed']","<Task description>: Ксения анализирует реализованные дизайн-проекты, которые собраны в файле формата csv. Напишите программу, которая выводит все строки, соответствующие реализованным в определенный период проектам, стоимость которых была не более 500 тыс. руб..

Программа должна открывать структурированный текстовый файл projects_file.csv, в кодировке utf-8, где на каждой строке записана следующая информация о дизайн-проекте: год, стоимость проекта, количество недель, за сколько был реализован проект. Например, строка ""2019,200 тыс. руб.,10 недель"" означает, что в 2019 году проект стоимостью 200 тыс. руб. был реализован за 10 недель.
Гарантируется, что стоимость реализованного проекта всегда записана в формате ""<целое число> тыс. руб."".
Гарантируется, что срок реализации проекта всегда записан в формате ""<целое число> недель"".
Разделителями данных в файле служат запятые.
Гарантируется, что в файле есть как минимум одна строка с данными. 
С клавиатуры вводится строка — год.
Программа должна выводить строки из оригинального файла, которые соответствуют проектам, реализованным не позднее, чем в указанном году, со стоимостью не более 500. тыс. руб. (не забудьте удалить символы конца строки!).
Если подходящих под условие строк в файле нет, то программа ничего не выводит.
ДОПОЛНИТЕЛЬНО
Ваше решение будет проверяться на закрытых тестах. Ваш код должен считывать файл projects_file.csv без дополнительных указаний (например, пути к файлу на вашем компьютере).
В открытом тесте используется файл projects_file.csv. Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: 2019 
<Вывод>: 2018,253 тыс. руб.,45 недель
2018,340 тыс. руб.,34 недель
2019,263 тыс. руб.,90 недель
2019,320 тыс. руб.,31 недель
2019,478 тыс. руб.,85 недель
2018,324 тыс. руб.,18 недель
2019,186 тыс. руб.,82 недель
2018,349 тыс. руб.,95 недель
2019,479 тыс. руб.,31 недель
2019,192 тыс. руб.,36 недель
2018,393 тыс. руб.,90 недель
2019,206 тыс. руб.,70 недель
2019,185 тыс. руб.,27 недель
2019,396 тыс. руб.,36 недель
2018,445 тыс. руб.,6 недель
2019,492 тыс. руб.,77 недель
2018,267 тыс. руб.,38 недель
2018,260 тыс. руб.,79 недель
2018,214 тыс. руб.,47 недель
2018,151 тыс. руб.,70 недель
2019,116 тыс. руб.,25 недель
2019,178 тыс. руб.,9 недель
2019,100 тыс. руб.,24 недель
2019,112 тыс. руб.,91 недель
2019,369 тыс. руб.,24 недель
2019,166 тыс. руб.,67 недель
2019,498 тыс. руб.,83 недель
2018,276 тыс. руб.,48 недель
2019,493 тыс. руб.,20 недель
2019,358 тыс. руб.,27 недель
2019,394 тыс. руб.,49 недель
2019,429 тыс. руб.,77 недель
2019,375 тыс. руб.,44 недель
2019,245 тыс. руб.,74 недель
2018,313 тыс. руб.,5 недель
2018,244 тыс. руб.,26 недель
2018,432 тыс. руб.,87 недель
2019,291 тыс. руб.,96 недель
2018,355 тыс. руб.,100 недель
2019,377 тыс. руб.,39 недель 
<Example 2>: 
<Тип теста 2>: closed 
<Ввод>: 2018 
<Вывод>: 2018,240 тыс. руб.,86 недель
2018,491 тыс. руб.,75 недель
2018,310 тыс. руб.,29 недель
2018,111 тыс. руб.,60 недель
2018,252 тыс. руб.,81 недель
2018,448 тыс. руб.,55 недель
2018,397 тыс. руб.,73 недель
2018,472 тыс. руб.,74 недель
2018,357 тыс. руб.,17 недель
2018,364 тыс. руб.,82 недель
2018,187 тыс. руб.,89 недель
2018,267 тыс. руб.,57 недель
2018,254 тыс. руб.,18 недель
2018,330 тыс. руб.,95 недель
2018,488 тыс. руб.,64 недель
2018,167 тыс. руб.,29 недель
2018,327 тыс. руб.,27 недель
2018,275 тыс. руб.,13 недель
2018,205 тыс. руб.,93 недель
2018,354 тыс. руб.,38 недель 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: 2015 
<Вывод>: 2015,497 тыс. руб.,82 недель
2015,391 тыс. руб.,81 недель
2015,488 тыс. руб.,72 недель
2015,188 тыс. руб.,72 недель
2015,320 тыс. руб.,57 недель
2015,251 тыс. руб.,36 недель
2015,488 тыс. руб.,96 недель
2015,379 тыс. руб.,14 недель
2015,305 тыс. руб.,90 недель
2015,284 тыс. руб.,33 недель
2015,180 тыс. руб.,15 недель
2015,328 тыс. руб.,50 недель
2015,355 тыс. руб.,84 недель
2015,426 тыс. руб.,63 недель
2015,294 тыс. руб.,15 недель
2015,327 тыс. руб.,72 недель
2015,452 тыс. руб.,71 недель
2015,240 тыс. руб.,88 недель 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: 2019 
<Вывод>: 2019,255 тыс. руб.,56 недель
2017,280 тыс. руб.,80 недель
2019,111 тыс. руб.,49 недель
2015,497 тыс. руб.,82 недель
2015,391 тыс. руб.,81 недель
2015,488 тыс. руб.,72 недель
2016,219 тыс. руб.,11 недель
2015,188 тыс. руб.,72 недель
2016,439 тыс. руб.,82 недель
2016,410 тыс. руб.,26 недель
2017,166 тыс. руб.,100 недель
2019,449 тыс. руб.,100 недель
2019,148 тыс. руб.,51 недель
2018,246 тыс. руб.,59 недель
2018,307 тыс. руб.,20 недель
2019,113 тыс. руб.,41 недель
2017,278 тыс. руб.,40 недель
2015,320 тыс. руб.,57 недель
2016,195 тыс. руб.,37 недель
2019,330 тыс. руб.,69 недель
2015,251 тыс. руб.,36 недель
2015,488 тыс. руб.,96 недель
2017,215 тыс. руб.,22 недель
2017,151 тыс. руб.,93 недель
2016,470 тыс. руб.,84 недель
2018,376 тыс. руб.,53 недель
2018,488 тыс. руб.,13 недель
2017,164 тыс. руб.,15 недель
2016,226 тыс. руб.,51 недель
2015,379 тыс. руб.,14 недель
2015,305 тыс. руб.,90 недель
2015,284 тыс. руб.,33 недель
2016,158 тыс. руб.,55 недель
2016,257 тыс. руб.,14 недель
2015,180 тыс. руб.,15 недель
2017,262 тыс. руб.,73 недель
2019,245 тыс. руб.,99 недель
2015,328 тыс. руб.,50 недель
2015,355 тыс. руб.,84 недель
2016,358 тыс. руб.,70 недель
2017,463 тыс. руб.,33 недель
2015,426 тыс. руб.,63 недель
2016,153 тыс. руб.,19 недель
2015,294 тыс. руб.,15 недель
2016,190 тыс. руб.,61 недель
2019,256 тыс. руб.,16 недель
2015,327 тыс. руб.,72 недель
2017,499 тыс. руб.,41 недель
2015,452 тыс. руб.,71 недель
2018,142 тыс. руб.,57 недель
2019,452 тыс. руб.,100 недель
2015,240 тыс. руб.,88 недель
2017,141 тыс. руб.,72 недель
2018,215 тыс. руб.,40 недель
2019,177 тыс. руб.,75 недель
2019,115 тыс. руб.,15 недель
2017,148 тыс. руб.,95 недель
2019,125 тыс. руб.,24 недель
2019,434 тыс. руб.,88 недель
2016,348 тыс. руб.,83 недель
2017,127 тыс. руб.,68 недель
2018,145 тыс. руб.,41 недель 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: 1990 
<Вывод>: nan 
<Решение студента>: year = input()

with open('projects_file.csv', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        info = line.split(',')
        if info[0] <= year and int(info[-2].split()[0]) <= 500:
            print(year) 
<Идеальное решение>: year = input()

with open('projects_file.csv', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        info = line.split(',')
        if info[0] <= year and int(info[-2].split()[0]) <= 500:
            print(line) 


<Комментарий эксперта>:"
79,122,7,"Ксения анализирует реализованные дизайн-проекты, которые собраны в файле формата csv. Напишите программу, которая выводит все строки, соответствующие реализованным в определенный период проектам, стоимость которых была не более 500 тыс. руб..

Программа должна открывать структурированный текстовый файл projects_file.csv, в кодировке utf-8, где на каждой строке записана следующая информация о дизайн-проекте: год, стоимость проекта, количество недель, за сколько был реализован проект. Например, строка ""2019,200 тыс. руб.,10 недель"" означает, что в 2019 году проект стоимостью 200 тыс. руб. был реализован за 10 недель.
Гарантируется, что стоимость реализованного проекта всегда записана в формате ""<целое число> тыс. руб."".
Гарантируется, что срок реализации проекта всегда записан в формате ""<целое число> недель"".
Разделителями данных в файле служат запятые.
Гарантируется, что в файле есть как минимум одна строка с данными. 
С клавиатуры вводится строка — год.
Программа должна выводить строки из оригинального файла, которые соответствуют проектам, реализованным не позднее, чем в указанном году, со стоимостью не более 500. тыс. руб. (не забудьте удалить символы конца строки!).
Если подходящих под условие строк в файле нет, то программа ничего не выводит.
ДОПОЛНИТЕЛЬНО
Ваше решение будет проверяться на закрытых тестах. Ваш код должен считывать файл projects_file.csv без дополнительных указаний (например, пути к файлу на вашем компьютере).
В открытом тесте используется файл projects_file.csv. Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.","['2019', '2018', '2015', '2019', '1990']","['2018,253 тыс. руб.,45 недель\n2018,340 тыс. руб.,34 недель\n2019,263 тыс. руб.,90 недель\n2019,320 тыс. руб.,31 недель\n2019,478 тыс. руб.,85 недель\n2018,324 тыс. руб.,18 недель\n2019,186 тыс. руб.,82 недель\n2018,349 тыс. руб.,95 недель\n2019,479 тыс. руб.,31 недель\n2019,192 тыс. руб.,36 недель\n2018,393 тыс. руб.,90 недель\n2019,206 тыс. руб.,70 недель\n2019,185 тыс. руб.,27 недель\n2019,396 тыс. руб.,36 недель\n2018,445 тыс. руб.,6 недель\n2019,492 тыс. руб.,77 недель\n2018,267 тыс. руб.,38 недель\n2018,260 тыс. руб.,79 недель\n2018,214 тыс. руб.,47 недель\n2018,151 тыс. руб.,70 недель\n2019,116 тыс. руб.,25 недель\n2019,178 тыс. руб.,9 недель\n2019,100 тыс. руб.,24 недель\n2019,112 тыс. руб.,91 недель\n2019,369 тыс. руб.,24 недель\n2019,166 тыс. руб.,67 недель\n2019,498 тыс. руб.,83 недель\n2018,276 тыс. руб.,48 недель\n2019,493 тыс. руб.,20 недель\n2019,358 тыс. руб.,27 недель\n2019,394 тыс. руб.,49 недель\n2019,429 тыс. руб.,77 недель\n2019,375 тыс. руб.,44 недель\n2019,245 тыс. руб.,74 недель\n2018,313 тыс. руб.,5 недель\n2018,244 тыс. руб.,26 недель\n2018,432 тыс. руб.,87 недель\n2019,291 тыс. руб.,96 недель\n2018,355 тыс. руб.,100 недель\n2019,377 тыс. руб.,39 недель', '2018,240 тыс. руб.,86 недель\n2018,491 тыс. руб.,75 недель\n2018,310 тыс. руб.,29 недель\n2018,111 тыс. руб.,60 недель\n2018,252 тыс. руб.,81 недель\n2018,448 тыс. руб.,55 недель\n2018,397 тыс. руб.,73 недель\n2018,472 тыс. руб.,74 недель\n2018,357 тыс. руб.,17 недель\n2018,364 тыс. руб.,82 недель\n2018,187 тыс. руб.,89 недель\n2018,267 тыс. руб.,57 недель\n2018,254 тыс. руб.,18 недель\n2018,330 тыс. руб.,95 недель\n2018,488 тыс. руб.,64 недель\n2018,167 тыс. руб.,29 недель\n2018,327 тыс. руб.,27 недель\n2018,275 тыс. руб.,13 недель\n2018,205 тыс. руб.,93 недель\n2018,354 тыс. руб.,38 недель', '2015,497 тыс. руб.,82 недель\n2015,391 тыс. руб.,81 недель\n2015,488 тыс. руб.,72 недель\n2015,188 тыс. руб.,72 недель\n2015,320 тыс. руб.,57 недель\n2015,251 тыс. руб.,36 недель\n2015,488 тыс. руб.,96 недель\n2015,379 тыс. руб.,14 недель\n2015,305 тыс. руб.,90 недель\n2015,284 тыс. руб.,33 недель\n2015,180 тыс. руб.,15 недель\n2015,328 тыс. руб.,50 недель\n2015,355 тыс. руб.,84 недель\n2015,426 тыс. руб.,63 недель\n2015,294 тыс. руб.,15 недель\n2015,327 тыс. руб.,72 недель\n2015,452 тыс. руб.,71 недель\n2015,240 тыс. руб.,88 недель', '2019,255 тыс. руб.,56 недель\n2017,280 тыс. руб.,80 недель\n2019,111 тыс. руб.,49 недель\n2015,497 тыс. руб.,82 недель\n2015,391 тыс. руб.,81 недель\n2015,488 тыс. руб.,72 недель\n2016,219 тыс. руб.,11 недель\n2015,188 тыс. руб.,72 недель\n2016,439 тыс. руб.,82 недель\n2016,410 тыс. руб.,26 недель\n2017,166 тыс. руб.,100 недель\n2019,449 тыс. руб.,100 недель\n2019,148 тыс. руб.,51 недель\n2018,246 тыс. руб.,59 недель\n2018,307 тыс. руб.,20 недель\n2019,113 тыс. руб.,41 недель\n2017,278 тыс. руб.,40 недель\n2015,320 тыс. руб.,57 недель\n2016,195 тыс. руб.,37 недель\n2019,330 тыс. руб.,69 недель\n2015,251 тыс. руб.,36 недель\n2015,488 тыс. руб.,96 недель\n2017,215 тыс. руб.,22 недель\n2017,151 тыс. руб.,93 недель\n2016,470 тыс. руб.,84 недель\n2018,376 тыс. руб.,53 недель\n2018,488 тыс. руб.,13 недель\n2017,164 тыс. руб.,15 недель\n2016,226 тыс. руб.,51 недель\n2015,379 тыс. руб.,14 недель\n2015,305 тыс. руб.,90 недель\n2015,284 тыс. руб.,33 недель\n2016,158 тыс. руб.,55 недель\n2016,257 тыс. руб.,14 недель\n2015,180 тыс. руб.,15 недель\n2017,262 тыс. руб.,73 недель\n2019,245 тыс. руб.,99 недель\n2015,328 тыс. руб.,50 недель\n2015,355 тыс. руб.,84 недель\n2016,358 тыс. руб.,70 недель\n2017,463 тыс. руб.,33 недель\n2015,426 тыс. руб.,63 недель\n2016,153 тыс. руб.,19 недель\n2015,294 тыс. руб.,15 недель\n2016,190 тыс. руб.,61 недель\n2019,256 тыс. руб.,16 недель\n2015,327 тыс. руб.,72 недель\n2017,499 тыс. руб.,41 недель\n2015,452 тыс. руб.,71 недель\n2018,142 тыс. руб.,57 недель\n2019,452 тыс. руб.,100 недель\n2015,240 тыс. руб.,88 недель\n2017,141 тыс. руб.,72 недель\n2018,215 тыс. руб.,40 недель\n2019,177 тыс. руб.,75 недель\n2019,115 тыс. руб.,15 недель\n2017,148 тыс. руб.,95 недель\n2019,125 тыс. руб.,24 недель\n2019,434 тыс. руб.,88 недель\n2016,348 тыс. руб.,83 недель\n2017,127 тыс. руб.,68 недель\n2018,145 тыс. руб.,41 недель', nan]","year = input()

open('projects_file.csv', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        info = line.split(',')
        if info[0] <= year and int(info[-2].split()[0]) <= 500:
            print(line)","year = input()

with open('projects_file.csv', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        info = line.split(',')
        if info[0] <= year and int(info[-2].split()[0]) <= 500:
            print(line)",Некорректный синтаксис при использовании функции open.,"['open', 'closed', 'closed', 'closed', 'closed']","<Task description>: Ксения анализирует реализованные дизайн-проекты, которые собраны в файле формата csv. Напишите программу, которая выводит все строки, соответствующие реализованным в определенный период проектам, стоимость которых была не более 500 тыс. руб..

Программа должна открывать структурированный текстовый файл projects_file.csv, в кодировке utf-8, где на каждой строке записана следующая информация о дизайн-проекте: год, стоимость проекта, количество недель, за сколько был реализован проект. Например, строка ""2019,200 тыс. руб.,10 недель"" означает, что в 2019 году проект стоимостью 200 тыс. руб. был реализован за 10 недель.
Гарантируется, что стоимость реализованного проекта всегда записана в формате ""<целое число> тыс. руб."".
Гарантируется, что срок реализации проекта всегда записан в формате ""<целое число> недель"".
Разделителями данных в файле служат запятые.
Гарантируется, что в файле есть как минимум одна строка с данными. 
С клавиатуры вводится строка — год.
Программа должна выводить строки из оригинального файла, которые соответствуют проектам, реализованным не позднее, чем в указанном году, со стоимостью не более 500. тыс. руб. (не забудьте удалить символы конца строки!).
Если подходящих под условие строк в файле нет, то программа ничего не выводит.
ДОПОЛНИТЕЛЬНО
Ваше решение будет проверяться на закрытых тестах. Ваш код должен считывать файл projects_file.csv без дополнительных указаний (например, пути к файлу на вашем компьютере).
В открытом тесте используется файл projects_file.csv. Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: 2019 
<Вывод>: 2018,253 тыс. руб.,45 недель
2018,340 тыс. руб.,34 недель
2019,263 тыс. руб.,90 недель
2019,320 тыс. руб.,31 недель
2019,478 тыс. руб.,85 недель
2018,324 тыс. руб.,18 недель
2019,186 тыс. руб.,82 недель
2018,349 тыс. руб.,95 недель
2019,479 тыс. руб.,31 недель
2019,192 тыс. руб.,36 недель
2018,393 тыс. руб.,90 недель
2019,206 тыс. руб.,70 недель
2019,185 тыс. руб.,27 недель
2019,396 тыс. руб.,36 недель
2018,445 тыс. руб.,6 недель
2019,492 тыс. руб.,77 недель
2018,267 тыс. руб.,38 недель
2018,260 тыс. руб.,79 недель
2018,214 тыс. руб.,47 недель
2018,151 тыс. руб.,70 недель
2019,116 тыс. руб.,25 недель
2019,178 тыс. руб.,9 недель
2019,100 тыс. руб.,24 недель
2019,112 тыс. руб.,91 недель
2019,369 тыс. руб.,24 недель
2019,166 тыс. руб.,67 недель
2019,498 тыс. руб.,83 недель
2018,276 тыс. руб.,48 недель
2019,493 тыс. руб.,20 недель
2019,358 тыс. руб.,27 недель
2019,394 тыс. руб.,49 недель
2019,429 тыс. руб.,77 недель
2019,375 тыс. руб.,44 недель
2019,245 тыс. руб.,74 недель
2018,313 тыс. руб.,5 недель
2018,244 тыс. руб.,26 недель
2018,432 тыс. руб.,87 недель
2019,291 тыс. руб.,96 недель
2018,355 тыс. руб.,100 недель
2019,377 тыс. руб.,39 недель 
<Example 2>: 
<Тип теста 2>: closed 
<Ввод>: 2018 
<Вывод>: 2018,240 тыс. руб.,86 недель
2018,491 тыс. руб.,75 недель
2018,310 тыс. руб.,29 недель
2018,111 тыс. руб.,60 недель
2018,252 тыс. руб.,81 недель
2018,448 тыс. руб.,55 недель
2018,397 тыс. руб.,73 недель
2018,472 тыс. руб.,74 недель
2018,357 тыс. руб.,17 недель
2018,364 тыс. руб.,82 недель
2018,187 тыс. руб.,89 недель
2018,267 тыс. руб.,57 недель
2018,254 тыс. руб.,18 недель
2018,330 тыс. руб.,95 недель
2018,488 тыс. руб.,64 недель
2018,167 тыс. руб.,29 недель
2018,327 тыс. руб.,27 недель
2018,275 тыс. руб.,13 недель
2018,205 тыс. руб.,93 недель
2018,354 тыс. руб.,38 недель 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: 2015 
<Вывод>: 2015,497 тыс. руб.,82 недель
2015,391 тыс. руб.,81 недель
2015,488 тыс. руб.,72 недель
2015,188 тыс. руб.,72 недель
2015,320 тыс. руб.,57 недель
2015,251 тыс. руб.,36 недель
2015,488 тыс. руб.,96 недель
2015,379 тыс. руб.,14 недель
2015,305 тыс. руб.,90 недель
2015,284 тыс. руб.,33 недель
2015,180 тыс. руб.,15 недель
2015,328 тыс. руб.,50 недель
2015,355 тыс. руб.,84 недель
2015,426 тыс. руб.,63 недель
2015,294 тыс. руб.,15 недель
2015,327 тыс. руб.,72 недель
2015,452 тыс. руб.,71 недель
2015,240 тыс. руб.,88 недель 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: 2019 
<Вывод>: 2019,255 тыс. руб.,56 недель
2017,280 тыс. руб.,80 недель
2019,111 тыс. руб.,49 недель
2015,497 тыс. руб.,82 недель
2015,391 тыс. руб.,81 недель
2015,488 тыс. руб.,72 недель
2016,219 тыс. руб.,11 недель
2015,188 тыс. руб.,72 недель
2016,439 тыс. руб.,82 недель
2016,410 тыс. руб.,26 недель
2017,166 тыс. руб.,100 недель
2019,449 тыс. руб.,100 недель
2019,148 тыс. руб.,51 недель
2018,246 тыс. руб.,59 недель
2018,307 тыс. руб.,20 недель
2019,113 тыс. руб.,41 недель
2017,278 тыс. руб.,40 недель
2015,320 тыс. руб.,57 недель
2016,195 тыс. руб.,37 недель
2019,330 тыс. руб.,69 недель
2015,251 тыс. руб.,36 недель
2015,488 тыс. руб.,96 недель
2017,215 тыс. руб.,22 недель
2017,151 тыс. руб.,93 недель
2016,470 тыс. руб.,84 недель
2018,376 тыс. руб.,53 недель
2018,488 тыс. руб.,13 недель
2017,164 тыс. руб.,15 недель
2016,226 тыс. руб.,51 недель
2015,379 тыс. руб.,14 недель
2015,305 тыс. руб.,90 недель
2015,284 тыс. руб.,33 недель
2016,158 тыс. руб.,55 недель
2016,257 тыс. руб.,14 недель
2015,180 тыс. руб.,15 недель
2017,262 тыс. руб.,73 недель
2019,245 тыс. руб.,99 недель
2015,328 тыс. руб.,50 недель
2015,355 тыс. руб.,84 недель
2016,358 тыс. руб.,70 недель
2017,463 тыс. руб.,33 недель
2015,426 тыс. руб.,63 недель
2016,153 тыс. руб.,19 недель
2015,294 тыс. руб.,15 недель
2016,190 тыс. руб.,61 недель
2019,256 тыс. руб.,16 недель
2015,327 тыс. руб.,72 недель
2017,499 тыс. руб.,41 недель
2015,452 тыс. руб.,71 недель
2018,142 тыс. руб.,57 недель
2019,452 тыс. руб.,100 недель
2015,240 тыс. руб.,88 недель
2017,141 тыс. руб.,72 недель
2018,215 тыс. руб.,40 недель
2019,177 тыс. руб.,75 недель
2019,115 тыс. руб.,15 недель
2017,148 тыс. руб.,95 недель
2019,125 тыс. руб.,24 недель
2019,434 тыс. руб.,88 недель
2016,348 тыс. руб.,83 недель
2017,127 тыс. руб.,68 недель
2018,145 тыс. руб.,41 недель 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: 1990 
<Вывод>: nan 
<Решение студента>: year = input()

open('projects_file.csv', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        info = line.split(',')
        if info[0] <= year and int(info[-2].split()[0]) <= 500:
            print(line) 
<Идеальное решение>: year = input()

with open('projects_file.csv', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        info = line.split(',')
        if info[0] <= year and int(info[-2].split()[0]) <= 500:
            print(line) 


<Комментарий эксперта>:"
80,220,14,"Реализуйте программу, которая определит количество корректных названий проектов для конкурса дизайнеров интерьера:

В цикле while считываются названия проектов до тех пор, пока не введена строка ""СТОП"".
Гарантируется, что названия проектов не повторяются. 
Гарантируется, что до строки ""СТОП"" будет введена как минимум одна строка.
Напечатайте количество проектов, которые состоят только из букв нижнего регистра и в которых есть знак подчеркивания.","['ПРОЕКТ 1\nПРОЕКТ_2\nпроект_3\nПроект 4\nинтерьер_\n_диз_ИНТ\nСТОП', 'ПРОЕКТ_1\nработа_ФИН\nФинальная_работа\nСТОП', '123_ПРОГА_П\n123_прога_п\n123ПРОГАП?\n123 ПРОГА п\nСТОП', '_дизайнер_\n_ПРОГРАМИСТ_\n_пробный\nПРОЕКТ!\n_____п\nСТОП', 'ПРОЕКТ_1\nПРОЕКТ_2\nПРОЕКТ_3\nПРОЕКТ!4\nпроект 1\nСТОП']","['2', '2', '1', '3', '0']","result = 0
info = input()

while info != 'СТОП':
    info = input()
        
    if '_' in info and info.islower():
        result += 1
        
print(result)","result = 0

while True:
    info = input()
    if info == 'СТОП':
        break
    
    if '_' in info and info.islower():
        result += 1
        
print(result)","Ошибка в скрытых тестах.

Ваш код некорректно обрабатывает данные. Обращение к новому элементу ввода происходит до обработки первого ввода.","['open', 'open', 'closed', 'closed', 'closed']","<Task description>: Реализуйте программу, которая определит количество корректных названий проектов для конкурса дизайнеров интерьера:

В цикле while считываются названия проектов до тех пор, пока не введена строка ""СТОП"".
Гарантируется, что названия проектов не повторяются. 
Гарантируется, что до строки ""СТОП"" будет введена как минимум одна строка.
Напечатайте количество проектов, которые состоят только из букв нижнего регистра и в которых есть знак подчеркивания. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: ПРОЕКТ 1
ПРОЕКТ_2
проект_3
Проект 4
интерьер_
_диз_ИНТ
СТОП 
<Вывод>: 2 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: ПРОЕКТ_1
работа_ФИН
Финальная_работа
СТОП 
<Вывод>: 2 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: 123_ПРОГА_П
123_прога_п
123ПРОГАП?
123 ПРОГА п
СТОП 
<Вывод>: 1 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: _дизайнер_
_ПРОГРАМИСТ_
_пробный
ПРОЕКТ!
_____п
СТОП 
<Вывод>: 3 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: ПРОЕКТ_1
ПРОЕКТ_2
ПРОЕКТ_3
ПРОЕКТ!4
проект 1
СТОП 
<Вывод>: 0 
<Решение студента>: result = 0
info = input()

while info != 'СТОП':
    info = input()
        
    if '_' in info and info.islower():
        result += 1
        
print(result) 
<Идеальное решение>: result = 0

while True:
    info = input()
    if info == 'СТОП':
        break
    
    if '_' in info and info.islower():
        result += 1
        
print(result) 


<Комментарий эксперта>:"
81,221,14,"Реализуйте программу, которая определит количество корректных названий проектов для конкурса дизайнеров интерьера:

В цикле while считываются названия проектов до тех пор, пока не введена строка ""СТОП"".
Гарантируется, что названия проектов не повторяются. 
Гарантируется, что до строки ""СТОП"" будет введена как минимум одна строка.
Напечатайте количество проектов, которые состоят только из букв нижнего регистра и в которых есть знак подчеркивания.","['ПРОЕКТ 1\nПРОЕКТ_2\nпроект_3\nПроект 4\nинтерьер_\n_диз_ИНТ\nСТОП', 'ПРОЕКТ_1\nработа_ФИН\nФинальная_работа\nСТОП', '123_ПРОГА_П\n123_прога_п\n123ПРОГАП?\n123 ПРОГА п\nСТОП', '_дизайнер_\n_ПРОГРАМИСТ_\n_пробный\nПРОЕКТ!\n_____п\nСТОП', 'ПРОЕКТ_1\nПРОЕКТ_2\nПРОЕКТ_3\nПРОЕКТ!4\nпроект 1\nСТОП']","['2', '2', '1', '3', '0']","result = 0

while True
    info = input()
    if info == 'СТОП':
        break
    
    if '_' in info and info.islower():
        result += 1
        
print(result)","result = 0

while True:
    info = input()
    if info == 'СТОП':
        break
    
    if '_' in info and info.islower():
        result += 1
        
print(result)",Вы забыли поставить двоеточие после условия цикла while.,"['open', 'open', 'closed', 'closed', 'closed']","<Task description>: Реализуйте программу, которая определит количество корректных названий проектов для конкурса дизайнеров интерьера:

В цикле while считываются названия проектов до тех пор, пока не введена строка ""СТОП"".
Гарантируется, что названия проектов не повторяются. 
Гарантируется, что до строки ""СТОП"" будет введена как минимум одна строка.
Напечатайте количество проектов, которые состоят только из букв нижнего регистра и в которых есть знак подчеркивания. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: ПРОЕКТ 1
ПРОЕКТ_2
проект_3
Проект 4
интерьер_
_диз_ИНТ
СТОП 
<Вывод>: 2 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: ПРОЕКТ_1
работа_ФИН
Финальная_работа
СТОП 
<Вывод>: 2 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: 123_ПРОГА_П
123_прога_п
123ПРОГАП?
123 ПРОГА п
СТОП 
<Вывод>: 1 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: _дизайнер_
_ПРОГРАМИСТ_
_пробный
ПРОЕКТ!
_____п
СТОП 
<Вывод>: 3 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: ПРОЕКТ_1
ПРОЕКТ_2
ПРОЕКТ_3
ПРОЕКТ!4
проект 1
СТОП 
<Вывод>: 0 
<Решение студента>: result = 0

while True
    info = input()
    if info == 'СТОП':
        break
    
    if '_' in info and info.islower():
        result += 1
        
print(result) 
<Идеальное решение>: result = 0

while True:
    info = input()
    if info == 'СТОП':
        break
    
    if '_' in info and info.islower():
        result += 1
        
print(result) 


<Комментарий эксперта>:"
82,222,14,"Реализуйте программу, которая определит количество корректных названий проектов для конкурса дизайнеров интерьера:

В цикле while считываются названия проектов до тех пор, пока не введена строка ""СТОП"".
Гарантируется, что названия проектов не повторяются. 
Гарантируется, что до строки ""СТОП"" будет введена как минимум одна строка.
Напечатайте количество проектов, которые состоят только из букв нижнего регистра и в которых есть знак подчеркивания.","['ПРОЕКТ 1\nПРОЕКТ_2\nпроект_3\nПроект 4\nинтерьер_\n_диз_ИНТ\nСТОП', 'ПРОЕКТ_1\nработа_ФИН\nФинальная_работа\nСТОП', '123_ПРОГА_П\n123_прога_п\n123ПРОГАП?\n123 ПРОГА п\nСТОП', '_дизайнер_\n_ПРОГРАМИСТ_\n_пробный\nПРОЕКТ!\n_____п\nСТОП', 'ПРОЕКТ_1\nПРОЕКТ_2\nПРОЕКТ_3\nПРОЕКТ!4\nпроект 1\nСТОП']","['2', '2', '1', '3', '0']","result = 0

while True:
    info = input()
    if info == 'END':
        break
    
    if '_' in info and info.islower():
        result += 1
        
print(result)","result = 0

while True:
    info = input()
    if info == 'СТОП':
        break
    
    if '_' in info and info.islower():
        result += 1
        
print(result)","Ошибка при обработке данных. Ваш код некорректно считывает строку ""СТОП"". Попробкйте изменить условие if для корректировки ошибки.","['open', 'open', 'closed', 'closed', 'closed']","<Task description>: Реализуйте программу, которая определит количество корректных названий проектов для конкурса дизайнеров интерьера:

В цикле while считываются названия проектов до тех пор, пока не введена строка ""СТОП"".
Гарантируется, что названия проектов не повторяются. 
Гарантируется, что до строки ""СТОП"" будет введена как минимум одна строка.
Напечатайте количество проектов, которые состоят только из букв нижнего регистра и в которых есть знак подчеркивания. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: ПРОЕКТ 1
ПРОЕКТ_2
проект_3
Проект 4
интерьер_
_диз_ИНТ
СТОП 
<Вывод>: 2 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: ПРОЕКТ_1
работа_ФИН
Финальная_работа
СТОП 
<Вывод>: 2 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: 123_ПРОГА_П
123_прога_п
123ПРОГАП?
123 ПРОГА п
СТОП 
<Вывод>: 1 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: _дизайнер_
_ПРОГРАМИСТ_
_пробный
ПРОЕКТ!
_____п
СТОП 
<Вывод>: 3 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: ПРОЕКТ_1
ПРОЕКТ_2
ПРОЕКТ_3
ПРОЕКТ!4
проект 1
СТОП 
<Вывод>: 0 
<Решение студента>: result = 0

while True:
    info = input()
    if info == 'END':
        break
    
    if '_' in info and info.islower():
        result += 1
        
print(result) 
<Идеальное решение>: result = 0

while True:
    info = input()
    if info == 'СТОП':
        break
    
    if '_' in info and info.islower():
        result += 1
        
print(result) 


<Комментарий эксперта>:"
83,223,14,"Реализуйте программу, которая определит количество корректных названий проектов для конкурса дизайнеров интерьера:

В цикле while считываются названия проектов до тех пор, пока не введена строка ""СТОП"".
Гарантируется, что названия проектов не повторяются. 
Гарантируется, что до строки ""СТОП"" будет введена как минимум одна строка.
Напечатайте количество проектов, которые состоят только из букв нижнего регистра и в которых есть знак подчеркивания.","['ПРОЕКТ 1\nПРОЕКТ_2\nпроект_3\nПроект 4\nинтерьер_\n_диз_ИНТ\nСТОП', 'ПРОЕКТ_1\nработа_ФИН\nФинальная_работа\nСТОП', '123_ПРОГА_П\n123_прога_п\n123ПРОГАП?\n123 ПРОГА п\nСТОП', '_дизайнер_\n_ПРОГРАМИСТ_\n_пробный\nПРОЕКТ!\n_____п\nСТОП', 'ПРОЕКТ_1\nПРОЕКТ_2\nПРОЕКТ_3\nПРОЕКТ!4\nпроект 1\nСТОП']","['2', '2', '1', '3', '0']","result = 0

while True:
    info = input()
    if info = 'СТОП':
        break
    
    if '_' in info and info.islower():
        result += 1
        
print(result)","result = 0

while True:
    info = input()
    if info == 'СТОП':
        break
    
    if '_' in info and info.islower():
        result += 1
        
print(result)","Синтаксическая ошибка в условии конструкции if. При сравнении переменной с определенными данными следует использовать двойной знак равенства, а не одинарный.","['open', 'open', 'closed', 'closed', 'closed']","<Task description>: Реализуйте программу, которая определит количество корректных названий проектов для конкурса дизайнеров интерьера:

В цикле while считываются названия проектов до тех пор, пока не введена строка ""СТОП"".
Гарантируется, что названия проектов не повторяются. 
Гарантируется, что до строки ""СТОП"" будет введена как минимум одна строка.
Напечатайте количество проектов, которые состоят только из букв нижнего регистра и в которых есть знак подчеркивания. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: ПРОЕКТ 1
ПРОЕКТ_2
проект_3
Проект 4
интерьер_
_диз_ИНТ
СТОП 
<Вывод>: 2 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: ПРОЕКТ_1
работа_ФИН
Финальная_работа
СТОП 
<Вывод>: 2 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: 123_ПРОГА_П
123_прога_п
123ПРОГАП?
123 ПРОГА п
СТОП 
<Вывод>: 1 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: _дизайнер_
_ПРОГРАМИСТ_
_пробный
ПРОЕКТ!
_____п
СТОП 
<Вывод>: 3 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: ПРОЕКТ_1
ПРОЕКТ_2
ПРОЕКТ_3
ПРОЕКТ!4
проект 1
СТОП 
<Вывод>: 0 
<Решение студента>: result = 0

while True:
    info = input()
    if info = 'СТОП':
        break
    
    if '_' in info and info.islower():
        result += 1
        
print(result) 
<Идеальное решение>: result = 0

while True:
    info = input()
    if info == 'СТОП':
        break
    
    if '_' in info and info.islower():
        result += 1
        
print(result) 


<Комментарий эксперта>:"
84,224,14,"Реализуйте программу, которая определит количество корректных названий проектов для конкурса дизайнеров интерьера:

В цикле while считываются названия проектов до тех пор, пока не введена строка ""СТОП"".
Гарантируется, что названия проектов не повторяются. 
Гарантируется, что до строки ""СТОП"" будет введена как минимум одна строка.
Напечатайте количество проектов, которые состоят только из букв нижнего регистра и в которых есть знак подчеркивания.","['ПРОЕКТ 1\nПРОЕКТ_2\nпроект_3\nПроект 4\nинтерьер_\n_диз_ИНТ\nСТОП', 'ПРОЕКТ_1\nработа_ФИН\nФинальная_работа\nСТОП', '123_ПРОГА_П\n123_прога_п\n123ПРОГАП?\n123 ПРОГА п\nСТОП', '_дизайнер_\n_ПРОГРАМИСТ_\n_пробный\nПРОЕКТ!\n_____п\nСТОП', 'ПРОЕКТ_1\nПРОЕКТ_2\nПРОЕКТ_3\nПРОЕКТ!4\nпроект 1\nСТОП']","['2', '2', '1', '3', '0']","result = 0

while True:
    info = input()
    if info == 'СТОП':
        break
    
    if _ in info and info.islower():
        result += 1
        
print(result)","result = 0

while True:
    info = input()
    if info == 'СТОП':
        break
    
    if '_' in info and info.islower():
        result += 1
        
print(result)",Вы забыли поставить знак подчеркивания в кавычки.,"['open', 'open', 'closed', 'closed', 'closed']","<Task description>: Реализуйте программу, которая определит количество корректных названий проектов для конкурса дизайнеров интерьера:

В цикле while считываются названия проектов до тех пор, пока не введена строка ""СТОП"".
Гарантируется, что названия проектов не повторяются. 
Гарантируется, что до строки ""СТОП"" будет введена как минимум одна строка.
Напечатайте количество проектов, которые состоят только из букв нижнего регистра и в которых есть знак подчеркивания. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: ПРОЕКТ 1
ПРОЕКТ_2
проект_3
Проект 4
интерьер_
_диз_ИНТ
СТОП 
<Вывод>: 2 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: ПРОЕКТ_1
работа_ФИН
Финальная_работа
СТОП 
<Вывод>: 2 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: 123_ПРОГА_П
123_прога_п
123ПРОГАП?
123 ПРОГА п
СТОП 
<Вывод>: 1 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: _дизайнер_
_ПРОГРАМИСТ_
_пробный
ПРОЕКТ!
_____п
СТОП 
<Вывод>: 3 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: ПРОЕКТ_1
ПРОЕКТ_2
ПРОЕКТ_3
ПРОЕКТ!4
проект 1
СТОП 
<Вывод>: 0 
<Решение студента>: result = 0

while True:
    info = input()
    if info == 'СТОП':
        break
    
    if _ in info and info.islower():
        result += 1
        
print(result) 
<Идеальное решение>: result = 0

while True:
    info = input()
    if info == 'СТОП':
        break
    
    if '_' in info and info.islower():
        result += 1
        
print(result) 


<Комментарий эксперта>:"
85,225,14,"Реализуйте программу, которая определит количество корректных названий проектов для конкурса дизайнеров интерьера:

В цикле while считываются названия проектов до тех пор, пока не введена строка ""СТОП"".
Гарантируется, что названия проектов не повторяются. 
Гарантируется, что до строки ""СТОП"" будет введена как минимум одна строка.
Напечатайте количество проектов, которые состоят только из букв нижнего регистра и в которых есть знак подчеркивания.","['ПРОЕКТ 1\nПРОЕКТ_2\nпроект_3\nПроект 4\nинтерьер_\n_диз_ИНТ\nСТОП', 'ПРОЕКТ_1\nработа_ФИН\nФинальная_работа\nСТОП', '123_ПРОГА_П\n123_прога_п\n123ПРОГАП?\n123 ПРОГА п\nСТОП', '_дизайнер_\n_ПРОГРАМИСТ_\n_пробный\nПРОЕКТ!\n_____п\nСТОП', 'ПРОЕКТ_1\nПРОЕКТ_2\nПРОЕКТ_3\nПРОЕКТ!4\nпроект 1\nСТОП']","['2', '2', '1', '3', '0']","result = 0

while True:
    info = input()
    if info == 'СТОП':
        break
    
    if '_' not in info and info.islower():
        result += 1
        
print(result)","result = 0

while True:
    info = input()
    if info == 'СТОП':
        break
    
    if '_' in info and info.islower():
        result += 1
        
print(result)","Ошибка в открытых и скрытых тестах. 

Ваш код неверно выполянет условие ""в которых есть знак подчеркивания"". Скорректируйте условие конструкции if для исправление ошибки.","['open', 'open', 'closed', 'closed', 'closed']","<Task description>: Реализуйте программу, которая определит количество корректных названий проектов для конкурса дизайнеров интерьера:

В цикле while считываются названия проектов до тех пор, пока не введена строка ""СТОП"".
Гарантируется, что названия проектов не повторяются. 
Гарантируется, что до строки ""СТОП"" будет введена как минимум одна строка.
Напечатайте количество проектов, которые состоят только из букв нижнего регистра и в которых есть знак подчеркивания. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: ПРОЕКТ 1
ПРОЕКТ_2
проект_3
Проект 4
интерьер_
_диз_ИНТ
СТОП 
<Вывод>: 2 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: ПРОЕКТ_1
работа_ФИН
Финальная_работа
СТОП 
<Вывод>: 2 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: 123_ПРОГА_П
123_прога_п
123ПРОГАП?
123 ПРОГА п
СТОП 
<Вывод>: 1 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: _дизайнер_
_ПРОГРАМИСТ_
_пробный
ПРОЕКТ!
_____п
СТОП 
<Вывод>: 3 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: ПРОЕКТ_1
ПРОЕКТ_2
ПРОЕКТ_3
ПРОЕКТ!4
проект 1
СТОП 
<Вывод>: 0 
<Решение студента>: result = 0

while True:
    info = input()
    if info == 'СТОП':
        break
    
    if '_' not in info and info.islower():
        result += 1
        
print(result) 
<Идеальное решение>: result = 0

while True:
    info = input()
    if info == 'СТОП':
        break
    
    if '_' in info and info.islower():
        result += 1
        
print(result) 


<Комментарий эксперта>:"
86,226,14,"Реализуйте программу, которая определит количество корректных названий проектов для конкурса дизайнеров интерьера:

В цикле while считываются названия проектов до тех пор, пока не введена строка ""СТОП"".
Гарантируется, что названия проектов не повторяются. 
Гарантируется, что до строки ""СТОП"" будет введена как минимум одна строка.
Напечатайте количество проектов, которые состоят только из букв нижнего регистра и в которых есть знак подчеркивания.","['ПРОЕКТ 1\nПРОЕКТ_2\nпроект_3\nПроект 4\nинтерьер_\n_диз_ИНТ\nСТОП', 'ПРОЕКТ_1\nработа_ФИН\nФинальная_работа\nСТОП', '123_ПРОГА_П\n123_прога_п\n123ПРОГАП?\n123 ПРОГА п\nСТОП', '_дизайнер_\n_ПРОГРАМИСТ_\n_пробный\nПРОЕКТ!\n_____п\nСТОП', 'ПРОЕКТ_1\nПРОЕКТ_2\nПРОЕКТ_3\nПРОЕКТ!4\nпроект 1\nСТОП']","['2', '2', '1', '3', '0']","result = 0

while True:
    info = input()
    if info == 'СТОП':
        break
    
    if '_' in info or info.islower():
        result += 1
        
print(result)","result = 0

while True:
    info = input()
    if info == 'СТОП':
        break
    
    if '_' in info and info.islower():
        result += 1
        
print(result)","Ошибка в открытых и скрытых тестах. 

Обратите внимание на неверный оператор сравнения — необходимо проверить, что соблюдаются оба условия одновременно.","['open', 'open', 'closed', 'closed', 'closed']","<Task description>: Реализуйте программу, которая определит количество корректных названий проектов для конкурса дизайнеров интерьера:

В цикле while считываются названия проектов до тех пор, пока не введена строка ""СТОП"".
Гарантируется, что названия проектов не повторяются. 
Гарантируется, что до строки ""СТОП"" будет введена как минимум одна строка.
Напечатайте количество проектов, которые состоят только из букв нижнего регистра и в которых есть знак подчеркивания. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: ПРОЕКТ 1
ПРОЕКТ_2
проект_3
Проект 4
интерьер_
_диз_ИНТ
СТОП 
<Вывод>: 2 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: ПРОЕКТ_1
работа_ФИН
Финальная_работа
СТОП 
<Вывод>: 2 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: 123_ПРОГА_П
123_прога_п
123ПРОГАП?
123 ПРОГА п
СТОП 
<Вывод>: 1 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: _дизайнер_
_ПРОГРАМИСТ_
_пробный
ПРОЕКТ!
_____п
СТОП 
<Вывод>: 3 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: ПРОЕКТ_1
ПРОЕКТ_2
ПРОЕКТ_3
ПРОЕКТ!4
проект 1
СТОП 
<Вывод>: 0 
<Решение студента>: result = 0

while True:
    info = input()
    if info == 'СТОП':
        break
    
    if '_' in info or info.islower():
        result += 1
        
print(result) 
<Идеальное решение>: result = 0

while True:
    info = input()
    if info == 'СТОП':
        break
    
    if '_' in info and info.islower():
        result += 1
        
print(result) 


<Комментарий эксперта>:"
87,227,14,"Реализуйте программу, которая определит количество корректных названий проектов для конкурса дизайнеров интерьера:

В цикле while считываются названия проектов до тех пор, пока не введена строка ""СТОП"".
Гарантируется, что названия проектов не повторяются. 
Гарантируется, что до строки ""СТОП"" будет введена как минимум одна строка.
Напечатайте количество проектов, которые состоят только из букв нижнего регистра и в которых есть знак подчеркивания.","['ПРОЕКТ 1\nПРОЕКТ_2\nпроект_3\nПроект 4\nинтерьер_\n_диз_ИНТ\nСТОП', 'ПРОЕКТ_1\nработа_ФИН\nФинальная_работа\nСТОП', '123_ПРОГА_П\n123_прога_п\n123ПРОГАП?\n123 ПРОГА п\nСТОП', '_дизайнер_\n_ПРОГРАМИСТ_\n_пробный\nПРОЕКТ!\n_____п\nСТОП', 'ПРОЕКТ_1\nПРОЕКТ_2\nПРОЕКТ_3\nПРОЕКТ!4\nпроект 1\nСТОП']","['2', '2', '1', '3', '0']","result = 0

while True:
    info = input()
    if info == 'СТОП':
        break
    
    if '_' in info and info.lower():
        result += 1
        
print(result)","result = 0

while True:
    info = input()
    if info == 'СТОП':
        break
    
    if '_' in info and info.islower():
        result += 1
        
print(result)",Ошибка в использовании метода проверки заглавных букв. Метод .lower() конвертирует все символы строки в строчные.,"['open', 'open', 'closed', 'closed', 'closed']","<Task description>: Реализуйте программу, которая определит количество корректных названий проектов для конкурса дизайнеров интерьера:

В цикле while считываются названия проектов до тех пор, пока не введена строка ""СТОП"".
Гарантируется, что названия проектов не повторяются. 
Гарантируется, что до строки ""СТОП"" будет введена как минимум одна строка.
Напечатайте количество проектов, которые состоят только из букв нижнего регистра и в которых есть знак подчеркивания. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: ПРОЕКТ 1
ПРОЕКТ_2
проект_3
Проект 4
интерьер_
_диз_ИНТ
СТОП 
<Вывод>: 2 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: ПРОЕКТ_1
работа_ФИН
Финальная_работа
СТОП 
<Вывод>: 2 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: 123_ПРОГА_П
123_прога_п
123ПРОГАП?
123 ПРОГА п
СТОП 
<Вывод>: 1 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: _дизайнер_
_ПРОГРАМИСТ_
_пробный
ПРОЕКТ!
_____п
СТОП 
<Вывод>: 3 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: ПРОЕКТ_1
ПРОЕКТ_2
ПРОЕКТ_3
ПРОЕКТ!4
проект 1
СТОП 
<Вывод>: 0 
<Решение студента>: result = 0

while True:
    info = input()
    if info == 'СТОП':
        break
    
    if '_' in info and info.lower():
        result += 1
        
print(result) 
<Идеальное решение>: result = 0

while True:
    info = input()
    if info == 'СТОП':
        break
    
    if '_' in info and info.islower():
        result += 1
        
print(result) 


<Комментарий эксперта>:"
88,228,14,"Реализуйте программу, которая определит количество корректных названий проектов для конкурса дизайнеров интерьера:

В цикле while считываются названия проектов до тех пор, пока не введена строка ""СТОП"".
Гарантируется, что названия проектов не повторяются. 
Гарантируется, что до строки ""СТОП"" будет введена как минимум одна строка.
Напечатайте количество проектов, которые состоят только из букв нижнего регистра и в которых есть знак подчеркивания.","['ПРОЕКТ 1\nПРОЕКТ_2\nпроект_3\nПроект 4\nинтерьер_\n_диз_ИНТ\nСТОП', 'ПРОЕКТ_1\nработа_ФИН\nФинальная_работа\nСТОП', '123_ПРОГА_П\n123_прога_п\n123ПРОГАП?\n123 ПРОГА п\nСТОП', '_дизайнер_\n_ПРОГРАМИСТ_\n_пробный\nПРОЕКТ!\n_____п\nСТОП', 'ПРОЕКТ_1\nПРОЕКТ_2\nПРОЕКТ_3\nПРОЕКТ!4\nпроект 1\nСТОП']","['2', '2', '1', '3', '0']","result = 0

while True:
    info = input()
    if info == 'СТОП':
        break
    
if '_' in info and info.islower():
    result += 1
        
print(result)","result = 0

while True:
    info = input()
    if info == 'СТОП':
        break
    
    if '_' in info and info.islower():
        result += 1
        
print(result)",Ошибка в табуляции. Проверьте табуляцию второй условной конструкции if.,"['open', 'open', 'closed', 'closed', 'closed']","<Task description>: Реализуйте программу, которая определит количество корректных названий проектов для конкурса дизайнеров интерьера:

В цикле while считываются названия проектов до тех пор, пока не введена строка ""СТОП"".
Гарантируется, что названия проектов не повторяются. 
Гарантируется, что до строки ""СТОП"" будет введена как минимум одна строка.
Напечатайте количество проектов, которые состоят только из букв нижнего регистра и в которых есть знак подчеркивания. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: ПРОЕКТ 1
ПРОЕКТ_2
проект_3
Проект 4
интерьер_
_диз_ИНТ
СТОП 
<Вывод>: 2 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: ПРОЕКТ_1
работа_ФИН
Финальная_работа
СТОП 
<Вывод>: 2 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: 123_ПРОГА_П
123_прога_п
123ПРОГАП?
123 ПРОГА п
СТОП 
<Вывод>: 1 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: _дизайнер_
_ПРОГРАМИСТ_
_пробный
ПРОЕКТ!
_____п
СТОП 
<Вывод>: 3 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: ПРОЕКТ_1
ПРОЕКТ_2
ПРОЕКТ_3
ПРОЕКТ!4
проект 1
СТОП 
<Вывод>: 0 
<Решение студента>: result = 0

while True:
    info = input()
    if info == 'СТОП':
        break
    
if '_' in info and info.islower():
    result += 1
        
print(result) 
<Идеальное решение>: result = 0

while True:
    info = input()
    if info == 'СТОП':
        break
    
    if '_' in info and info.islower():
        result += 1
        
print(result) 


<Комментарий эксперта>:"
89,229,14,"Реализуйте программу, которая определит количество корректных названий проектов для конкурса дизайнеров интерьера:

В цикле while считываются названия проектов до тех пор, пока не введена строка ""СТОП"".
Гарантируется, что названия проектов не повторяются. 
Гарантируется, что до строки ""СТОП"" будет введена как минимум одна строка.
Напечатайте количество проектов, которые состоят только из букв нижнего регистра и в которых есть знак подчеркивания.","['ПРОЕКТ 1\nПРОЕКТ_2\nпроект_3\nПроект 4\nинтерьер_\n_диз_ИНТ\nСТОП', 'ПРОЕКТ_1\nработа_ФИН\nФинальная_работа\nСТОП', '123_ПРОГА_П\n123_прога_п\n123ПРОГАП?\n123 ПРОГА п\nСТОП', '_дизайнер_\n_ПРОГРАМИСТ_\n_пробный\nПРОЕКТ!\n_____п\nСТОП', 'ПРОЕКТ_1\nПРОЕКТ_2\nПРОЕКТ_3\nПРОЕКТ!4\nпроект 1\nСТОП']","['2', '2', '1', '3', '0']","result = 0

while True:
    info = input()
    if info == 'СТОП':
        break
    
    if '_' in info:
         result += 1
    if info.islower():
         result += 1

print(result)","result = 0

while True:
    info = input()
    if info == 'СТОП':
        break
    
    if '_' in info and info.islower():
        result += 1
        
print(result)","Ошибка в открытых и скрытых тестах. 

Обратите внимание, что вы должны проверить, что условия ""состоят только из строчных букв и в которых есть знак подчеркивания"" выполняются одновременно.","['open', 'open', 'closed', 'closed', 'closed']","<Task description>: Реализуйте программу, которая определит количество корректных названий проектов для конкурса дизайнеров интерьера:

В цикле while считываются названия проектов до тех пор, пока не введена строка ""СТОП"".
Гарантируется, что названия проектов не повторяются. 
Гарантируется, что до строки ""СТОП"" будет введена как минимум одна строка.
Напечатайте количество проектов, которые состоят только из букв нижнего регистра и в которых есть знак подчеркивания. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: ПРОЕКТ 1
ПРОЕКТ_2
проект_3
Проект 4
интерьер_
_диз_ИНТ
СТОП 
<Вывод>: 2 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: ПРОЕКТ_1
работа_ФИН
Финальная_работа
СТОП 
<Вывод>: 2 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: 123_ПРОГА_П
123_прога_п
123ПРОГАП?
123 ПРОГА п
СТОП 
<Вывод>: 1 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: _дизайнер_
_ПРОГРАМИСТ_
_пробный
ПРОЕКТ!
_____п
СТОП 
<Вывод>: 3 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: ПРОЕКТ_1
ПРОЕКТ_2
ПРОЕКТ_3
ПРОЕКТ!4
проект 1
СТОП 
<Вывод>: 0 
<Решение студента>: result = 0

while True:
    info = input()
    if info == 'СТОП':
        break
    
    if '_' in info:
         result += 1
    if info.islower():
         result += 1

print(result) 
<Идеальное решение>: result = 0

while True:
    info = input()
    if info == 'СТОП':
        break
    
    if '_' in info and info.islower():
        result += 1
        
print(result) 


<Комментарий эксперта>:"
90,230,14,"Реализуйте программу, которая определит количество корректных названий проектов для конкурса дизайнеров интерьера:

В цикле while считываются названия проектов до тех пор, пока не введена строка ""СТОП"".
Гарантируется, что названия проектов не повторяются. 
Гарантируется, что до строки ""СТОП"" будет введена как минимум одна строка.
Напечатайте количество проектов, которые состоят только из букв нижнего регистра и в которых есть знак подчеркивания.","['ПРОЕКТ 1\nПРОЕКТ_2\nпроект_3\nПроект 4\nинтерьер_\n_диз_ИНТ\nСТОП', 'ПРОЕКТ_1\nработа_ФИН\nФинальная_работа\nСТОП', '123_ПРОГА_П\n123_прога_п\n123ПРОГАП?\n123 ПРОГА п\nСТОП', '_дизайнер_\n_ПРОГРАМИСТ_\n_пробный\nПРОЕКТ!\n_____п\nСТОП', 'ПРОЕКТ_1\nПРОЕКТ_2\nПРОЕКТ_3\nПРОЕКТ!4\nпроект 1\nСТОП']","['2', '2', '1', '3', '0']","result = 0

while True:
    info = input()
    if info == 'СТОП':
        break
    
    if '_' in info and info.islower():
        result += 1
        
print(info)","result = 0

while True:
    info = input()
    if info == 'СТОП':
        break
    
    if '_' in info and info.islower():
        result += 1
        
print(result)",Вы вывели неверную переменную.,"['open', 'open', 'closed', 'closed', 'closed']","<Task description>: Реализуйте программу, которая определит количество корректных названий проектов для конкурса дизайнеров интерьера:

В цикле while считываются названия проектов до тех пор, пока не введена строка ""СТОП"".
Гарантируется, что названия проектов не повторяются. 
Гарантируется, что до строки ""СТОП"" будет введена как минимум одна строка.
Напечатайте количество проектов, которые состоят только из букв нижнего регистра и в которых есть знак подчеркивания. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: ПРОЕКТ 1
ПРОЕКТ_2
проект_3
Проект 4
интерьер_
_диз_ИНТ
СТОП 
<Вывод>: 2 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: ПРОЕКТ_1
работа_ФИН
Финальная_работа
СТОП 
<Вывод>: 2 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: 123_ПРОГА_П
123_прога_п
123ПРОГАП?
123 ПРОГА п
СТОП 
<Вывод>: 1 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: _дизайнер_
_ПРОГРАМИСТ_
_пробный
ПРОЕКТ!
_____п
СТОП 
<Вывод>: 3 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: ПРОЕКТ_1
ПРОЕКТ_2
ПРОЕКТ_3
ПРОЕКТ!4
проект 1
СТОП 
<Вывод>: 0 
<Решение студента>: result = 0

while True:
    info = input()
    if info == 'СТОП':
        break
    
    if '_' in info and info.islower():
        result += 1
        
print(info) 
<Идеальное решение>: result = 0

while True:
    info = input()
    if info == 'СТОП':
        break
    
    if '_' in info and info.islower():
        result += 1
        
print(result) 


<Комментарий эксперта>:"
91,231,14,"Реализуйте программу, которая определит количество корректных названий проектов для конкурса дизайнеров интерьера:

В цикле while считываются названия проектов до тех пор, пока не введена строка ""СТОП"".
Гарантируется, что названия проектов не повторяются. 
Гарантируется, что до строки ""СТОП"" будет введена как минимум одна строка.
Напечатайте количество проектов, которые состоят только из букв нижнего регистра и в которых есть знак подчеркивания.","['ПРОЕКТ 1\nПРОЕКТ_2\nпроект_3\nПроект 4\nинтерьер_\n_диз_ИНТ\nСТОП', 'ПРОЕКТ_1\nработа_ФИН\nФинальная_работа\nСТОП', '123_ПРОГА_П\n123_прога_п\n123ПРОГАП?\n123 ПРОГА п\nСТОП', '_дизайнер_\n_ПРОГРАМИСТ_\n_пробный\nПРОЕКТ!\n_____п\nСТОП', 'ПРОЕКТ_1\nПРОЕКТ_2\nПРОЕКТ_3\nПРОЕКТ!4\nпроект 1\nСТОП']","['2', '2', '1', '3', '0']","result = 0

while True:
    info = input()
    if info == 'СТОП':
        break
    
    if '_' in info and info.islower():
        result += 1
        
    print(result)","result = 0

while True:
    info = input()
    if info == 'СТОП':
        break
    
    if '_' in info and info.islower():
        result += 1
        
print(result)",Ошибка в табуляции. Результат должен выводиться только после обработке всех вводных данных.,"['open', 'open', 'closed', 'closed', 'closed']","<Task description>: Реализуйте программу, которая определит количество корректных названий проектов для конкурса дизайнеров интерьера:

В цикле while считываются названия проектов до тех пор, пока не введена строка ""СТОП"".
Гарантируется, что названия проектов не повторяются. 
Гарантируется, что до строки ""СТОП"" будет введена как минимум одна строка.
Напечатайте количество проектов, которые состоят только из букв нижнего регистра и в которых есть знак подчеркивания. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: ПРОЕКТ 1
ПРОЕКТ_2
проект_3
Проект 4
интерьер_
_диз_ИНТ
СТОП 
<Вывод>: 2 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: ПРОЕКТ_1
работа_ФИН
Финальная_работа
СТОП 
<Вывод>: 2 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: 123_ПРОГА_П
123_прога_п
123ПРОГАП?
123 ПРОГА п
СТОП 
<Вывод>: 1 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: _дизайнер_
_ПРОГРАМИСТ_
_пробный
ПРОЕКТ!
_____п
СТОП 
<Вывод>: 3 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: ПРОЕКТ_1
ПРОЕКТ_2
ПРОЕКТ_3
ПРОЕКТ!4
проект 1
СТОП 
<Вывод>: 0 
<Решение студента>: result = 0

while True:
    info = input()
    if info == 'СТОП':
        break
    
    if '_' in info and info.islower():
        result += 1
        
    print(result) 
<Идеальное решение>: result = 0

while True:
    info = input()
    if info == 'СТОП':
        break
    
    if '_' in info and info.islower():
        result += 1
        
print(result) 


<Комментарий эксперта>:"
92,232,14,"Реализуйте программу, которая определит количество корректных названий проектов для конкурса дизайнеров интерьера:

В цикле while считываются названия проектов до тех пор, пока не введена строка ""СТОП"".
Гарантируется, что названия проектов не повторяются. 
Гарантируется, что до строки ""СТОП"" будет введена как минимум одна строка.
Напечатайте количество проектов, которые состоят только из букв нижнего регистра и в которых есть знак подчеркивания.","['ПРОЕКТ 1\nПРОЕКТ_2\nпроект_3\nПроект 4\nинтерьер_\n_диз_ИНТ\nСТОП', 'ПРОЕКТ_1\nработа_ФИН\nФинальная_работа\nСТОП', '123_ПРОГА_П\n123_прога_п\n123ПРОГАП?\n123 ПРОГА п\nСТОП', '_дизайнер_\n_ПРОГРАМИСТ_\n_пробный\nПРОЕКТ!\n_____п\nСТОП', 'ПРОЕКТ_1\nПРОЕКТ_2\nПРОЕКТ_3\nПРОЕКТ!4\nпроект 1\nСТОП']","['2', '2', '1', '3', '0']","result = 0

while True:
    info = input()
    if info == 'СТОП':
        break
    
    if info.islower():
        result += 1
        
print(result)","result = 0

while True:
    info = input()
    if info == 'СТОП':
        break
    
    if '_' in info and info.islower():
        result += 1
        
print(result)","Ошибка в открытых и скрытых тестах. 

Ваш код некорректно проверяет условия задания. Например, он не проверяет есть ли в проектах знак подчеркивания. Попробуйте изменить условие if, чтобы скорректировать ошибку.","['open', 'open', 'closed', 'closed', 'closed']","<Task description>: Реализуйте программу, которая определит количество корректных названий проектов для конкурса дизайнеров интерьера:

В цикле while считываются названия проектов до тех пор, пока не введена строка ""СТОП"".
Гарантируется, что названия проектов не повторяются. 
Гарантируется, что до строки ""СТОП"" будет введена как минимум одна строка.
Напечатайте количество проектов, которые состоят только из букв нижнего регистра и в которых есть знак подчеркивания. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: ПРОЕКТ 1
ПРОЕКТ_2
проект_3
Проект 4
интерьер_
_диз_ИНТ
СТОП 
<Вывод>: 2 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: ПРОЕКТ_1
работа_ФИН
Финальная_работа
СТОП 
<Вывод>: 2 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: 123_ПРОГА_П
123_прога_п
123ПРОГАП?
123 ПРОГА п
СТОП 
<Вывод>: 1 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: _дизайнер_
_ПРОГРАМИСТ_
_пробный
ПРОЕКТ!
_____п
СТОП 
<Вывод>: 3 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: ПРОЕКТ_1
ПРОЕКТ_2
ПРОЕКТ_3
ПРОЕКТ!4
проект 1
СТОП 
<Вывод>: 0 
<Решение студента>: result = 0

while True:
    info = input()
    if info == 'СТОП':
        break
    
    if info.islower():
        result += 1
        
print(result) 
<Идеальное решение>: result = 0

while True:
    info = input()
    if info == 'СТОП':
        break
    
    if '_' in info and info.islower():
        result += 1
        
print(result) 


<Комментарий эксперта>:"
93,233,14,"Реализуйте программу, которая определит количество корректных названий проектов для конкурса дизайнеров интерьера:

В цикле while считываются названия проектов до тех пор, пока не введена строка ""СТОП"".
Гарантируется, что названия проектов не повторяются. 
Гарантируется, что до строки ""СТОП"" будет введена как минимум одна строка.
Напечатайте количество проектов, которые состоят только из букв нижнего регистра и в которых есть знак подчеркивания.","['ПРОЕКТ 1\nПРОЕКТ_2\nпроект_3\nПроект 4\nинтерьер_\n_диз_ИНТ\nСТОП', 'ПРОЕКТ_1\nработа_ФИН\nФинальная_работа\nСТОП', '123_ПРОГА_П\n123_прога_п\n123ПРОГАП?\n123 ПРОГА п\nСТОП', '_дизайнер_\n_ПРОГРАМИСТ_\n_пробный\nПРОЕКТ!\n_____п\nСТОП', 'ПРОЕКТ_1\nПРОЕКТ_2\nПРОЕКТ_3\nПРОЕКТ!4\nпроект 1\nСТОП']","['2', '2', '1', '3', '0']","result = 0

while True:
    info = input()
    if info == 'СТОП':
        break
    
    if '_' in info:
        result += 1
        
print(result)","result = 0

while True:
    info = input()
    if info == 'СТОП':
        break
    
    if '_' in info and info.islower():
        result += 1
        
print(result)","Ошибка в открытых и скрытых тестах. 

Ваш код охватывает не все возможные случаи. Например, он не проверяет, состоят ли проекты только из строчных букв. Попробуйте дополнить условие if, чтобы охватить все возможные случаи.","['open', 'open', 'closed', 'closed', 'closed']","<Task description>: Реализуйте программу, которая определит количество корректных названий проектов для конкурса дизайнеров интерьера:

В цикле while считываются названия проектов до тех пор, пока не введена строка ""СТОП"".
Гарантируется, что названия проектов не повторяются. 
Гарантируется, что до строки ""СТОП"" будет введена как минимум одна строка.
Напечатайте количество проектов, которые состоят только из букв нижнего регистра и в которых есть знак подчеркивания. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: ПРОЕКТ 1
ПРОЕКТ_2
проект_3
Проект 4
интерьер_
_диз_ИНТ
СТОП 
<Вывод>: 2 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: ПРОЕКТ_1
работа_ФИН
Финальная_работа
СТОП 
<Вывод>: 2 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: 123_ПРОГА_П
123_прога_п
123ПРОГАП?
123 ПРОГА п
СТОП 
<Вывод>: 1 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: _дизайнер_
_ПРОГРАМИСТ_
_пробный
ПРОЕКТ!
_____п
СТОП 
<Вывод>: 3 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: ПРОЕКТ_1
ПРОЕКТ_2
ПРОЕКТ_3
ПРОЕКТ!4
проект 1
СТОП 
<Вывод>: 0 
<Решение студента>: result = 0

while True:
    info = input()
    if info == 'СТОП':
        break
    
    if '_' in info:
        result += 1
        
print(result) 
<Идеальное решение>: result = 0

while True:
    info = input()
    if info == 'СТОП':
        break
    
    if '_' in info and info.islower():
        result += 1
        
print(result) 


<Комментарий эксперта>:"
94,234,14,"Реализуйте программу, которая определит количество корректных названий проектов для конкурса дизайнеров интерьера:

В цикле while считываются названия проектов до тех пор, пока не введена строка ""СТОП"".
Гарантируется, что названия проектов не повторяются. 
Гарантируется, что до строки ""СТОП"" будет введена как минимум одна строка.
Напечатайте количество проектов, которые состоят только из букв нижнего регистра и в которых есть знак подчеркивания.","['ПРОЕКТ 1\nПРОЕКТ_2\nпроект_3\nПроект 4\nинтерьер_\n_диз_ИНТ\nСТОП', 'ПРОЕКТ_1\nработа_ФИН\nФинальная_работа\nСТОП', '123_ПРОГА_П\n123_прога_п\n123ПРОГАП?\n123 ПРОГА п\nСТОП', '_дизайнер_\n_ПРОГРАМИСТ_\n_пробный\nПРОЕКТ!\n_____п\nСТОП', 'ПРОЕКТ_1\nПРОЕКТ_2\nПРОЕКТ_3\nПРОЕКТ!4\nпроект 1\nСТОП']","['2', '2', '1', '3', '0']","result = 0

while True:
    info = input()
    if info == 'СТОП':
        break
    
    if info.islower():
        for i in info:
            if i == '_':
                result += 1
        
print(result)","result = 0

while True:
    info = input()
    if info == 'СТОП':
        break
    
    if '_' in info and info.islower():
        result += 1
        
print(result)","Ошибка в открытых и скрытых тестах. 

Ваш код некорректно обрабатывает данные. Вместо обновления счетчика после каждого символа подчеркивания, код должен обновляться только после каждого слова. Попробуйте изменить условие if, чтобы скорректировать ошибку.","['open', 'open', 'closed', 'closed', 'closed']","<Task description>: Реализуйте программу, которая определит количество корректных названий проектов для конкурса дизайнеров интерьера:

В цикле while считываются названия проектов до тех пор, пока не введена строка ""СТОП"".
Гарантируется, что названия проектов не повторяются. 
Гарантируется, что до строки ""СТОП"" будет введена как минимум одна строка.
Напечатайте количество проектов, которые состоят только из букв нижнего регистра и в которых есть знак подчеркивания. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: ПРОЕКТ 1
ПРОЕКТ_2
проект_3
Проект 4
интерьер_
_диз_ИНТ
СТОП 
<Вывод>: 2 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: ПРОЕКТ_1
работа_ФИН
Финальная_работа
СТОП 
<Вывод>: 2 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: 123_ПРОГА_П
123_прога_п
123ПРОГАП?
123 ПРОГА п
СТОП 
<Вывод>: 1 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: _дизайнер_
_ПРОГРАМИСТ_
_пробный
ПРОЕКТ!
_____п
СТОП 
<Вывод>: 3 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: ПРОЕКТ_1
ПРОЕКТ_2
ПРОЕКТ_3
ПРОЕКТ!4
проект 1
СТОП 
<Вывод>: 0 
<Решение студента>: result = 0

while True:
    info = input()
    if info == 'СТОП':
        break
    
    if info.islower():
        for i in info:
            if i == '_':
                result += 1
        
print(result) 
<Идеальное решение>: result = 0

while True:
    info = input()
    if info == 'СТОП':
        break
    
    if '_' in info and info.islower():
        result += 1
        
print(result) 


<Комментарий эксперта>:"
95,281,18,"Напишите функцию, определяющую дизайнера, который работает над самым сложным проектом в городе Москва.

Определите функцию designer, которая принимает на вход три списка:
в первой списке перечислены фамилии дизайнеров;
во втором списке перечислены размеры помещений (в кв. м.) (строки), для которых эти дизайнеры создают проекты интерьера соответственно.
в третьем списке перечислены города, в которых располагаются помещения.
Гарантируется, что фамилии дизайнеров не повторяются. При этом размеры помещений могут повторяться.
Самым сложным считается проект, в котором площадь помещения максимальна. Гарантируется, что такой проект только один.
Функция должна возвращать фамилию дизайнера, который работает над самым сложным проектом в городе Москва. 
Важно! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке.","[""['Круглов', 'Квадратов', 'Иванов', 'Марков', 'Пеньков', 'Гуськов'], ['100', '60', '67', '120', '90', '32'], ['Москва', 'Санкт-Петербург', 'Пермь', 'Москва', 'Сочи', 'Иваново']"", ""['Елисеев', 'Краков'], ['67', '100'], ['Москва', 'Томск']"", ""['Петров', 'Иванов', 'Волков', 'Меньшов'], ['50', '109', '30', '40'], ['Сочи', 'Москва', 'Иркутск', 'Краснодар']"", ""['Елисеев', 'Воробьев', 'Стариков'], ['100', '100', '150'], ['Москва', 'Санкт-Петербург', 'Реутов']"", ""['Графов', 'Петров'], ['10', '10'], ['Санкт-Петербург', 'Москва']"", ""['Степанов'], ['100'], ['Москва']""]","['Круглов', 'Елисеев', 'Иванов', 'Елисеев', 'Петров', 'Степанов']","def designer (designers, sizes, towns)
    sizes = list(map(int, sizes))
    lst_of_des = []
    lst_of_siz = []
    for i in range(len(towns)):
        if towns[i] == ""Москва"":
            lst_of_des.append(designers[i])
            lst_of_siz.append(sizes[i])
    
    return lst_of_des[lst_of_siz.index(max(lst_of_siz))]  ","def designer (designers, sizes, towns):
    sizes = list(map(int, sizes))
    lst_of_des = []
    lst_of_siz = []
    for i in range(len(towns)):
        if towns[i] == ""Москва"":
            lst_of_des.append(designers[i])
            lst_of_siz.append(sizes[i])
    
    return lst_of_des[lst_of_siz.index(min(lst_of_siz))]  ",Вы забыли поставить двоеточие после определения функции.,"['open', 'open', 'closed', 'closed', 'closed', 'closed']","<Task description>: Напишите функцию, определяющую дизайнера, который работает над самым сложным проектом в городе Москва.

Определите функцию designer, которая принимает на вход три списка:
в первой списке перечислены фамилии дизайнеров;
во втором списке перечислены размеры помещений (в кв. м.) (строки), для которых эти дизайнеры создают проекты интерьера соответственно.
в третьем списке перечислены города, в которых располагаются помещения.
Гарантируется, что фамилии дизайнеров не повторяются. При этом размеры помещений могут повторяться.
Самым сложным считается проект, в котором площадь помещения максимальна. Гарантируется, что такой проект только один.
Функция должна возвращать фамилию дизайнера, который работает над самым сложным проектом в городе Москва. 
Важно! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: ['Круглов', 'Квадратов', 'Иванов', 'Марков', 'Пеньков', 'Гуськов'], ['100', '60', '67', '120', '90', '32'], ['Москва', 'Санкт-Петербург', 'Пермь', 'Москва', 'Сочи', 'Иваново'] 
<Вывод>: Круглов 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: ['Елисеев', 'Краков'], ['67', '100'], ['Москва', 'Томск'] 
<Вывод>: Елисеев 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: ['Петров', 'Иванов', 'Волков', 'Меньшов'], ['50', '109', '30', '40'], ['Сочи', 'Москва', 'Иркутск', 'Краснодар'] 
<Вывод>: Иванов 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: ['Елисеев', 'Воробьев', 'Стариков'], ['100', '100', '150'], ['Москва', 'Санкт-Петербург', 'Реутов'] 
<Вывод>: Елисеев 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: ['Графов', 'Петров'], ['10', '10'], ['Санкт-Петербург', 'Москва'] 
<Вывод>: Петров 
<Example 6>: 
<Тип теста 6>: closed 
<Ввод>: ['Степанов'], ['100'], ['Москва'] 
<Вывод>: Степанов 
<Решение студента>: def designer (designers, sizes, towns)
    sizes = list(map(int, sizes))
    lst_of_des = []
    lst_of_siz = []
    for i in range(len(towns)):
        if towns[i] == ""Москва"":
            lst_of_des.append(designers[i])
            lst_of_siz.append(sizes[i])
    
    return lst_of_des[lst_of_siz.index(max(lst_of_siz))]   
<Идеальное решение>: def designer (designers, sizes, towns):
    sizes = list(map(int, sizes))
    lst_of_des = []
    lst_of_siz = []
    for i in range(len(towns)):
        if towns[i] == ""Москва"":
            lst_of_des.append(designers[i])
            lst_of_siz.append(sizes[i])
    
    return lst_of_des[lst_of_siz.index(min(lst_of_siz))]   


<Комментарий эксперта>:"
96,282,18,"Напишите функцию, определяющую дизайнера, который работает над самым сложным проектом в городе Москва.

Определите функцию designer, которая принимает на вход три списка:
в первой списке перечислены фамилии дизайнеров;
во втором списке перечислены размеры помещений (в кв. м.) (строки), для которых эти дизайнеры создают проекты интерьера соответственно.
в третьем списке перечислены города, в которых располагаются помещения.
Гарантируется, что фамилии дизайнеров не повторяются. При этом размеры помещений могут повторяться.
Самым сложным считается проект, в котором площадь помещения максимальна. Гарантируется, что такой проект только один.
Функция должна возвращать фамилию дизайнера, который работает над самым сложным проектом в городе Москва. 
Важно! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке.","[""['Круглов', 'Квадратов', 'Иванов', 'Марков', 'Пеньков', 'Гуськов'], ['100', '60', '67', '120', '90', '32'], ['Москва', 'Санкт-Петербург', 'Пермь', 'Москва', 'Сочи', 'Иваново']"", ""['Елисеев', 'Краков'], ['67', '100'], ['Москва', 'Томск']"", ""['Петров', 'Иванов', 'Волков', 'Меньшов'], ['50', '109', '30', '40'], ['Сочи', 'Москва', 'Иркутск', 'Краснодар']"", ""['Елисеев', 'Воробьев', 'Стариков'], ['100', '100', '150'], ['Москва', 'Санкт-Петербург', 'Реутов']"", ""['Графов', 'Петров'], ['10', '10'], ['Санкт-Петербург', 'Москва']"", ""['Степанов'], ['100'], ['Москва']""]","['Круглов', 'Елисеев', 'Иванов', 'Елисеев', 'Петров', 'Степанов']","def designer ():
    sizes = list(map(int, sizes))
    lst_of_des = []
    lst_of_siz = []
    for i in range(len(towns)):
        if towns[i] == ""Москва"":
            lst_of_des.append(designers[i])
            lst_of_siz.append(sizes[i])
    
    return lst_of_des[lst_of_siz.index(max(lst_of_siz))]  ","def designer (designers, sizes, towns):
    sizes = list(map(int, sizes))
    lst_of_des = []
    lst_of_siz = []
    for i in range(len(towns)):
        if towns[i] == ""Москва"":
            lst_of_des.append(designers[i])
            lst_of_siz.append(sizes[i])
    
    return lst_of_des[lst_of_siz.index(min(lst_of_siz))]  ","Вы не добавили переменные, которые функция будет принимать как аргументы.","['open', 'open', 'closed', 'closed', 'closed', 'closed']","<Task description>: Напишите функцию, определяющую дизайнера, который работает над самым сложным проектом в городе Москва.

Определите функцию designer, которая принимает на вход три списка:
в первой списке перечислены фамилии дизайнеров;
во втором списке перечислены размеры помещений (в кв. м.) (строки), для которых эти дизайнеры создают проекты интерьера соответственно.
в третьем списке перечислены города, в которых располагаются помещения.
Гарантируется, что фамилии дизайнеров не повторяются. При этом размеры помещений могут повторяться.
Самым сложным считается проект, в котором площадь помещения максимальна. Гарантируется, что такой проект только один.
Функция должна возвращать фамилию дизайнера, который работает над самым сложным проектом в городе Москва. 
Важно! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: ['Круглов', 'Квадратов', 'Иванов', 'Марков', 'Пеньков', 'Гуськов'], ['100', '60', '67', '120', '90', '32'], ['Москва', 'Санкт-Петербург', 'Пермь', 'Москва', 'Сочи', 'Иваново'] 
<Вывод>: Круглов 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: ['Елисеев', 'Краков'], ['67', '100'], ['Москва', 'Томск'] 
<Вывод>: Елисеев 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: ['Петров', 'Иванов', 'Волков', 'Меньшов'], ['50', '109', '30', '40'], ['Сочи', 'Москва', 'Иркутск', 'Краснодар'] 
<Вывод>: Иванов 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: ['Елисеев', 'Воробьев', 'Стариков'], ['100', '100', '150'], ['Москва', 'Санкт-Петербург', 'Реутов'] 
<Вывод>: Елисеев 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: ['Графов', 'Петров'], ['10', '10'], ['Санкт-Петербург', 'Москва'] 
<Вывод>: Петров 
<Example 6>: 
<Тип теста 6>: closed 
<Ввод>: ['Степанов'], ['100'], ['Москва'] 
<Вывод>: Степанов 
<Решение студента>: def designer ():
    sizes = list(map(int, sizes))
    lst_of_des = []
    lst_of_siz = []
    for i in range(len(towns)):
        if towns[i] == ""Москва"":
            lst_of_des.append(designers[i])
            lst_of_siz.append(sizes[i])
    
    return lst_of_des[lst_of_siz.index(max(lst_of_siz))]   
<Идеальное решение>: def designer (designers, sizes, towns):
    sizes = list(map(int, sizes))
    lst_of_des = []
    lst_of_siz = []
    for i in range(len(towns)):
        if towns[i] == ""Москва"":
            lst_of_des.append(designers[i])
            lst_of_siz.append(sizes[i])
    
    return lst_of_des[lst_of_siz.index(min(lst_of_siz))]   


<Комментарий эксперта>:"
97,283,18,"Напишите функцию, определяющую дизайнера, который работает над самым сложным проектом в городе Москва.

Определите функцию designer, которая принимает на вход три списка:
в первой списке перечислены фамилии дизайнеров;
во втором списке перечислены размеры помещений (в кв. м.) (строки), для которых эти дизайнеры создают проекты интерьера соответственно.
в третьем списке перечислены города, в которых располагаются помещения.
Гарантируется, что фамилии дизайнеров не повторяются. При этом размеры помещений могут повторяться.
Самым сложным считается проект, в котором площадь помещения максимальна. Гарантируется, что такой проект только один.
Функция должна возвращать фамилию дизайнера, который работает над самым сложным проектом в городе Москва. 
Важно! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке.","[""['Круглов', 'Квадратов', 'Иванов', 'Марков', 'Пеньков', 'Гуськов'], ['100', '60', '67', '120', '90', '32'], ['Москва', 'Санкт-Петербург', 'Пермь', 'Москва', 'Сочи', 'Иваново']"", ""['Елисеев', 'Краков'], ['67', '100'], ['Москва', 'Томск']"", ""['Петров', 'Иванов', 'Волков', 'Меньшов'], ['50', '109', '30', '40'], ['Сочи', 'Москва', 'Иркутск', 'Краснодар']"", ""['Елисеев', 'Воробьев', 'Стариков'], ['100', '100', '150'], ['Москва', 'Санкт-Петербург', 'Реутов']"", ""['Графов', 'Петров'], ['10', '10'], ['Санкт-Петербург', 'Москва']"", ""['Степанов'], ['100'], ['Москва']""]","['Круглов', 'Елисеев', 'Иванов', 'Елисеев', 'Петров', 'Степанов']","def designer (designers, ammount, towns):
    sizes = list(map(int, sizes))
    lst_of_des = []
    lst_of_siz = []
    for i in range(len(towns)):
        if towns[i] == ""Москва"":
            lst_of_des.append(designers[i])
            lst_of_siz.append(sizes[i])
    
    return lst_of_des[lst_of_siz.index(max(lst_of_siz))]  ","def designer (designers, sizes, towns):
    sizes = list(map(int, sizes))
    lst_of_des = []
    lst_of_siz = []
    for i in range(len(towns)):
        if towns[i] == ""Москва"":
            lst_of_des.append(designers[i])
            lst_of_siz.append(sizes[i])
    
    return lst_of_des[lst_of_siz.index(min(lst_of_siz))]  ","Вы обращаетесь к незаданным переменным внутри функции. Используйте внутри функции только те переменные, которые были заданы в качестве аргументов функции.","['open', 'open', 'closed', 'closed', 'closed', 'closed']","<Task description>: Напишите функцию, определяющую дизайнера, который работает над самым сложным проектом в городе Москва.

Определите функцию designer, которая принимает на вход три списка:
в первой списке перечислены фамилии дизайнеров;
во втором списке перечислены размеры помещений (в кв. м.) (строки), для которых эти дизайнеры создают проекты интерьера соответственно.
в третьем списке перечислены города, в которых располагаются помещения.
Гарантируется, что фамилии дизайнеров не повторяются. При этом размеры помещений могут повторяться.
Самым сложным считается проект, в котором площадь помещения максимальна. Гарантируется, что такой проект только один.
Функция должна возвращать фамилию дизайнера, который работает над самым сложным проектом в городе Москва. 
Важно! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: ['Круглов', 'Квадратов', 'Иванов', 'Марков', 'Пеньков', 'Гуськов'], ['100', '60', '67', '120', '90', '32'], ['Москва', 'Санкт-Петербург', 'Пермь', 'Москва', 'Сочи', 'Иваново'] 
<Вывод>: Круглов 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: ['Елисеев', 'Краков'], ['67', '100'], ['Москва', 'Томск'] 
<Вывод>: Елисеев 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: ['Петров', 'Иванов', 'Волков', 'Меньшов'], ['50', '109', '30', '40'], ['Сочи', 'Москва', 'Иркутск', 'Краснодар'] 
<Вывод>: Иванов 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: ['Елисеев', 'Воробьев', 'Стариков'], ['100', '100', '150'], ['Москва', 'Санкт-Петербург', 'Реутов'] 
<Вывод>: Елисеев 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: ['Графов', 'Петров'], ['10', '10'], ['Санкт-Петербург', 'Москва'] 
<Вывод>: Петров 
<Example 6>: 
<Тип теста 6>: closed 
<Ввод>: ['Степанов'], ['100'], ['Москва'] 
<Вывод>: Степанов 
<Решение студента>: def designer (designers, ammount, towns):
    sizes = list(map(int, sizes))
    lst_of_des = []
    lst_of_siz = []
    for i in range(len(towns)):
        if towns[i] == ""Москва"":
            lst_of_des.append(designers[i])
            lst_of_siz.append(sizes[i])
    
    return lst_of_des[lst_of_siz.index(max(lst_of_siz))]   
<Идеальное решение>: def designer (designers, sizes, towns):
    sizes = list(map(int, sizes))
    lst_of_des = []
    lst_of_siz = []
    for i in range(len(towns)):
        if towns[i] == ""Москва"":
            lst_of_des.append(designers[i])
            lst_of_siz.append(sizes[i])
    
    return lst_of_des[lst_of_siz.index(min(lst_of_siz))]   


<Комментарий эксперта>:"
98,284,18,"Напишите функцию, определяющую дизайнера, который работает над самым сложным проектом в городе Москва.

Определите функцию designer, которая принимает на вход три списка:
в первой списке перечислены фамилии дизайнеров;
во втором списке перечислены размеры помещений (в кв. м.) (строки), для которых эти дизайнеры создают проекты интерьера соответственно.
в третьем списке перечислены города, в которых располагаются помещения.
Гарантируется, что фамилии дизайнеров не повторяются. При этом размеры помещений могут повторяться.
Самым сложным считается проект, в котором площадь помещения максимальна. Гарантируется, что такой проект только один.
Функция должна возвращать фамилию дизайнера, который работает над самым сложным проектом в городе Москва. 
Важно! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке.","[""['Круглов', 'Квадратов', 'Иванов', 'Марков', 'Пеньков', 'Гуськов'], ['100', '60', '67', '120', '90', '32'], ['Москва', 'Санкт-Петербург', 'Пермь', 'Москва', 'Сочи', 'Иваново']"", ""['Елисеев', 'Краков'], ['67', '100'], ['Москва', 'Томск']"", ""['Петров', 'Иванов', 'Волков', 'Меньшов'], ['50', '109', '30', '40'], ['Сочи', 'Москва', 'Иркутск', 'Краснодар']"", ""['Елисеев', 'Воробьев', 'Стариков'], ['100', '100', '150'], ['Москва', 'Санкт-Петербург', 'Реутов']"", ""['Графов', 'Петров'], ['10', '10'], ['Санкт-Петербург', 'Москва']"", ""['Степанов'], ['100'], ['Москва']""]","['Круглов', 'Елисеев', 'Иванов', 'Елисеев', 'Петров', 'Степанов']","def designer (designers, sizes, towns):
    sizes = list(map(int, sizes))
    lst_of_des = []
    lst_of_siz = []
    for i in range(len(towns)):
        if towns[i] == ""Москва"":
            lst_of_des.add(designers[i])
            lst_of_siz.add(sizes[i])
    
    return lst_of_des[lst_of_siz.index(max(lst_of_siz))]  ","def designer (designers, sizes, towns):
    sizes = list(map(int, sizes))
    lst_of_des = []
    lst_of_siz = []
    for i in range(len(towns)):
        if towns[i] == ""Москва"":
            lst_of_des.append(designers[i])
            lst_of_siz.append(sizes[i])
    
    return lst_of_des[lst_of_siz.index(min(lst_of_siz))]  ",Некорректно использован метод добавления элементов в список. Список не имеет метода .add().,"['open', 'open', 'closed', 'closed', 'closed', 'closed']","<Task description>: Напишите функцию, определяющую дизайнера, который работает над самым сложным проектом в городе Москва.

Определите функцию designer, которая принимает на вход три списка:
в первой списке перечислены фамилии дизайнеров;
во втором списке перечислены размеры помещений (в кв. м.) (строки), для которых эти дизайнеры создают проекты интерьера соответственно.
в третьем списке перечислены города, в которых располагаются помещения.
Гарантируется, что фамилии дизайнеров не повторяются. При этом размеры помещений могут повторяться.
Самым сложным считается проект, в котором площадь помещения максимальна. Гарантируется, что такой проект только один.
Функция должна возвращать фамилию дизайнера, который работает над самым сложным проектом в городе Москва. 
Важно! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: ['Круглов', 'Квадратов', 'Иванов', 'Марков', 'Пеньков', 'Гуськов'], ['100', '60', '67', '120', '90', '32'], ['Москва', 'Санкт-Петербург', 'Пермь', 'Москва', 'Сочи', 'Иваново'] 
<Вывод>: Круглов 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: ['Елисеев', 'Краков'], ['67', '100'], ['Москва', 'Томск'] 
<Вывод>: Елисеев 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: ['Петров', 'Иванов', 'Волков', 'Меньшов'], ['50', '109', '30', '40'], ['Сочи', 'Москва', 'Иркутск', 'Краснодар'] 
<Вывод>: Иванов 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: ['Елисеев', 'Воробьев', 'Стариков'], ['100', '100', '150'], ['Москва', 'Санкт-Петербург', 'Реутов'] 
<Вывод>: Елисеев 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: ['Графов', 'Петров'], ['10', '10'], ['Санкт-Петербург', 'Москва'] 
<Вывод>: Петров 
<Example 6>: 
<Тип теста 6>: closed 
<Ввод>: ['Степанов'], ['100'], ['Москва'] 
<Вывод>: Степанов 
<Решение студента>: def designer (designers, sizes, towns):
    sizes = list(map(int, sizes))
    lst_of_des = []
    lst_of_siz = []
    for i in range(len(towns)):
        if towns[i] == ""Москва"":
            lst_of_des.add(designers[i])
            lst_of_siz.add(sizes[i])
    
    return lst_of_des[lst_of_siz.index(max(lst_of_siz))]   
<Идеальное решение>: def designer (designers, sizes, towns):
    sizes = list(map(int, sizes))
    lst_of_des = []
    lst_of_siz = []
    for i in range(len(towns)):
        if towns[i] == ""Москва"":
            lst_of_des.append(designers[i])
            lst_of_siz.append(sizes[i])
    
    return lst_of_des[lst_of_siz.index(min(lst_of_siz))]   


<Комментарий эксперта>:"
99,285,18,"Напишите функцию, определяющую дизайнера, который работает над самым сложным проектом в городе Москва.

Определите функцию designer, которая принимает на вход три списка:
в первой списке перечислены фамилии дизайнеров;
во втором списке перечислены размеры помещений (в кв. м.) (строки), для которых эти дизайнеры создают проекты интерьера соответственно.
в третьем списке перечислены города, в которых располагаются помещения.
Гарантируется, что фамилии дизайнеров не повторяются. При этом размеры помещений могут повторяться.
Самым сложным считается проект, в котором площадь помещения максимальна. Гарантируется, что такой проект только один.
Функция должна возвращать фамилию дизайнера, который работает над самым сложным проектом в городе Москва. 
Важно! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке.","[""['Круглов', 'Квадратов', 'Иванов', 'Марков', 'Пеньков', 'Гуськов'], ['100', '60', '67', '120', '90', '32'], ['Москва', 'Санкт-Петербург', 'Пермь', 'Москва', 'Сочи', 'Иваново']"", ""['Елисеев', 'Краков'], ['67', '100'], ['Москва', 'Томск']"", ""['Петров', 'Иванов', 'Волков', 'Меньшов'], ['50', '109', '30', '40'], ['Сочи', 'Москва', 'Иркутск', 'Краснодар']"", ""['Елисеев', 'Воробьев', 'Стариков'], ['100', '100', '150'], ['Москва', 'Санкт-Петербург', 'Реутов']"", ""['Графов', 'Петров'], ['10', '10'], ['Санкт-Петербург', 'Москва']"", ""['Степанов'], ['100'], ['Москва']""]","['Круглов', 'Елисеев', 'Иванов', 'Елисеев', 'Петров', 'Степанов']","def designer (designers, sizes, towns):
    sizes = list(map(int, sizes))
    lst_of_des = []
    lst_of_siz = []
    for i in range(len(towns)):
        if towns[i] == ""Москва"":
            lst_of_des.append(designers[i])
            lst_of_siz.append(sizes[i])
    
    print(lst_of_des[lst_of_siz.index(max(lst_of_siz))])","def designer (designers, sizes, towns):
    sizes = list(map(int, sizes))
    lst_of_des = []
    lst_of_siz = []
    for i in range(len(towns)):
        if towns[i] == ""Москва"":
            lst_of_des.append(designers[i])
            lst_of_siz.append(sizes[i])
    
    return lst_of_des[lst_of_siz.index(min(lst_of_siz))]  ",Ошибка при возвращении данных функцией. Функция не должна использовать оператор print(). ,"['open', 'open', 'closed', 'closed', 'closed', 'closed']","<Task description>: Напишите функцию, определяющую дизайнера, который работает над самым сложным проектом в городе Москва.

Определите функцию designer, которая принимает на вход три списка:
в первой списке перечислены фамилии дизайнеров;
во втором списке перечислены размеры помещений (в кв. м.) (строки), для которых эти дизайнеры создают проекты интерьера соответственно.
в третьем списке перечислены города, в которых располагаются помещения.
Гарантируется, что фамилии дизайнеров не повторяются. При этом размеры помещений могут повторяться.
Самым сложным считается проект, в котором площадь помещения максимальна. Гарантируется, что такой проект только один.
Функция должна возвращать фамилию дизайнера, который работает над самым сложным проектом в городе Москва. 
Важно! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: ['Круглов', 'Квадратов', 'Иванов', 'Марков', 'Пеньков', 'Гуськов'], ['100', '60', '67', '120', '90', '32'], ['Москва', 'Санкт-Петербург', 'Пермь', 'Москва', 'Сочи', 'Иваново'] 
<Вывод>: Круглов 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: ['Елисеев', 'Краков'], ['67', '100'], ['Москва', 'Томск'] 
<Вывод>: Елисеев 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: ['Петров', 'Иванов', 'Волков', 'Меньшов'], ['50', '109', '30', '40'], ['Сочи', 'Москва', 'Иркутск', 'Краснодар'] 
<Вывод>: Иванов 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: ['Елисеев', 'Воробьев', 'Стариков'], ['100', '100', '150'], ['Москва', 'Санкт-Петербург', 'Реутов'] 
<Вывод>: Елисеев 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: ['Графов', 'Петров'], ['10', '10'], ['Санкт-Петербург', 'Москва'] 
<Вывод>: Петров 
<Example 6>: 
<Тип теста 6>: closed 
<Ввод>: ['Степанов'], ['100'], ['Москва'] 
<Вывод>: Степанов 
<Решение студента>: def designer (designers, sizes, towns):
    sizes = list(map(int, sizes))
    lst_of_des = []
    lst_of_siz = []
    for i in range(len(towns)):
        if towns[i] == ""Москва"":
            lst_of_des.append(designers[i])
            lst_of_siz.append(sizes[i])
    
    print(lst_of_des[lst_of_siz.index(max(lst_of_siz))]) 
<Идеальное решение>: def designer (designers, sizes, towns):
    sizes = list(map(int, sizes))
    lst_of_des = []
    lst_of_siz = []
    for i in range(len(towns)):
        if towns[i] == ""Москва"":
            lst_of_des.append(designers[i])
            lst_of_siz.append(sizes[i])
    
    return lst_of_des[lst_of_siz.index(min(lst_of_siz))]   


<Комментарий эксперта>:"
100,286,18,"Напишите функцию, определяющую дизайнера, который работает над самым сложным проектом в городе Москва.

Определите функцию designer, которая принимает на вход три списка:
в первой списке перечислены фамилии дизайнеров;
во втором списке перечислены размеры помещений (в кв. м.) (строки), для которых эти дизайнеры создают проекты интерьера соответственно.
в третьем списке перечислены города, в которых располагаются помещения.
Гарантируется, что фамилии дизайнеров не повторяются. При этом размеры помещений могут повторяться.
Самым сложным считается проект, в котором площадь помещения максимальна. Гарантируется, что такой проект только один.
Функция должна возвращать фамилию дизайнера, который работает над самым сложным проектом в городе Москва. 
Важно! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке.","[""['Круглов', 'Квадратов', 'Иванов', 'Марков', 'Пеньков', 'Гуськов'], ['100', '60', '67', '120', '90', '32'], ['Москва', 'Санкт-Петербург', 'Пермь', 'Москва', 'Сочи', 'Иваново']"", ""['Елисеев', 'Краков'], ['67', '100'], ['Москва', 'Томск']"", ""['Петров', 'Иванов', 'Волков', 'Меньшов'], ['50', '109', '30', '40'], ['Сочи', 'Москва', 'Иркутск', 'Краснодар']"", ""['Елисеев', 'Воробьев', 'Стариков'], ['100', '100', '150'], ['Москва', 'Санкт-Петербург', 'Реутов']"", ""['Графов', 'Петров'], ['10', '10'], ['Санкт-Петербург', 'Москва']"", ""['Степанов'], ['100'], ['Москва']""]","['Круглов', 'Елисеев', 'Иванов', 'Елисеев', 'Петров', 'Степанов']","def designer (designers, sizes, towns):
    sizes = list(map(int, sizes))
    lst_of_des = []
    lst_of_siz = []
    for i in range(len(towns)):
        if towns[i] == ""Москва"":
            lst_of_des.append(designers[i])
            lst_of_siz.append(sizes[i])
    
return lst_of_des[lst_of_siz.index(max(lst_of_siz))]  ","def designer (designers, sizes, towns):
    sizes = list(map(int, sizes))
    lst_of_des = []
    lst_of_siz = []
    for i in range(len(towns)):
        if towns[i] == ""Москва"":
            lst_of_des.append(designers[i])
            lst_of_siz.append(sizes[i])
    
    return lst_of_des[lst_of_siz.index(min(lst_of_siz))]  ",Ошибка в табуляции оператора return.,"['open', 'open', 'closed', 'closed', 'closed', 'closed']","<Task description>: Напишите функцию, определяющую дизайнера, который работает над самым сложным проектом в городе Москва.

Определите функцию designer, которая принимает на вход три списка:
в первой списке перечислены фамилии дизайнеров;
во втором списке перечислены размеры помещений (в кв. м.) (строки), для которых эти дизайнеры создают проекты интерьера соответственно.
в третьем списке перечислены города, в которых располагаются помещения.
Гарантируется, что фамилии дизайнеров не повторяются. При этом размеры помещений могут повторяться.
Самым сложным считается проект, в котором площадь помещения максимальна. Гарантируется, что такой проект только один.
Функция должна возвращать фамилию дизайнера, который работает над самым сложным проектом в городе Москва. 
Важно! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: ['Круглов', 'Квадратов', 'Иванов', 'Марков', 'Пеньков', 'Гуськов'], ['100', '60', '67', '120', '90', '32'], ['Москва', 'Санкт-Петербург', 'Пермь', 'Москва', 'Сочи', 'Иваново'] 
<Вывод>: Круглов 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: ['Елисеев', 'Краков'], ['67', '100'], ['Москва', 'Томск'] 
<Вывод>: Елисеев 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: ['Петров', 'Иванов', 'Волков', 'Меньшов'], ['50', '109', '30', '40'], ['Сочи', 'Москва', 'Иркутск', 'Краснодар'] 
<Вывод>: Иванов 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: ['Елисеев', 'Воробьев', 'Стариков'], ['100', '100', '150'], ['Москва', 'Санкт-Петербург', 'Реутов'] 
<Вывод>: Елисеев 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: ['Графов', 'Петров'], ['10', '10'], ['Санкт-Петербург', 'Москва'] 
<Вывод>: Петров 
<Example 6>: 
<Тип теста 6>: closed 
<Ввод>: ['Степанов'], ['100'], ['Москва'] 
<Вывод>: Степанов 
<Решение студента>: def designer (designers, sizes, towns):
    sizes = list(map(int, sizes))
    lst_of_des = []
    lst_of_siz = []
    for i in range(len(towns)):
        if towns[i] == ""Москва"":
            lst_of_des.append(designers[i])
            lst_of_siz.append(sizes[i])
    
return lst_of_des[lst_of_siz.index(max(lst_of_siz))]   
<Идеальное решение>: def designer (designers, sizes, towns):
    sizes = list(map(int, sizes))
    lst_of_des = []
    lst_of_siz = []
    for i in range(len(towns)):
        if towns[i] == ""Москва"":
            lst_of_des.append(designers[i])
            lst_of_siz.append(sizes[i])
    
    return lst_of_des[lst_of_siz.index(min(lst_of_siz))]   


<Комментарий эксперта>:"
101,287,18,"Напишите функцию, определяющую дизайнера, который работает над самым сложным проектом в городе Москва.

Определите функцию designer, которая принимает на вход три списка:
в первой списке перечислены фамилии дизайнеров;
во втором списке перечислены размеры помещений (в кв. м.) (строки), для которых эти дизайнеры создают проекты интерьера соответственно.
в третьем списке перечислены города, в которых располагаются помещения.
Гарантируется, что фамилии дизайнеров не повторяются. При этом размеры помещений могут повторяться.
Самым сложным считается проект, в котором площадь помещения максимальна. Гарантируется, что такой проект только один.
Функция должна возвращать фамилию дизайнера, который работает над самым сложным проектом в городе Москва. 
Важно! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке.","[""['Круглов', 'Квадратов', 'Иванов', 'Марков', 'Пеньков', 'Гуськов'], ['100', '60', '67', '120', '90', '32'], ['Москва', 'Санкт-Петербург', 'Пермь', 'Москва', 'Сочи', 'Иваново']"", ""['Елисеев', 'Краков'], ['67', '100'], ['Москва', 'Томск']"", ""['Петров', 'Иванов', 'Волков', 'Меньшов'], ['50', '109', '30', '40'], ['Сочи', 'Москва', 'Иркутск', 'Краснодар']"", ""['Елисеев', 'Воробьев', 'Стариков'], ['100', '100', '150'], ['Москва', 'Санкт-Петербург', 'Реутов']"", ""['Графов', 'Петров'], ['10', '10'], ['Санкт-Петербург', 'Москва']"", ""['Степанов'], ['100'], ['Москва']""]","['Круглов', 'Елисеев', 'Иванов', 'Елисеев', 'Петров', 'Степанов']","def designer (designers, sizes, towns):
    sizes =int(sizes)
    lst_of_des = []
    lst_of_siz = []
    for i in range(len(towns)):
        if towns[i] == ""Москва"":
            lst_of_des.append(designers[i])
            lst_of_siz.append(sizes[i])
    
    return lst_of_des[lst_of_siz.index(max(lst_of_siz))]  ","def designer (designers, sizes, towns):
    sizes = list(map(int, sizes))
    lst_of_des = []
    lst_of_siz = []
    for i in range(len(towns)):
        if towns[i] == ""Москва"":
            lst_of_des.append(designers[i])
            lst_of_siz.append(sizes[i])
    
    return lst_of_des[lst_of_siz.index(min(lst_of_siz))]  ","Вы не можете применить int() ко всему списку сразу, только к каждому элементу.","['open', 'open', 'closed', 'closed', 'closed', 'closed']","<Task description>: Напишите функцию, определяющую дизайнера, который работает над самым сложным проектом в городе Москва.

Определите функцию designer, которая принимает на вход три списка:
в первой списке перечислены фамилии дизайнеров;
во втором списке перечислены размеры помещений (в кв. м.) (строки), для которых эти дизайнеры создают проекты интерьера соответственно.
в третьем списке перечислены города, в которых располагаются помещения.
Гарантируется, что фамилии дизайнеров не повторяются. При этом размеры помещений могут повторяться.
Самым сложным считается проект, в котором площадь помещения максимальна. Гарантируется, что такой проект только один.
Функция должна возвращать фамилию дизайнера, который работает над самым сложным проектом в городе Москва. 
Важно! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: ['Круглов', 'Квадратов', 'Иванов', 'Марков', 'Пеньков', 'Гуськов'], ['100', '60', '67', '120', '90', '32'], ['Москва', 'Санкт-Петербург', 'Пермь', 'Москва', 'Сочи', 'Иваново'] 
<Вывод>: Круглов 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: ['Елисеев', 'Краков'], ['67', '100'], ['Москва', 'Томск'] 
<Вывод>: Елисеев 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: ['Петров', 'Иванов', 'Волков', 'Меньшов'], ['50', '109', '30', '40'], ['Сочи', 'Москва', 'Иркутск', 'Краснодар'] 
<Вывод>: Иванов 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: ['Елисеев', 'Воробьев', 'Стариков'], ['100', '100', '150'], ['Москва', 'Санкт-Петербург', 'Реутов'] 
<Вывод>: Елисеев 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: ['Графов', 'Петров'], ['10', '10'], ['Санкт-Петербург', 'Москва'] 
<Вывод>: Петров 
<Example 6>: 
<Тип теста 6>: closed 
<Ввод>: ['Степанов'], ['100'], ['Москва'] 
<Вывод>: Степанов 
<Решение студента>: def designer (designers, sizes, towns):
    sizes =int(sizes)
    lst_of_des = []
    lst_of_siz = []
    for i in range(len(towns)):
        if towns[i] == ""Москва"":
            lst_of_des.append(designers[i])
            lst_of_siz.append(sizes[i])
    
    return lst_of_des[lst_of_siz.index(max(lst_of_siz))]   
<Идеальное решение>: def designer (designers, sizes, towns):
    sizes = list(map(int, sizes))
    lst_of_des = []
    lst_of_siz = []
    for i in range(len(towns)):
        if towns[i] == ""Москва"":
            lst_of_des.append(designers[i])
            lst_of_siz.append(sizes[i])
    
    return lst_of_des[lst_of_siz.index(min(lst_of_siz))]   


<Комментарий эксперта>:"
102,288,18,"Напишите функцию, определяющую дизайнера, который работает над самым сложным проектом в городе Москва.

Определите функцию designer, которая принимает на вход три списка:
в первой списке перечислены фамилии дизайнеров;
во втором списке перечислены размеры помещений (в кв. м.) (строки), для которых эти дизайнеры создают проекты интерьера соответственно.
в третьем списке перечислены города, в которых располагаются помещения.
Гарантируется, что фамилии дизайнеров не повторяются. При этом размеры помещений могут повторяться.
Самым сложным считается проект, в котором площадь помещения максимальна. Гарантируется, что такой проект только один.
Функция должна возвращать фамилию дизайнера, который работает над самым сложным проектом в городе Москва. 
Важно! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке.","[""['Круглов', 'Квадратов', 'Иванов', 'Марков', 'Пеньков', 'Гуськов'], ['100', '60', '67', '120', '90', '32'], ['Москва', 'Санкт-Петербург', 'Пермь', 'Москва', 'Сочи', 'Иваново']"", ""['Елисеев', 'Краков'], ['67', '100'], ['Москва', 'Томск']"", ""['Петров', 'Иванов', 'Волков', 'Меньшов'], ['50', '109', '30', '40'], ['Сочи', 'Москва', 'Иркутск', 'Краснодар']"", ""['Елисеев', 'Воробьев', 'Стариков'], ['100', '100', '150'], ['Москва', 'Санкт-Петербург', 'Реутов']"", ""['Графов', 'Петров'], ['10', '10'], ['Санкт-Петербург', 'Москва']"", ""['Степанов'], ['100'], ['Москва']""]","['Круглов', 'Елисеев', 'Иванов', 'Елисеев', 'Петров', 'Степанов']","def designer (designers, sizes, towns):
    sizes = list(map(int, sizes))
    lst_of_des = []
    lst_of_siz = []
    for i in range(towns):
        if towns[i] == ""Москва"":
            lst_of_des.append(designers[i])
            lst_of_siz.append(sizes[i])
    
    return lst_of_des[lst_of_siz.index(max(lst_of_siz))]  ","def designer (designers, sizes, towns):
    sizes = list(map(int, sizes))
    lst_of_des = []
    lst_of_siz = []
    for i in range(len(towns)):
        if towns[i] == ""Москва"":
            lst_of_des.append(designers[i])
            lst_of_siz.append(sizes[i])
    
    return lst_of_des[lst_of_siz.index(min(lst_of_siz))]  ","Ошибка при передаче аргумента функции range. Список не может счиаться аргументом функции, только переменная типа integer.","['open', 'open', 'closed', 'closed', 'closed', 'closed']","<Task description>: Напишите функцию, определяющую дизайнера, который работает над самым сложным проектом в городе Москва.

Определите функцию designer, которая принимает на вход три списка:
в первой списке перечислены фамилии дизайнеров;
во втором списке перечислены размеры помещений (в кв. м.) (строки), для которых эти дизайнеры создают проекты интерьера соответственно.
в третьем списке перечислены города, в которых располагаются помещения.
Гарантируется, что фамилии дизайнеров не повторяются. При этом размеры помещений могут повторяться.
Самым сложным считается проект, в котором площадь помещения максимальна. Гарантируется, что такой проект только один.
Функция должна возвращать фамилию дизайнера, который работает над самым сложным проектом в городе Москва. 
Важно! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: ['Круглов', 'Квадратов', 'Иванов', 'Марков', 'Пеньков', 'Гуськов'], ['100', '60', '67', '120', '90', '32'], ['Москва', 'Санкт-Петербург', 'Пермь', 'Москва', 'Сочи', 'Иваново'] 
<Вывод>: Круглов 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: ['Елисеев', 'Краков'], ['67', '100'], ['Москва', 'Томск'] 
<Вывод>: Елисеев 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: ['Петров', 'Иванов', 'Волков', 'Меньшов'], ['50', '109', '30', '40'], ['Сочи', 'Москва', 'Иркутск', 'Краснодар'] 
<Вывод>: Иванов 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: ['Елисеев', 'Воробьев', 'Стариков'], ['100', '100', '150'], ['Москва', 'Санкт-Петербург', 'Реутов'] 
<Вывод>: Елисеев 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: ['Графов', 'Петров'], ['10', '10'], ['Санкт-Петербург', 'Москва'] 
<Вывод>: Петров 
<Example 6>: 
<Тип теста 6>: closed 
<Ввод>: ['Степанов'], ['100'], ['Москва'] 
<Вывод>: Степанов 
<Решение студента>: def designer (designers, sizes, towns):
    sizes = list(map(int, sizes))
    lst_of_des = []
    lst_of_siz = []
    for i in range(towns):
        if towns[i] == ""Москва"":
            lst_of_des.append(designers[i])
            lst_of_siz.append(sizes[i])
    
    return lst_of_des[lst_of_siz.index(max(lst_of_siz))]   
<Идеальное решение>: def designer (designers, sizes, towns):
    sizes = list(map(int, sizes))
    lst_of_des = []
    lst_of_siz = []
    for i in range(len(towns)):
        if towns[i] == ""Москва"":
            lst_of_des.append(designers[i])
            lst_of_siz.append(sizes[i])
    
    return lst_of_des[lst_of_siz.index(min(lst_of_siz))]   


<Комментарий эксперта>:"
103,289,18,"Напишите функцию, определяющую дизайнера, который работает над самым сложным проектом в городе Москва.

Определите функцию designer, которая принимает на вход три списка:
в первой списке перечислены фамилии дизайнеров;
во втором списке перечислены размеры помещений (в кв. м.) (строки), для которых эти дизайнеры создают проекты интерьера соответственно.
в третьем списке перечислены города, в которых располагаются помещения.
Гарантируется, что фамилии дизайнеров не повторяются. При этом размеры помещений могут повторяться.
Самым сложным считается проект, в котором площадь помещения максимальна. Гарантируется, что такой проект только один.
Функция должна возвращать фамилию дизайнера, который работает над самым сложным проектом в городе Москва. 
Важно! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке.","[""['Круглов', 'Квадратов', 'Иванов', 'Марков', 'Пеньков', 'Гуськов'], ['100', '60', '67', '120', '90', '32'], ['Москва', 'Санкт-Петербург', 'Пермь', 'Москва', 'Сочи', 'Иваново']"", ""['Елисеев', 'Краков'], ['67', '100'], ['Москва', 'Томск']"", ""['Петров', 'Иванов', 'Волков', 'Меньшов'], ['50', '109', '30', '40'], ['Сочи', 'Москва', 'Иркутск', 'Краснодар']"", ""['Елисеев', 'Воробьев', 'Стариков'], ['100', '100', '150'], ['Москва', 'Санкт-Петербург', 'Реутов']"", ""['Графов', 'Петров'], ['10', '10'], ['Санкт-Петербург', 'Москва']"", ""['Степанов'], ['100'], ['Москва']""]","['Круглов', 'Елисеев', 'Иванов', 'Елисеев', 'Петров', 'Степанов']","def designer (designers, sizes, towns):
    sizes = list(map(int, sizes))
    lst_of_des = []
    lst_of_siz = []
    for i in len(towns):
        if towns[i] == ""Москва"":
            lst_of_des.append(designers[i])
            lst_of_siz.append(sizes[i])
    
    return lst_of_des[lst_of_siz.index(max(lst_of_siz))]  ","def designer (designers, sizes, towns):
    sizes = list(map(int, sizes))
    lst_of_des = []
    lst_of_siz = []
    for i in range(len(towns)):
        if towns[i] == ""Москва"":
            lst_of_des.append(designers[i])
            lst_of_siz.append(sizes[i])
    
    return lst_of_des[lst_of_siz.index(min(lst_of_siz))]  ",Ошибка при попытке итерации в цикле for. Невозможно проводить итерацию по объекту класса integer. Попробуйте использовать функцию range().,"['open', 'open', 'closed', 'closed', 'closed', 'closed']","<Task description>: Напишите функцию, определяющую дизайнера, который работает над самым сложным проектом в городе Москва.

Определите функцию designer, которая принимает на вход три списка:
в первой списке перечислены фамилии дизайнеров;
во втором списке перечислены размеры помещений (в кв. м.) (строки), для которых эти дизайнеры создают проекты интерьера соответственно.
в третьем списке перечислены города, в которых располагаются помещения.
Гарантируется, что фамилии дизайнеров не повторяются. При этом размеры помещений могут повторяться.
Самым сложным считается проект, в котором площадь помещения максимальна. Гарантируется, что такой проект только один.
Функция должна возвращать фамилию дизайнера, который работает над самым сложным проектом в городе Москва. 
Важно! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: ['Круглов', 'Квадратов', 'Иванов', 'Марков', 'Пеньков', 'Гуськов'], ['100', '60', '67', '120', '90', '32'], ['Москва', 'Санкт-Петербург', 'Пермь', 'Москва', 'Сочи', 'Иваново'] 
<Вывод>: Круглов 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: ['Елисеев', 'Краков'], ['67', '100'], ['Москва', 'Томск'] 
<Вывод>: Елисеев 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: ['Петров', 'Иванов', 'Волков', 'Меньшов'], ['50', '109', '30', '40'], ['Сочи', 'Москва', 'Иркутск', 'Краснодар'] 
<Вывод>: Иванов 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: ['Елисеев', 'Воробьев', 'Стариков'], ['100', '100', '150'], ['Москва', 'Санкт-Петербург', 'Реутов'] 
<Вывод>: Елисеев 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: ['Графов', 'Петров'], ['10', '10'], ['Санкт-Петербург', 'Москва'] 
<Вывод>: Петров 
<Example 6>: 
<Тип теста 6>: closed 
<Ввод>: ['Степанов'], ['100'], ['Москва'] 
<Вывод>: Степанов 
<Решение студента>: def designer (designers, sizes, towns):
    sizes = list(map(int, sizes))
    lst_of_des = []
    lst_of_siz = []
    for i in len(towns):
        if towns[i] == ""Москва"":
            lst_of_des.append(designers[i])
            lst_of_siz.append(sizes[i])
    
    return lst_of_des[lst_of_siz.index(max(lst_of_siz))]   
<Идеальное решение>: def designer (designers, sizes, towns):
    sizes = list(map(int, sizes))
    lst_of_des = []
    lst_of_siz = []
    for i in range(len(towns)):
        if towns[i] == ""Москва"":
            lst_of_des.append(designers[i])
            lst_of_siz.append(sizes[i])
    
    return lst_of_des[lst_of_siz.index(min(lst_of_siz))]   


<Комментарий эксперта>:"
104,290,18,"Напишите функцию, определяющую дизайнера, который работает над самым сложным проектом в городе Москва.

Определите функцию designer, которая принимает на вход три списка:
в первой списке перечислены фамилии дизайнеров;
во втором списке перечислены размеры помещений (в кв. м.) (строки), для которых эти дизайнеры создают проекты интерьера соответственно.
в третьем списке перечислены города, в которых располагаются помещения.
Гарантируется, что фамилии дизайнеров не повторяются. При этом размеры помещений могут повторяться.
Самым сложным считается проект, в котором площадь помещения максимальна. Гарантируется, что такой проект только один.
Функция должна возвращать фамилию дизайнера, который работает над самым сложным проектом в городе Москва. 
Важно! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке.","[""['Круглов', 'Квадратов', 'Иванов', 'Марков', 'Пеньков', 'Гуськов'], ['100', '60', '67', '120', '90', '32'], ['Москва', 'Санкт-Петербург', 'Пермь', 'Москва', 'Сочи', 'Иваново']"", ""['Елисеев', 'Краков'], ['67', '100'], ['Москва', 'Томск']"", ""['Петров', 'Иванов', 'Волков', 'Меньшов'], ['50', '109', '30', '40'], ['Сочи', 'Москва', 'Иркутск', 'Краснодар']"", ""['Елисеев', 'Воробьев', 'Стариков'], ['100', '100', '150'], ['Москва', 'Санкт-Петербург', 'Реутов']"", ""['Графов', 'Петров'], ['10', '10'], ['Санкт-Петербург', 'Москва']"", ""['Степанов'], ['100'], ['Москва']""]","['Круглов', 'Елисеев', 'Иванов', 'Елисеев', 'Петров', 'Степанов']","def designer (designers, sizes, towns):
    sizes = list(map(int, sizes))
    lst_of_des = []
    lst_of_siz = []
    for i in range(len(towns)):
        if towns[i] = ""Москва"":
            lst_of_des.append(designers[i])
            lst_of_siz.append(sizes[i])
    
    return lst_of_des[lst_of_siz.index(max(lst_of_siz))]  ","def designer (designers, sizes, towns):
    sizes = list(map(int, sizes))
    lst_of_des = []
    lst_of_siz = []
    for i in range(len(towns)):
        if towns[i] == ""Москва"":
            lst_of_des.append(designers[i])
            lst_of_siz.append(sizes[i])
    
    return lst_of_des[lst_of_siz.index(min(lst_of_siz))]  ",Синтаксическая ошибка при попытке сравнить переменные. При сравнении переменных используйте знак двойного равенства. ,"['open', 'open', 'closed', 'closed', 'closed', 'closed']","<Task description>: Напишите функцию, определяющую дизайнера, который работает над самым сложным проектом в городе Москва.

Определите функцию designer, которая принимает на вход три списка:
в первой списке перечислены фамилии дизайнеров;
во втором списке перечислены размеры помещений (в кв. м.) (строки), для которых эти дизайнеры создают проекты интерьера соответственно.
в третьем списке перечислены города, в которых располагаются помещения.
Гарантируется, что фамилии дизайнеров не повторяются. При этом размеры помещений могут повторяться.
Самым сложным считается проект, в котором площадь помещения максимальна. Гарантируется, что такой проект только один.
Функция должна возвращать фамилию дизайнера, который работает над самым сложным проектом в городе Москва. 
Важно! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: ['Круглов', 'Квадратов', 'Иванов', 'Марков', 'Пеньков', 'Гуськов'], ['100', '60', '67', '120', '90', '32'], ['Москва', 'Санкт-Петербург', 'Пермь', 'Москва', 'Сочи', 'Иваново'] 
<Вывод>: Круглов 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: ['Елисеев', 'Краков'], ['67', '100'], ['Москва', 'Томск'] 
<Вывод>: Елисеев 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: ['Петров', 'Иванов', 'Волков', 'Меньшов'], ['50', '109', '30', '40'], ['Сочи', 'Москва', 'Иркутск', 'Краснодар'] 
<Вывод>: Иванов 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: ['Елисеев', 'Воробьев', 'Стариков'], ['100', '100', '150'], ['Москва', 'Санкт-Петербург', 'Реутов'] 
<Вывод>: Елисеев 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: ['Графов', 'Петров'], ['10', '10'], ['Санкт-Петербург', 'Москва'] 
<Вывод>: Петров 
<Example 6>: 
<Тип теста 6>: closed 
<Ввод>: ['Степанов'], ['100'], ['Москва'] 
<Вывод>: Степанов 
<Решение студента>: def designer (designers, sizes, towns):
    sizes = list(map(int, sizes))
    lst_of_des = []
    lst_of_siz = []
    for i in range(len(towns)):
        if towns[i] = ""Москва"":
            lst_of_des.append(designers[i])
            lst_of_siz.append(sizes[i])
    
    return lst_of_des[lst_of_siz.index(max(lst_of_siz))]   
<Идеальное решение>: def designer (designers, sizes, towns):
    sizes = list(map(int, sizes))
    lst_of_des = []
    lst_of_siz = []
    for i in range(len(towns)):
        if towns[i] == ""Москва"":
            lst_of_des.append(designers[i])
            lst_of_siz.append(sizes[i])
    
    return lst_of_des[lst_of_siz.index(min(lst_of_siz))]   


<Комментарий эксперта>:"
105,291,18,"Напишите функцию, определяющую дизайнера, который работает над самым сложным проектом в городе Москва.

Определите функцию designer, которая принимает на вход три списка:
в первой списке перечислены фамилии дизайнеров;
во втором списке перечислены размеры помещений (в кв. м.) (строки), для которых эти дизайнеры создают проекты интерьера соответственно.
в третьем списке перечислены города, в которых располагаются помещения.
Гарантируется, что фамилии дизайнеров не повторяются. При этом размеры помещений могут повторяться.
Самым сложным считается проект, в котором площадь помещения максимальна. Гарантируется, что такой проект только один.
Функция должна возвращать фамилию дизайнера, который работает над самым сложным проектом в городе Москва. 
Важно! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке.","[""['Круглов', 'Квадратов', 'Иванов', 'Марков', 'Пеньков', 'Гуськов'], ['100', '60', '67', '120', '90', '32'], ['Москва', 'Санкт-Петербург', 'Пермь', 'Москва', 'Сочи', 'Иваново']"", ""['Елисеев', 'Краков'], ['67', '100'], ['Москва', 'Томск']"", ""['Петров', 'Иванов', 'Волков', 'Меньшов'], ['50', '109', '30', '40'], ['Сочи', 'Москва', 'Иркутск', 'Краснодар']"", ""['Елисеев', 'Воробьев', 'Стариков'], ['100', '100', '150'], ['Москва', 'Санкт-Петербург', 'Реутов']"", ""['Графов', 'Петров'], ['10', '10'], ['Санкт-Петербург', 'Москва']"", ""['Степанов'], ['100'], ['Москва']""]","['Круглов', 'Елисеев', 'Иванов', 'Елисеев', 'Петров', 'Степанов']","def designer (designers, sizes, towns):
    sizes = list(map(int, sizes))
    lst_of_des = []
    lst_of_siz = []
    for i in range(len(towns)):
        if towns[i] == Москва:
            lst_of_des.append(designers[i])
            lst_of_siz.append(sizes[i])
    
    return lst_of_des[lst_of_siz.index(max(lst_of_siz))]  ","def designer (designers, sizes, towns):
    sizes = list(map(int, sizes))
    lst_of_des = []
    lst_of_siz = []
    for i in range(len(towns)):
        if towns[i] == ""Москва"":
            lst_of_des.append(designers[i])
            lst_of_siz.append(sizes[i])
    
    return lst_of_des[lst_of_siz.index(min(lst_of_siz))]  ",Вы забыли заключить значение Москва в кавычки.,"['open', 'open', 'closed', 'closed', 'closed', 'closed']","<Task description>: Напишите функцию, определяющую дизайнера, который работает над самым сложным проектом в городе Москва.

Определите функцию designer, которая принимает на вход три списка:
в первой списке перечислены фамилии дизайнеров;
во втором списке перечислены размеры помещений (в кв. м.) (строки), для которых эти дизайнеры создают проекты интерьера соответственно.
в третьем списке перечислены города, в которых располагаются помещения.
Гарантируется, что фамилии дизайнеров не повторяются. При этом размеры помещений могут повторяться.
Самым сложным считается проект, в котором площадь помещения максимальна. Гарантируется, что такой проект только один.
Функция должна возвращать фамилию дизайнера, который работает над самым сложным проектом в городе Москва. 
Важно! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: ['Круглов', 'Квадратов', 'Иванов', 'Марков', 'Пеньков', 'Гуськов'], ['100', '60', '67', '120', '90', '32'], ['Москва', 'Санкт-Петербург', 'Пермь', 'Москва', 'Сочи', 'Иваново'] 
<Вывод>: Круглов 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: ['Елисеев', 'Краков'], ['67', '100'], ['Москва', 'Томск'] 
<Вывод>: Елисеев 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: ['Петров', 'Иванов', 'Волков', 'Меньшов'], ['50', '109', '30', '40'], ['Сочи', 'Москва', 'Иркутск', 'Краснодар'] 
<Вывод>: Иванов 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: ['Елисеев', 'Воробьев', 'Стариков'], ['100', '100', '150'], ['Москва', 'Санкт-Петербург', 'Реутов'] 
<Вывод>: Елисеев 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: ['Графов', 'Петров'], ['10', '10'], ['Санкт-Петербург', 'Москва'] 
<Вывод>: Петров 
<Example 6>: 
<Тип теста 6>: closed 
<Ввод>: ['Степанов'], ['100'], ['Москва'] 
<Вывод>: Степанов 
<Решение студента>: def designer (designers, sizes, towns):
    sizes = list(map(int, sizes))
    lst_of_des = []
    lst_of_siz = []
    for i in range(len(towns)):
        if towns[i] == Москва:
            lst_of_des.append(designers[i])
            lst_of_siz.append(sizes[i])
    
    return lst_of_des[lst_of_siz.index(max(lst_of_siz))]   
<Идеальное решение>: def designer (designers, sizes, towns):
    sizes = list(map(int, sizes))
    lst_of_des = []
    lst_of_siz = []
    for i in range(len(towns)):
        if towns[i] == ""Москва"":
            lst_of_des.append(designers[i])
            lst_of_siz.append(sizes[i])
    
    return lst_of_des[lst_of_siz.index(min(lst_of_siz))]   


<Комментарий эксперта>:"
106,292,18,"Напишите функцию, определяющую дизайнера, который работает над самым сложным проектом в городе Москва.

Определите функцию designer, которая принимает на вход три списка:
в первой списке перечислены фамилии дизайнеров;
во втором списке перечислены размеры помещений (в кв. м.) (строки), для которых эти дизайнеры создают проекты интерьера соответственно.
в третьем списке перечислены города, в которых располагаются помещения.
Гарантируется, что фамилии дизайнеров не повторяются. При этом размеры помещений могут повторяться.
Самым сложным считается проект, в котором площадь помещения максимальна. Гарантируется, что такой проект только один.
Функция должна возвращать фамилию дизайнера, который работает над самым сложным проектом в городе Москва. 
Важно! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке.","[""['Круглов', 'Квадратов', 'Иванов', 'Марков', 'Пеньков', 'Гуськов'], ['100', '60', '67', '120', '90', '32'], ['Москва', 'Санкт-Петербург', 'Пермь', 'Москва', 'Сочи', 'Иваново']"", ""['Елисеев', 'Краков'], ['67', '100'], ['Москва', 'Томск']"", ""['Петров', 'Иванов', 'Волков', 'Меньшов'], ['50', '109', '30', '40'], ['Сочи', 'Москва', 'Иркутск', 'Краснодар']"", ""['Елисеев', 'Воробьев', 'Стариков'], ['100', '100', '150'], ['Москва', 'Санкт-Петербург', 'Реутов']"", ""['Графов', 'Петров'], ['10', '10'], ['Санкт-Петербург', 'Москва']"", ""['Степанов'], ['100'], ['Москва']""]","['Круглов', 'Елисеев', 'Иванов', 'Елисеев', 'Петров', 'Степанов']","def designer (designers, sizes, towns):
    sizes = list(map(int, sizes))
    lst_of_des = []
    lst_of_siz = []
    for i in range(len(towns)):
        if towns[i] == ""Москва"":
            lst_of_des.append(designers[i])
            lst_of_siz.append(sizes[i])
    
    return lst_of_des[max(lst_of_siz)]  ","def designer (designers, sizes, towns):
    sizes = list(map(int, sizes))
    lst_of_des = []
    lst_of_siz = []
    for i in range(len(towns)):
        if towns[i] == ""Москва"":
            lst_of_des.append(designers[i])
            lst_of_siz.append(sizes[i])
    
    return lst_of_des[lst_of_siz.index(min(lst_of_siz))]  ",Ошибка при возвращении данных функцией. Попробуйте обратиться к индексу минимального значения списка lst_of_siz.,"['open', 'open', 'closed', 'closed', 'closed', 'closed']","<Task description>: Напишите функцию, определяющую дизайнера, который работает над самым сложным проектом в городе Москва.

Определите функцию designer, которая принимает на вход три списка:
в первой списке перечислены фамилии дизайнеров;
во втором списке перечислены размеры помещений (в кв. м.) (строки), для которых эти дизайнеры создают проекты интерьера соответственно.
в третьем списке перечислены города, в которых располагаются помещения.
Гарантируется, что фамилии дизайнеров не повторяются. При этом размеры помещений могут повторяться.
Самым сложным считается проект, в котором площадь помещения максимальна. Гарантируется, что такой проект только один.
Функция должна возвращать фамилию дизайнера, который работает над самым сложным проектом в городе Москва. 
Важно! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: ['Круглов', 'Квадратов', 'Иванов', 'Марков', 'Пеньков', 'Гуськов'], ['100', '60', '67', '120', '90', '32'], ['Москва', 'Санкт-Петербург', 'Пермь', 'Москва', 'Сочи', 'Иваново'] 
<Вывод>: Круглов 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: ['Елисеев', 'Краков'], ['67', '100'], ['Москва', 'Томск'] 
<Вывод>: Елисеев 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: ['Петров', 'Иванов', 'Волков', 'Меньшов'], ['50', '109', '30', '40'], ['Сочи', 'Москва', 'Иркутск', 'Краснодар'] 
<Вывод>: Иванов 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: ['Елисеев', 'Воробьев', 'Стариков'], ['100', '100', '150'], ['Москва', 'Санкт-Петербург', 'Реутов'] 
<Вывод>: Елисеев 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: ['Графов', 'Петров'], ['10', '10'], ['Санкт-Петербург', 'Москва'] 
<Вывод>: Петров 
<Example 6>: 
<Тип теста 6>: closed 
<Ввод>: ['Степанов'], ['100'], ['Москва'] 
<Вывод>: Степанов 
<Решение студента>: def designer (designers, sizes, towns):
    sizes = list(map(int, sizes))
    lst_of_des = []
    lst_of_siz = []
    for i in range(len(towns)):
        if towns[i] == ""Москва"":
            lst_of_des.append(designers[i])
            lst_of_siz.append(sizes[i])
    
    return lst_of_des[max(lst_of_siz)]   
<Идеальное решение>: def designer (designers, sizes, towns):
    sizes = list(map(int, sizes))
    lst_of_des = []
    lst_of_siz = []
    for i in range(len(towns)):
        if towns[i] == ""Москва"":
            lst_of_des.append(designers[i])
            lst_of_siz.append(sizes[i])
    
    return lst_of_des[lst_of_siz.index(min(lst_of_siz))]   


<Комментарий эксперта>:"
107,293,18,"Напишите функцию, определяющую дизайнера, который работает над самым сложным проектом в городе Москва.

Определите функцию designer, которая принимает на вход три списка:
в первой списке перечислены фамилии дизайнеров;
во втором списке перечислены размеры помещений (в кв. м.) (строки), для которых эти дизайнеры создают проекты интерьера соответственно.
в третьем списке перечислены города, в которых располагаются помещения.
Гарантируется, что фамилии дизайнеров не повторяются. При этом размеры помещений могут повторяться.
Самым сложным считается проект, в котором площадь помещения максимальна. Гарантируется, что такой проект только один.
Функция должна возвращать фамилию дизайнера, который работает над самым сложным проектом в городе Москва. 
Важно! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке.","[""['Круглов', 'Квадратов', 'Иванов', 'Марков', 'Пеньков', 'Гуськов'], ['100', '60', '67', '120', '90', '32'], ['Москва', 'Санкт-Петербург', 'Пермь', 'Москва', 'Сочи', 'Иваново']"", ""['Елисеев', 'Краков'], ['67', '100'], ['Москва', 'Томск']"", ""['Петров', 'Иванов', 'Волков', 'Меньшов'], ['50', '109', '30', '40'], ['Сочи', 'Москва', 'Иркутск', 'Краснодар']"", ""['Елисеев', 'Воробьев', 'Стариков'], ['100', '100', '150'], ['Москва', 'Санкт-Петербург', 'Реутов']"", ""['Графов', 'Петров'], ['10', '10'], ['Санкт-Петербург', 'Москва']"", ""['Степанов'], ['100'], ['Москва']""]","['Круглов', 'Елисеев', 'Иванов', 'Елисеев', 'Петров', 'Степанов']","def designer (designers, sizes, towns):
    sizes = list(map(int, sizes))
    lst_of_des = []
    lst_of_siz = []
    for i in range(len(towns)):
        if towns[i] == ""Москва"":
            lst_of_des.append(designers[i])
            lst_of_siz.append(sizes[i])
    
    return lst_of_des[lst_of_siz.index(min(lst_of_siz))]  ","def designer (designers, sizes, towns):
    sizes = list(map(int, sizes))
    lst_of_des = []
    lst_of_siz = []
    for i in range(len(towns)):
        if towns[i] == ""Москва"":
            lst_of_des.append(designers[i])
            lst_of_siz.append(sizes[i])
    
    return lst_of_des[lst_of_siz.index(min(lst_of_siz))]  ","Ошибка в открытых и скрытых тестах. 

Ваш код не выполняет условия задания ""Функция должна возвращать фамилию дизайнера, который работает над самым сложным проектом в городе Москва"". Попробуйте изменить условие оператора return, чтобы скорректировать ошибку.","['open', 'open', 'closed', 'closed', 'closed', 'closed']","<Task description>: Напишите функцию, определяющую дизайнера, который работает над самым сложным проектом в городе Москва.

Определите функцию designer, которая принимает на вход три списка:
в первой списке перечислены фамилии дизайнеров;
во втором списке перечислены размеры помещений (в кв. м.) (строки), для которых эти дизайнеры создают проекты интерьера соответственно.
в третьем списке перечислены города, в которых располагаются помещения.
Гарантируется, что фамилии дизайнеров не повторяются. При этом размеры помещений могут повторяться.
Самым сложным считается проект, в котором площадь помещения максимальна. Гарантируется, что такой проект только один.
Функция должна возвращать фамилию дизайнера, который работает над самым сложным проектом в городе Москва. 
Важно! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: ['Круглов', 'Квадратов', 'Иванов', 'Марков', 'Пеньков', 'Гуськов'], ['100', '60', '67', '120', '90', '32'], ['Москва', 'Санкт-Петербург', 'Пермь', 'Москва', 'Сочи', 'Иваново'] 
<Вывод>: Круглов 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: ['Елисеев', 'Краков'], ['67', '100'], ['Москва', 'Томск'] 
<Вывод>: Елисеев 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: ['Петров', 'Иванов', 'Волков', 'Меньшов'], ['50', '109', '30', '40'], ['Сочи', 'Москва', 'Иркутск', 'Краснодар'] 
<Вывод>: Иванов 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: ['Елисеев', 'Воробьев', 'Стариков'], ['100', '100', '150'], ['Москва', 'Санкт-Петербург', 'Реутов'] 
<Вывод>: Елисеев 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: ['Графов', 'Петров'], ['10', '10'], ['Санкт-Петербург', 'Москва'] 
<Вывод>: Петров 
<Example 6>: 
<Тип теста 6>: closed 
<Ввод>: ['Степанов'], ['100'], ['Москва'] 
<Вывод>: Степанов 
<Решение студента>: def designer (designers, sizes, towns):
    sizes = list(map(int, sizes))
    lst_of_des = []
    lst_of_siz = []
    for i in range(len(towns)):
        if towns[i] == ""Москва"":
            lst_of_des.append(designers[i])
            lst_of_siz.append(sizes[i])
    
    return lst_of_des[lst_of_siz.index(min(lst_of_siz))]   
<Идеальное решение>: def designer (designers, sizes, towns):
    sizes = list(map(int, sizes))
    lst_of_des = []
    lst_of_siz = []
    for i in range(len(towns)):
        if towns[i] == ""Москва"":
            lst_of_des.append(designers[i])
            lst_of_siz.append(sizes[i])
    
    return lst_of_des[lst_of_siz.index(min(lst_of_siz))]   


<Комментарий эксперта>:"
108,294,18,"Напишите функцию, определяющую дизайнера, который работает над самым сложным проектом в городе Москва.

Определите функцию designer, которая принимает на вход три списка:
в первой списке перечислены фамилии дизайнеров;
во втором списке перечислены размеры помещений (в кв. м.) (строки), для которых эти дизайнеры создают проекты интерьера соответственно.
в третьем списке перечислены города, в которых располагаются помещения.
Гарантируется, что фамилии дизайнеров не повторяются. При этом размеры помещений могут повторяться.
Самым сложным считается проект, в котором площадь помещения максимальна. Гарантируется, что такой проект только один.
Функция должна возвращать фамилию дизайнера, который работает над самым сложным проектом в городе Москва. 
Важно! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке.","[""['Круглов', 'Квадратов', 'Иванов', 'Марков', 'Пеньков', 'Гуськов'], ['100', '60', '67', '120', '90', '32'], ['Москва', 'Санкт-Петербург', 'Пермь', 'Москва', 'Сочи', 'Иваново']"", ""['Елисеев', 'Краков'], ['67', '100'], ['Москва', 'Томск']"", ""['Петров', 'Иванов', 'Волков', 'Меньшов'], ['50', '109', '30', '40'], ['Сочи', 'Москва', 'Иркутск', 'Краснодар']"", ""['Елисеев', 'Воробьев', 'Стариков'], ['100', '100', '150'], ['Москва', 'Санкт-Петербург', 'Реутов']"", ""['Графов', 'Петров'], ['10', '10'], ['Санкт-Петербург', 'Москва']"", ""['Степанов'], ['100'], ['Москва']""]","['Круглов', 'Елисеев', 'Иванов', 'Елисеев', 'Петров', 'Степанов']","def designer (designers, sizes, towns):
    sizes = list(map(int, sizes))
    lst_of_des = []
    lst_of_siz = []
    for i in range(len(towns)):
        if towns[i] == ""Москва"":
            lst_of_des.append(designers[i])
            lst_of_siz.append(sizes[i])
    
    return lst_of_des[lst_of_siz.index(min(lst_of_des))]  ","def designer (designers, sizes, towns):
    sizes = list(map(int, sizes))
    lst_of_des = []
    lst_of_siz = []
    for i in range(len(towns)):
        if towns[i] == ""Москва"":
            lst_of_des.append(designers[i])
            lst_of_siz.append(sizes[i])
    
    return lst_of_des[lst_of_siz.index(min(lst_of_siz))]  ",Ошибка при возвращении данных функцией. Функция обращается к неверному словарю при попылке вернуть минимальное значение.,"['open', 'open', 'closed', 'closed', 'closed', 'closed']","<Task description>: Напишите функцию, определяющую дизайнера, который работает над самым сложным проектом в городе Москва.

Определите функцию designer, которая принимает на вход три списка:
в первой списке перечислены фамилии дизайнеров;
во втором списке перечислены размеры помещений (в кв. м.) (строки), для которых эти дизайнеры создают проекты интерьера соответственно.
в третьем списке перечислены города, в которых располагаются помещения.
Гарантируется, что фамилии дизайнеров не повторяются. При этом размеры помещений могут повторяться.
Самым сложным считается проект, в котором площадь помещения максимальна. Гарантируется, что такой проект только один.
Функция должна возвращать фамилию дизайнера, который работает над самым сложным проектом в городе Москва. 
Важно! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: ['Круглов', 'Квадратов', 'Иванов', 'Марков', 'Пеньков', 'Гуськов'], ['100', '60', '67', '120', '90', '32'], ['Москва', 'Санкт-Петербург', 'Пермь', 'Москва', 'Сочи', 'Иваново'] 
<Вывод>: Круглов 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: ['Елисеев', 'Краков'], ['67', '100'], ['Москва', 'Томск'] 
<Вывод>: Елисеев 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: ['Петров', 'Иванов', 'Волков', 'Меньшов'], ['50', '109', '30', '40'], ['Сочи', 'Москва', 'Иркутск', 'Краснодар'] 
<Вывод>: Иванов 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: ['Елисеев', 'Воробьев', 'Стариков'], ['100', '100', '150'], ['Москва', 'Санкт-Петербург', 'Реутов'] 
<Вывод>: Елисеев 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: ['Графов', 'Петров'], ['10', '10'], ['Санкт-Петербург', 'Москва'] 
<Вывод>: Петров 
<Example 6>: 
<Тип теста 6>: closed 
<Ввод>: ['Степанов'], ['100'], ['Москва'] 
<Вывод>: Степанов 
<Решение студента>: def designer (designers, sizes, towns):
    sizes = list(map(int, sizes))
    lst_of_des = []
    lst_of_siz = []
    for i in range(len(towns)):
        if towns[i] == ""Москва"":
            lst_of_des.append(designers[i])
            lst_of_siz.append(sizes[i])
    
    return lst_of_des[lst_of_siz.index(min(lst_of_des))]   
<Идеальное решение>: def designer (designers, sizes, towns):
    sizes = list(map(int, sizes))
    lst_of_des = []
    lst_of_siz = []
    for i in range(len(towns)):
        if towns[i] == ""Москва"":
            lst_of_des.append(designers[i])
            lst_of_siz.append(sizes[i])
    
    return lst_of_des[lst_of_siz.index(min(lst_of_siz))]   


<Комментарий эксперта>:"
109,295,18,"Напишите функцию, определяющую дизайнера, который работает над самым сложным проектом в городе Москва.

Определите функцию designer, которая принимает на вход три списка:
в первой списке перечислены фамилии дизайнеров;
во втором списке перечислены размеры помещений (в кв. м.) (строки), для которых эти дизайнеры создают проекты интерьера соответственно.
в третьем списке перечислены города, в которых располагаются помещения.
Гарантируется, что фамилии дизайнеров не повторяются. При этом размеры помещений могут повторяться.
Самым сложным считается проект, в котором площадь помещения максимальна. Гарантируется, что такой проект только один.
Функция должна возвращать фамилию дизайнера, который работает над самым сложным проектом в городе Москва. 
Важно! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке.","[""['Круглов', 'Квадратов', 'Иванов', 'Марков', 'Пеньков', 'Гуськов'], ['100', '60', '67', '120', '90', '32'], ['Москва', 'Санкт-Петербург', 'Пермь', 'Москва', 'Сочи', 'Иваново']"", ""['Елисеев', 'Краков'], ['67', '100'], ['Москва', 'Томск']"", ""['Петров', 'Иванов', 'Волков', 'Меньшов'], ['50', '109', '30', '40'], ['Сочи', 'Москва', 'Иркутск', 'Краснодар']"", ""['Елисеев', 'Воробьев', 'Стариков'], ['100', '100', '150'], ['Москва', 'Санкт-Петербург', 'Реутов']"", ""['Графов', 'Петров'], ['10', '10'], ['Санкт-Петербург', 'Москва']"", ""['Степанов'], ['100'], ['Москва']""]","['Круглов', 'Елисеев', 'Иванов', 'Елисеев', 'Петров', 'Степанов']","def designer (designers, sizes, towns):
    sizes = list(map(int, sizes))
    lst_of_des = []
    lst_of_siz = []
    for i in range(len(towns)):
        if towns[i] != ""Москва"":
            lst_of_des.append(designers[i])
            lst_of_siz.append(sizes[i])
    
    return lst_of_des[lst_of_siz.index(min(lst_of_siz))]  ","def designer (designers, sizes, towns):
    sizes = list(map(int, sizes))
    lst_of_des = []
    lst_of_siz = []
    for i in range(len(towns)):
        if towns[i] == ""Москва"":
            lst_of_des.append(designers[i])
            lst_of_siz.append(sizes[i])
    
    return lst_of_des[lst_of_siz.index(min(lst_of_siz))]  ","Ошибка в открытых и скрытых тестах. 

Ваш код не выполняет условия задания ""Функция должна возвращать фамилию дизайнера, который работает над самым сложным проектом в городе Москва"". Попробуйте изменить условие оператора return, чтобы скорректировать ошибку.","['open', 'open', 'closed', 'closed', 'closed', 'closed']","<Task description>: Напишите функцию, определяющую дизайнера, который работает над самым сложным проектом в городе Москва.

Определите функцию designer, которая принимает на вход три списка:
в первой списке перечислены фамилии дизайнеров;
во втором списке перечислены размеры помещений (в кв. м.) (строки), для которых эти дизайнеры создают проекты интерьера соответственно.
в третьем списке перечислены города, в которых располагаются помещения.
Гарантируется, что фамилии дизайнеров не повторяются. При этом размеры помещений могут повторяться.
Самым сложным считается проект, в котором площадь помещения максимальна. Гарантируется, что такой проект только один.
Функция должна возвращать фамилию дизайнера, который работает над самым сложным проектом в городе Москва. 
Важно! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: ['Круглов', 'Квадратов', 'Иванов', 'Марков', 'Пеньков', 'Гуськов'], ['100', '60', '67', '120', '90', '32'], ['Москва', 'Санкт-Петербург', 'Пермь', 'Москва', 'Сочи', 'Иваново'] 
<Вывод>: Круглов 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: ['Елисеев', 'Краков'], ['67', '100'], ['Москва', 'Томск'] 
<Вывод>: Елисеев 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: ['Петров', 'Иванов', 'Волков', 'Меньшов'], ['50', '109', '30', '40'], ['Сочи', 'Москва', 'Иркутск', 'Краснодар'] 
<Вывод>: Иванов 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: ['Елисеев', 'Воробьев', 'Стариков'], ['100', '100', '150'], ['Москва', 'Санкт-Петербург', 'Реутов'] 
<Вывод>: Елисеев 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: ['Графов', 'Петров'], ['10', '10'], ['Санкт-Петербург', 'Москва'] 
<Вывод>: Петров 
<Example 6>: 
<Тип теста 6>: closed 
<Ввод>: ['Степанов'], ['100'], ['Москва'] 
<Вывод>: Степанов 
<Решение студента>: def designer (designers, sizes, towns):
    sizes = list(map(int, sizes))
    lst_of_des = []
    lst_of_siz = []
    for i in range(len(towns)):
        if towns[i] != ""Москва"":
            lst_of_des.append(designers[i])
            lst_of_siz.append(sizes[i])
    
    return lst_of_des[lst_of_siz.index(min(lst_of_siz))]   
<Идеальное решение>: def designer (designers, sizes, towns):
    sizes = list(map(int, sizes))
    lst_of_des = []
    lst_of_siz = []
    for i in range(len(towns)):
        if towns[i] == ""Москва"":
            lst_of_des.append(designers[i])
            lst_of_siz.append(sizes[i])
    
    return lst_of_des[lst_of_siz.index(min(lst_of_siz))]   


<Комментарий эксперта>:"
110,296,18,"Напишите функцию, определяющую дизайнера, который работает над самым сложным проектом в городе Москва.

Определите функцию designer, которая принимает на вход три списка:
в первой списке перечислены фамилии дизайнеров;
во втором списке перечислены размеры помещений (в кв. м.) (строки), для которых эти дизайнеры создают проекты интерьера соответственно.
в третьем списке перечислены города, в которых располагаются помещения.
Гарантируется, что фамилии дизайнеров не повторяются. При этом размеры помещений могут повторяться.
Самым сложным считается проект, в котором площадь помещения максимальна. Гарантируется, что такой проект только один.
Функция должна возвращать фамилию дизайнера, который работает над самым сложным проектом в городе Москва. 
Важно! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке.","[""['Круглов', 'Квадратов', 'Иванов', 'Марков', 'Пеньков', 'Гуськов'], ['100', '60', '67', '120', '90', '32'], ['Москва', 'Санкт-Петербург', 'Пермь', 'Москва', 'Сочи', 'Иваново']"", ""['Елисеев', 'Краков'], ['67', '100'], ['Москва', 'Томск']"", ""['Петров', 'Иванов', 'Волков', 'Меньшов'], ['50', '109', '30', '40'], ['Сочи', 'Москва', 'Иркутск', 'Краснодар']"", ""['Елисеев', 'Воробьев', 'Стариков'], ['100', '100', '150'], ['Москва', 'Санкт-Петербург', 'Реутов']"", ""['Графов', 'Петров'], ['10', '10'], ['Санкт-Петербург', 'Москва']"", ""['Степанов'], ['100'], ['Москва']""]","['Круглов', 'Елисеев', 'Иванов', 'Елисеев', 'Петров', 'Степанов']","def designer (designers, sizes, towns):
    sizes = list(map(int, sizes))
    lst_of_des = []
    lst_of_siz = []
    for i in range(len(towns)):
        if towns[i] == ""Москва"":
            lst_of_des.append(designers[i])
            lst_of_siz.append(sizes[i])
    
    return lst_ofdes[lst_of_siz.index(min(lst_of_siz))]  ","def designer (designers, sizes, towns):
    sizes = list(map(int, sizes))
    lst_of_des = []
    lst_of_siz = []
    for i in range(len(towns)):
        if towns[i] == ""Москва"":
            lst_of_des.append(designers[i])
            lst_of_siz.append(sizes[i])
    
    return lst_of_des[lst_of_siz.index(min(lst_of_siz))]  ",Синтаксическая ошибка. Обратите внимание на синтаксис всех переменных.,"['open', 'open', 'closed', 'closed', 'closed', 'closed']","<Task description>: Напишите функцию, определяющую дизайнера, который работает над самым сложным проектом в городе Москва.

Определите функцию designer, которая принимает на вход три списка:
в первой списке перечислены фамилии дизайнеров;
во втором списке перечислены размеры помещений (в кв. м.) (строки), для которых эти дизайнеры создают проекты интерьера соответственно.
в третьем списке перечислены города, в которых располагаются помещения.
Гарантируется, что фамилии дизайнеров не повторяются. При этом размеры помещений могут повторяться.
Самым сложным считается проект, в котором площадь помещения максимальна. Гарантируется, что такой проект только один.
Функция должна возвращать фамилию дизайнера, который работает над самым сложным проектом в городе Москва. 
Важно! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: ['Круглов', 'Квадратов', 'Иванов', 'Марков', 'Пеньков', 'Гуськов'], ['100', '60', '67', '120', '90', '32'], ['Москва', 'Санкт-Петербург', 'Пермь', 'Москва', 'Сочи', 'Иваново'] 
<Вывод>: Круглов 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: ['Елисеев', 'Краков'], ['67', '100'], ['Москва', 'Томск'] 
<Вывод>: Елисеев 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: ['Петров', 'Иванов', 'Волков', 'Меньшов'], ['50', '109', '30', '40'], ['Сочи', 'Москва', 'Иркутск', 'Краснодар'] 
<Вывод>: Иванов 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: ['Елисеев', 'Воробьев', 'Стариков'], ['100', '100', '150'], ['Москва', 'Санкт-Петербург', 'Реутов'] 
<Вывод>: Елисеев 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: ['Графов', 'Петров'], ['10', '10'], ['Санкт-Петербург', 'Москва'] 
<Вывод>: Петров 
<Example 6>: 
<Тип теста 6>: closed 
<Ввод>: ['Степанов'], ['100'], ['Москва'] 
<Вывод>: Степанов 
<Решение студента>: def designer (designers, sizes, towns):
    sizes = list(map(int, sizes))
    lst_of_des = []
    lst_of_siz = []
    for i in range(len(towns)):
        if towns[i] == ""Москва"":
            lst_of_des.append(designers[i])
            lst_of_siz.append(sizes[i])
    
    return lst_ofdes[lst_of_siz.index(min(lst_of_siz))]   
<Идеальное решение>: def designer (designers, sizes, towns):
    sizes = list(map(int, sizes))
    lst_of_des = []
    lst_of_siz = []
    for i in range(len(towns)):
        if towns[i] == ""Москва"":
            lst_of_des.append(designers[i])
            lst_of_siz.append(sizes[i])
    
    return lst_of_des[lst_of_siz.index(min(lst_of_siz))]   


<Комментарий эксперта>:"
111,297,18,"Напишите функцию, определяющую дизайнера, который работает над самым сложным проектом в городе Москва.

Определите функцию designer, которая принимает на вход три списка:
в первой списке перечислены фамилии дизайнеров;
во втором списке перечислены размеры помещений (в кв. м.) (строки), для которых эти дизайнеры создают проекты интерьера соответственно.
в третьем списке перечислены города, в которых располагаются помещения.
Гарантируется, что фамилии дизайнеров не повторяются. При этом размеры помещений могут повторяться.
Самым сложным считается проект, в котором площадь помещения максимальна. Гарантируется, что такой проект только один.
Функция должна возвращать фамилию дизайнера, который работает над самым сложным проектом в городе Москва. 
Важно! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке.","[""['Круглов', 'Квадратов', 'Иванов', 'Марков', 'Пеньков', 'Гуськов'], ['100', '60', '67', '120', '90', '32'], ['Москва', 'Санкт-Петербург', 'Пермь', 'Москва', 'Сочи', 'Иваново']"", ""['Елисеев', 'Краков'], ['67', '100'], ['Москва', 'Томск']"", ""['Петров', 'Иванов', 'Волков', 'Меньшов'], ['50', '109', '30', '40'], ['Сочи', 'Москва', 'Иркутск', 'Краснодар']"", ""['Елисеев', 'Воробьев', 'Стариков'], ['100', '100', '150'], ['Москва', 'Санкт-Петербург', 'Реутов']"", ""['Графов', 'Петров'], ['10', '10'], ['Санкт-Петербург', 'Москва']"", ""['Степанов'], ['100'], ['Москва']""]","['Круглов', 'Елисеев', 'Иванов', 'Елисеев', 'Петров', 'Степанов']","def designer (designers, sizes, towns):
    sizes = map(int, sizes)
    lst_of_des = []
    lst_of_siz = []
    for i in range(len(towns)):
        if towns[i] == ""Москва"":
            lst_of_des.append(designers[i])
            lst_of_siz.append(sizes[i])
    
    return lst_of_des[lst_of_siz.index(min(lst_of_siz))]  ","def designer (designers, sizes, towns):
    sizes = list(map(int, sizes))
    lst_of_des = []
    lst_of_siz = []
    for i in range(len(towns)):
        if towns[i] == ""Москва"":
            lst_of_des.append(designers[i])
            lst_of_siz.append(sizes[i])
    
    return lst_of_des[lst_of_siz.index(min(lst_of_siz))]  ","Ошибка преобразования данных. При использовании map() необходимо использовать также метод list(). map() создает лишь объект типа map, который нельяза итерировать. ","['open', 'open', 'closed', 'closed', 'closed', 'closed']","<Task description>: Напишите функцию, определяющую дизайнера, который работает над самым сложным проектом в городе Москва.

Определите функцию designer, которая принимает на вход три списка:
в первой списке перечислены фамилии дизайнеров;
во втором списке перечислены размеры помещений (в кв. м.) (строки), для которых эти дизайнеры создают проекты интерьера соответственно.
в третьем списке перечислены города, в которых располагаются помещения.
Гарантируется, что фамилии дизайнеров не повторяются. При этом размеры помещений могут повторяться.
Самым сложным считается проект, в котором площадь помещения максимальна. Гарантируется, что такой проект только один.
Функция должна возвращать фамилию дизайнера, который работает над самым сложным проектом в городе Москва. 
Важно! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: ['Круглов', 'Квадратов', 'Иванов', 'Марков', 'Пеньков', 'Гуськов'], ['100', '60', '67', '120', '90', '32'], ['Москва', 'Санкт-Петербург', 'Пермь', 'Москва', 'Сочи', 'Иваново'] 
<Вывод>: Круглов 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: ['Елисеев', 'Краков'], ['67', '100'], ['Москва', 'Томск'] 
<Вывод>: Елисеев 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: ['Петров', 'Иванов', 'Волков', 'Меньшов'], ['50', '109', '30', '40'], ['Сочи', 'Москва', 'Иркутск', 'Краснодар'] 
<Вывод>: Иванов 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: ['Елисеев', 'Воробьев', 'Стариков'], ['100', '100', '150'], ['Москва', 'Санкт-Петербург', 'Реутов'] 
<Вывод>: Елисеев 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: ['Графов', 'Петров'], ['10', '10'], ['Санкт-Петербург', 'Москва'] 
<Вывод>: Петров 
<Example 6>: 
<Тип теста 6>: closed 
<Ввод>: ['Степанов'], ['100'], ['Москва'] 
<Вывод>: Степанов 
<Решение студента>: def designer (designers, sizes, towns):
    sizes = map(int, sizes)
    lst_of_des = []
    lst_of_siz = []
    for i in range(len(towns)):
        if towns[i] == ""Москва"":
            lst_of_des.append(designers[i])
            lst_of_siz.append(sizes[i])
    
    return lst_of_des[lst_of_siz.index(min(lst_of_siz))]   
<Идеальное решение>: def designer (designers, sizes, towns):
    sizes = list(map(int, sizes))
    lst_of_des = []
    lst_of_siz = []
    for i in range(len(towns)):
        if towns[i] == ""Москва"":
            lst_of_des.append(designers[i])
            lst_of_siz.append(sizes[i])
    
    return lst_of_des[lst_of_siz.index(min(lst_of_siz))]   


<Комментарий эксперта>:"
112,334,21,"Андрей хочет пойти работать в одну из студий дизайна интерьеров и смотрит, выпускников каких вузов они хотели бы у себя видеть. Напишите программу, которая поможет Андрею определить студии, куда его не могут взять на работу. 

ФОРМАТ ВВОДА
На первой строке через точку с запятой и пробел вводится информация о компании и вузах '<название студии дизайна>: <названия вузов через запятую и пробел>'. Гарантируется, что строка содержит информацию минимум об одной компании. 
На второй строке вводится название вуза, в котором обучается Андрей. 
ФОРМАТ ВЫВОДА
Названия студий дизайна, куда Андрея не могут взять на работу.
Названия должны выводиться через прямой слэш и пробел (""/ "") в обратном алфавитном порядке.
Если таких студий нет, программа ничего не выводит.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Считайте в переменную строку со студиями и вузами, сразу разделите по разделителю и получите список.
Считайте в переменную название вуза.
Создайте пустой список, в который будете добавлять название студии, если она готова пригласить Андрея на стажировку.
Обратитесь к каждому элементу из списка, созданного в п.1:
разбейте его (строку) по разделителю и сохраните название студии в одну переменную, а названия вузов — в другую переменную;
если вуза Андрея (переменная из п.2) нет в названиях вузов, то добавьте название студии в список из п.3.
Отсортируйте получившийся список в обратном алфавитном порядке. 
Напечатайте элементы списка через прямой слэш и пробел.","['Greenfield: МГУ, ВШЭ, МГСУ, СПбГУ; VDT: ВШЭ, РГГУ, Бауманка; A29: МИФИ, МФТИ, МГСУ, РАНХиГС; DA Bureau: РАНХиГС, ВШЭ, МГУ\nВШЭ', 'Sinitsa Buro: МГСУ, ВШЭ, МГИМО\nМГСУ', 'Lepo bureau: СПбГУ\nМГУ', 'Greenfield: МГСУ; Da-sein: МГСУ; Suite n.7: МГСУ\nВШЭ', 'Akke Collective: НИУ ВШЭ; Taiga Architects: НИУ ВШЭ; Better: НИУ ВШЭ\nНИУ ВШЭ', 'Artbureau 1/1: НИУ ВШЭ, КФУ, РГГУ; IA Buro: МФТИ, РГУ, МГСУ; Objct: МИФИ, МГПУ, МГСУ, РГУ\nРГУ']","['A29', nan, 'Lepo burea', 'Suite n.7/ Greenfield/ Da-sein', nan, 'Artbureau 1/1']","data = input().split(';')
university = input()

result = []
for studio in data:
    st, univ = studio.split(': ')
    univ = univ.split(', ')
    if university not in univ:
        result.append(st)

print(*sorted(result, reverse = True), sep = '/ ')","data = input().split('; ')
university = input()

result = []
for studio in data:
    st, univ = studio.split(': ')
    univ = univ.split(', ')
    if university not in univ:
        result.append(st)

print(*sorted(result, reverse = True), sep = '/ ')","Ошибка в открытых и скрытых тестах. 

Ваш код использует неверный параметр в функции split().","['open', 'open', 'open', 'closed', 'closed', 'closed']","<Task description>: Андрей хочет пойти работать в одну из студий дизайна интерьеров и смотрит, выпускников каких вузов они хотели бы у себя видеть. Напишите программу, которая поможет Андрею определить студии, куда его не могут взять на работу. 

ФОРМАТ ВВОДА
На первой строке через точку с запятой и пробел вводится информация о компании и вузах '<название студии дизайна>: <названия вузов через запятую и пробел>'. Гарантируется, что строка содержит информацию минимум об одной компании. 
На второй строке вводится название вуза, в котором обучается Андрей. 
ФОРМАТ ВЫВОДА
Названия студий дизайна, куда Андрея не могут взять на работу.
Названия должны выводиться через прямой слэш и пробел (""/ "") в обратном алфавитном порядке.
Если таких студий нет, программа ничего не выводит.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Считайте в переменную строку со студиями и вузами, сразу разделите по разделителю и получите список.
Считайте в переменную название вуза.
Создайте пустой список, в который будете добавлять название студии, если она готова пригласить Андрея на стажировку.
Обратитесь к каждому элементу из списка, созданного в п.1:
разбейте его (строку) по разделителю и сохраните название студии в одну переменную, а названия вузов — в другую переменную;
если вуза Андрея (переменная из п.2) нет в названиях вузов, то добавьте название студии в список из п.3.
Отсортируйте получившийся список в обратном алфавитном порядке. 
Напечатайте элементы списка через прямой слэш и пробел. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: Greenfield: МГУ, ВШЭ, МГСУ, СПбГУ; VDT: ВШЭ, РГГУ, Бауманка; A29: МИФИ, МФТИ, МГСУ, РАНХиГС; DA Bureau: РАНХиГС, ВШЭ, МГУ
ВШЭ 
<Вывод>: A29 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: Sinitsa Buro: МГСУ, ВШЭ, МГИМО
МГСУ 
<Вывод>: nan 
<Example 3>: 
<Тип теста 3>: open 
<Ввод>: Lepo bureau: СПбГУ
МГУ 
<Вывод>: Lepo burea 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: Greenfield: МГСУ; Da-sein: МГСУ; Suite n.7: МГСУ
ВШЭ 
<Вывод>: Suite n.7/ Greenfield/ Da-sein 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: Akke Collective: НИУ ВШЭ; Taiga Architects: НИУ ВШЭ; Better: НИУ ВШЭ
НИУ ВШЭ 
<Вывод>: nan 
<Example 6>: 
<Тип теста 6>: closed 
<Ввод>: Artbureau 1/1: НИУ ВШЭ, КФУ, РГГУ; IA Buro: МФТИ, РГУ, МГСУ; Objct: МИФИ, МГПУ, МГСУ, РГУ
РГУ 
<Вывод>: Artbureau 1/1 
<Решение студента>: data = input().split(';')
university = input()

result = []
for studio in data:
    st, univ = studio.split(': ')
    univ = univ.split(', ')
    if university not in univ:
        result.append(st)

print(*sorted(result, reverse = True), sep = '/ ') 
<Идеальное решение>: data = input().split('; ')
university = input()

result = []
for studio in data:
    st, univ = studio.split(': ')
    univ = univ.split(', ')
    if university not in univ:
        result.append(st)

print(*sorted(result, reverse = True), sep = '/ ') 


<Комментарий эксперта>:"
113,335,21,"Андрей хочет пойти работать в одну из студий дизайна интерьеров и смотрит, выпускников каких вузов они хотели бы у себя видеть. Напишите программу, которая поможет Андрею определить студии, куда его не могут взять на работу. 

ФОРМАТ ВВОДА
На первой строке через точку с запятой и пробел вводится информация о компании и вузах '<название студии дизайна>: <названия вузов через запятую и пробел>'. Гарантируется, что строка содержит информацию минимум об одной компании. 
На второй строке вводится название вуза, в котором обучается Андрей. 
ФОРМАТ ВЫВОДА
Названия студий дизайна, куда Андрея не могут взять на работу.
Названия должны выводиться через прямой слэш и пробел (""/ "") в обратном алфавитном порядке.
Если таких студий нет, программа ничего не выводит.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Считайте в переменную строку со студиями и вузами, сразу разделите по разделителю и получите список.
Считайте в переменную название вуза.
Создайте пустой список, в который будете добавлять название студии, если она готова пригласить Андрея на стажировку.
Обратитесь к каждому элементу из списка, созданного в п.1:
разбейте его (строку) по разделителю и сохраните название студии в одну переменную, а названия вузов — в другую переменную;
если вуза Андрея (переменная из п.2) нет в названиях вузов, то добавьте название студии в список из п.3.
Отсортируйте получившийся список в обратном алфавитном порядке. 
Напечатайте элементы списка через прямой слэш и пробел.","['Greenfield: МГУ, ВШЭ, МГСУ, СПбГУ; VDT: ВШЭ, РГГУ, Бауманка; A29: МИФИ, МФТИ, МГСУ, РАНХиГС; DA Bureau: РАНХиГС, ВШЭ, МГУ\nВШЭ', 'Sinitsa Buro: МГСУ, ВШЭ, МГИМО\nМГСУ', 'Lepo bureau: СПбГУ\nМГУ', 'Greenfield: МГСУ; Da-sein: МГСУ; Suite n.7: МГСУ\nВШЭ', 'Akke Collective: НИУ ВШЭ; Taiga Architects: НИУ ВШЭ; Better: НИУ ВШЭ\nНИУ ВШЭ', 'Artbureau 1/1: НИУ ВШЭ, КФУ, РГГУ; IA Buro: МФТИ, РГУ, МГСУ; Objct: МИФИ, МГПУ, МГСУ, РГУ\nРГУ']","['A29', nan, 'Lepo burea', 'Suite n.7/ Greenfield/ Da-sein', nan, 'Artbureau 1/1']","data = input().split('; ')
university = input()

result = []
for studio in data:
    st, univ = studio.split(';')
    univ = univ.split(', ')
    if university not in univ:
        result.append(st)

print(*sorted(result, reverse = True), sep = '/ ')","data = input().split('; ')
university = input()

result = []
for studio in data:
    st, univ = studio.split(': ')
    univ = univ.split(', ')
    if university not in univ:
        result.append(st)

print(*sorted(result, reverse = True), sep = '/ ')",Ваш код использует неверный параметр в функции split().,"['open', 'open', 'open', 'closed', 'closed', 'closed']","<Task description>: Андрей хочет пойти работать в одну из студий дизайна интерьеров и смотрит, выпускников каких вузов они хотели бы у себя видеть. Напишите программу, которая поможет Андрею определить студии, куда его не могут взять на работу. 

ФОРМАТ ВВОДА
На первой строке через точку с запятой и пробел вводится информация о компании и вузах '<название студии дизайна>: <названия вузов через запятую и пробел>'. Гарантируется, что строка содержит информацию минимум об одной компании. 
На второй строке вводится название вуза, в котором обучается Андрей. 
ФОРМАТ ВЫВОДА
Названия студий дизайна, куда Андрея не могут взять на работу.
Названия должны выводиться через прямой слэш и пробел (""/ "") в обратном алфавитном порядке.
Если таких студий нет, программа ничего не выводит.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Считайте в переменную строку со студиями и вузами, сразу разделите по разделителю и получите список.
Считайте в переменную название вуза.
Создайте пустой список, в который будете добавлять название студии, если она готова пригласить Андрея на стажировку.
Обратитесь к каждому элементу из списка, созданного в п.1:
разбейте его (строку) по разделителю и сохраните название студии в одну переменную, а названия вузов — в другую переменную;
если вуза Андрея (переменная из п.2) нет в названиях вузов, то добавьте название студии в список из п.3.
Отсортируйте получившийся список в обратном алфавитном порядке. 
Напечатайте элементы списка через прямой слэш и пробел. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: Greenfield: МГУ, ВШЭ, МГСУ, СПбГУ; VDT: ВШЭ, РГГУ, Бауманка; A29: МИФИ, МФТИ, МГСУ, РАНХиГС; DA Bureau: РАНХиГС, ВШЭ, МГУ
ВШЭ 
<Вывод>: A29 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: Sinitsa Buro: МГСУ, ВШЭ, МГИМО
МГСУ 
<Вывод>: nan 
<Example 3>: 
<Тип теста 3>: open 
<Ввод>: Lepo bureau: СПбГУ
МГУ 
<Вывод>: Lepo burea 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: Greenfield: МГСУ; Da-sein: МГСУ; Suite n.7: МГСУ
ВШЭ 
<Вывод>: Suite n.7/ Greenfield/ Da-sein 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: Akke Collective: НИУ ВШЭ; Taiga Architects: НИУ ВШЭ; Better: НИУ ВШЭ
НИУ ВШЭ 
<Вывод>: nan 
<Example 6>: 
<Тип теста 6>: closed 
<Ввод>: Artbureau 1/1: НИУ ВШЭ, КФУ, РГГУ; IA Buro: МФТИ, РГУ, МГСУ; Objct: МИФИ, МГПУ, МГСУ, РГУ
РГУ 
<Вывод>: Artbureau 1/1 
<Решение студента>: data = input().split('; ')
university = input()

result = []
for studio in data:
    st, univ = studio.split(';')
    univ = univ.split(', ')
    if university not in univ:
        result.append(st)

print(*sorted(result, reverse = True), sep = '/ ') 
<Идеальное решение>: data = input().split('; ')
university = input()

result = []
for studio in data:
    st, univ = studio.split(': ')
    univ = univ.split(', ')
    if university not in univ:
        result.append(st)

print(*sorted(result, reverse = True), sep = '/ ') 


<Комментарий эксперта>:"
114,336,21,"Андрей хочет пойти работать в одну из студий дизайна интерьеров и смотрит, выпускников каких вузов они хотели бы у себя видеть. Напишите программу, которая поможет Андрею определить студии, куда его не могут взять на работу. 

ФОРМАТ ВВОДА
На первой строке через точку с запятой и пробел вводится информация о компании и вузах '<название студии дизайна>: <названия вузов через запятую и пробел>'. Гарантируется, что строка содержит информацию минимум об одной компании. 
На второй строке вводится название вуза, в котором обучается Андрей. 
ФОРМАТ ВЫВОДА
Названия студий дизайна, куда Андрея не могут взять на работу.
Названия должны выводиться через прямой слэш и пробел (""/ "") в обратном алфавитном порядке.
Если таких студий нет, программа ничего не выводит.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Считайте в переменную строку со студиями и вузами, сразу разделите по разделителю и получите список.
Считайте в переменную название вуза.
Создайте пустой список, в который будете добавлять название студии, если она готова пригласить Андрея на стажировку.
Обратитесь к каждому элементу из списка, созданного в п.1:
разбейте его (строку) по разделителю и сохраните название студии в одну переменную, а названия вузов — в другую переменную;
если вуза Андрея (переменная из п.2) нет в названиях вузов, то добавьте название студии в список из п.3.
Отсортируйте получившийся список в обратном алфавитном порядке. 
Напечатайте элементы списка через прямой слэш и пробел.","['Greenfield: МГУ, ВШЭ, МГСУ, СПбГУ; VDT: ВШЭ, РГГУ, Бауманка; A29: МИФИ, МФТИ, МГСУ, РАНХиГС; DA Bureau: РАНХиГС, ВШЭ, МГУ\nВШЭ', 'Sinitsa Buro: МГСУ, ВШЭ, МГИМО\nМГСУ', 'Lepo bureau: СПбГУ\nМГУ', 'Greenfield: МГСУ; Da-sein: МГСУ; Suite n.7: МГСУ\nВШЭ', 'Akke Collective: НИУ ВШЭ; Taiga Architects: НИУ ВШЭ; Better: НИУ ВШЭ\nНИУ ВШЭ', 'Artbureau 1/1: НИУ ВШЭ, КФУ, РГГУ; IA Buro: МФТИ, РГУ, МГСУ; Objct: МИФИ, МГПУ, МГСУ, РГУ\nРГУ']","['A29', nan, 'Lepo burea', 'Suite n.7/ Greenfield/ Da-sein', nan, 'Artbureau 1/1']","data = input().split('; ')
university = input()

result = []
for studio in data:
    st, univ = studio.split(': ')
    univ = univ.split('; ')
    if university not in univ:
        result.append(st)

print(*sorted(result, reverse = True), sep = '/ ')","data = input().split('; ')
university = input()

result = []
for studio in data:
    st, univ = studio.split(': ')
    univ = univ.split(', ')
    if university not in univ:
        result.append(st)

print(*sorted(result, reverse = True), sep = '/ ')","Ошибка в открытых и скрытых тестах. 

Ваш код использует неверный параметр в функции split().","['open', 'open', 'open', 'closed', 'closed', 'closed']","<Task description>: Андрей хочет пойти работать в одну из студий дизайна интерьеров и смотрит, выпускников каких вузов они хотели бы у себя видеть. Напишите программу, которая поможет Андрею определить студии, куда его не могут взять на работу. 

ФОРМАТ ВВОДА
На первой строке через точку с запятой и пробел вводится информация о компании и вузах '<название студии дизайна>: <названия вузов через запятую и пробел>'. Гарантируется, что строка содержит информацию минимум об одной компании. 
На второй строке вводится название вуза, в котором обучается Андрей. 
ФОРМАТ ВЫВОДА
Названия студий дизайна, куда Андрея не могут взять на работу.
Названия должны выводиться через прямой слэш и пробел (""/ "") в обратном алфавитном порядке.
Если таких студий нет, программа ничего не выводит.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Считайте в переменную строку со студиями и вузами, сразу разделите по разделителю и получите список.
Считайте в переменную название вуза.
Создайте пустой список, в который будете добавлять название студии, если она готова пригласить Андрея на стажировку.
Обратитесь к каждому элементу из списка, созданного в п.1:
разбейте его (строку) по разделителю и сохраните название студии в одну переменную, а названия вузов — в другую переменную;
если вуза Андрея (переменная из п.2) нет в названиях вузов, то добавьте название студии в список из п.3.
Отсортируйте получившийся список в обратном алфавитном порядке. 
Напечатайте элементы списка через прямой слэш и пробел. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: Greenfield: МГУ, ВШЭ, МГСУ, СПбГУ; VDT: ВШЭ, РГГУ, Бауманка; A29: МИФИ, МФТИ, МГСУ, РАНХиГС; DA Bureau: РАНХиГС, ВШЭ, МГУ
ВШЭ 
<Вывод>: A29 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: Sinitsa Buro: МГСУ, ВШЭ, МГИМО
МГСУ 
<Вывод>: nan 
<Example 3>: 
<Тип теста 3>: open 
<Ввод>: Lepo bureau: СПбГУ
МГУ 
<Вывод>: Lepo burea 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: Greenfield: МГСУ; Da-sein: МГСУ; Suite n.7: МГСУ
ВШЭ 
<Вывод>: Suite n.7/ Greenfield/ Da-sein 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: Akke Collective: НИУ ВШЭ; Taiga Architects: НИУ ВШЭ; Better: НИУ ВШЭ
НИУ ВШЭ 
<Вывод>: nan 
<Example 6>: 
<Тип теста 6>: closed 
<Ввод>: Artbureau 1/1: НИУ ВШЭ, КФУ, РГГУ; IA Buro: МФТИ, РГУ, МГСУ; Objct: МИФИ, МГПУ, МГСУ, РГУ
РГУ 
<Вывод>: Artbureau 1/1 
<Решение студента>: data = input().split('; ')
university = input()

result = []
for studio in data:
    st, univ = studio.split(': ')
    univ = univ.split('; ')
    if university not in univ:
        result.append(st)

print(*sorted(result, reverse = True), sep = '/ ') 
<Идеальное решение>: data = input().split('; ')
university = input()

result = []
for studio in data:
    st, univ = studio.split(': ')
    univ = univ.split(', ')
    if university not in univ:
        result.append(st)

print(*sorted(result, reverse = True), sep = '/ ') 


<Комментарий эксперта>:"
115,337,21,"Андрей хочет пойти работать в одну из студий дизайна интерьеров и смотрит, выпускников каких вузов они хотели бы у себя видеть. Напишите программу, которая поможет Андрею определить студии, куда его не могут взять на работу. 

ФОРМАТ ВВОДА
На первой строке через точку с запятой и пробел вводится информация о компании и вузах '<название студии дизайна>: <названия вузов через запятую и пробел>'. Гарантируется, что строка содержит информацию минимум об одной компании. 
На второй строке вводится название вуза, в котором обучается Андрей. 
ФОРМАТ ВЫВОДА
Названия студий дизайна, куда Андрея не могут взять на работу.
Названия должны выводиться через прямой слэш и пробел (""/ "") в обратном алфавитном порядке.
Если таких студий нет, программа ничего не выводит.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Считайте в переменную строку со студиями и вузами, сразу разделите по разделителю и получите список.
Считайте в переменную название вуза.
Создайте пустой список, в который будете добавлять название студии, если она готова пригласить Андрея на стажировку.
Обратитесь к каждому элементу из списка, созданного в п.1:
разбейте его (строку) по разделителю и сохраните название студии в одну переменную, а названия вузов — в другую переменную;
если вуза Андрея (переменная из п.2) нет в названиях вузов, то добавьте название студии в список из п.3.
Отсортируйте получившийся список в обратном алфавитном порядке. 
Напечатайте элементы списка через прямой слэш и пробел.","['Greenfield: МГУ, ВШЭ, МГСУ, СПбГУ; VDT: ВШЭ, РГГУ, Бауманка; A29: МИФИ, МФТИ, МГСУ, РАНХиГС; DA Bureau: РАНХиГС, ВШЭ, МГУ\nВШЭ', 'Sinitsa Buro: МГСУ, ВШЭ, МГИМО\nМГСУ', 'Lepo bureau: СПбГУ\nМГУ', 'Greenfield: МГСУ; Da-sein: МГСУ; Suite n.7: МГСУ\nВШЭ', 'Akke Collective: НИУ ВШЭ; Taiga Architects: НИУ ВШЭ; Better: НИУ ВШЭ\nНИУ ВШЭ', 'Artbureau 1/1: НИУ ВШЭ, КФУ, РГГУ; IA Buro: МФТИ, РГУ, МГСУ; Objct: МИФИ, МГПУ, МГСУ, РГУ\nРГУ']","['A29', nan, 'Lepo burea', 'Suite n.7/ Greenfield/ Da-sein', nan, 'Artbureau 1/1']","data = input().split('; ')
university = input()

result = []
for i in data:
    st, univ = studio.split(': ')
    univ = univ.split(', ')
    if university not in univ:
        result.append(st)

print(*sorted(result, reverse = True), sep = '/ ')","data = input().split('; ')
university = input()

result = []
for studio in data:
    st, univ = studio.split(': ')
    univ = univ.split(', ')
    if university not in univ:
        result.append(st)

print(*sorted(result, reverse = True), sep = '/ ')","Вы использовали переменную, которая не была задана ранее. Проверьте в условии цикла for, что все переменные заданы корректно.","['open', 'open', 'open', 'closed', 'closed', 'closed']","<Task description>: Андрей хочет пойти работать в одну из студий дизайна интерьеров и смотрит, выпускников каких вузов они хотели бы у себя видеть. Напишите программу, которая поможет Андрею определить студии, куда его не могут взять на работу. 

ФОРМАТ ВВОДА
На первой строке через точку с запятой и пробел вводится информация о компании и вузах '<название студии дизайна>: <названия вузов через запятую и пробел>'. Гарантируется, что строка содержит информацию минимум об одной компании. 
На второй строке вводится название вуза, в котором обучается Андрей. 
ФОРМАТ ВЫВОДА
Названия студий дизайна, куда Андрея не могут взять на работу.
Названия должны выводиться через прямой слэш и пробел (""/ "") в обратном алфавитном порядке.
Если таких студий нет, программа ничего не выводит.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Считайте в переменную строку со студиями и вузами, сразу разделите по разделителю и получите список.
Считайте в переменную название вуза.
Создайте пустой список, в который будете добавлять название студии, если она готова пригласить Андрея на стажировку.
Обратитесь к каждому элементу из списка, созданного в п.1:
разбейте его (строку) по разделителю и сохраните название студии в одну переменную, а названия вузов — в другую переменную;
если вуза Андрея (переменная из п.2) нет в названиях вузов, то добавьте название студии в список из п.3.
Отсортируйте получившийся список в обратном алфавитном порядке. 
Напечатайте элементы списка через прямой слэш и пробел. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: Greenfield: МГУ, ВШЭ, МГСУ, СПбГУ; VDT: ВШЭ, РГГУ, Бауманка; A29: МИФИ, МФТИ, МГСУ, РАНХиГС; DA Bureau: РАНХиГС, ВШЭ, МГУ
ВШЭ 
<Вывод>: A29 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: Sinitsa Buro: МГСУ, ВШЭ, МГИМО
МГСУ 
<Вывод>: nan 
<Example 3>: 
<Тип теста 3>: open 
<Ввод>: Lepo bureau: СПбГУ
МГУ 
<Вывод>: Lepo burea 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: Greenfield: МГСУ; Da-sein: МГСУ; Suite n.7: МГСУ
ВШЭ 
<Вывод>: Suite n.7/ Greenfield/ Da-sein 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: Akke Collective: НИУ ВШЭ; Taiga Architects: НИУ ВШЭ; Better: НИУ ВШЭ
НИУ ВШЭ 
<Вывод>: nan 
<Example 6>: 
<Тип теста 6>: closed 
<Ввод>: Artbureau 1/1: НИУ ВШЭ, КФУ, РГГУ; IA Buro: МФТИ, РГУ, МГСУ; Objct: МИФИ, МГПУ, МГСУ, РГУ
РГУ 
<Вывод>: Artbureau 1/1 
<Решение студента>: data = input().split('; ')
university = input()

result = []
for i in data:
    st, univ = studio.split(': ')
    univ = univ.split(', ')
    if university not in univ:
        result.append(st)

print(*sorted(result, reverse = True), sep = '/ ') 
<Идеальное решение>: data = input().split('; ')
university = input()

result = []
for studio in data:
    st, univ = studio.split(': ')
    univ = univ.split(', ')
    if university not in univ:
        result.append(st)

print(*sorted(result, reverse = True), sep = '/ ') 


<Комментарий эксперта>:"
116,338,21,"Андрей хочет пойти работать в одну из студий дизайна интерьеров и смотрит, выпускников каких вузов они хотели бы у себя видеть. Напишите программу, которая поможет Андрею определить студии, куда его не могут взять на работу. 

ФОРМАТ ВВОДА
На первой строке через точку с запятой и пробел вводится информация о компании и вузах '<название студии дизайна>: <названия вузов через запятую и пробел>'. Гарантируется, что строка содержит информацию минимум об одной компании. 
На второй строке вводится название вуза, в котором обучается Андрей. 
ФОРМАТ ВЫВОДА
Названия студий дизайна, куда Андрея не могут взять на работу.
Названия должны выводиться через прямой слэш и пробел (""/ "") в обратном алфавитном порядке.
Если таких студий нет, программа ничего не выводит.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Считайте в переменную строку со студиями и вузами, сразу разделите по разделителю и получите список.
Считайте в переменную название вуза.
Создайте пустой список, в который будете добавлять название студии, если она готова пригласить Андрея на стажировку.
Обратитесь к каждому элементу из списка, созданного в п.1:
разбейте его (строку) по разделителю и сохраните название студии в одну переменную, а названия вузов — в другую переменную;
если вуза Андрея (переменная из п.2) нет в названиях вузов, то добавьте название студии в список из п.3.
Отсортируйте получившийся список в обратном алфавитном порядке. 
Напечатайте элементы списка через прямой слэш и пробел.","['Greenfield: МГУ, ВШЭ, МГСУ, СПбГУ; VDT: ВШЭ, РГГУ, Бауманка; A29: МИФИ, МФТИ, МГСУ, РАНХиГС; DA Bureau: РАНХиГС, ВШЭ, МГУ\nВШЭ', 'Sinitsa Buro: МГСУ, ВШЭ, МГИМО\nМГСУ', 'Lepo bureau: СПбГУ\nМГУ', 'Greenfield: МГСУ; Da-sein: МГСУ; Suite n.7: МГСУ\nВШЭ', 'Akke Collective: НИУ ВШЭ; Taiga Architects: НИУ ВШЭ; Better: НИУ ВШЭ\nНИУ ВШЭ', 'Artbureau 1/1: НИУ ВШЭ, КФУ, РГГУ; IA Buro: МФТИ, РГУ, МГСУ; Objct: МИФИ, МГПУ, МГСУ, РГУ\nРГУ']","['A29', nan, 'Lepo burea', 'Suite n.7/ Greenfield/ Da-sein', nan, 'Artbureau 1/1']","data = input().split('; ')
university = input()

result = []
for studio in data:
    st, univ = studio.split(': ')
    univ = univ.split(', ')
    if university in univ:
        result.append(st)

print(*sorted(result, reverse = True), sep = '/ ')","data = input().split('; ')
university = input()

result = []
for studio in data:
    st, univ = studio.split(': ')
    univ = univ.split(', ')
    if university not in univ:
        result.append(st)

print(*sorted(result, reverse = True), sep = '/ ')","Ошибка в открытых и скрытых тестах. 

Ваш код некорректно выполняет условия задания. Так, он некорректно выполянет условие ""выведите названия студий дизайна, куда Андрея не могут взять на работу"". Попробуйте изменить условие if для исправления ошибки.","['open', 'open', 'open', 'closed', 'closed', 'closed']","<Task description>: Андрей хочет пойти работать в одну из студий дизайна интерьеров и смотрит, выпускников каких вузов они хотели бы у себя видеть. Напишите программу, которая поможет Андрею определить студии, куда его не могут взять на работу. 

ФОРМАТ ВВОДА
На первой строке через точку с запятой и пробел вводится информация о компании и вузах '<название студии дизайна>: <названия вузов через запятую и пробел>'. Гарантируется, что строка содержит информацию минимум об одной компании. 
На второй строке вводится название вуза, в котором обучается Андрей. 
ФОРМАТ ВЫВОДА
Названия студий дизайна, куда Андрея не могут взять на работу.
Названия должны выводиться через прямой слэш и пробел (""/ "") в обратном алфавитном порядке.
Если таких студий нет, программа ничего не выводит.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Считайте в переменную строку со студиями и вузами, сразу разделите по разделителю и получите список.
Считайте в переменную название вуза.
Создайте пустой список, в который будете добавлять название студии, если она готова пригласить Андрея на стажировку.
Обратитесь к каждому элементу из списка, созданного в п.1:
разбейте его (строку) по разделителю и сохраните название студии в одну переменную, а названия вузов — в другую переменную;
если вуза Андрея (переменная из п.2) нет в названиях вузов, то добавьте название студии в список из п.3.
Отсортируйте получившийся список в обратном алфавитном порядке. 
Напечатайте элементы списка через прямой слэш и пробел. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: Greenfield: МГУ, ВШЭ, МГСУ, СПбГУ; VDT: ВШЭ, РГГУ, Бауманка; A29: МИФИ, МФТИ, МГСУ, РАНХиГС; DA Bureau: РАНХиГС, ВШЭ, МГУ
ВШЭ 
<Вывод>: A29 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: Sinitsa Buro: МГСУ, ВШЭ, МГИМО
МГСУ 
<Вывод>: nan 
<Example 3>: 
<Тип теста 3>: open 
<Ввод>: Lepo bureau: СПбГУ
МГУ 
<Вывод>: Lepo burea 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: Greenfield: МГСУ; Da-sein: МГСУ; Suite n.7: МГСУ
ВШЭ 
<Вывод>: Suite n.7/ Greenfield/ Da-sein 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: Akke Collective: НИУ ВШЭ; Taiga Architects: НИУ ВШЭ; Better: НИУ ВШЭ
НИУ ВШЭ 
<Вывод>: nan 
<Example 6>: 
<Тип теста 6>: closed 
<Ввод>: Artbureau 1/1: НИУ ВШЭ, КФУ, РГГУ; IA Buro: МФТИ, РГУ, МГСУ; Objct: МИФИ, МГПУ, МГСУ, РГУ
РГУ 
<Вывод>: Artbureau 1/1 
<Решение студента>: data = input().split('; ')
university = input()

result = []
for studio in data:
    st, univ = studio.split(': ')
    univ = univ.split(', ')
    if university in univ:
        result.append(st)

print(*sorted(result, reverse = True), sep = '/ ') 
<Идеальное решение>: data = input().split('; ')
university = input()

result = []
for studio in data:
    st, univ = studio.split(': ')
    univ = univ.split(', ')
    if university not in univ:
        result.append(st)

print(*sorted(result, reverse = True), sep = '/ ') 


<Комментарий эксперта>:"
117,339,21,"Андрей хочет пойти работать в одну из студий дизайна интерьеров и смотрит, выпускников каких вузов они хотели бы у себя видеть. Напишите программу, которая поможет Андрею определить студии, куда его не могут взять на работу. 

ФОРМАТ ВВОДА
На первой строке через точку с запятой и пробел вводится информация о компании и вузах '<название студии дизайна>: <названия вузов через запятую и пробел>'. Гарантируется, что строка содержит информацию минимум об одной компании. 
На второй строке вводится название вуза, в котором обучается Андрей. 
ФОРМАТ ВЫВОДА
Названия студий дизайна, куда Андрея не могут взять на работу.
Названия должны выводиться через прямой слэш и пробел (""/ "") в обратном алфавитном порядке.
Если таких студий нет, программа ничего не выводит.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Считайте в переменную строку со студиями и вузами, сразу разделите по разделителю и получите список.
Считайте в переменную название вуза.
Создайте пустой список, в который будете добавлять название студии, если она готова пригласить Андрея на стажировку.
Обратитесь к каждому элементу из списка, созданного в п.1:
разбейте его (строку) по разделителю и сохраните название студии в одну переменную, а названия вузов — в другую переменную;
если вуза Андрея (переменная из п.2) нет в названиях вузов, то добавьте название студии в список из п.3.
Отсортируйте получившийся список в обратном алфавитном порядке. 
Напечатайте элементы списка через прямой слэш и пробел.","['Greenfield: МГУ, ВШЭ, МГСУ, СПбГУ; VDT: ВШЭ, РГГУ, Бауманка; A29: МИФИ, МФТИ, МГСУ, РАНХиГС; DA Bureau: РАНХиГС, ВШЭ, МГУ\nВШЭ', 'Sinitsa Buro: МГСУ, ВШЭ, МГИМО\nМГСУ', 'Lepo bureau: СПбГУ\nМГУ', 'Greenfield: МГСУ; Da-sein: МГСУ; Suite n.7: МГСУ\nВШЭ', 'Akke Collective: НИУ ВШЭ; Taiga Architects: НИУ ВШЭ; Better: НИУ ВШЭ\nНИУ ВШЭ', 'Artbureau 1/1: НИУ ВШЭ, КФУ, РГГУ; IA Buro: МФТИ, РГУ, МГСУ; Objct: МИФИ, МГПУ, МГСУ, РГУ\nРГУ']","['A29', nan, 'Lepo burea', 'Suite n.7/ Greenfield/ Da-sein', nan, 'Artbureau 1/1']","data = input().split('; ')
university = input()

result = []
for studio in data:
    st, univ = studio.split(': ')
    univ = univ.split(', ')
    if university not in univ:
        result.add(st)

print(*sorted(result, reverse = True), sep = '/ ')","data = input().split('; ')
university = input()

result = []
for studio in data:
    st, univ = studio.split(': ')
    univ = univ.split(', ')
    if university not in univ:
        result.append(st)

print(*sorted(result, reverse = True), sep = '/ ')",Некорректно использован метод добавления элементов в список. Список не имеет метода .add().,"['open', 'open', 'open', 'closed', 'closed', 'closed']","<Task description>: Андрей хочет пойти работать в одну из студий дизайна интерьеров и смотрит, выпускников каких вузов они хотели бы у себя видеть. Напишите программу, которая поможет Андрею определить студии, куда его не могут взять на работу. 

ФОРМАТ ВВОДА
На первой строке через точку с запятой и пробел вводится информация о компании и вузах '<название студии дизайна>: <названия вузов через запятую и пробел>'. Гарантируется, что строка содержит информацию минимум об одной компании. 
На второй строке вводится название вуза, в котором обучается Андрей. 
ФОРМАТ ВЫВОДА
Названия студий дизайна, куда Андрея не могут взять на работу.
Названия должны выводиться через прямой слэш и пробел (""/ "") в обратном алфавитном порядке.
Если таких студий нет, программа ничего не выводит.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Считайте в переменную строку со студиями и вузами, сразу разделите по разделителю и получите список.
Считайте в переменную название вуза.
Создайте пустой список, в который будете добавлять название студии, если она готова пригласить Андрея на стажировку.
Обратитесь к каждому элементу из списка, созданного в п.1:
разбейте его (строку) по разделителю и сохраните название студии в одну переменную, а названия вузов — в другую переменную;
если вуза Андрея (переменная из п.2) нет в названиях вузов, то добавьте название студии в список из п.3.
Отсортируйте получившийся список в обратном алфавитном порядке. 
Напечатайте элементы списка через прямой слэш и пробел. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: Greenfield: МГУ, ВШЭ, МГСУ, СПбГУ; VDT: ВШЭ, РГГУ, Бауманка; A29: МИФИ, МФТИ, МГСУ, РАНХиГС; DA Bureau: РАНХиГС, ВШЭ, МГУ
ВШЭ 
<Вывод>: A29 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: Sinitsa Buro: МГСУ, ВШЭ, МГИМО
МГСУ 
<Вывод>: nan 
<Example 3>: 
<Тип теста 3>: open 
<Ввод>: Lepo bureau: СПбГУ
МГУ 
<Вывод>: Lepo burea 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: Greenfield: МГСУ; Da-sein: МГСУ; Suite n.7: МГСУ
ВШЭ 
<Вывод>: Suite n.7/ Greenfield/ Da-sein 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: Akke Collective: НИУ ВШЭ; Taiga Architects: НИУ ВШЭ; Better: НИУ ВШЭ
НИУ ВШЭ 
<Вывод>: nan 
<Example 6>: 
<Тип теста 6>: closed 
<Ввод>: Artbureau 1/1: НИУ ВШЭ, КФУ, РГГУ; IA Buro: МФТИ, РГУ, МГСУ; Objct: МИФИ, МГПУ, МГСУ, РГУ
РГУ 
<Вывод>: Artbureau 1/1 
<Решение студента>: data = input().split('; ')
university = input()

result = []
for studio in data:
    st, univ = studio.split(': ')
    univ = univ.split(', ')
    if university not in univ:
        result.add(st)

print(*sorted(result, reverse = True), sep = '/ ') 
<Идеальное решение>: data = input().split('; ')
university = input()

result = []
for studio in data:
    st, univ = studio.split(': ')
    univ = univ.split(', ')
    if university not in univ:
        result.append(st)

print(*sorted(result, reverse = True), sep = '/ ') 


<Комментарий эксперта>:"
118,340,21,"Андрей хочет пойти работать в одну из студий дизайна интерьеров и смотрит, выпускников каких вузов они хотели бы у себя видеть. Напишите программу, которая поможет Андрею определить студии, куда его не могут взять на работу. 

ФОРМАТ ВВОДА
На первой строке через точку с запятой и пробел вводится информация о компании и вузах '<название студии дизайна>: <названия вузов через запятую и пробел>'. Гарантируется, что строка содержит информацию минимум об одной компании. 
На второй строке вводится название вуза, в котором обучается Андрей. 
ФОРМАТ ВЫВОДА
Названия студий дизайна, куда Андрея не могут взять на работу.
Названия должны выводиться через прямой слэш и пробел (""/ "") в обратном алфавитном порядке.
Если таких студий нет, программа ничего не выводит.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Считайте в переменную строку со студиями и вузами, сразу разделите по разделителю и получите список.
Считайте в переменную название вуза.
Создайте пустой список, в который будете добавлять название студии, если она готова пригласить Андрея на стажировку.
Обратитесь к каждому элементу из списка, созданного в п.1:
разбейте его (строку) по разделителю и сохраните название студии в одну переменную, а названия вузов — в другую переменную;
если вуза Андрея (переменная из п.2) нет в названиях вузов, то добавьте название студии в список из п.3.
Отсортируйте получившийся список в обратном алфавитном порядке. 
Напечатайте элементы списка через прямой слэш и пробел.","['Greenfield: МГУ, ВШЭ, МГСУ, СПбГУ; VDT: ВШЭ, РГГУ, Бауманка; A29: МИФИ, МФТИ, МГСУ, РАНХиГС; DA Bureau: РАНХиГС, ВШЭ, МГУ\nВШЭ', 'Sinitsa Buro: МГСУ, ВШЭ, МГИМО\nМГСУ', 'Lepo bureau: СПбГУ\nМГУ', 'Greenfield: МГСУ; Da-sein: МГСУ; Suite n.7: МГСУ\nВШЭ', 'Akke Collective: НИУ ВШЭ; Taiga Architects: НИУ ВШЭ; Better: НИУ ВШЭ\nНИУ ВШЭ', 'Artbureau 1/1: НИУ ВШЭ, КФУ, РГГУ; IA Buro: МФТИ, РГУ, МГСУ; Objct: МИФИ, МГПУ, МГСУ, РГУ\nРГУ']","['A29', nan, 'Lepo burea', 'Suite n.7/ Greenfield/ Da-sein', nan, 'Artbureau 1/1']","data = input().split('; ')
university = input()

result = []
for studio in data:
    st, univ = studio.split(': ')
    univ = univ.split(', ')
    if university not in univ:
        result.append(st)

print(result)","data = input().split('; ')
university = input()

result = []
for studio in data:
    st, univ = studio.split(': ')
    univ = univ.split(', ')
    if university not in univ:
        result.append(st)

print(*sorted(result, reverse = True), sep = '/ ')","Ошибка в открытых и скрытых тестах. 

Ваш код некорректно выполняет условия задания. Так, он некорректно выполянет условие ""названия должны выводиться через прямой слэш и пробел (""/ "") в обратном алфавитном порядке"". Попробуйте изменить условие if для исправления ошибки.","['open', 'open', 'open', 'closed', 'closed', 'closed']","<Task description>: Андрей хочет пойти работать в одну из студий дизайна интерьеров и смотрит, выпускников каких вузов они хотели бы у себя видеть. Напишите программу, которая поможет Андрею определить студии, куда его не могут взять на работу. 

ФОРМАТ ВВОДА
На первой строке через точку с запятой и пробел вводится информация о компании и вузах '<название студии дизайна>: <названия вузов через запятую и пробел>'. Гарантируется, что строка содержит информацию минимум об одной компании. 
На второй строке вводится название вуза, в котором обучается Андрей. 
ФОРМАТ ВЫВОДА
Названия студий дизайна, куда Андрея не могут взять на работу.
Названия должны выводиться через прямой слэш и пробел (""/ "") в обратном алфавитном порядке.
Если таких студий нет, программа ничего не выводит.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Считайте в переменную строку со студиями и вузами, сразу разделите по разделителю и получите список.
Считайте в переменную название вуза.
Создайте пустой список, в который будете добавлять название студии, если она готова пригласить Андрея на стажировку.
Обратитесь к каждому элементу из списка, созданного в п.1:
разбейте его (строку) по разделителю и сохраните название студии в одну переменную, а названия вузов — в другую переменную;
если вуза Андрея (переменная из п.2) нет в названиях вузов, то добавьте название студии в список из п.3.
Отсортируйте получившийся список в обратном алфавитном порядке. 
Напечатайте элементы списка через прямой слэш и пробел. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: Greenfield: МГУ, ВШЭ, МГСУ, СПбГУ; VDT: ВШЭ, РГГУ, Бауманка; A29: МИФИ, МФТИ, МГСУ, РАНХиГС; DA Bureau: РАНХиГС, ВШЭ, МГУ
ВШЭ 
<Вывод>: A29 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: Sinitsa Buro: МГСУ, ВШЭ, МГИМО
МГСУ 
<Вывод>: nan 
<Example 3>: 
<Тип теста 3>: open 
<Ввод>: Lepo bureau: СПбГУ
МГУ 
<Вывод>: Lepo burea 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: Greenfield: МГСУ; Da-sein: МГСУ; Suite n.7: МГСУ
ВШЭ 
<Вывод>: Suite n.7/ Greenfield/ Da-sein 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: Akke Collective: НИУ ВШЭ; Taiga Architects: НИУ ВШЭ; Better: НИУ ВШЭ
НИУ ВШЭ 
<Вывод>: nan 
<Example 6>: 
<Тип теста 6>: closed 
<Ввод>: Artbureau 1/1: НИУ ВШЭ, КФУ, РГГУ; IA Buro: МФТИ, РГУ, МГСУ; Objct: МИФИ, МГПУ, МГСУ, РГУ
РГУ 
<Вывод>: Artbureau 1/1 
<Решение студента>: data = input().split('; ')
university = input()

result = []
for studio in data:
    st, univ = studio.split(': ')
    univ = univ.split(', ')
    if university not in univ:
        result.append(st)

print(result) 
<Идеальное решение>: data = input().split('; ')
university = input()

result = []
for studio in data:
    st, univ = studio.split(': ')
    univ = univ.split(', ')
    if university not in univ:
        result.append(st)

print(*sorted(result, reverse = True), sep = '/ ') 


<Комментарий эксперта>:"
119,341,21,"Андрей хочет пойти работать в одну из студий дизайна интерьеров и смотрит, выпускников каких вузов они хотели бы у себя видеть. Напишите программу, которая поможет Андрею определить студии, куда его не могут взять на работу. 

ФОРМАТ ВВОДА
На первой строке через точку с запятой и пробел вводится информация о компании и вузах '<название студии дизайна>: <названия вузов через запятую и пробел>'. Гарантируется, что строка содержит информацию минимум об одной компании. 
На второй строке вводится название вуза, в котором обучается Андрей. 
ФОРМАТ ВЫВОДА
Названия студий дизайна, куда Андрея не могут взять на работу.
Названия должны выводиться через прямой слэш и пробел (""/ "") в обратном алфавитном порядке.
Если таких студий нет, программа ничего не выводит.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Считайте в переменную строку со студиями и вузами, сразу разделите по разделителю и получите список.
Считайте в переменную название вуза.
Создайте пустой список, в который будете добавлять название студии, если она готова пригласить Андрея на стажировку.
Обратитесь к каждому элементу из списка, созданного в п.1:
разбейте его (строку) по разделителю и сохраните название студии в одну переменную, а названия вузов — в другую переменную;
если вуза Андрея (переменная из п.2) нет в названиях вузов, то добавьте название студии в список из п.3.
Отсортируйте получившийся список в обратном алфавитном порядке. 
Напечатайте элементы списка через прямой слэш и пробел.","['Greenfield: МГУ, ВШЭ, МГСУ, СПбГУ; VDT: ВШЭ, РГГУ, Бауманка; A29: МИФИ, МФТИ, МГСУ, РАНХиГС; DA Bureau: РАНХиГС, ВШЭ, МГУ\nВШЭ', 'Sinitsa Buro: МГСУ, ВШЭ, МГИМО\nМГСУ', 'Lepo bureau: СПбГУ\nМГУ', 'Greenfield: МГСУ; Da-sein: МГСУ; Suite n.7: МГСУ\nВШЭ', 'Akke Collective: НИУ ВШЭ; Taiga Architects: НИУ ВШЭ; Better: НИУ ВШЭ\nНИУ ВШЭ', 'Artbureau 1/1: НИУ ВШЭ, КФУ, РГГУ; IA Buro: МФТИ, РГУ, МГСУ; Objct: МИФИ, МГПУ, МГСУ, РГУ\nРГУ']","['A29', nan, 'Lepo burea', 'Suite n.7/ Greenfield/ Da-sein', nan, 'Artbureau 1/1']","data = input().split('; ')
university = input()

result = []
for studio in data:
    st, univ = studio.split(': ')
    univ = univ.split(', ')
    if university not in univ:
        result.append(st)

print(*sorted(result)","data = input().split('; ')
university = input()

result = []
for studio in data:
    st, univ = studio.split(': ')
    univ = univ.split(', ')
    if university not in univ:
        result.append(st)

print(*sorted(result, reverse = True), sep = '/ ')","Ошибка в открытых и скрытых тестах. 

Ваш код некорректно выполняет условия задания. Так, он некорректно выполянет условие ""названия должны выводиться через прямой слэш и пробел (""/ "") в обратном алфавитном порядке"". Попробуйте изменить условие if для исправления ошибки.","['open', 'open', 'open', 'closed', 'closed', 'closed']","<Task description>: Андрей хочет пойти работать в одну из студий дизайна интерьеров и смотрит, выпускников каких вузов они хотели бы у себя видеть. Напишите программу, которая поможет Андрею определить студии, куда его не могут взять на работу. 

ФОРМАТ ВВОДА
На первой строке через точку с запятой и пробел вводится информация о компании и вузах '<название студии дизайна>: <названия вузов через запятую и пробел>'. Гарантируется, что строка содержит информацию минимум об одной компании. 
На второй строке вводится название вуза, в котором обучается Андрей. 
ФОРМАТ ВЫВОДА
Названия студий дизайна, куда Андрея не могут взять на работу.
Названия должны выводиться через прямой слэш и пробел (""/ "") в обратном алфавитном порядке.
Если таких студий нет, программа ничего не выводит.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Считайте в переменную строку со студиями и вузами, сразу разделите по разделителю и получите список.
Считайте в переменную название вуза.
Создайте пустой список, в который будете добавлять название студии, если она готова пригласить Андрея на стажировку.
Обратитесь к каждому элементу из списка, созданного в п.1:
разбейте его (строку) по разделителю и сохраните название студии в одну переменную, а названия вузов — в другую переменную;
если вуза Андрея (переменная из п.2) нет в названиях вузов, то добавьте название студии в список из п.3.
Отсортируйте получившийся список в обратном алфавитном порядке. 
Напечатайте элементы списка через прямой слэш и пробел. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: Greenfield: МГУ, ВШЭ, МГСУ, СПбГУ; VDT: ВШЭ, РГГУ, Бауманка; A29: МИФИ, МФТИ, МГСУ, РАНХиГС; DA Bureau: РАНХиГС, ВШЭ, МГУ
ВШЭ 
<Вывод>: A29 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: Sinitsa Buro: МГСУ, ВШЭ, МГИМО
МГСУ 
<Вывод>: nan 
<Example 3>: 
<Тип теста 3>: open 
<Ввод>: Lepo bureau: СПбГУ
МГУ 
<Вывод>: Lepo burea 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: Greenfield: МГСУ; Da-sein: МГСУ; Suite n.7: МГСУ
ВШЭ 
<Вывод>: Suite n.7/ Greenfield/ Da-sein 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: Akke Collective: НИУ ВШЭ; Taiga Architects: НИУ ВШЭ; Better: НИУ ВШЭ
НИУ ВШЭ 
<Вывод>: nan 
<Example 6>: 
<Тип теста 6>: closed 
<Ввод>: Artbureau 1/1: НИУ ВШЭ, КФУ, РГГУ; IA Buro: МФТИ, РГУ, МГСУ; Objct: МИФИ, МГПУ, МГСУ, РГУ
РГУ 
<Вывод>: Artbureau 1/1 
<Решение студента>: data = input().split('; ')
university = input()

result = []
for studio in data:
    st, univ = studio.split(': ')
    univ = univ.split(', ')
    if university not in univ:
        result.append(st)

print(*sorted(result) 
<Идеальное решение>: data = input().split('; ')
university = input()

result = []
for studio in data:
    st, univ = studio.split(': ')
    univ = univ.split(', ')
    if university not in univ:
        result.append(st)

print(*sorted(result, reverse = True), sep = '/ ') 


<Комментарий эксперта>:"
120,342,21,"Андрей хочет пойти работать в одну из студий дизайна интерьеров и смотрит, выпускников каких вузов они хотели бы у себя видеть. Напишите программу, которая поможет Андрею определить студии, куда его не могут взять на работу. 

ФОРМАТ ВВОДА
На первой строке через точку с запятой и пробел вводится информация о компании и вузах '<название студии дизайна>: <названия вузов через запятую и пробел>'. Гарантируется, что строка содержит информацию минимум об одной компании. 
На второй строке вводится название вуза, в котором обучается Андрей. 
ФОРМАТ ВЫВОДА
Названия студий дизайна, куда Андрея не могут взять на работу.
Названия должны выводиться через прямой слэш и пробел (""/ "") в обратном алфавитном порядке.
Если таких студий нет, программа ничего не выводит.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Считайте в переменную строку со студиями и вузами, сразу разделите по разделителю и получите список.
Считайте в переменную название вуза.
Создайте пустой список, в который будете добавлять название студии, если она готова пригласить Андрея на стажировку.
Обратитесь к каждому элементу из списка, созданного в п.1:
разбейте его (строку) по разделителю и сохраните название студии в одну переменную, а названия вузов — в другую переменную;
если вуза Андрея (переменная из п.2) нет в названиях вузов, то добавьте название студии в список из п.3.
Отсортируйте получившийся список в обратном алфавитном порядке. 
Напечатайте элементы списка через прямой слэш и пробел.","['Greenfield: МГУ, ВШЭ, МГСУ, СПбГУ; VDT: ВШЭ, РГГУ, Бауманка; A29: МИФИ, МФТИ, МГСУ, РАНХиГС; DA Bureau: РАНХиГС, ВШЭ, МГУ\nВШЭ', 'Sinitsa Buro: МГСУ, ВШЭ, МГИМО\nМГСУ', 'Lepo bureau: СПбГУ\nМГУ', 'Greenfield: МГСУ; Da-sein: МГСУ; Suite n.7: МГСУ\nВШЭ', 'Akke Collective: НИУ ВШЭ; Taiga Architects: НИУ ВШЭ; Better: НИУ ВШЭ\nНИУ ВШЭ', 'Artbureau 1/1: НИУ ВШЭ, КФУ, РГГУ; IA Buro: МФТИ, РГУ, МГСУ; Objct: МИФИ, МГПУ, МГСУ, РГУ\nРГУ']","['A29', nan, 'Lepo burea', 'Suite n.7/ Greenfield/ Da-sein', nan, 'Artbureau 1/1']","data = input().split('; ')
university = input()

result = []
for studio in data:
    st, univ = studio.split(': ')
    univ = univ.split(', ')
    if university not in univ:
        result.append(st)

print(*sorted(result), sep = '/ ')","data = input().split('; ')
university = input()

result = []
for studio in data:
    st, univ = studio.split(': ')
    univ = univ.split(', ')
    if university not in univ:
        result.append(st)

print(*sorted(result, reverse = True), sep = '/ ')","Ошибка в открытых и скрытых тестах. 

Ваш код некорректно выполняет условия задания. Так, он некорректно выполянет условие ""названия должны выводиться через прямой слэш и пробел (""/ "") в обратном алфавитном порядке"". Попробуйте изменить условие if для исправления ошибки.","['open', 'open', 'open', 'closed', 'closed', 'closed']","<Task description>: Андрей хочет пойти работать в одну из студий дизайна интерьеров и смотрит, выпускников каких вузов они хотели бы у себя видеть. Напишите программу, которая поможет Андрею определить студии, куда его не могут взять на работу. 

ФОРМАТ ВВОДА
На первой строке через точку с запятой и пробел вводится информация о компании и вузах '<название студии дизайна>: <названия вузов через запятую и пробел>'. Гарантируется, что строка содержит информацию минимум об одной компании. 
На второй строке вводится название вуза, в котором обучается Андрей. 
ФОРМАТ ВЫВОДА
Названия студий дизайна, куда Андрея не могут взять на работу.
Названия должны выводиться через прямой слэш и пробел (""/ "") в обратном алфавитном порядке.
Если таких студий нет, программа ничего не выводит.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Считайте в переменную строку со студиями и вузами, сразу разделите по разделителю и получите список.
Считайте в переменную название вуза.
Создайте пустой список, в который будете добавлять название студии, если она готова пригласить Андрея на стажировку.
Обратитесь к каждому элементу из списка, созданного в п.1:
разбейте его (строку) по разделителю и сохраните название студии в одну переменную, а названия вузов — в другую переменную;
если вуза Андрея (переменная из п.2) нет в названиях вузов, то добавьте название студии в список из п.3.
Отсортируйте получившийся список в обратном алфавитном порядке. 
Напечатайте элементы списка через прямой слэш и пробел. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: Greenfield: МГУ, ВШЭ, МГСУ, СПбГУ; VDT: ВШЭ, РГГУ, Бауманка; A29: МИФИ, МФТИ, МГСУ, РАНХиГС; DA Bureau: РАНХиГС, ВШЭ, МГУ
ВШЭ 
<Вывод>: A29 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: Sinitsa Buro: МГСУ, ВШЭ, МГИМО
МГСУ 
<Вывод>: nan 
<Example 3>: 
<Тип теста 3>: open 
<Ввод>: Lepo bureau: СПбГУ
МГУ 
<Вывод>: Lepo burea 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: Greenfield: МГСУ; Da-sein: МГСУ; Suite n.7: МГСУ
ВШЭ 
<Вывод>: Suite n.7/ Greenfield/ Da-sein 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: Akke Collective: НИУ ВШЭ; Taiga Architects: НИУ ВШЭ; Better: НИУ ВШЭ
НИУ ВШЭ 
<Вывод>: nan 
<Example 6>: 
<Тип теста 6>: closed 
<Ввод>: Artbureau 1/1: НИУ ВШЭ, КФУ, РГГУ; IA Buro: МФТИ, РГУ, МГСУ; Objct: МИФИ, МГПУ, МГСУ, РГУ
РГУ 
<Вывод>: Artbureau 1/1 
<Решение студента>: data = input().split('; ')
university = input()

result = []
for studio in data:
    st, univ = studio.split(': ')
    univ = univ.split(', ')
    if university not in univ:
        result.append(st)

print(*sorted(result), sep = '/ ') 
<Идеальное решение>: data = input().split('; ')
university = input()

result = []
for studio in data:
    st, univ = studio.split(': ')
    univ = univ.split(', ')
    if university not in univ:
        result.append(st)

print(*sorted(result, reverse = True), sep = '/ ') 


<Комментарий эксперта>:"
121,343,21,"Андрей хочет пойти работать в одну из студий дизайна интерьеров и смотрит, выпускников каких вузов они хотели бы у себя видеть. Напишите программу, которая поможет Андрею определить студии, куда его не могут взять на работу. 

ФОРМАТ ВВОДА
На первой строке через точку с запятой и пробел вводится информация о компании и вузах '<название студии дизайна>: <названия вузов через запятую и пробел>'. Гарантируется, что строка содержит информацию минимум об одной компании. 
На второй строке вводится название вуза, в котором обучается Андрей. 
ФОРМАТ ВЫВОДА
Названия студий дизайна, куда Андрея не могут взять на работу.
Названия должны выводиться через прямой слэш и пробел (""/ "") в обратном алфавитном порядке.
Если таких студий нет, программа ничего не выводит.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Считайте в переменную строку со студиями и вузами, сразу разделите по разделителю и получите список.
Считайте в переменную название вуза.
Создайте пустой список, в который будете добавлять название студии, если она готова пригласить Андрея на стажировку.
Обратитесь к каждому элементу из списка, созданного в п.1:
разбейте его (строку) по разделителю и сохраните название студии в одну переменную, а названия вузов — в другую переменную;
если вуза Андрея (переменная из п.2) нет в названиях вузов, то добавьте название студии в список из п.3.
Отсортируйте получившийся список в обратном алфавитном порядке. 
Напечатайте элементы списка через прямой слэш и пробел.","['Greenfield: МГУ, ВШЭ, МГСУ, СПбГУ; VDT: ВШЭ, РГГУ, Бауманка; A29: МИФИ, МФТИ, МГСУ, РАНХиГС; DA Bureau: РАНХиГС, ВШЭ, МГУ\nВШЭ', 'Sinitsa Buro: МГСУ, ВШЭ, МГИМО\nМГСУ', 'Lepo bureau: СПбГУ\nМГУ', 'Greenfield: МГСУ; Da-sein: МГСУ; Suite n.7: МГСУ\nВШЭ', 'Akke Collective: НИУ ВШЭ; Taiga Architects: НИУ ВШЭ; Better: НИУ ВШЭ\nНИУ ВШЭ', 'Artbureau 1/1: НИУ ВШЭ, КФУ, РГГУ; IA Buro: МФТИ, РГУ, МГСУ; Objct: МИФИ, МГПУ, МГСУ, РГУ\nРГУ']","['A29', nan, 'Lepo burea', 'Suite n.7/ Greenfield/ Da-sein', nan, 'Artbureau 1/1']","data = input().split('; ')
university = input()

result = []
for studio in data:
    st, univ = studio.split(': ')
    univ = univ.split(', ')
    if university not in univ:
        result.append(st)

print(*sorted(result, reverse = True))","data = input().split('; ')
university = input()

result = []
for studio in data:
    st, univ = studio.split(': ')
    univ = univ.split(', ')
    if university not in univ:
        result.append(st)

print(*sorted(result, reverse = True), sep = '/ ')","Ошибка в открытых и скрытых тестах. 

Ваш код некорректно выполняет условия задания. Так, он некорректно выполянет условие ""названия должны выводиться через прямой слэш и пробел (""/ "") в обратном алфавитном порядке"". Попробуйте изменить условие if для исправления ошибки.","['open', 'open', 'open', 'closed', 'closed', 'closed']","<Task description>: Андрей хочет пойти работать в одну из студий дизайна интерьеров и смотрит, выпускников каких вузов они хотели бы у себя видеть. Напишите программу, которая поможет Андрею определить студии, куда его не могут взять на работу. 

ФОРМАТ ВВОДА
На первой строке через точку с запятой и пробел вводится информация о компании и вузах '<название студии дизайна>: <названия вузов через запятую и пробел>'. Гарантируется, что строка содержит информацию минимум об одной компании. 
На второй строке вводится название вуза, в котором обучается Андрей. 
ФОРМАТ ВЫВОДА
Названия студий дизайна, куда Андрея не могут взять на работу.
Названия должны выводиться через прямой слэш и пробел (""/ "") в обратном алфавитном порядке.
Если таких студий нет, программа ничего не выводит.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Считайте в переменную строку со студиями и вузами, сразу разделите по разделителю и получите список.
Считайте в переменную название вуза.
Создайте пустой список, в который будете добавлять название студии, если она готова пригласить Андрея на стажировку.
Обратитесь к каждому элементу из списка, созданного в п.1:
разбейте его (строку) по разделителю и сохраните название студии в одну переменную, а названия вузов — в другую переменную;
если вуза Андрея (переменная из п.2) нет в названиях вузов, то добавьте название студии в список из п.3.
Отсортируйте получившийся список в обратном алфавитном порядке. 
Напечатайте элементы списка через прямой слэш и пробел. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: Greenfield: МГУ, ВШЭ, МГСУ, СПбГУ; VDT: ВШЭ, РГГУ, Бауманка; A29: МИФИ, МФТИ, МГСУ, РАНХиГС; DA Bureau: РАНХиГС, ВШЭ, МГУ
ВШЭ 
<Вывод>: A29 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: Sinitsa Buro: МГСУ, ВШЭ, МГИМО
МГСУ 
<Вывод>: nan 
<Example 3>: 
<Тип теста 3>: open 
<Ввод>: Lepo bureau: СПбГУ
МГУ 
<Вывод>: Lepo burea 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: Greenfield: МГСУ; Da-sein: МГСУ; Suite n.7: МГСУ
ВШЭ 
<Вывод>: Suite n.7/ Greenfield/ Da-sein 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: Akke Collective: НИУ ВШЭ; Taiga Architects: НИУ ВШЭ; Better: НИУ ВШЭ
НИУ ВШЭ 
<Вывод>: nan 
<Example 6>: 
<Тип теста 6>: closed 
<Ввод>: Artbureau 1/1: НИУ ВШЭ, КФУ, РГГУ; IA Buro: МФТИ, РГУ, МГСУ; Objct: МИФИ, МГПУ, МГСУ, РГУ
РГУ 
<Вывод>: Artbureau 1/1 
<Решение студента>: data = input().split('; ')
university = input()

result = []
for studio in data:
    st, univ = studio.split(': ')
    univ = univ.split(', ')
    if university not in univ:
        result.append(st)

print(*sorted(result, reverse = True)) 
<Идеальное решение>: data = input().split('; ')
university = input()

result = []
for studio in data:
    st, univ = studio.split(': ')
    univ = univ.split(', ')
    if university not in univ:
        result.append(st)

print(*sorted(result, reverse = True), sep = '/ ') 


<Комментарий эксперта>:"
122,344,21,"Андрей хочет пойти работать в одну из студий дизайна интерьеров и смотрит, выпускников каких вузов они хотели бы у себя видеть. Напишите программу, которая поможет Андрею определить студии, куда его не могут взять на работу. 

ФОРМАТ ВВОДА
На первой строке через точку с запятой и пробел вводится информация о компании и вузах '<название студии дизайна>: <названия вузов через запятую и пробел>'. Гарантируется, что строка содержит информацию минимум об одной компании. 
На второй строке вводится название вуза, в котором обучается Андрей. 
ФОРМАТ ВЫВОДА
Названия студий дизайна, куда Андрея не могут взять на работу.
Названия должны выводиться через прямой слэш и пробел (""/ "") в обратном алфавитном порядке.
Если таких студий нет, программа ничего не выводит.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Считайте в переменную строку со студиями и вузами, сразу разделите по разделителю и получите список.
Считайте в переменную название вуза.
Создайте пустой список, в который будете добавлять название студии, если она готова пригласить Андрея на стажировку.
Обратитесь к каждому элементу из списка, созданного в п.1:
разбейте его (строку) по разделителю и сохраните название студии в одну переменную, а названия вузов — в другую переменную;
если вуза Андрея (переменная из п.2) нет в названиях вузов, то добавьте название студии в список из п.3.
Отсортируйте получившийся список в обратном алфавитном порядке. 
Напечатайте элементы списка через прямой слэш и пробел.","['Greenfield: МГУ, ВШЭ, МГСУ, СПбГУ; VDT: ВШЭ, РГГУ, Бауманка; A29: МИФИ, МФТИ, МГСУ, РАНХиГС; DA Bureau: РАНХиГС, ВШЭ, МГУ\nВШЭ', 'Sinitsa Buro: МГСУ, ВШЭ, МГИМО\nМГСУ', 'Lepo bureau: СПбГУ\nМГУ', 'Greenfield: МГСУ; Da-sein: МГСУ; Suite n.7: МГСУ\nВШЭ', 'Akke Collective: НИУ ВШЭ; Taiga Architects: НИУ ВШЭ; Better: НИУ ВШЭ\nНИУ ВШЭ', 'Artbureau 1/1: НИУ ВШЭ, КФУ, РГГУ; IA Buro: МФТИ, РГУ, МГСУ; Objct: МИФИ, МГПУ, МГСУ, РГУ\nРГУ']","['A29', nan, 'Lepo burea', 'Suite n.7/ Greenfield/ Da-sein', nan, 'Artbureau 1/1']","data = input().split('; ')
university = input()

result = []
for studio in data:
    st, univ = studio.split(': ')
    univ = univ.split(', ')
    if university not in univ:
        result.append(st)

    print(*sorted(result, reverse = True), sep = '/ ')","data = input().split('; ')
university = input()

result = []
for studio in data:
    st, univ = studio.split(': ')
    univ = univ.split(', ')
    if university not in univ:
        result.append(st)

print(*sorted(result, reverse = True), sep = '/ ')",Ошибка в табуляции функции print().,"['open', 'open', 'open', 'closed', 'closed', 'closed']","<Task description>: Андрей хочет пойти работать в одну из студий дизайна интерьеров и смотрит, выпускников каких вузов они хотели бы у себя видеть. Напишите программу, которая поможет Андрею определить студии, куда его не могут взять на работу. 

ФОРМАТ ВВОДА
На первой строке через точку с запятой и пробел вводится информация о компании и вузах '<название студии дизайна>: <названия вузов через запятую и пробел>'. Гарантируется, что строка содержит информацию минимум об одной компании. 
На второй строке вводится название вуза, в котором обучается Андрей. 
ФОРМАТ ВЫВОДА
Названия студий дизайна, куда Андрея не могут взять на работу.
Названия должны выводиться через прямой слэш и пробел (""/ "") в обратном алфавитном порядке.
Если таких студий нет, программа ничего не выводит.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Считайте в переменную строку со студиями и вузами, сразу разделите по разделителю и получите список.
Считайте в переменную название вуза.
Создайте пустой список, в который будете добавлять название студии, если она готова пригласить Андрея на стажировку.
Обратитесь к каждому элементу из списка, созданного в п.1:
разбейте его (строку) по разделителю и сохраните название студии в одну переменную, а названия вузов — в другую переменную;
если вуза Андрея (переменная из п.2) нет в названиях вузов, то добавьте название студии в список из п.3.
Отсортируйте получившийся список в обратном алфавитном порядке. 
Напечатайте элементы списка через прямой слэш и пробел. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: Greenfield: МГУ, ВШЭ, МГСУ, СПбГУ; VDT: ВШЭ, РГГУ, Бауманка; A29: МИФИ, МФТИ, МГСУ, РАНХиГС; DA Bureau: РАНХиГС, ВШЭ, МГУ
ВШЭ 
<Вывод>: A29 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: Sinitsa Buro: МГСУ, ВШЭ, МГИМО
МГСУ 
<Вывод>: nan 
<Example 3>: 
<Тип теста 3>: open 
<Ввод>: Lepo bureau: СПбГУ
МГУ 
<Вывод>: Lepo burea 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: Greenfield: МГСУ; Da-sein: МГСУ; Suite n.7: МГСУ
ВШЭ 
<Вывод>: Suite n.7/ Greenfield/ Da-sein 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: Akke Collective: НИУ ВШЭ; Taiga Architects: НИУ ВШЭ; Better: НИУ ВШЭ
НИУ ВШЭ 
<Вывод>: nan 
<Example 6>: 
<Тип теста 6>: closed 
<Ввод>: Artbureau 1/1: НИУ ВШЭ, КФУ, РГГУ; IA Buro: МФТИ, РГУ, МГСУ; Objct: МИФИ, МГПУ, МГСУ, РГУ
РГУ 
<Вывод>: Artbureau 1/1 
<Решение студента>: data = input().split('; ')
university = input()

result = []
for studio in data:
    st, univ = studio.split(': ')
    univ = univ.split(', ')
    if university not in univ:
        result.append(st)

    print(*sorted(result, reverse = True), sep = '/ ') 
<Идеальное решение>: data = input().split('; ')
university = input()

result = []
for studio in data:
    st, univ = studio.split(': ')
    univ = univ.split(', ')
    if university not in univ:
        result.append(st)

print(*sorted(result, reverse = True), sep = '/ ') 


<Комментарий эксперта>:"
123,345,21,"Андрей хочет пойти работать в одну из студий дизайна интерьеров и смотрит, выпускников каких вузов они хотели бы у себя видеть. Напишите программу, которая поможет Андрею определить студии, куда его не могут взять на работу. 

ФОРМАТ ВВОДА
На первой строке через точку с запятой и пробел вводится информация о компании и вузах '<название студии дизайна>: <названия вузов через запятую и пробел>'. Гарантируется, что строка содержит информацию минимум об одной компании. 
На второй строке вводится название вуза, в котором обучается Андрей. 
ФОРМАТ ВЫВОДА
Названия студий дизайна, куда Андрея не могут взять на работу.
Названия должны выводиться через прямой слэш и пробел (""/ "") в обратном алфавитном порядке.
Если таких студий нет, программа ничего не выводит.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Считайте в переменную строку со студиями и вузами, сразу разделите по разделителю и получите список.
Считайте в переменную название вуза.
Создайте пустой список, в который будете добавлять название студии, если она готова пригласить Андрея на стажировку.
Обратитесь к каждому элементу из списка, созданного в п.1:
разбейте его (строку) по разделителю и сохраните название студии в одну переменную, а названия вузов — в другую переменную;
если вуза Андрея (переменная из п.2) нет в названиях вузов, то добавьте название студии в список из п.3.
Отсортируйте получившийся список в обратном алфавитном порядке. 
Напечатайте элементы списка через прямой слэш и пробел.","['Greenfield: МГУ, ВШЭ, МГСУ, СПбГУ; VDT: ВШЭ, РГГУ, Бауманка; A29: МИФИ, МФТИ, МГСУ, РАНХиГС; DA Bureau: РАНХиГС, ВШЭ, МГУ\nВШЭ', 'Sinitsa Buro: МГСУ, ВШЭ, МГИМО\nМГСУ', 'Lepo bureau: СПбГУ\nМГУ', 'Greenfield: МГСУ; Da-sein: МГСУ; Suite n.7: МГСУ\nВШЭ', 'Akke Collective: НИУ ВШЭ; Taiga Architects: НИУ ВШЭ; Better: НИУ ВШЭ\nНИУ ВШЭ', 'Artbureau 1/1: НИУ ВШЭ, КФУ, РГГУ; IA Buro: МФТИ, РГУ, МГСУ; Objct: МИФИ, МГПУ, МГСУ, РГУ\nРГУ']","['A29', nan, 'Lepo burea', 'Suite n.7/ Greenfield/ Da-sein', nan, 'Artbureau 1/1']","data = input().split('; ')
university = input()

result = []
for studio in data
    st, univ = studio.split(': ')
    univ = univ.split(', ')
    if university not in univ:
        result.append(st)

print(*sorted(result, reverse = True), sep = '/ ')","data = input().split('; ')
university = input()

result = []
for studio in data:
    st, univ = studio.split(': ')
    univ = univ.split(', ')
    if university not in univ:
        result.append(st)

print(*sorted(result, reverse = True), sep = '/ ')",Вы забыли поставить двоеточие после цикла for.,"['open', 'open', 'open', 'closed', 'closed', 'closed']","<Task description>: Андрей хочет пойти работать в одну из студий дизайна интерьеров и смотрит, выпускников каких вузов они хотели бы у себя видеть. Напишите программу, которая поможет Андрею определить студии, куда его не могут взять на работу. 

ФОРМАТ ВВОДА
На первой строке через точку с запятой и пробел вводится информация о компании и вузах '<название студии дизайна>: <названия вузов через запятую и пробел>'. Гарантируется, что строка содержит информацию минимум об одной компании. 
На второй строке вводится название вуза, в котором обучается Андрей. 
ФОРМАТ ВЫВОДА
Названия студий дизайна, куда Андрея не могут взять на работу.
Названия должны выводиться через прямой слэш и пробел (""/ "") в обратном алфавитном порядке.
Если таких студий нет, программа ничего не выводит.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Считайте в переменную строку со студиями и вузами, сразу разделите по разделителю и получите список.
Считайте в переменную название вуза.
Создайте пустой список, в который будете добавлять название студии, если она готова пригласить Андрея на стажировку.
Обратитесь к каждому элементу из списка, созданного в п.1:
разбейте его (строку) по разделителю и сохраните название студии в одну переменную, а названия вузов — в другую переменную;
если вуза Андрея (переменная из п.2) нет в названиях вузов, то добавьте название студии в список из п.3.
Отсортируйте получившийся список в обратном алфавитном порядке. 
Напечатайте элементы списка через прямой слэш и пробел. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: Greenfield: МГУ, ВШЭ, МГСУ, СПбГУ; VDT: ВШЭ, РГГУ, Бауманка; A29: МИФИ, МФТИ, МГСУ, РАНХиГС; DA Bureau: РАНХиГС, ВШЭ, МГУ
ВШЭ 
<Вывод>: A29 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: Sinitsa Buro: МГСУ, ВШЭ, МГИМО
МГСУ 
<Вывод>: nan 
<Example 3>: 
<Тип теста 3>: open 
<Ввод>: Lepo bureau: СПбГУ
МГУ 
<Вывод>: Lepo burea 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: Greenfield: МГСУ; Da-sein: МГСУ; Suite n.7: МГСУ
ВШЭ 
<Вывод>: Suite n.7/ Greenfield/ Da-sein 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: Akke Collective: НИУ ВШЭ; Taiga Architects: НИУ ВШЭ; Better: НИУ ВШЭ
НИУ ВШЭ 
<Вывод>: nan 
<Example 6>: 
<Тип теста 6>: closed 
<Ввод>: Artbureau 1/1: НИУ ВШЭ, КФУ, РГГУ; IA Buro: МФТИ, РГУ, МГСУ; Objct: МИФИ, МГПУ, МГСУ, РГУ
РГУ 
<Вывод>: Artbureau 1/1 
<Решение студента>: data = input().split('; ')
university = input()

result = []
for studio in data
    st, univ = studio.split(': ')
    univ = univ.split(', ')
    if university not in univ:
        result.append(st)

print(*sorted(result, reverse = True), sep = '/ ') 
<Идеальное решение>: data = input().split('; ')
university = input()

result = []
for studio in data:
    st, univ = studio.split(': ')
    univ = univ.split(', ')
    if university not in univ:
        result.append(st)

print(*sorted(result, reverse = True), sep = '/ ') 


<Комментарий эксперта>:"
124,346,21,"Андрей хочет пойти работать в одну из студий дизайна интерьеров и смотрит, выпускников каких вузов они хотели бы у себя видеть. Напишите программу, которая поможет Андрею определить студии, куда его не могут взять на работу. 

ФОРМАТ ВВОДА
На первой строке через точку с запятой и пробел вводится информация о компании и вузах '<название студии дизайна>: <названия вузов через запятую и пробел>'. Гарантируется, что строка содержит информацию минимум об одной компании. 
На второй строке вводится название вуза, в котором обучается Андрей. 
ФОРМАТ ВЫВОДА
Названия студий дизайна, куда Андрея не могут взять на работу.
Названия должны выводиться через прямой слэш и пробел (""/ "") в обратном алфавитном порядке.
Если таких студий нет, программа ничего не выводит.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Считайте в переменную строку со студиями и вузами, сразу разделите по разделителю и получите список.
Считайте в переменную название вуза.
Создайте пустой список, в который будете добавлять название студии, если она готова пригласить Андрея на стажировку.
Обратитесь к каждому элементу из списка, созданного в п.1:
разбейте его (строку) по разделителю и сохраните название студии в одну переменную, а названия вузов — в другую переменную;
если вуза Андрея (переменная из п.2) нет в названиях вузов, то добавьте название студии в список из п.3.
Отсортируйте получившийся список в обратном алфавитном порядке. 
Напечатайте элементы списка через прямой слэш и пробел.","['Greenfield: МГУ, ВШЭ, МГСУ, СПбГУ; VDT: ВШЭ, РГГУ, Бауманка; A29: МИФИ, МФТИ, МГСУ, РАНХиГС; DA Bureau: РАНХиГС, ВШЭ, МГУ\nВШЭ', 'Sinitsa Buro: МГСУ, ВШЭ, МГИМО\nМГСУ', 'Lepo bureau: СПбГУ\nМГУ', 'Greenfield: МГСУ; Da-sein: МГСУ; Suite n.7: МГСУ\nВШЭ', 'Akke Collective: НИУ ВШЭ; Taiga Architects: НИУ ВШЭ; Better: НИУ ВШЭ\nНИУ ВШЭ', 'Artbureau 1/1: НИУ ВШЭ, КФУ, РГГУ; IA Buro: МФТИ, РГУ, МГСУ; Objct: МИФИ, МГПУ, МГСУ, РГУ\nРГУ']","['A29', nan, 'Lepo burea', 'Suite n.7/ Greenfield/ Da-sein', nan, 'Artbureau 1/1']","data = input().split('; ')
university = input()

result = []
for studio in data:
    st, univ = studio.split(': ')
    univ = univ.split(', ')
    if university not in univ:
        result.append(univ)

print(*sorted(result, reverse = True), sep = '/ ')","data = input().split('; ')
university = input()

result = []
for studio in data:
    st, univ = studio.split(': ')
    univ = univ.split(', ')
    if university not in univ:
        result.append(st)

print(*sorted(result, reverse = True), sep = '/ ')","Ошибка в открытых и скрытых тестах. 

Ваш код некорректно выполняет условия задания. Так, он некорректно выполянет условие ""выведите названия студий дизайна, куда Андрея не могут взять на работу"". Попробуйте изменить условие if для исправления ошибки.","['open', 'open', 'open', 'closed', 'closed', 'closed']","<Task description>: Андрей хочет пойти работать в одну из студий дизайна интерьеров и смотрит, выпускников каких вузов они хотели бы у себя видеть. Напишите программу, которая поможет Андрею определить студии, куда его не могут взять на работу. 

ФОРМАТ ВВОДА
На первой строке через точку с запятой и пробел вводится информация о компании и вузах '<название студии дизайна>: <названия вузов через запятую и пробел>'. Гарантируется, что строка содержит информацию минимум об одной компании. 
На второй строке вводится название вуза, в котором обучается Андрей. 
ФОРМАТ ВЫВОДА
Названия студий дизайна, куда Андрея не могут взять на работу.
Названия должны выводиться через прямой слэш и пробел (""/ "") в обратном алфавитном порядке.
Если таких студий нет, программа ничего не выводит.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Считайте в переменную строку со студиями и вузами, сразу разделите по разделителю и получите список.
Считайте в переменную название вуза.
Создайте пустой список, в который будете добавлять название студии, если она готова пригласить Андрея на стажировку.
Обратитесь к каждому элементу из списка, созданного в п.1:
разбейте его (строку) по разделителю и сохраните название студии в одну переменную, а названия вузов — в другую переменную;
если вуза Андрея (переменная из п.2) нет в названиях вузов, то добавьте название студии в список из п.3.
Отсортируйте получившийся список в обратном алфавитном порядке. 
Напечатайте элементы списка через прямой слэш и пробел. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: Greenfield: МГУ, ВШЭ, МГСУ, СПбГУ; VDT: ВШЭ, РГГУ, Бауманка; A29: МИФИ, МФТИ, МГСУ, РАНХиГС; DA Bureau: РАНХиГС, ВШЭ, МГУ
ВШЭ 
<Вывод>: A29 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: Sinitsa Buro: МГСУ, ВШЭ, МГИМО
МГСУ 
<Вывод>: nan 
<Example 3>: 
<Тип теста 3>: open 
<Ввод>: Lepo bureau: СПбГУ
МГУ 
<Вывод>: Lepo burea 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: Greenfield: МГСУ; Da-sein: МГСУ; Suite n.7: МГСУ
ВШЭ 
<Вывод>: Suite n.7/ Greenfield/ Da-sein 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: Akke Collective: НИУ ВШЭ; Taiga Architects: НИУ ВШЭ; Better: НИУ ВШЭ
НИУ ВШЭ 
<Вывод>: nan 
<Example 6>: 
<Тип теста 6>: closed 
<Ввод>: Artbureau 1/1: НИУ ВШЭ, КФУ, РГГУ; IA Buro: МФТИ, РГУ, МГСУ; Objct: МИФИ, МГПУ, МГСУ, РГУ
РГУ 
<Вывод>: Artbureau 1/1 
<Решение студента>: data = input().split('; ')
university = input()

result = []
for studio in data:
    st, univ = studio.split(': ')
    univ = univ.split(', ')
    if university not in univ:
        result.append(univ)

print(*sorted(result, reverse = True), sep = '/ ') 
<Идеальное решение>: data = input().split('; ')
university = input()

result = []
for studio in data:
    st, univ = studio.split(': ')
    univ = univ.split(', ')
    if university not in univ:
        result.append(st)

print(*sorted(result, reverse = True), sep = '/ ') 


<Комментарий эксперта>:"
125,347,21,"Андрей хочет пойти работать в одну из студий дизайна интерьеров и смотрит, выпускников каких вузов они хотели бы у себя видеть. Напишите программу, которая поможет Андрею определить студии, куда его не могут взять на работу. 

ФОРМАТ ВВОДА
На первой строке через точку с запятой и пробел вводится информация о компании и вузах '<название студии дизайна>: <названия вузов через запятую и пробел>'. Гарантируется, что строка содержит информацию минимум об одной компании. 
На второй строке вводится название вуза, в котором обучается Андрей. 
ФОРМАТ ВЫВОДА
Названия студий дизайна, куда Андрея не могут взять на работу.
Названия должны выводиться через прямой слэш и пробел (""/ "") в обратном алфавитном порядке.
Если таких студий нет, программа ничего не выводит.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Считайте в переменную строку со студиями и вузами, сразу разделите по разделителю и получите список.
Считайте в переменную название вуза.
Создайте пустой список, в который будете добавлять название студии, если она готова пригласить Андрея на стажировку.
Обратитесь к каждому элементу из списка, созданного в п.1:
разбейте его (строку) по разделителю и сохраните название студии в одну переменную, а названия вузов — в другую переменную;
если вуза Андрея (переменная из п.2) нет в названиях вузов, то добавьте название студии в список из п.3.
Отсортируйте получившийся список в обратном алфавитном порядке. 
Напечатайте элементы списка через прямой слэш и пробел.","['Greenfield: МГУ, ВШЭ, МГСУ, СПбГУ; VDT: ВШЭ, РГГУ, Бауманка; A29: МИФИ, МФТИ, МГСУ, РАНХиГС; DA Bureau: РАНХиГС, ВШЭ, МГУ\nВШЭ', 'Sinitsa Buro: МГСУ, ВШЭ, МГИМО\nМГСУ', 'Lepo bureau: СПбГУ\nМГУ', 'Greenfield: МГСУ; Da-sein: МГСУ; Suite n.7: МГСУ\nВШЭ', 'Akke Collective: НИУ ВШЭ; Taiga Architects: НИУ ВШЭ; Better: НИУ ВШЭ\nНИУ ВШЭ', 'Artbureau 1/1: НИУ ВШЭ, КФУ, РГГУ; IA Buro: МФТИ, РГУ, МГСУ; Objct: МИФИ, МГПУ, МГСУ, РГУ\nРГУ']","['A29', nan, 'Lepo burea', 'Suite n.7/ Greenfield/ Da-sein', nan, 'Artbureau 1/1']","data = input().split('; ')
university = input()

result = []
for studio in data:
    st, univ = studio.split(': ')
    univ = univ.split(', ')
    if university not in univ:
        result.append(studio)

print(*sorted(result, reverse = True), sep = '/ ')","data = input().split('; ')
university = input()

result = []
for studio in data:
    st, univ = studio.split(': ')
    univ = univ.split(', ')
    if university not in univ:
        result.append(st)

print(*sorted(result, reverse = True), sep = '/ ')","Ошибка в открытых и скрытых тестах. 

Ваш код некорректно выполняет условия задания. Так, он некорректно выполянет условие ""выведите названия студий дизайна, куда Андрея не могут взять на работу"". Попробуйте изменить условие if для исправления ошибки.","['open', 'open', 'open', 'closed', 'closed', 'closed']","<Task description>: Андрей хочет пойти работать в одну из студий дизайна интерьеров и смотрит, выпускников каких вузов они хотели бы у себя видеть. Напишите программу, которая поможет Андрею определить студии, куда его не могут взять на работу. 

ФОРМАТ ВВОДА
На первой строке через точку с запятой и пробел вводится информация о компании и вузах '<название студии дизайна>: <названия вузов через запятую и пробел>'. Гарантируется, что строка содержит информацию минимум об одной компании. 
На второй строке вводится название вуза, в котором обучается Андрей. 
ФОРМАТ ВЫВОДА
Названия студий дизайна, куда Андрея не могут взять на работу.
Названия должны выводиться через прямой слэш и пробел (""/ "") в обратном алфавитном порядке.
Если таких студий нет, программа ничего не выводит.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Считайте в переменную строку со студиями и вузами, сразу разделите по разделителю и получите список.
Считайте в переменную название вуза.
Создайте пустой список, в который будете добавлять название студии, если она готова пригласить Андрея на стажировку.
Обратитесь к каждому элементу из списка, созданного в п.1:
разбейте его (строку) по разделителю и сохраните название студии в одну переменную, а названия вузов — в другую переменную;
если вуза Андрея (переменная из п.2) нет в названиях вузов, то добавьте название студии в список из п.3.
Отсортируйте получившийся список в обратном алфавитном порядке. 
Напечатайте элементы списка через прямой слэш и пробел. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: Greenfield: МГУ, ВШЭ, МГСУ, СПбГУ; VDT: ВШЭ, РГГУ, Бауманка; A29: МИФИ, МФТИ, МГСУ, РАНХиГС; DA Bureau: РАНХиГС, ВШЭ, МГУ
ВШЭ 
<Вывод>: A29 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: Sinitsa Buro: МГСУ, ВШЭ, МГИМО
МГСУ 
<Вывод>: nan 
<Example 3>: 
<Тип теста 3>: open 
<Ввод>: Lepo bureau: СПбГУ
МГУ 
<Вывод>: Lepo burea 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: Greenfield: МГСУ; Da-sein: МГСУ; Suite n.7: МГСУ
ВШЭ 
<Вывод>: Suite n.7/ Greenfield/ Da-sein 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: Akke Collective: НИУ ВШЭ; Taiga Architects: НИУ ВШЭ; Better: НИУ ВШЭ
НИУ ВШЭ 
<Вывод>: nan 
<Example 6>: 
<Тип теста 6>: closed 
<Ввод>: Artbureau 1/1: НИУ ВШЭ, КФУ, РГГУ; IA Buro: МФТИ, РГУ, МГСУ; Objct: МИФИ, МГПУ, МГСУ, РГУ
РГУ 
<Вывод>: Artbureau 1/1 
<Решение студента>: data = input().split('; ')
university = input()

result = []
for studio in data:
    st, univ = studio.split(': ')
    univ = univ.split(', ')
    if university not in univ:
        result.append(studio)

print(*sorted(result, reverse = True), sep = '/ ') 
<Идеальное решение>: data = input().split('; ')
university = input()

result = []
for studio in data:
    st, univ = studio.split(': ')
    univ = univ.split(', ')
    if university not in univ:
        result.append(st)

print(*sorted(result, reverse = True), sep = '/ ') 


<Комментарий эксперта>:"
126,348,21,"Андрей хочет пойти работать в одну из студий дизайна интерьеров и смотрит, выпускников каких вузов они хотели бы у себя видеть. Напишите программу, которая поможет Андрею определить студии, куда его не могут взять на работу. 

ФОРМАТ ВВОДА
На первой строке через точку с запятой и пробел вводится информация о компании и вузах '<название студии дизайна>: <названия вузов через запятую и пробел>'. Гарантируется, что строка содержит информацию минимум об одной компании. 
На второй строке вводится название вуза, в котором обучается Андрей. 
ФОРМАТ ВЫВОДА
Названия студий дизайна, куда Андрея не могут взять на работу.
Названия должны выводиться через прямой слэш и пробел (""/ "") в обратном алфавитном порядке.
Если таких студий нет, программа ничего не выводит.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Считайте в переменную строку со студиями и вузами, сразу разделите по разделителю и получите список.
Считайте в переменную название вуза.
Создайте пустой список, в который будете добавлять название студии, если она готова пригласить Андрея на стажировку.
Обратитесь к каждому элементу из списка, созданного в п.1:
разбейте его (строку) по разделителю и сохраните название студии в одну переменную, а названия вузов — в другую переменную;
если вуза Андрея (переменная из п.2) нет в названиях вузов, то добавьте название студии в список из п.3.
Отсортируйте получившийся список в обратном алфавитном порядке. 
Напечатайте элементы списка через прямой слэш и пробел.","['Greenfield: МГУ, ВШЭ, МГСУ, СПбГУ; VDT: ВШЭ, РГГУ, Бауманка; A29: МИФИ, МФТИ, МГСУ, РАНХиГС; DA Bureau: РАНХиГС, ВШЭ, МГУ\nВШЭ', 'Sinitsa Buro: МГСУ, ВШЭ, МГИМО\nМГСУ', 'Lepo bureau: СПбГУ\nМГУ', 'Greenfield: МГСУ; Da-sein: МГСУ; Suite n.7: МГСУ\nВШЭ', 'Akke Collective: НИУ ВШЭ; Taiga Architects: НИУ ВШЭ; Better: НИУ ВШЭ\nНИУ ВШЭ', 'Artbureau 1/1: НИУ ВШЭ, КФУ, РГГУ; IA Buro: МФТИ, РГУ, МГСУ; Objct: МИФИ, МГПУ, МГСУ, РГУ\nРГУ']","['A29', nan, 'Lepo burea', 'Suite n.7/ Greenfield/ Da-sein', nan, 'Artbureau 1/1']","data = input().split('; ')
university = input()

result = []
for studio in data:
    st, univ = studio.split(': ')
    univ = univ.split(', ')
    if university not in univ:
        result.append(st)

print(*sorted(result, reverse = True), sep = ' / ')","data = input().split('; ')
university = input()

result = []
for studio in data:
    st, univ = studio.split(': ')
    univ = univ.split(', ')
    if university not in univ:
        result.append(st)

print(*sorted(result, reverse = True), sep = '/ ')","Ошибка в скрытых тестах. 

Ваш код некорректно выполняет условия задания. Так, он Вы используйте некорректный параметр для разделения элементов в функции print. Следите за пробелами.","['open', 'open', 'open', 'closed', 'closed', 'closed']","<Task description>: Андрей хочет пойти работать в одну из студий дизайна интерьеров и смотрит, выпускников каких вузов они хотели бы у себя видеть. Напишите программу, которая поможет Андрею определить студии, куда его не могут взять на работу. 

ФОРМАТ ВВОДА
На первой строке через точку с запятой и пробел вводится информация о компании и вузах '<название студии дизайна>: <названия вузов через запятую и пробел>'. Гарантируется, что строка содержит информацию минимум об одной компании. 
На второй строке вводится название вуза, в котором обучается Андрей. 
ФОРМАТ ВЫВОДА
Названия студий дизайна, куда Андрея не могут взять на работу.
Названия должны выводиться через прямой слэш и пробел (""/ "") в обратном алфавитном порядке.
Если таких студий нет, программа ничего не выводит.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Считайте в переменную строку со студиями и вузами, сразу разделите по разделителю и получите список.
Считайте в переменную название вуза.
Создайте пустой список, в который будете добавлять название студии, если она готова пригласить Андрея на стажировку.
Обратитесь к каждому элементу из списка, созданного в п.1:
разбейте его (строку) по разделителю и сохраните название студии в одну переменную, а названия вузов — в другую переменную;
если вуза Андрея (переменная из п.2) нет в названиях вузов, то добавьте название студии в список из п.3.
Отсортируйте получившийся список в обратном алфавитном порядке. 
Напечатайте элементы списка через прямой слэш и пробел. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: Greenfield: МГУ, ВШЭ, МГСУ, СПбГУ; VDT: ВШЭ, РГГУ, Бауманка; A29: МИФИ, МФТИ, МГСУ, РАНХиГС; DA Bureau: РАНХиГС, ВШЭ, МГУ
ВШЭ 
<Вывод>: A29 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: Sinitsa Buro: МГСУ, ВШЭ, МГИМО
МГСУ 
<Вывод>: nan 
<Example 3>: 
<Тип теста 3>: open 
<Ввод>: Lepo bureau: СПбГУ
МГУ 
<Вывод>: Lepo burea 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: Greenfield: МГСУ; Da-sein: МГСУ; Suite n.7: МГСУ
ВШЭ 
<Вывод>: Suite n.7/ Greenfield/ Da-sein 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: Akke Collective: НИУ ВШЭ; Taiga Architects: НИУ ВШЭ; Better: НИУ ВШЭ
НИУ ВШЭ 
<Вывод>: nan 
<Example 6>: 
<Тип теста 6>: closed 
<Ввод>: Artbureau 1/1: НИУ ВШЭ, КФУ, РГГУ; IA Buro: МФТИ, РГУ, МГСУ; Objct: МИФИ, МГПУ, МГСУ, РГУ
РГУ 
<Вывод>: Artbureau 1/1 
<Решение студента>: data = input().split('; ')
university = input()

result = []
for studio in data:
    st, univ = studio.split(': ')
    univ = univ.split(', ')
    if university not in univ:
        result.append(st)

print(*sorted(result, reverse = True), sep = ' / ') 
<Идеальное решение>: data = input().split('; ')
university = input()

result = []
for studio in data:
    st, univ = studio.split(': ')
    univ = univ.split(', ')
    if university not in univ:
        result.append(st)

print(*sorted(result, reverse = True), sep = '/ ') 


<Комментарий эксперта>:"
127,349,21,"Андрей хочет пойти работать в одну из студий дизайна интерьеров и смотрит, выпускников каких вузов они хотели бы у себя видеть. Напишите программу, которая поможет Андрею определить студии, куда его не могут взять на работу. 

ФОРМАТ ВВОДА
На первой строке через точку с запятой и пробел вводится информация о компании и вузах '<название студии дизайна>: <названия вузов через запятую и пробел>'. Гарантируется, что строка содержит информацию минимум об одной компании. 
На второй строке вводится название вуза, в котором обучается Андрей. 
ФОРМАТ ВЫВОДА
Названия студий дизайна, куда Андрея не могут взять на работу.
Названия должны выводиться через прямой слэш и пробел (""/ "") в обратном алфавитном порядке.
Если таких студий нет, программа ничего не выводит.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Считайте в переменную строку со студиями и вузами, сразу разделите по разделителю и получите список.
Считайте в переменную название вуза.
Создайте пустой список, в который будете добавлять название студии, если она готова пригласить Андрея на стажировку.
Обратитесь к каждому элементу из списка, созданного в п.1:
разбейте его (строку) по разделителю и сохраните название студии в одну переменную, а названия вузов — в другую переменную;
если вуза Андрея (переменная из п.2) нет в названиях вузов, то добавьте название студии в список из п.3.
Отсортируйте получившийся список в обратном алфавитном порядке. 
Напечатайте элементы списка через прямой слэш и пробел.","['Greenfield: МГУ, ВШЭ, МГСУ, СПбГУ; VDT: ВШЭ, РГГУ, Бауманка; A29: МИФИ, МФТИ, МГСУ, РАНХиГС; DA Bureau: РАНХиГС, ВШЭ, МГУ\nВШЭ', 'Sinitsa Buro: МГСУ, ВШЭ, МГИМО\nМГСУ', 'Lepo bureau: СПбГУ\nМГУ', 'Greenfield: МГСУ; Da-sein: МГСУ; Suite n.7: МГСУ\nВШЭ', 'Akke Collective: НИУ ВШЭ; Taiga Architects: НИУ ВШЭ; Better: НИУ ВШЭ\nНИУ ВШЭ', 'Artbureau 1/1: НИУ ВШЭ, КФУ, РГГУ; IA Buro: МФТИ, РГУ, МГСУ; Objct: МИФИ, МГПУ, МГСУ, РГУ\nРГУ']","['A29', nan, 'Lepo burea', 'Suite n.7/ Greenfield/ Da-sein', nan, 'Artbureau 1/1']","data = input().split('; ')
university = input()

result = []
for studio in data:
    st, univ = studio.split(': ')
    univ = univ.split(', ')
if university not in univ:
    result.append(st)

print(*sorted(result, reverse = True), sep = '/ ')","data = input().split('; ')
university = input()

result = []
for studio in data:
    st, univ = studio.split(': ')
    univ = univ.split(', ')
    if university not in univ:
        result.append(st)

print(*sorted(result, reverse = True), sep = '/ ')",Ошибка в табуляции оператора if.,"['open', 'open', 'open', 'closed', 'closed', 'closed']","<Task description>: Андрей хочет пойти работать в одну из студий дизайна интерьеров и смотрит, выпускников каких вузов они хотели бы у себя видеть. Напишите программу, которая поможет Андрею определить студии, куда его не могут взять на работу. 

ФОРМАТ ВВОДА
На первой строке через точку с запятой и пробел вводится информация о компании и вузах '<название студии дизайна>: <названия вузов через запятую и пробел>'. Гарантируется, что строка содержит информацию минимум об одной компании. 
На второй строке вводится название вуза, в котором обучается Андрей. 
ФОРМАТ ВЫВОДА
Названия студий дизайна, куда Андрея не могут взять на работу.
Названия должны выводиться через прямой слэш и пробел (""/ "") в обратном алфавитном порядке.
Если таких студий нет, программа ничего не выводит.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Считайте в переменную строку со студиями и вузами, сразу разделите по разделителю и получите список.
Считайте в переменную название вуза.
Создайте пустой список, в который будете добавлять название студии, если она готова пригласить Андрея на стажировку.
Обратитесь к каждому элементу из списка, созданного в п.1:
разбейте его (строку) по разделителю и сохраните название студии в одну переменную, а названия вузов — в другую переменную;
если вуза Андрея (переменная из п.2) нет в названиях вузов, то добавьте название студии в список из п.3.
Отсортируйте получившийся список в обратном алфавитном порядке. 
Напечатайте элементы списка через прямой слэш и пробел. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: Greenfield: МГУ, ВШЭ, МГСУ, СПбГУ; VDT: ВШЭ, РГГУ, Бауманка; A29: МИФИ, МФТИ, МГСУ, РАНХиГС; DA Bureau: РАНХиГС, ВШЭ, МГУ
ВШЭ 
<Вывод>: A29 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: Sinitsa Buro: МГСУ, ВШЭ, МГИМО
МГСУ 
<Вывод>: nan 
<Example 3>: 
<Тип теста 3>: open 
<Ввод>: Lepo bureau: СПбГУ
МГУ 
<Вывод>: Lepo burea 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: Greenfield: МГСУ; Da-sein: МГСУ; Suite n.7: МГСУ
ВШЭ 
<Вывод>: Suite n.7/ Greenfield/ Da-sein 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: Akke Collective: НИУ ВШЭ; Taiga Architects: НИУ ВШЭ; Better: НИУ ВШЭ
НИУ ВШЭ 
<Вывод>: nan 
<Example 6>: 
<Тип теста 6>: closed 
<Ввод>: Artbureau 1/1: НИУ ВШЭ, КФУ, РГГУ; IA Buro: МФТИ, РГУ, МГСУ; Objct: МИФИ, МГПУ, МГСУ, РГУ
РГУ 
<Вывод>: Artbureau 1/1 
<Решение студента>: data = input().split('; ')
university = input()

result = []
for studio in data:
    st, univ = studio.split(': ')
    univ = univ.split(', ')
if university not in univ:
    result.append(st)

print(*sorted(result, reverse = True), sep = '/ ') 
<Идеальное решение>: data = input().split('; ')
university = input()

result = []
for studio in data:
    st, univ = studio.split(': ')
    univ = univ.split(', ')
    if university not in univ:
        result.append(st)

print(*sorted(result, reverse = True), sep = '/ ') 


<Комментарий эксперта>:"
128,368,23,"Роман изучает отчет по объекту, где упоминаются различные цвета, которые использовались в проекте. Помогите определить цвета, которые использовались не менее двух раз.

ФОРМАТ ВВОДА
Текстовый файл report.txt, в котором записан отчет по объекту. Гарантируется, что в тексте только названия цветов начинаются с хэштега (""#""). 
Гарантируется, что пустых строк в файле нет.
Гарантируется, что в файле будет упоминание хотя бы одного цвета.
Также дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.
ФОРМАТ ВЫВОДА
Названия цветов, которые использовались в проекте не менее двух раз. 
Названия должны быть записаны в обратном алфавитном порядке через точку с запятой и пробел.
ДОПОЛНИТЕЛЬНО
В открытом тесте используется файл report.txt  Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Создайте пустой словарь, в который будете записывать цвета и то, сколько раз их использовали в проекте.
Откройте файл в режиме чтения в кодировке utf-8.
Обратитесь к каждой строке в файле и выполните следующие действия:
уберите невидимые символы в конце строки (символ перехода на новую строку);
обратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;
разбейте строку по разделителю, в результате получите список;
обратитесь к каждому элементу в получившемся списке: если первый его элемент — хэштег, тогда это цвет и нужно проверить:
если этого цвета еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.
если такой цвет уже есть в словаре из п.1, то нужно увеличить его значение на 1.
После цикла создайте пустой список — в него нужно будет добавить названия тех цветов, значение которых в словаре больше 1.
Обратитесь к парам ключ-значение в словаре: если значение больше или равно  2, то добавьте ключ в список из п.4.
Отсортируйте список в обратном алфавиту порядке и напечатайте его элементы через точку с запятой и пробел.","[nan, nan, nan]","['#FFFFFF; #BFBFBF; #3F3F3F; #000000', '#FA8072; #DC143C; #CD5C5C', nan]","punctuation = '!$%&()*+,-./:;<=>?@^_'

data = {}

open('report.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip('\n')
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].startswith('#'):
                if w not in data:
                    data[w] = 1
                else:
                    data[w] += 1
                    
res = []

for k, v in data.items():
    if v >= 2:
        res.append(k)
        
print(*sorted(res, reverse = True), sep='; ')","punctuation = '!$%&()*+,-./:;<=>?@^_'

data = {}

with open('report.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip('\n')
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].startswith('#'):
                if w not in data:
                    data[w] = 1
                else:
                    data[w] += 1
                    
res = []

for k, v in data.items():
    if v >= 2:
        res.append(k)
        
print(*sorted(res, reverse = True), sep='; ')",Некорректный синтаксис при использовании функции open.,"['open', 'closed', 'closed']","<Task description>: Роман изучает отчет по объекту, где упоминаются различные цвета, которые использовались в проекте. Помогите определить цвета, которые использовались не менее двух раз.

ФОРМАТ ВВОДА
Текстовый файл report.txt, в котором записан отчет по объекту. Гарантируется, что в тексте только названия цветов начинаются с хэштега (""#""). 
Гарантируется, что пустых строк в файле нет.
Гарантируется, что в файле будет упоминание хотя бы одного цвета.
Также дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.
ФОРМАТ ВЫВОДА
Названия цветов, которые использовались в проекте не менее двух раз. 
Названия должны быть записаны в обратном алфавитном порядке через точку с запятой и пробел.
ДОПОЛНИТЕЛЬНО
В открытом тесте используется файл report.txt  Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Создайте пустой словарь, в который будете записывать цвета и то, сколько раз их использовали в проекте.
Откройте файл в режиме чтения в кодировке utf-8.
Обратитесь к каждой строке в файле и выполните следующие действия:
уберите невидимые символы в конце строки (символ перехода на новую строку);
обратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;
разбейте строку по разделителю, в результате получите список;
обратитесь к каждому элементу в получившемся списке: если первый его элемент — хэштег, тогда это цвет и нужно проверить:
если этого цвета еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.
если такой цвет уже есть в словаре из п.1, то нужно увеличить его значение на 1.
После цикла создайте пустой список — в него нужно будет добавить названия тех цветов, значение которых в словаре больше 1.
Обратитесь к парам ключ-значение в словаре: если значение больше или равно  2, то добавьте ключ в список из п.4.
Отсортируйте список в обратном алфавиту порядке и напечатайте его элементы через точку с запятой и пробел. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: nan 
<Вывод>: #FFFFFF; #BFBFBF; #3F3F3F; #000000 
<Example 2>: 
<Тип теста 2>: closed 
<Ввод>: nan 
<Вывод>: #FA8072; #DC143C; #CD5C5C 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: nan 
<Вывод>: nan 
<Решение студента>: punctuation = '!$%&()*+,-./:;<=>?@^_'

data = {}

open('report.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip('\n')
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].startswith('#'):
                if w not in data:
                    data[w] = 1
                else:
                    data[w] += 1
                    
res = []

for k, v in data.items():
    if v >= 2:
        res.append(k)
        
print(*sorted(res, reverse = True), sep='; ') 
<Идеальное решение>: punctuation = '!$%&()*+,-./:;<=>?@^_'

data = {}

with open('report.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip('\n')
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].startswith('#'):
                if w not in data:
                    data[w] = 1
                else:
                    data[w] += 1
                    
res = []

for k, v in data.items():
    if v >= 2:
        res.append(k)
        
print(*sorted(res, reverse = True), sep='; ') 


<Комментарий эксперта>:"
129,369,23,"Роман изучает отчет по объекту, где упоминаются различные цвета, которые использовались в проекте. Помогите определить цвета, которые использовались не менее двух раз.

ФОРМАТ ВВОДА
Текстовый файл report.txt, в котором записан отчет по объекту. Гарантируется, что в тексте только названия цветов начинаются с хэштега (""#""). 
Гарантируется, что пустых строк в файле нет.
Гарантируется, что в файле будет упоминание хотя бы одного цвета.
Также дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.
ФОРМАТ ВЫВОДА
Названия цветов, которые использовались в проекте не менее двух раз. 
Названия должны быть записаны в обратном алфавитном порядке через точку с запятой и пробел.
ДОПОЛНИТЕЛЬНО
В открытом тесте используется файл report.txt  Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Создайте пустой словарь, в который будете записывать цвета и то, сколько раз их использовали в проекте.
Откройте файл в режиме чтения в кодировке utf-8.
Обратитесь к каждой строке в файле и выполните следующие действия:
уберите невидимые символы в конце строки (символ перехода на новую строку);
обратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;
разбейте строку по разделителю, в результате получите список;
обратитесь к каждому элементу в получившемся списке: если первый его элемент — хэштег, тогда это цвет и нужно проверить:
если этого цвета еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.
если такой цвет уже есть в словаре из п.1, то нужно увеличить его значение на 1.
После цикла создайте пустой список — в него нужно будет добавить названия тех цветов, значение которых в словаре больше 1.
Обратитесь к парам ключ-значение в словаре: если значение больше или равно  2, то добавьте ключ в список из п.4.
Отсортируйте список в обратном алфавиту порядке и напечатайте его элементы через точку с запятой и пробел.","[nan, nan, nan]","['#FFFFFF; #BFBFBF; #3F3F3F; #000000', '#FA8072; #DC143C; #CD5C5C', nan]","punctuation = '!$%&()*+,-./:;<=>?@^_'

data = {}

with open('report.csv', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip('\n')
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].startswith('#'):
                if w not in data:
                    data[w] = 1
                else:
                    data[w] += 1
                    
res = []

for k, v in data.items():
    if v >= 2:
        res.append(k)
        
print(*sorted(res, reverse = True), sep='; ')","punctuation = '!$%&()*+,-./:;<=>?@^_'

data = {}

with open('report.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip('\n')
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].startswith('#'):
                if w not in data:
                    data[w] = 1
                else:
                    data[w] += 1
                    
res = []

for k, v in data.items():
    if v >= 2:
        res.append(k)
        
print(*sorted(res, reverse = True), sep='; ')",Ошибка при открытии файла. Обращение к файлу некорректного формата.,"['open', 'closed', 'closed']","<Task description>: Роман изучает отчет по объекту, где упоминаются различные цвета, которые использовались в проекте. Помогите определить цвета, которые использовались не менее двух раз.

ФОРМАТ ВВОДА
Текстовый файл report.txt, в котором записан отчет по объекту. Гарантируется, что в тексте только названия цветов начинаются с хэштега (""#""). 
Гарантируется, что пустых строк в файле нет.
Гарантируется, что в файле будет упоминание хотя бы одного цвета.
Также дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.
ФОРМАТ ВЫВОДА
Названия цветов, которые использовались в проекте не менее двух раз. 
Названия должны быть записаны в обратном алфавитном порядке через точку с запятой и пробел.
ДОПОЛНИТЕЛЬНО
В открытом тесте используется файл report.txt  Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Создайте пустой словарь, в который будете записывать цвета и то, сколько раз их использовали в проекте.
Откройте файл в режиме чтения в кодировке utf-8.
Обратитесь к каждой строке в файле и выполните следующие действия:
уберите невидимые символы в конце строки (символ перехода на новую строку);
обратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;
разбейте строку по разделителю, в результате получите список;
обратитесь к каждому элементу в получившемся списке: если первый его элемент — хэштег, тогда это цвет и нужно проверить:
если этого цвета еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.
если такой цвет уже есть в словаре из п.1, то нужно увеличить его значение на 1.
После цикла создайте пустой список — в него нужно будет добавить названия тех цветов, значение которых в словаре больше 1.
Обратитесь к парам ключ-значение в словаре: если значение больше или равно  2, то добавьте ключ в список из п.4.
Отсортируйте список в обратном алфавиту порядке и напечатайте его элементы через точку с запятой и пробел. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: nan 
<Вывод>: #FFFFFF; #BFBFBF; #3F3F3F; #000000 
<Example 2>: 
<Тип теста 2>: closed 
<Ввод>: nan 
<Вывод>: #FA8072; #DC143C; #CD5C5C 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: nan 
<Вывод>: nan 
<Решение студента>: punctuation = '!$%&()*+,-./:;<=>?@^_'

data = {}

with open('report.csv', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip('\n')
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].startswith('#'):
                if w not in data:
                    data[w] = 1
                else:
                    data[w] += 1
                    
res = []

for k, v in data.items():
    if v >= 2:
        res.append(k)
        
print(*sorted(res, reverse = True), sep='; ') 
<Идеальное решение>: punctuation = '!$%&()*+,-./:;<=>?@^_'

data = {}

with open('report.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip('\n')
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].startswith('#'):
                if w not in data:
                    data[w] = 1
                else:
                    data[w] += 1
                    
res = []

for k, v in data.items():
    if v >= 2:
        res.append(k)
        
print(*sorted(res, reverse = True), sep='; ') 


<Комментарий эксперта>:"
130,370,23,"Роман изучает отчет по объекту, где упоминаются различные цвета, которые использовались в проекте. Помогите определить цвета, которые использовались не менее двух раз.

ФОРМАТ ВВОДА
Текстовый файл report.txt, в котором записан отчет по объекту. Гарантируется, что в тексте только названия цветов начинаются с хэштега (""#""). 
Гарантируется, что пустых строк в файле нет.
Гарантируется, что в файле будет упоминание хотя бы одного цвета.
Также дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.
ФОРМАТ ВЫВОДА
Названия цветов, которые использовались в проекте не менее двух раз. 
Названия должны быть записаны в обратном алфавитном порядке через точку с запятой и пробел.
ДОПОЛНИТЕЛЬНО
В открытом тесте используется файл report.txt  Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Создайте пустой словарь, в который будете записывать цвета и то, сколько раз их использовали в проекте.
Откройте файл в режиме чтения в кодировке utf-8.
Обратитесь к каждой строке в файле и выполните следующие действия:
уберите невидимые символы в конце строки (символ перехода на новую строку);
обратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;
разбейте строку по разделителю, в результате получите список;
обратитесь к каждому элементу в получившемся списке: если первый его элемент — хэштег, тогда это цвет и нужно проверить:
если этого цвета еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.
если такой цвет уже есть в словаре из п.1, то нужно увеличить его значение на 1.
После цикла создайте пустой список — в него нужно будет добавить названия тех цветов, значение которых в словаре больше 1.
Обратитесь к парам ключ-значение в словаре: если значение больше или равно  2, то добавьте ключ в список из п.4.
Отсортируйте список в обратном алфавиту порядке и напечатайте его элементы через точку с запятой и пробел.","[nan, nan, nan]","['#FFFFFF; #BFBFBF; #3F3F3F; #000000', '#FA8072; #DC143C; #CD5C5C', nan]","punctuation = '!$%&()*+,-./:;<=>?@^_'

with open('report.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip('\n')
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].startswith('#'):
                if w not in data:
                    data[w] = 1
                else:
                    data[w] += 1
                    
res = []

for k, v in data.items():
    if v >= 2:
        res.append(k)
        
print(*sorted(res, reverse = True), sep='; ')","punctuation = '!$%&()*+,-./:;<=>?@^_'

data = {}

with open('report.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip('\n')
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].startswith('#'):
                if w not in data:
                    data[w] = 1
                else:
                    data[w] += 1
                    
res = []

for k, v in data.items():
    if v >= 2:
        res.append(k)
        
print(*sorted(res, reverse = True), sep='; ')","Ошибка при обращении к незаданной переменной. Проверьте, что все Ваши переменные корректно заданы.","['open', 'closed', 'closed']","<Task description>: Роман изучает отчет по объекту, где упоминаются различные цвета, которые использовались в проекте. Помогите определить цвета, которые использовались не менее двух раз.

ФОРМАТ ВВОДА
Текстовый файл report.txt, в котором записан отчет по объекту. Гарантируется, что в тексте только названия цветов начинаются с хэштега (""#""). 
Гарантируется, что пустых строк в файле нет.
Гарантируется, что в файле будет упоминание хотя бы одного цвета.
Также дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.
ФОРМАТ ВЫВОДА
Названия цветов, которые использовались в проекте не менее двух раз. 
Названия должны быть записаны в обратном алфавитном порядке через точку с запятой и пробел.
ДОПОЛНИТЕЛЬНО
В открытом тесте используется файл report.txt  Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Создайте пустой словарь, в который будете записывать цвета и то, сколько раз их использовали в проекте.
Откройте файл в режиме чтения в кодировке utf-8.
Обратитесь к каждой строке в файле и выполните следующие действия:
уберите невидимые символы в конце строки (символ перехода на новую строку);
обратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;
разбейте строку по разделителю, в результате получите список;
обратитесь к каждому элементу в получившемся списке: если первый его элемент — хэштег, тогда это цвет и нужно проверить:
если этого цвета еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.
если такой цвет уже есть в словаре из п.1, то нужно увеличить его значение на 1.
После цикла создайте пустой список — в него нужно будет добавить названия тех цветов, значение которых в словаре больше 1.
Обратитесь к парам ключ-значение в словаре: если значение больше или равно  2, то добавьте ключ в список из п.4.
Отсортируйте список в обратном алфавиту порядке и напечатайте его элементы через точку с запятой и пробел. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: nan 
<Вывод>: #FFFFFF; #BFBFBF; #3F3F3F; #000000 
<Example 2>: 
<Тип теста 2>: closed 
<Ввод>: nan 
<Вывод>: #FA8072; #DC143C; #CD5C5C 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: nan 
<Вывод>: nan 
<Решение студента>: punctuation = '!$%&()*+,-./:;<=>?@^_'

with open('report.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip('\n')
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].startswith('#'):
                if w not in data:
                    data[w] = 1
                else:
                    data[w] += 1
                    
res = []

for k, v in data.items():
    if v >= 2:
        res.append(k)
        
print(*sorted(res, reverse = True), sep='; ') 
<Идеальное решение>: punctuation = '!$%&()*+,-./:;<=>?@^_'

data = {}

with open('report.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip('\n')
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].startswith('#'):
                if w not in data:
                    data[w] = 1
                else:
                    data[w] += 1
                    
res = []

for k, v in data.items():
    if v >= 2:
        res.append(k)
        
print(*sorted(res, reverse = True), sep='; ') 


<Комментарий эксперта>:"
131,371,23,"Роман изучает отчет по объекту, где упоминаются различные цвета, которые использовались в проекте. Помогите определить цвета, которые использовались не менее двух раз.

ФОРМАТ ВВОДА
Текстовый файл report.txt, в котором записан отчет по объекту. Гарантируется, что в тексте только названия цветов начинаются с хэштега (""#""). 
Гарантируется, что пустых строк в файле нет.
Гарантируется, что в файле будет упоминание хотя бы одного цвета.
Также дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.
ФОРМАТ ВЫВОДА
Названия цветов, которые использовались в проекте не менее двух раз. 
Названия должны быть записаны в обратном алфавитном порядке через точку с запятой и пробел.
ДОПОЛНИТЕЛЬНО
В открытом тесте используется файл report.txt  Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Создайте пустой словарь, в который будете записывать цвета и то, сколько раз их использовали в проекте.
Откройте файл в режиме чтения в кодировке utf-8.
Обратитесь к каждой строке в файле и выполните следующие действия:
уберите невидимые символы в конце строки (символ перехода на новую строку);
обратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;
разбейте строку по разделителю, в результате получите список;
обратитесь к каждому элементу в получившемся списке: если первый его элемент — хэштег, тогда это цвет и нужно проверить:
если этого цвета еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.
если такой цвет уже есть в словаре из п.1, то нужно увеличить его значение на 1.
После цикла создайте пустой список — в него нужно будет добавить названия тех цветов, значение которых в словаре больше 1.
Обратитесь к парам ключ-значение в словаре: если значение больше или равно  2, то добавьте ключ в список из п.4.
Отсортируйте список в обратном алфавиту порядке и напечатайте его элементы через точку с запятой и пробел.","[nan, nan, nan]","['#FFFFFF; #BFBFBF; #3F3F3F; #000000', '#FA8072; #DC143C; #CD5C5C', nan]","punctuation = '!$%&()*+,-./:;<=>?@^_'

data = {}

with open('report.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip('\n')
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].startswith('#'):
                if w not in data:
                    data[w] = 1
                else:
                    data[w] += 1
                    
for k, v in data.items():
    if v >= 2:
        res.append(k)
        
print(*sorted(res, reverse = True), sep='; ')","punctuation = '!$%&()*+,-./:;<=>?@^_'

data = {}

with open('report.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip('\n')
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].startswith('#'):
                if w not in data:
                    data[w] = 1
                else:
                    data[w] += 1
                    
res = []

for k, v in data.items():
    if v >= 2:
        res.append(k)
        
print(*sorted(res, reverse = True), sep='; ')","Ошибка при обращении к незаданной переменной. Проверьте, что все Ваши переменные корректно заданы.","['open', 'closed', 'closed']","<Task description>: Роман изучает отчет по объекту, где упоминаются различные цвета, которые использовались в проекте. Помогите определить цвета, которые использовались не менее двух раз.

ФОРМАТ ВВОДА
Текстовый файл report.txt, в котором записан отчет по объекту. Гарантируется, что в тексте только названия цветов начинаются с хэштега (""#""). 
Гарантируется, что пустых строк в файле нет.
Гарантируется, что в файле будет упоминание хотя бы одного цвета.
Также дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.
ФОРМАТ ВЫВОДА
Названия цветов, которые использовались в проекте не менее двух раз. 
Названия должны быть записаны в обратном алфавитном порядке через точку с запятой и пробел.
ДОПОЛНИТЕЛЬНО
В открытом тесте используется файл report.txt  Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Создайте пустой словарь, в который будете записывать цвета и то, сколько раз их использовали в проекте.
Откройте файл в режиме чтения в кодировке utf-8.
Обратитесь к каждой строке в файле и выполните следующие действия:
уберите невидимые символы в конце строки (символ перехода на новую строку);
обратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;
разбейте строку по разделителю, в результате получите список;
обратитесь к каждому элементу в получившемся списке: если первый его элемент — хэштег, тогда это цвет и нужно проверить:
если этого цвета еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.
если такой цвет уже есть в словаре из п.1, то нужно увеличить его значение на 1.
После цикла создайте пустой список — в него нужно будет добавить названия тех цветов, значение которых в словаре больше 1.
Обратитесь к парам ключ-значение в словаре: если значение больше или равно  2, то добавьте ключ в список из п.4.
Отсортируйте список в обратном алфавиту порядке и напечатайте его элементы через точку с запятой и пробел. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: nan 
<Вывод>: #FFFFFF; #BFBFBF; #3F3F3F; #000000 
<Example 2>: 
<Тип теста 2>: closed 
<Ввод>: nan 
<Вывод>: #FA8072; #DC143C; #CD5C5C 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: nan 
<Вывод>: nan 
<Решение студента>: punctuation = '!$%&()*+,-./:;<=>?@^_'

data = {}

with open('report.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip('\n')
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].startswith('#'):
                if w not in data:
                    data[w] = 1
                else:
                    data[w] += 1
                    
for k, v in data.items():
    if v >= 2:
        res.append(k)
        
print(*sorted(res, reverse = True), sep='; ') 
<Идеальное решение>: punctuation = '!$%&()*+,-./:;<=>?@^_'

data = {}

with open('report.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip('\n')
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].startswith('#'):
                if w not in data:
                    data[w] = 1
                else:
                    data[w] += 1
                    
res = []

for k, v in data.items():
    if v >= 2:
        res.append(k)
        
print(*sorted(res, reverse = True), sep='; ') 


<Комментарий эксперта>:"
132,372,23,"Роман изучает отчет по объекту, где упоминаются различные цвета, которые использовались в проекте. Помогите определить цвета, которые использовались не менее двух раз.

ФОРМАТ ВВОДА
Текстовый файл report.txt, в котором записан отчет по объекту. Гарантируется, что в тексте только названия цветов начинаются с хэштега (""#""). 
Гарантируется, что пустых строк в файле нет.
Гарантируется, что в файле будет упоминание хотя бы одного цвета.
Также дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.
ФОРМАТ ВЫВОДА
Названия цветов, которые использовались в проекте не менее двух раз. 
Названия должны быть записаны в обратном алфавитном порядке через точку с запятой и пробел.
ДОПОЛНИТЕЛЬНО
В открытом тесте используется файл report.txt  Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Создайте пустой словарь, в который будете записывать цвета и то, сколько раз их использовали в проекте.
Откройте файл в режиме чтения в кодировке utf-8.
Обратитесь к каждой строке в файле и выполните следующие действия:
уберите невидимые символы в конце строки (символ перехода на новую строку);
обратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;
разбейте строку по разделителю, в результате получите список;
обратитесь к каждому элементу в получившемся списке: если первый его элемент — хэштег, тогда это цвет и нужно проверить:
если этого цвета еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.
если такой цвет уже есть в словаре из п.1, то нужно увеличить его значение на 1.
После цикла создайте пустой список — в него нужно будет добавить названия тех цветов, значение которых в словаре больше 1.
Обратитесь к парам ключ-значение в словаре: если значение больше или равно  2, то добавьте ключ в список из п.4.
Отсортируйте список в обратном алфавиту порядке и напечатайте его элементы через точку с запятой и пробел.","[nan, nan, nan]","['#FFFFFF; #BFBFBF; #3F3F3F; #000000', '#FA8072; #DC143C; #CD5C5C', nan]","punctuation = '!$%&()*+,-./:;<=>?@^_'

data = {}

with open('report.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip('\n')
                
        line = line.split()
        for w in line:
            if w[0].startswith('#'):
                if w not in data:
                    data[w] = 1
                else:
                    data[w] += 1
                    
res = []

for k, v in data.items():
    if v >= 2:
        res.append(k)
        
print(*sorted(res, reverse = True), sep='; ')","punctuation = '!$%&()*+,-./:;<=>?@^_'

data = {}

with open('report.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip('\n')
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].startswith('#'):
                if w not in data:
                    data[w] = 1
                else:
                    data[w] += 1
                    
res = []

for k, v in data.items():
    if v >= 2:
        res.append(k)
        
print(*sorted(res, reverse = True), sep='; ')","Ошибка в открытых и скрытых тестах. 

Ваш код некорректно обрабатывает данные. Ваш код не выполняет условие ""необходимо будет очистить от символов, сохраненных в переменную punctuation"" Попробуйте изменить код, чтобы скорректировать ошибку.","['open', 'closed', 'closed']","<Task description>: Роман изучает отчет по объекту, где упоминаются различные цвета, которые использовались в проекте. Помогите определить цвета, которые использовались не менее двух раз.

ФОРМАТ ВВОДА
Текстовый файл report.txt, в котором записан отчет по объекту. Гарантируется, что в тексте только названия цветов начинаются с хэштега (""#""). 
Гарантируется, что пустых строк в файле нет.
Гарантируется, что в файле будет упоминание хотя бы одного цвета.
Также дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.
ФОРМАТ ВЫВОДА
Названия цветов, которые использовались в проекте не менее двух раз. 
Названия должны быть записаны в обратном алфавитном порядке через точку с запятой и пробел.
ДОПОЛНИТЕЛЬНО
В открытом тесте используется файл report.txt  Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Создайте пустой словарь, в который будете записывать цвета и то, сколько раз их использовали в проекте.
Откройте файл в режиме чтения в кодировке utf-8.
Обратитесь к каждой строке в файле и выполните следующие действия:
уберите невидимые символы в конце строки (символ перехода на новую строку);
обратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;
разбейте строку по разделителю, в результате получите список;
обратитесь к каждому элементу в получившемся списке: если первый его элемент — хэштег, тогда это цвет и нужно проверить:
если этого цвета еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.
если такой цвет уже есть в словаре из п.1, то нужно увеличить его значение на 1.
После цикла создайте пустой список — в него нужно будет добавить названия тех цветов, значение которых в словаре больше 1.
Обратитесь к парам ключ-значение в словаре: если значение больше или равно  2, то добавьте ключ в список из п.4.
Отсортируйте список в обратном алфавиту порядке и напечатайте его элементы через точку с запятой и пробел. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: nan 
<Вывод>: #FFFFFF; #BFBFBF; #3F3F3F; #000000 
<Example 2>: 
<Тип теста 2>: closed 
<Ввод>: nan 
<Вывод>: #FA8072; #DC143C; #CD5C5C 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: nan 
<Вывод>: nan 
<Решение студента>: punctuation = '!$%&()*+,-./:;<=>?@^_'

data = {}

with open('report.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip('\n')
                
        line = line.split()
        for w in line:
            if w[0].startswith('#'):
                if w not in data:
                    data[w] = 1
                else:
                    data[w] += 1
                    
res = []

for k, v in data.items():
    if v >= 2:
        res.append(k)
        
print(*sorted(res, reverse = True), sep='; ') 
<Идеальное решение>: punctuation = '!$%&()*+,-./:;<=>?@^_'

data = {}

with open('report.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip('\n')
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].startswith('#'):
                if w not in data:
                    data[w] = 1
                else:
                    data[w] += 1
                    
res = []

for k, v in data.items():
    if v >= 2:
        res.append(k)
        
print(*sorted(res, reverse = True), sep='; ') 


<Комментарий эксперта>:"
133,373,23,"Роман изучает отчет по объекту, где упоминаются различные цвета, которые использовались в проекте. Помогите определить цвета, которые использовались не менее двух раз.

ФОРМАТ ВВОДА
Текстовый файл report.txt, в котором записан отчет по объекту. Гарантируется, что в тексте только названия цветов начинаются с хэштега (""#""). 
Гарантируется, что пустых строк в файле нет.
Гарантируется, что в файле будет упоминание хотя бы одного цвета.
Также дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.
ФОРМАТ ВЫВОДА
Названия цветов, которые использовались в проекте не менее двух раз. 
Названия должны быть записаны в обратном алфавитном порядке через точку с запятой и пробел.
ДОПОЛНИТЕЛЬНО
В открытом тесте используется файл report.txt  Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Создайте пустой словарь, в который будете записывать цвета и то, сколько раз их использовали в проекте.
Откройте файл в режиме чтения в кодировке utf-8.
Обратитесь к каждой строке в файле и выполните следующие действия:
уберите невидимые символы в конце строки (символ перехода на новую строку);
обратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;
разбейте строку по разделителю, в результате получите список;
обратитесь к каждому элементу в получившемся списке: если первый его элемент — хэштег, тогда это цвет и нужно проверить:
если этого цвета еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.
если такой цвет уже есть в словаре из п.1, то нужно увеличить его значение на 1.
После цикла создайте пустой список — в него нужно будет добавить названия тех цветов, значение которых в словаре больше 1.
Обратитесь к парам ключ-значение в словаре: если значение больше или равно  2, то добавьте ключ в список из п.4.
Отсортируйте список в обратном алфавиту порядке и напечатайте его элементы через точку с запятой и пробел.","[nan, nan, nan]","['#FFFFFF; #BFBFBF; #3F3F3F; #000000', '#FA8072; #DC143C; #CD5C5C', nan]","punctuation = '!$%&()*+,-./:;<=>?@^_'

data = {}

with open('report.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip('\n')
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split
        for w in line:
            if w[0].startswith('#'):
                if w not in data:
                    data[w] = 1
                else:
                    data[w] += 1
                    
res = []

for k, v in data.items():
    if v >= 2:
        res.append(k)
        
print(*sorted(res, reverse = True), sep='; ')","punctuation = '!$%&()*+,-./:;<=>?@^_'

data = {}

with open('report.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip('\n')
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].startswith('#'):
                if w not in data:
                    data[w] = 1
                else:
                    data[w] += 1
                    
res = []

for k, v in data.items():
    if v >= 2:
        res.append(k)
        
print(*sorted(res, reverse = True), sep='; ')",Синтаксическая ошибка при использовании метода split(). Не забывайте использовать скобки после каждого метода.,"['open', 'closed', 'closed']","<Task description>: Роман изучает отчет по объекту, где упоминаются различные цвета, которые использовались в проекте. Помогите определить цвета, которые использовались не менее двух раз.

ФОРМАТ ВВОДА
Текстовый файл report.txt, в котором записан отчет по объекту. Гарантируется, что в тексте только названия цветов начинаются с хэштега (""#""). 
Гарантируется, что пустых строк в файле нет.
Гарантируется, что в файле будет упоминание хотя бы одного цвета.
Также дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.
ФОРМАТ ВЫВОДА
Названия цветов, которые использовались в проекте не менее двух раз. 
Названия должны быть записаны в обратном алфавитном порядке через точку с запятой и пробел.
ДОПОЛНИТЕЛЬНО
В открытом тесте используется файл report.txt  Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Создайте пустой словарь, в который будете записывать цвета и то, сколько раз их использовали в проекте.
Откройте файл в режиме чтения в кодировке utf-8.
Обратитесь к каждой строке в файле и выполните следующие действия:
уберите невидимые символы в конце строки (символ перехода на новую строку);
обратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;
разбейте строку по разделителю, в результате получите список;
обратитесь к каждому элементу в получившемся списке: если первый его элемент — хэштег, тогда это цвет и нужно проверить:
если этого цвета еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.
если такой цвет уже есть в словаре из п.1, то нужно увеличить его значение на 1.
После цикла создайте пустой список — в него нужно будет добавить названия тех цветов, значение которых в словаре больше 1.
Обратитесь к парам ключ-значение в словаре: если значение больше или равно  2, то добавьте ключ в список из п.4.
Отсортируйте список в обратном алфавиту порядке и напечатайте его элементы через точку с запятой и пробел. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: nan 
<Вывод>: #FFFFFF; #BFBFBF; #3F3F3F; #000000 
<Example 2>: 
<Тип теста 2>: closed 
<Ввод>: nan 
<Вывод>: #FA8072; #DC143C; #CD5C5C 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: nan 
<Вывод>: nan 
<Решение студента>: punctuation = '!$%&()*+,-./:;<=>?@^_'

data = {}

with open('report.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip('\n')
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split
        for w in line:
            if w[0].startswith('#'):
                if w not in data:
                    data[w] = 1
                else:
                    data[w] += 1
                    
res = []

for k, v in data.items():
    if v >= 2:
        res.append(k)
        
print(*sorted(res, reverse = True), sep='; ') 
<Идеальное решение>: punctuation = '!$%&()*+,-./:;<=>?@^_'

data = {}

with open('report.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip('\n')
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].startswith('#'):
                if w not in data:
                    data[w] = 1
                else:
                    data[w] += 1
                    
res = []

for k, v in data.items():
    if v >= 2:
        res.append(k)
        
print(*sorted(res, reverse = True), sep='; ') 


<Комментарий эксперта>:"
134,374,23,"Роман изучает отчет по объекту, где упоминаются различные цвета, которые использовались в проекте. Помогите определить цвета, которые использовались не менее двух раз.

ФОРМАТ ВВОДА
Текстовый файл report.txt, в котором записан отчет по объекту. Гарантируется, что в тексте только названия цветов начинаются с хэштега (""#""). 
Гарантируется, что пустых строк в файле нет.
Гарантируется, что в файле будет упоминание хотя бы одного цвета.
Также дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.
ФОРМАТ ВЫВОДА
Названия цветов, которые использовались в проекте не менее двух раз. 
Названия должны быть записаны в обратном алфавитном порядке через точку с запятой и пробел.
ДОПОЛНИТЕЛЬНО
В открытом тесте используется файл report.txt  Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Создайте пустой словарь, в который будете записывать цвета и то, сколько раз их использовали в проекте.
Откройте файл в режиме чтения в кодировке utf-8.
Обратитесь к каждой строке в файле и выполните следующие действия:
уберите невидимые символы в конце строки (символ перехода на новую строку);
обратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;
разбейте строку по разделителю, в результате получите список;
обратитесь к каждому элементу в получившемся списке: если первый его элемент — хэштег, тогда это цвет и нужно проверить:
если этого цвета еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.
если такой цвет уже есть в словаре из п.1, то нужно увеличить его значение на 1.
После цикла создайте пустой список — в него нужно будет добавить названия тех цветов, значение которых в словаре больше 1.
Обратитесь к парам ключ-значение в словаре: если значение больше или равно  2, то добавьте ключ в список из п.4.
Отсортируйте список в обратном алфавиту порядке и напечатайте его элементы через точку с запятой и пробел.","[nan, nan, nan]","['#FFFFFF; #BFBFBF; #3F3F3F; #000000', '#FA8072; #DC143C; #CD5C5C', nan]","punctuation = '!$%&()*+,-./:;<=>?@^_'

data = {}

with open('report.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip('\n')
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for word in line:
            if w[0].startswith('#'):
                if w not in data:
                    data[w] = 1
                else:
                    data[w] += 1
                    
res = []

for k, v in data.items():
    if v >= 2:
        res.append(k)
        
print(*sorted(res, reverse = True), sep='; ')","punctuation = '!$%&()*+,-./:;<=>?@^_'

data = {}

with open('report.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip('\n')
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].startswith('#'):
                if w not in data:
                    data[w] = 1
                else:
                    data[w] += 1
                    
res = []

for k, v in data.items():
    if v >= 2:
        res.append(k)
        
print(*sorted(res, reverse = True), sep='; ')","Ошибка при обращении к ранее не заданным переменным. Проверьте, что все Ваши переменные написаны корректно.","['open', 'closed', 'closed']","<Task description>: Роман изучает отчет по объекту, где упоминаются различные цвета, которые использовались в проекте. Помогите определить цвета, которые использовались не менее двух раз.

ФОРМАТ ВВОДА
Текстовый файл report.txt, в котором записан отчет по объекту. Гарантируется, что в тексте только названия цветов начинаются с хэштега (""#""). 
Гарантируется, что пустых строк в файле нет.
Гарантируется, что в файле будет упоминание хотя бы одного цвета.
Также дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.
ФОРМАТ ВЫВОДА
Названия цветов, которые использовались в проекте не менее двух раз. 
Названия должны быть записаны в обратном алфавитном порядке через точку с запятой и пробел.
ДОПОЛНИТЕЛЬНО
В открытом тесте используется файл report.txt  Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Создайте пустой словарь, в который будете записывать цвета и то, сколько раз их использовали в проекте.
Откройте файл в режиме чтения в кодировке utf-8.
Обратитесь к каждой строке в файле и выполните следующие действия:
уберите невидимые символы в конце строки (символ перехода на новую строку);
обратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;
разбейте строку по разделителю, в результате получите список;
обратитесь к каждому элементу в получившемся списке: если первый его элемент — хэштег, тогда это цвет и нужно проверить:
если этого цвета еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.
если такой цвет уже есть в словаре из п.1, то нужно увеличить его значение на 1.
После цикла создайте пустой список — в него нужно будет добавить названия тех цветов, значение которых в словаре больше 1.
Обратитесь к парам ключ-значение в словаре: если значение больше или равно  2, то добавьте ключ в список из п.4.
Отсортируйте список в обратном алфавиту порядке и напечатайте его элементы через точку с запятой и пробел. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: nan 
<Вывод>: #FFFFFF; #BFBFBF; #3F3F3F; #000000 
<Example 2>: 
<Тип теста 2>: closed 
<Ввод>: nan 
<Вывод>: #FA8072; #DC143C; #CD5C5C 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: nan 
<Вывод>: nan 
<Решение студента>: punctuation = '!$%&()*+,-./:;<=>?@^_'

data = {}

with open('report.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip('\n')
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for word in line:
            if w[0].startswith('#'):
                if w not in data:
                    data[w] = 1
                else:
                    data[w] += 1
                    
res = []

for k, v in data.items():
    if v >= 2:
        res.append(k)
        
print(*sorted(res, reverse = True), sep='; ') 
<Идеальное решение>: punctuation = '!$%&()*+,-./:;<=>?@^_'

data = {}

with open('report.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip('\n')
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].startswith('#'):
                if w not in data:
                    data[w] = 1
                else:
                    data[w] += 1
                    
res = []

for k, v in data.items():
    if v >= 2:
        res.append(k)
        
print(*sorted(res, reverse = True), sep='; ') 


<Комментарий эксперта>:"
135,375,23,"Роман изучает отчет по объекту, где упоминаются различные цвета, которые использовались в проекте. Помогите определить цвета, которые использовались не менее двух раз.

ФОРМАТ ВВОДА
Текстовый файл report.txt, в котором записан отчет по объекту. Гарантируется, что в тексте только названия цветов начинаются с хэштега (""#""). 
Гарантируется, что пустых строк в файле нет.
Гарантируется, что в файле будет упоминание хотя бы одного цвета.
Также дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.
ФОРМАТ ВЫВОДА
Названия цветов, которые использовались в проекте не менее двух раз. 
Названия должны быть записаны в обратном алфавитном порядке через точку с запятой и пробел.
ДОПОЛНИТЕЛЬНО
В открытом тесте используется файл report.txt  Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Создайте пустой словарь, в который будете записывать цвета и то, сколько раз их использовали в проекте.
Откройте файл в режиме чтения в кодировке utf-8.
Обратитесь к каждой строке в файле и выполните следующие действия:
уберите невидимые символы в конце строки (символ перехода на новую строку);
обратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;
разбейте строку по разделителю, в результате получите список;
обратитесь к каждому элементу в получившемся списке: если первый его элемент — хэштег, тогда это цвет и нужно проверить:
если этого цвета еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.
если такой цвет уже есть в словаре из п.1, то нужно увеличить его значение на 1.
После цикла создайте пустой список — в него нужно будет добавить названия тех цветов, значение которых в словаре больше 1.
Обратитесь к парам ключ-значение в словаре: если значение больше или равно  2, то добавьте ключ в список из п.4.
Отсортируйте список в обратном алфавиту порядке и напечатайте его элементы через точку с запятой и пробел.","[nan, nan, nan]","['#FFFFFF; #BFBFBF; #3F3F3F; #000000', '#FA8072; #DC143C; #CD5C5C', nan]","punctuation = '!$%&()*+,-./:;<=>?@^_'

data = {}

with open('report.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip('\n')
        for p in punctuation
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].startswith('#'):
                if w not in data:
                    data[w] = 1
                else:
                    data[w] += 1
                    
res = []

for k, v in data.items():
    if v >= 2:
        res.append(k)
        
print(*sorted(res, reverse = True), sep='; ')","punctuation = '!$%&()*+,-./:;<=>?@^_'

data = {}

with open('report.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip('\n')
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].startswith('#'):
                if w not in data:
                    data[w] = 1
                else:
                    data[w] += 1
                    
res = []

for k, v in data.items():
    if v >= 2:
        res.append(k)
        
print(*sorted(res, reverse = True), sep='; ')",Вы забыли поставить двоеточие после условия цикла for.,"['open', 'closed', 'closed']","<Task description>: Роман изучает отчет по объекту, где упоминаются различные цвета, которые использовались в проекте. Помогите определить цвета, которые использовались не менее двух раз.

ФОРМАТ ВВОДА
Текстовый файл report.txt, в котором записан отчет по объекту. Гарантируется, что в тексте только названия цветов начинаются с хэштега (""#""). 
Гарантируется, что пустых строк в файле нет.
Гарантируется, что в файле будет упоминание хотя бы одного цвета.
Также дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.
ФОРМАТ ВЫВОДА
Названия цветов, которые использовались в проекте не менее двух раз. 
Названия должны быть записаны в обратном алфавитном порядке через точку с запятой и пробел.
ДОПОЛНИТЕЛЬНО
В открытом тесте используется файл report.txt  Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Создайте пустой словарь, в который будете записывать цвета и то, сколько раз их использовали в проекте.
Откройте файл в режиме чтения в кодировке utf-8.
Обратитесь к каждой строке в файле и выполните следующие действия:
уберите невидимые символы в конце строки (символ перехода на новую строку);
обратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;
разбейте строку по разделителю, в результате получите список;
обратитесь к каждому элементу в получившемся списке: если первый его элемент — хэштег, тогда это цвет и нужно проверить:
если этого цвета еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.
если такой цвет уже есть в словаре из п.1, то нужно увеличить его значение на 1.
После цикла создайте пустой список — в него нужно будет добавить названия тех цветов, значение которых в словаре больше 1.
Обратитесь к парам ключ-значение в словаре: если значение больше или равно  2, то добавьте ключ в список из п.4.
Отсортируйте список в обратном алфавиту порядке и напечатайте его элементы через точку с запятой и пробел. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: nan 
<Вывод>: #FFFFFF; #BFBFBF; #3F3F3F; #000000 
<Example 2>: 
<Тип теста 2>: closed 
<Ввод>: nan 
<Вывод>: #FA8072; #DC143C; #CD5C5C 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: nan 
<Вывод>: nan 
<Решение студента>: punctuation = '!$%&()*+,-./:;<=>?@^_'

data = {}

with open('report.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip('\n')
        for p in punctuation
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].startswith('#'):
                if w not in data:
                    data[w] = 1
                else:
                    data[w] += 1
                    
res = []

for k, v in data.items():
    if v >= 2:
        res.append(k)
        
print(*sorted(res, reverse = True), sep='; ') 
<Идеальное решение>: punctuation = '!$%&()*+,-./:;<=>?@^_'

data = {}

with open('report.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip('\n')
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].startswith('#'):
                if w not in data:
                    data[w] = 1
                else:
                    data[w] += 1
                    
res = []

for k, v in data.items():
    if v >= 2:
        res.append(k)
        
print(*sorted(res, reverse = True), sep='; ') 


<Комментарий эксперта>:"
136,376,23,"Роман изучает отчет по объекту, где упоминаются различные цвета, которые использовались в проекте. Помогите определить цвета, которые использовались не менее двух раз.

ФОРМАТ ВВОДА
Текстовый файл report.txt, в котором записан отчет по объекту. Гарантируется, что в тексте только названия цветов начинаются с хэштега (""#""). 
Гарантируется, что пустых строк в файле нет.
Гарантируется, что в файле будет упоминание хотя бы одного цвета.
Также дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.
ФОРМАТ ВЫВОДА
Названия цветов, которые использовались в проекте не менее двух раз. 
Названия должны быть записаны в обратном алфавитном порядке через точку с запятой и пробел.
ДОПОЛНИТЕЛЬНО
В открытом тесте используется файл report.txt  Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Создайте пустой словарь, в который будете записывать цвета и то, сколько раз их использовали в проекте.
Откройте файл в режиме чтения в кодировке utf-8.
Обратитесь к каждой строке в файле и выполните следующие действия:
уберите невидимые символы в конце строки (символ перехода на новую строку);
обратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;
разбейте строку по разделителю, в результате получите список;
обратитесь к каждому элементу в получившемся списке: если первый его элемент — хэштег, тогда это цвет и нужно проверить:
если этого цвета еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.
если такой цвет уже есть в словаре из п.1, то нужно увеличить его значение на 1.
После цикла создайте пустой список — в него нужно будет добавить названия тех цветов, значение которых в словаре больше 1.
Обратитесь к парам ключ-значение в словаре: если значение больше или равно  2, то добавьте ключ в список из п.4.
Отсортируйте список в обратном алфавиту порядке и напечатайте его элементы через точку с запятой и пробел.","[nan, nan, nan]","['#FFFFFF; #BFBFBF; #3F3F3F; #000000', '#FA8072; #DC143C; #CD5C5C', nan]","punctuation = '!$%&()*+,-./:;<=>?@^_'

data = {}

with open('report.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip('\n')
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[1].startswith('#'):
                if w not in data:
                    data[w] = 1
                else:
                    data[w] += 1
                    
res = []

for k, v in data.items():
    if v >= 2:
        res.append(k)
        
print(*sorted(res, reverse = True), sep='; ')","punctuation = '!$%&()*+,-./:;<=>?@^_'

data = {}

with open('report.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip('\n')
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].startswith('#'):
                if w not in data:
                    data[w] = 1
                else:
                    data[w] += 1
                    
res = []

for k, v in data.items():
    if v >= 2:
        res.append(k)
        
print(*sorted(res, reverse = True), sep='; ')","Ошибка при итерации по символам каждого слова. Помните, что в Python нумерация элементов начинается с 0.","['open', 'closed', 'closed']","<Task description>: Роман изучает отчет по объекту, где упоминаются различные цвета, которые использовались в проекте. Помогите определить цвета, которые использовались не менее двух раз.

ФОРМАТ ВВОДА
Текстовый файл report.txt, в котором записан отчет по объекту. Гарантируется, что в тексте только названия цветов начинаются с хэштега (""#""). 
Гарантируется, что пустых строк в файле нет.
Гарантируется, что в файле будет упоминание хотя бы одного цвета.
Также дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.
ФОРМАТ ВЫВОДА
Названия цветов, которые использовались в проекте не менее двух раз. 
Названия должны быть записаны в обратном алфавитном порядке через точку с запятой и пробел.
ДОПОЛНИТЕЛЬНО
В открытом тесте используется файл report.txt  Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Создайте пустой словарь, в который будете записывать цвета и то, сколько раз их использовали в проекте.
Откройте файл в режиме чтения в кодировке utf-8.
Обратитесь к каждой строке в файле и выполните следующие действия:
уберите невидимые символы в конце строки (символ перехода на новую строку);
обратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;
разбейте строку по разделителю, в результате получите список;
обратитесь к каждому элементу в получившемся списке: если первый его элемент — хэштег, тогда это цвет и нужно проверить:
если этого цвета еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.
если такой цвет уже есть в словаре из п.1, то нужно увеличить его значение на 1.
После цикла создайте пустой список — в него нужно будет добавить названия тех цветов, значение которых в словаре больше 1.
Обратитесь к парам ключ-значение в словаре: если значение больше или равно  2, то добавьте ключ в список из п.4.
Отсортируйте список в обратном алфавиту порядке и напечатайте его элементы через точку с запятой и пробел. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: nan 
<Вывод>: #FFFFFF; #BFBFBF; #3F3F3F; #000000 
<Example 2>: 
<Тип теста 2>: closed 
<Ввод>: nan 
<Вывод>: #FA8072; #DC143C; #CD5C5C 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: nan 
<Вывод>: nan 
<Решение студента>: punctuation = '!$%&()*+,-./:;<=>?@^_'

data = {}

with open('report.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip('\n')
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[1].startswith('#'):
                if w not in data:
                    data[w] = 1
                else:
                    data[w] += 1
                    
res = []

for k, v in data.items():
    if v >= 2:
        res.append(k)
        
print(*sorted(res, reverse = True), sep='; ') 
<Идеальное решение>: punctuation = '!$%&()*+,-./:;<=>?@^_'

data = {}

with open('report.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip('\n')
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].startswith('#'):
                if w not in data:
                    data[w] = 1
                else:
                    data[w] += 1
                    
res = []

for k, v in data.items():
    if v >= 2:
        res.append(k)
        
print(*sorted(res, reverse = True), sep='; ') 


<Комментарий эксперта>:"
137,377,23,"Роман изучает отчет по объекту, где упоминаются различные цвета, которые использовались в проекте. Помогите определить цвета, которые использовались не менее двух раз.

ФОРМАТ ВВОДА
Текстовый файл report.txt, в котором записан отчет по объекту. Гарантируется, что в тексте только названия цветов начинаются с хэштега (""#""). 
Гарантируется, что пустых строк в файле нет.
Гарантируется, что в файле будет упоминание хотя бы одного цвета.
Также дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.
ФОРМАТ ВЫВОДА
Названия цветов, которые использовались в проекте не менее двух раз. 
Названия должны быть записаны в обратном алфавитном порядке через точку с запятой и пробел.
ДОПОЛНИТЕЛЬНО
В открытом тесте используется файл report.txt  Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Создайте пустой словарь, в который будете записывать цвета и то, сколько раз их использовали в проекте.
Откройте файл в режиме чтения в кодировке utf-8.
Обратитесь к каждой строке в файле и выполните следующие действия:
уберите невидимые символы в конце строки (символ перехода на новую строку);
обратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;
разбейте строку по разделителю, в результате получите список;
обратитесь к каждому элементу в получившемся списке: если первый его элемент — хэштег, тогда это цвет и нужно проверить:
если этого цвета еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.
если такой цвет уже есть в словаре из п.1, то нужно увеличить его значение на 1.
После цикла создайте пустой список — в него нужно будет добавить названия тех цветов, значение которых в словаре больше 1.
Обратитесь к парам ключ-значение в словаре: если значение больше или равно  2, то добавьте ключ в список из п.4.
Отсортируйте список в обратном алфавиту порядке и напечатайте его элементы через точку с запятой и пробел.","[nan, nan, nan]","['#FFFFFF; #BFBFBF; #3F3F3F; #000000', '#FA8072; #DC143C; #CD5C5C', nan]","punctuation = '!$%&()*+,-./:;<=>?@^_'

data = {}

with open('report.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip('\n')
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].startswith(#):
                if w not in data:
                    data[w] = 1
                else:
                    data[w] += 1
                    
res = []

for k, v in data.items():
    if v >= 2:
        res.append(k)
        
print(*sorted(res, reverse = True), sep='; ')","punctuation = '!$%&()*+,-./:;<=>?@^_'

data = {}

with open('report.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip('\n')
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].startswith('#'):
                if w not in data:
                    data[w] = 1
                else:
                    data[w] += 1
                    
res = []

for k, v in data.items():
    if v >= 2:
        res.append(k)
        
print(*sorted(res, reverse = True), sep='; ')","Синтаксическая ошибка. Вы забыли заключить знак ""#"" в кавычки.","['open', 'closed', 'closed']","<Task description>: Роман изучает отчет по объекту, где упоминаются различные цвета, которые использовались в проекте. Помогите определить цвета, которые использовались не менее двух раз.

ФОРМАТ ВВОДА
Текстовый файл report.txt, в котором записан отчет по объекту. Гарантируется, что в тексте только названия цветов начинаются с хэштега (""#""). 
Гарантируется, что пустых строк в файле нет.
Гарантируется, что в файле будет упоминание хотя бы одного цвета.
Также дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.
ФОРМАТ ВЫВОДА
Названия цветов, которые использовались в проекте не менее двух раз. 
Названия должны быть записаны в обратном алфавитном порядке через точку с запятой и пробел.
ДОПОЛНИТЕЛЬНО
В открытом тесте используется файл report.txt  Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Создайте пустой словарь, в который будете записывать цвета и то, сколько раз их использовали в проекте.
Откройте файл в режиме чтения в кодировке utf-8.
Обратитесь к каждой строке в файле и выполните следующие действия:
уберите невидимые символы в конце строки (символ перехода на новую строку);
обратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;
разбейте строку по разделителю, в результате получите список;
обратитесь к каждому элементу в получившемся списке: если первый его элемент — хэштег, тогда это цвет и нужно проверить:
если этого цвета еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.
если такой цвет уже есть в словаре из п.1, то нужно увеличить его значение на 1.
После цикла создайте пустой список — в него нужно будет добавить названия тех цветов, значение которых в словаре больше 1.
Обратитесь к парам ключ-значение в словаре: если значение больше или равно  2, то добавьте ключ в список из п.4.
Отсортируйте список в обратном алфавиту порядке и напечатайте его элементы через точку с запятой и пробел. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: nan 
<Вывод>: #FFFFFF; #BFBFBF; #3F3F3F; #000000 
<Example 2>: 
<Тип теста 2>: closed 
<Ввод>: nan 
<Вывод>: #FA8072; #DC143C; #CD5C5C 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: nan 
<Вывод>: nan 
<Решение студента>: punctuation = '!$%&()*+,-./:;<=>?@^_'

data = {}

with open('report.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip('\n')
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].startswith(#):
                if w not in data:
                    data[w] = 1
                else:
                    data[w] += 1
                    
res = []

for k, v in data.items():
    if v >= 2:
        res.append(k)
        
print(*sorted(res, reverse = True), sep='; ') 
<Идеальное решение>: punctuation = '!$%&()*+,-./:;<=>?@^_'

data = {}

with open('report.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip('\n')
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].startswith('#'):
                if w not in data:
                    data[w] = 1
                else:
                    data[w] += 1
                    
res = []

for k, v in data.items():
    if v >= 2:
        res.append(k)
        
print(*sorted(res, reverse = True), sep='; ') 


<Комментарий эксперта>:"
138,378,23,"Роман изучает отчет по объекту, где упоминаются различные цвета, которые использовались в проекте. Помогите определить цвета, которые использовались не менее двух раз.

ФОРМАТ ВВОДА
Текстовый файл report.txt, в котором записан отчет по объекту. Гарантируется, что в тексте только названия цветов начинаются с хэштега (""#""). 
Гарантируется, что пустых строк в файле нет.
Гарантируется, что в файле будет упоминание хотя бы одного цвета.
Также дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.
ФОРМАТ ВЫВОДА
Названия цветов, которые использовались в проекте не менее двух раз. 
Названия должны быть записаны в обратном алфавитном порядке через точку с запятой и пробел.
ДОПОЛНИТЕЛЬНО
В открытом тесте используется файл report.txt  Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Создайте пустой словарь, в который будете записывать цвета и то, сколько раз их использовали в проекте.
Откройте файл в режиме чтения в кодировке utf-8.
Обратитесь к каждой строке в файле и выполните следующие действия:
уберите невидимые символы в конце строки (символ перехода на новую строку);
обратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;
разбейте строку по разделителю, в результате получите список;
обратитесь к каждому элементу в получившемся списке: если первый его элемент — хэштег, тогда это цвет и нужно проверить:
если этого цвета еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.
если такой цвет уже есть в словаре из п.1, то нужно увеличить его значение на 1.
После цикла создайте пустой список — в него нужно будет добавить названия тех цветов, значение которых в словаре больше 1.
Обратитесь к парам ключ-значение в словаре: если значение больше или равно  2, то добавьте ключ в список из п.4.
Отсортируйте список в обратном алфавиту порядке и напечатайте его элементы через точку с запятой и пробел.","[nan, nan, nan]","['#FFFFFF; #BFBFBF; #3F3F3F; #000000', '#FA8072; #DC143C; #CD5C5C', nan]","punctuation = '!$%&()*+,-./:;<=>?@^_'

data = {}

with open('report.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip('\n')
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].isalnum():
                if w not in data:
                    data[w] = 1
                else:
                    data[w] += 1
                    
res = []

for k, v in data.items():
    if v >= 2:
        res.append(k)
        
print(*sorted(res, reverse = True), sep='; ')","punctuation = '!$%&()*+,-./:;<=>?@^_'

data = {}

with open('report.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip('\n')
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].startswith('#'):
                if w not in data:
                    data[w] = 1
                else:
                    data[w] += 1
                    
res = []

for k, v in data.items():
    if v >= 2:
        res.append(k)
        
print(*sorted(res, reverse = True), sep='; ')","Ошибка в открытых и скрытых тестах. 

Ваш код некорректно обрабатывает данные. Ваш код некорректно работает с условием ""названия цветов начинаются с хэштега (""#"")"". Попробуйте изменить метод анализа первого символа каждого слова, чтобы скорректировать ошибку.","['open', 'closed', 'closed']","<Task description>: Роман изучает отчет по объекту, где упоминаются различные цвета, которые использовались в проекте. Помогите определить цвета, которые использовались не менее двух раз.

ФОРМАТ ВВОДА
Текстовый файл report.txt, в котором записан отчет по объекту. Гарантируется, что в тексте только названия цветов начинаются с хэштега (""#""). 
Гарантируется, что пустых строк в файле нет.
Гарантируется, что в файле будет упоминание хотя бы одного цвета.
Также дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.
ФОРМАТ ВЫВОДА
Названия цветов, которые использовались в проекте не менее двух раз. 
Названия должны быть записаны в обратном алфавитном порядке через точку с запятой и пробел.
ДОПОЛНИТЕЛЬНО
В открытом тесте используется файл report.txt  Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Создайте пустой словарь, в который будете записывать цвета и то, сколько раз их использовали в проекте.
Откройте файл в режиме чтения в кодировке utf-8.
Обратитесь к каждой строке в файле и выполните следующие действия:
уберите невидимые символы в конце строки (символ перехода на новую строку);
обратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;
разбейте строку по разделителю, в результате получите список;
обратитесь к каждому элементу в получившемся списке: если первый его элемент — хэштег, тогда это цвет и нужно проверить:
если этого цвета еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.
если такой цвет уже есть в словаре из п.1, то нужно увеличить его значение на 1.
После цикла создайте пустой список — в него нужно будет добавить названия тех цветов, значение которых в словаре больше 1.
Обратитесь к парам ключ-значение в словаре: если значение больше или равно  2, то добавьте ключ в список из п.4.
Отсортируйте список в обратном алфавиту порядке и напечатайте его элементы через точку с запятой и пробел. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: nan 
<Вывод>: #FFFFFF; #BFBFBF; #3F3F3F; #000000 
<Example 2>: 
<Тип теста 2>: closed 
<Ввод>: nan 
<Вывод>: #FA8072; #DC143C; #CD5C5C 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: nan 
<Вывод>: nan 
<Решение студента>: punctuation = '!$%&()*+,-./:;<=>?@^_'

data = {}

with open('report.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip('\n')
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].isalnum():
                if w not in data:
                    data[w] = 1
                else:
                    data[w] += 1
                    
res = []

for k, v in data.items():
    if v >= 2:
        res.append(k)
        
print(*sorted(res, reverse = True), sep='; ') 
<Идеальное решение>: punctuation = '!$%&()*+,-./:;<=>?@^_'

data = {}

with open('report.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip('\n')
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].startswith('#'):
                if w not in data:
                    data[w] = 1
                else:
                    data[w] += 1
                    
res = []

for k, v in data.items():
    if v >= 2:
        res.append(k)
        
print(*sorted(res, reverse = True), sep='; ') 


<Комментарий эксперта>:"
139,379,23,"Роман изучает отчет по объекту, где упоминаются различные цвета, которые использовались в проекте. Помогите определить цвета, которые использовались не менее двух раз.

ФОРМАТ ВВОДА
Текстовый файл report.txt, в котором записан отчет по объекту. Гарантируется, что в тексте только названия цветов начинаются с хэштега (""#""). 
Гарантируется, что пустых строк в файле нет.
Гарантируется, что в файле будет упоминание хотя бы одного цвета.
Также дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.
ФОРМАТ ВЫВОДА
Названия цветов, которые использовались в проекте не менее двух раз. 
Названия должны быть записаны в обратном алфавитном порядке через точку с запятой и пробел.
ДОПОЛНИТЕЛЬНО
В открытом тесте используется файл report.txt  Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Создайте пустой словарь, в который будете записывать цвета и то, сколько раз их использовали в проекте.
Откройте файл в режиме чтения в кодировке utf-8.
Обратитесь к каждой строке в файле и выполните следующие действия:
уберите невидимые символы в конце строки (символ перехода на новую строку);
обратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;
разбейте строку по разделителю, в результате получите список;
обратитесь к каждому элементу в получившемся списке: если первый его элемент — хэштег, тогда это цвет и нужно проверить:
если этого цвета еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.
если такой цвет уже есть в словаре из п.1, то нужно увеличить его значение на 1.
После цикла создайте пустой список — в него нужно будет добавить названия тех цветов, значение которых в словаре больше 1.
Обратитесь к парам ключ-значение в словаре: если значение больше или равно  2, то добавьте ключ в список из п.4.
Отсортируйте список в обратном алфавиту порядке и напечатайте его элементы через точку с запятой и пробел.","[nan, nan, nan]","['#FFFFFF; #BFBFBF; #3F3F3F; #000000', '#FA8072; #DC143C; #CD5C5C', nan]","punctuation = '!$%&()*+,-./:;<=>?@^_'

data = {}

with open('report.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip('\n')
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].startswith('#'):
                if w in data:
                    data[w] = 1
                else:
                    data[w] += 1
                    
res = []

for k, v in data.items():
    if v >= 2:
        res.append(k)
        
print(*sorted(res, reverse = True), sep='; ')","punctuation = '!$%&()*+,-./:;<=>?@^_'

data = {}

with open('report.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip('\n')
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].startswith('#'):
                if w not in data:
                    data[w] = 1
                else:
                    data[w] += 1
                    
res = []

for k, v in data.items():
    if v >= 2:
        res.append(k)
        
print(*sorted(res, reverse = True), sep='; ')","Ошибка при добавлении данных в словарь. Скорректируйте код таким образом, чтобы в словарь добавлялись только те ключи, которые ранее добавлены не были.","['open', 'closed', 'closed']","<Task description>: Роман изучает отчет по объекту, где упоминаются различные цвета, которые использовались в проекте. Помогите определить цвета, которые использовались не менее двух раз.

ФОРМАТ ВВОДА
Текстовый файл report.txt, в котором записан отчет по объекту. Гарантируется, что в тексте только названия цветов начинаются с хэштега (""#""). 
Гарантируется, что пустых строк в файле нет.
Гарантируется, что в файле будет упоминание хотя бы одного цвета.
Также дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.
ФОРМАТ ВЫВОДА
Названия цветов, которые использовались в проекте не менее двух раз. 
Названия должны быть записаны в обратном алфавитном порядке через точку с запятой и пробел.
ДОПОЛНИТЕЛЬНО
В открытом тесте используется файл report.txt  Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Создайте пустой словарь, в который будете записывать цвета и то, сколько раз их использовали в проекте.
Откройте файл в режиме чтения в кодировке utf-8.
Обратитесь к каждой строке в файле и выполните следующие действия:
уберите невидимые символы в конце строки (символ перехода на новую строку);
обратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;
разбейте строку по разделителю, в результате получите список;
обратитесь к каждому элементу в получившемся списке: если первый его элемент — хэштег, тогда это цвет и нужно проверить:
если этого цвета еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.
если такой цвет уже есть в словаре из п.1, то нужно увеличить его значение на 1.
После цикла создайте пустой список — в него нужно будет добавить названия тех цветов, значение которых в словаре больше 1.
Обратитесь к парам ключ-значение в словаре: если значение больше или равно  2, то добавьте ключ в список из п.4.
Отсортируйте список в обратном алфавиту порядке и напечатайте его элементы через точку с запятой и пробел. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: nan 
<Вывод>: #FFFFFF; #BFBFBF; #3F3F3F; #000000 
<Example 2>: 
<Тип теста 2>: closed 
<Ввод>: nan 
<Вывод>: #FA8072; #DC143C; #CD5C5C 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: nan 
<Вывод>: nan 
<Решение студента>: punctuation = '!$%&()*+,-./:;<=>?@^_'

data = {}

with open('report.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip('\n')
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].startswith('#'):
                if w in data:
                    data[w] = 1
                else:
                    data[w] += 1
                    
res = []

for k, v in data.items():
    if v >= 2:
        res.append(k)
        
print(*sorted(res, reverse = True), sep='; ') 
<Идеальное решение>: punctuation = '!$%&()*+,-./:;<=>?@^_'

data = {}

with open('report.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip('\n')
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].startswith('#'):
                if w not in data:
                    data[w] = 1
                else:
                    data[w] += 1
                    
res = []

for k, v in data.items():
    if v >= 2:
        res.append(k)
        
print(*sorted(res, reverse = True), sep='; ') 


<Комментарий эксперта>:"
140,380,23,"Роман изучает отчет по объекту, где упоминаются различные цвета, которые использовались в проекте. Помогите определить цвета, которые использовались не менее двух раз.

ФОРМАТ ВВОДА
Текстовый файл report.txt, в котором записан отчет по объекту. Гарантируется, что в тексте только названия цветов начинаются с хэштега (""#""). 
Гарантируется, что пустых строк в файле нет.
Гарантируется, что в файле будет упоминание хотя бы одного цвета.
Также дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.
ФОРМАТ ВЫВОДА
Названия цветов, которые использовались в проекте не менее двух раз. 
Названия должны быть записаны в обратном алфавитном порядке через точку с запятой и пробел.
ДОПОЛНИТЕЛЬНО
В открытом тесте используется файл report.txt  Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Создайте пустой словарь, в который будете записывать цвета и то, сколько раз их использовали в проекте.
Откройте файл в режиме чтения в кодировке utf-8.
Обратитесь к каждой строке в файле и выполните следующие действия:
уберите невидимые символы в конце строки (символ перехода на новую строку);
обратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;
разбейте строку по разделителю, в результате получите список;
обратитесь к каждому элементу в получившемся списке: если первый его элемент — хэштег, тогда это цвет и нужно проверить:
если этого цвета еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.
если такой цвет уже есть в словаре из п.1, то нужно увеличить его значение на 1.
После цикла создайте пустой список — в него нужно будет добавить названия тех цветов, значение которых в словаре больше 1.
Обратитесь к парам ключ-значение в словаре: если значение больше или равно  2, то добавьте ключ в список из п.4.
Отсортируйте список в обратном алфавиту порядке и напечатайте его элементы через точку с запятой и пробел.","[nan, nan, nan]","['#FFFFFF; #BFBFBF; #3F3F3F; #000000', '#FA8072; #DC143C; #CD5C5C', nan]","punctuation = '!$%&()*+,-./:;<=>?@^_'

data = {}

with open('report.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip('\n')
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].startswith('#'):
                if w not in data:
                    data[w] = 1
                else:
                    data[w] += 1
                    
res = []

for k, v in data:
    if v >= 2:
        res.append(k)
        
print(*sorted(res, reverse = True), sep='; ')","punctuation = '!$%&()*+,-./:;<=>?@^_'

data = {}

with open('report.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip('\n')
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].startswith('#'):
                if w not in data:
                    data[w] = 1
                else:
                    data[w] += 1
                    
res = []

for k, v in data.items():
    if v >= 2:
        res.append(k)
        
print(*sorted(res, reverse = True), sep='; ')","Ошибка при обращении к элементам словаря data. Попытка обратиться к двум значениям, вместо одного. Используйте опреатор .items().","['open', 'closed', 'closed']","<Task description>: Роман изучает отчет по объекту, где упоминаются различные цвета, которые использовались в проекте. Помогите определить цвета, которые использовались не менее двух раз.

ФОРМАТ ВВОДА
Текстовый файл report.txt, в котором записан отчет по объекту. Гарантируется, что в тексте только названия цветов начинаются с хэштега (""#""). 
Гарантируется, что пустых строк в файле нет.
Гарантируется, что в файле будет упоминание хотя бы одного цвета.
Также дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.
ФОРМАТ ВЫВОДА
Названия цветов, которые использовались в проекте не менее двух раз. 
Названия должны быть записаны в обратном алфавитном порядке через точку с запятой и пробел.
ДОПОЛНИТЕЛЬНО
В открытом тесте используется файл report.txt  Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Создайте пустой словарь, в который будете записывать цвета и то, сколько раз их использовали в проекте.
Откройте файл в режиме чтения в кодировке utf-8.
Обратитесь к каждой строке в файле и выполните следующие действия:
уберите невидимые символы в конце строки (символ перехода на новую строку);
обратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;
разбейте строку по разделителю, в результате получите список;
обратитесь к каждому элементу в получившемся списке: если первый его элемент — хэштег, тогда это цвет и нужно проверить:
если этого цвета еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.
если такой цвет уже есть в словаре из п.1, то нужно увеличить его значение на 1.
После цикла создайте пустой список — в него нужно будет добавить названия тех цветов, значение которых в словаре больше 1.
Обратитесь к парам ключ-значение в словаре: если значение больше или равно  2, то добавьте ключ в список из п.4.
Отсортируйте список в обратном алфавиту порядке и напечатайте его элементы через точку с запятой и пробел. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: nan 
<Вывод>: #FFFFFF; #BFBFBF; #3F3F3F; #000000 
<Example 2>: 
<Тип теста 2>: closed 
<Ввод>: nan 
<Вывод>: #FA8072; #DC143C; #CD5C5C 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: nan 
<Вывод>: nan 
<Решение студента>: punctuation = '!$%&()*+,-./:;<=>?@^_'

data = {}

with open('report.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip('\n')
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].startswith('#'):
                if w not in data:
                    data[w] = 1
                else:
                    data[w] += 1
                    
res = []

for k, v in data:
    if v >= 2:
        res.append(k)
        
print(*sorted(res, reverse = True), sep='; ') 
<Идеальное решение>: punctuation = '!$%&()*+,-./:;<=>?@^_'

data = {}

with open('report.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip('\n')
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].startswith('#'):
                if w not in data:
                    data[w] = 1
                else:
                    data[w] += 1
                    
res = []

for k, v in data.items():
    if v >= 2:
        res.append(k)
        
print(*sorted(res, reverse = True), sep='; ') 


<Комментарий эксперта>:"
141,381,23,"Роман изучает отчет по объекту, где упоминаются различные цвета, которые использовались в проекте. Помогите определить цвета, которые использовались не менее двух раз.

ФОРМАТ ВВОДА
Текстовый файл report.txt, в котором записан отчет по объекту. Гарантируется, что в тексте только названия цветов начинаются с хэштега (""#""). 
Гарантируется, что пустых строк в файле нет.
Гарантируется, что в файле будет упоминание хотя бы одного цвета.
Также дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.
ФОРМАТ ВЫВОДА
Названия цветов, которые использовались в проекте не менее двух раз. 
Названия должны быть записаны в обратном алфавитном порядке через точку с запятой и пробел.
ДОПОЛНИТЕЛЬНО
В открытом тесте используется файл report.txt  Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Создайте пустой словарь, в который будете записывать цвета и то, сколько раз их использовали в проекте.
Откройте файл в режиме чтения в кодировке utf-8.
Обратитесь к каждой строке в файле и выполните следующие действия:
уберите невидимые символы в конце строки (символ перехода на новую строку);
обратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;
разбейте строку по разделителю, в результате получите список;
обратитесь к каждому элементу в получившемся списке: если первый его элемент — хэштег, тогда это цвет и нужно проверить:
если этого цвета еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.
если такой цвет уже есть в словаре из п.1, то нужно увеличить его значение на 1.
После цикла создайте пустой список — в него нужно будет добавить названия тех цветов, значение которых в словаре больше 1.
Обратитесь к парам ключ-значение в словаре: если значение больше или равно  2, то добавьте ключ в список из п.4.
Отсортируйте список в обратном алфавиту порядке и напечатайте его элементы через точку с запятой и пробел.","[nan, nan, nan]","['#FFFFFF; #BFBFBF; #3F3F3F; #000000', '#FA8072; #DC143C; #CD5C5C', nan]","punctuation = '!$%&()*+,-./:;<=>?@^_'

data = {}

with open('report.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip('\n')
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].startswith('#'):
                if w not in data:
                    data[w] = 1
                else:
                    data[w] += 1
                    
res = []

for k, v in data.items():
    if k >= 2:
        res.append(v)
        
print(*sorted(res, reverse = True), sep='; ')","punctuation = '!$%&()*+,-./:;<=>?@^_'

data = {}

with open('report.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip('\n')
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].startswith('#'):
                if w not in data:
                    data[w] = 1
                else:
                    data[w] += 1
                    
res = []

for k, v in data.items():
    if v >= 2:
        res.append(k)
        
print(*sorted(res, reverse = True), sep='; ')",Вы обращаетесь к неверной переменной пары ключ-значение.,"['open', 'closed', 'closed']","<Task description>: Роман изучает отчет по объекту, где упоминаются различные цвета, которые использовались в проекте. Помогите определить цвета, которые использовались не менее двух раз.

ФОРМАТ ВВОДА
Текстовый файл report.txt, в котором записан отчет по объекту. Гарантируется, что в тексте только названия цветов начинаются с хэштега (""#""). 
Гарантируется, что пустых строк в файле нет.
Гарантируется, что в файле будет упоминание хотя бы одного цвета.
Также дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.
ФОРМАТ ВЫВОДА
Названия цветов, которые использовались в проекте не менее двух раз. 
Названия должны быть записаны в обратном алфавитном порядке через точку с запятой и пробел.
ДОПОЛНИТЕЛЬНО
В открытом тесте используется файл report.txt  Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Создайте пустой словарь, в который будете записывать цвета и то, сколько раз их использовали в проекте.
Откройте файл в режиме чтения в кодировке utf-8.
Обратитесь к каждой строке в файле и выполните следующие действия:
уберите невидимые символы в конце строки (символ перехода на новую строку);
обратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;
разбейте строку по разделителю, в результате получите список;
обратитесь к каждому элементу в получившемся списке: если первый его элемент — хэштег, тогда это цвет и нужно проверить:
если этого цвета еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.
если такой цвет уже есть в словаре из п.1, то нужно увеличить его значение на 1.
После цикла создайте пустой список — в него нужно будет добавить названия тех цветов, значение которых в словаре больше 1.
Обратитесь к парам ключ-значение в словаре: если значение больше или равно  2, то добавьте ключ в список из п.4.
Отсортируйте список в обратном алфавиту порядке и напечатайте его элементы через точку с запятой и пробел. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: nan 
<Вывод>: #FFFFFF; #BFBFBF; #3F3F3F; #000000 
<Example 2>: 
<Тип теста 2>: closed 
<Ввод>: nan 
<Вывод>: #FA8072; #DC143C; #CD5C5C 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: nan 
<Вывод>: nan 
<Решение студента>: punctuation = '!$%&()*+,-./:;<=>?@^_'

data = {}

with open('report.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip('\n')
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].startswith('#'):
                if w not in data:
                    data[w] = 1
                else:
                    data[w] += 1
                    
res = []

for k, v in data.items():
    if k >= 2:
        res.append(v)
        
print(*sorted(res, reverse = True), sep='; ') 
<Идеальное решение>: punctuation = '!$%&()*+,-./:;<=>?@^_'

data = {}

with open('report.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip('\n')
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].startswith('#'):
                if w not in data:
                    data[w] = 1
                else:
                    data[w] += 1
                    
res = []

for k, v in data.items():
    if v >= 2:
        res.append(k)
        
print(*sorted(res, reverse = True), sep='; ') 


<Комментарий эксперта>:"
142,382,23,"Роман изучает отчет по объекту, где упоминаются различные цвета, которые использовались в проекте. Помогите определить цвета, которые использовались не менее двух раз.

ФОРМАТ ВВОДА
Текстовый файл report.txt, в котором записан отчет по объекту. Гарантируется, что в тексте только названия цветов начинаются с хэштега (""#""). 
Гарантируется, что пустых строк в файле нет.
Гарантируется, что в файле будет упоминание хотя бы одного цвета.
Также дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.
ФОРМАТ ВЫВОДА
Названия цветов, которые использовались в проекте не менее двух раз. 
Названия должны быть записаны в обратном алфавитном порядке через точку с запятой и пробел.
ДОПОЛНИТЕЛЬНО
В открытом тесте используется файл report.txt  Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Создайте пустой словарь, в который будете записывать цвета и то, сколько раз их использовали в проекте.
Откройте файл в режиме чтения в кодировке utf-8.
Обратитесь к каждой строке в файле и выполните следующие действия:
уберите невидимые символы в конце строки (символ перехода на новую строку);
обратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;
разбейте строку по разделителю, в результате получите список;
обратитесь к каждому элементу в получившемся списке: если первый его элемент — хэштег, тогда это цвет и нужно проверить:
если этого цвета еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.
если такой цвет уже есть в словаре из п.1, то нужно увеличить его значение на 1.
После цикла создайте пустой список — в него нужно будет добавить названия тех цветов, значение которых в словаре больше 1.
Обратитесь к парам ключ-значение в словаре: если значение больше или равно  2, то добавьте ключ в список из п.4.
Отсортируйте список в обратном алфавиту порядке и напечатайте его элементы через точку с запятой и пробел.","[nan, nan, nan]","['#FFFFFF; #BFBFBF; #3F3F3F; #000000', '#FA8072; #DC143C; #CD5C5C', nan]","punctuation = '!$%&()*+,-./:;<=>?@^_'

data = {}

with open('report.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip('\n')
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].startswith('#'):
                if w not in data:
                    data[w] = 1
                else:
                    data[w] += 1
                    
res = []

for k, v in data.items():
    if v > 2:
        res.append(k)
        
print(*sorted(res, reverse = True), sep='; ')","punctuation = '!$%&()*+,-./:;<=>?@^_'

data = {}

with open('report.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip('\n')
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].startswith('#'):
                if w not in data:
                    data[w] = 1
                else:
                    data[w] += 1
                    
res = []

for k, v in data.items():
    if v >= 2:
        res.append(k)
        
print(*sorted(res, reverse = True), sep='; ')","Ошибка в открытых и скрытых тестах. 

Ваш код некорректно выполняет условия задания. Так, он некорректно выполянет условия ""выведите названия цветов, которые использовались в проекте не менее двух раз"". Попробуйте изменить условие if для исправления ошибки.","['open', 'closed', 'closed']","<Task description>: Роман изучает отчет по объекту, где упоминаются различные цвета, которые использовались в проекте. Помогите определить цвета, которые использовались не менее двух раз.

ФОРМАТ ВВОДА
Текстовый файл report.txt, в котором записан отчет по объекту. Гарантируется, что в тексте только названия цветов начинаются с хэштега (""#""). 
Гарантируется, что пустых строк в файле нет.
Гарантируется, что в файле будет упоминание хотя бы одного цвета.
Также дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.
ФОРМАТ ВЫВОДА
Названия цветов, которые использовались в проекте не менее двух раз. 
Названия должны быть записаны в обратном алфавитном порядке через точку с запятой и пробел.
ДОПОЛНИТЕЛЬНО
В открытом тесте используется файл report.txt  Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Создайте пустой словарь, в который будете записывать цвета и то, сколько раз их использовали в проекте.
Откройте файл в режиме чтения в кодировке utf-8.
Обратитесь к каждой строке в файле и выполните следующие действия:
уберите невидимые символы в конце строки (символ перехода на новую строку);
обратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;
разбейте строку по разделителю, в результате получите список;
обратитесь к каждому элементу в получившемся списке: если первый его элемент — хэштег, тогда это цвет и нужно проверить:
если этого цвета еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.
если такой цвет уже есть в словаре из п.1, то нужно увеличить его значение на 1.
После цикла создайте пустой список — в него нужно будет добавить названия тех цветов, значение которых в словаре больше 1.
Обратитесь к парам ключ-значение в словаре: если значение больше или равно  2, то добавьте ключ в список из п.4.
Отсортируйте список в обратном алфавиту порядке и напечатайте его элементы через точку с запятой и пробел. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: nan 
<Вывод>: #FFFFFF; #BFBFBF; #3F3F3F; #000000 
<Example 2>: 
<Тип теста 2>: closed 
<Ввод>: nan 
<Вывод>: #FA8072; #DC143C; #CD5C5C 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: nan 
<Вывод>: nan 
<Решение студента>: punctuation = '!$%&()*+,-./:;<=>?@^_'

data = {}

with open('report.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip('\n')
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].startswith('#'):
                if w not in data:
                    data[w] = 1
                else:
                    data[w] += 1
                    
res = []

for k, v in data.items():
    if v > 2:
        res.append(k)
        
print(*sorted(res, reverse = True), sep='; ') 
<Идеальное решение>: punctuation = '!$%&()*+,-./:;<=>?@^_'

data = {}

with open('report.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip('\n')
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].startswith('#'):
                if w not in data:
                    data[w] = 1
                else:
                    data[w] += 1
                    
res = []

for k, v in data.items():
    if v >= 2:
        res.append(k)
        
print(*sorted(res, reverse = True), sep='; ') 


<Комментарий эксперта>:"
143,383,23,"Роман изучает отчет по объекту, где упоминаются различные цвета, которые использовались в проекте. Помогите определить цвета, которые использовались не менее двух раз.

ФОРМАТ ВВОДА
Текстовый файл report.txt, в котором записан отчет по объекту. Гарантируется, что в тексте только названия цветов начинаются с хэштега (""#""). 
Гарантируется, что пустых строк в файле нет.
Гарантируется, что в файле будет упоминание хотя бы одного цвета.
Также дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.
ФОРМАТ ВЫВОДА
Названия цветов, которые использовались в проекте не менее двух раз. 
Названия должны быть записаны в обратном алфавитном порядке через точку с запятой и пробел.
ДОПОЛНИТЕЛЬНО
В открытом тесте используется файл report.txt  Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Создайте пустой словарь, в который будете записывать цвета и то, сколько раз их использовали в проекте.
Откройте файл в режиме чтения в кодировке utf-8.
Обратитесь к каждой строке в файле и выполните следующие действия:
уберите невидимые символы в конце строки (символ перехода на новую строку);
обратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;
разбейте строку по разделителю, в результате получите список;
обратитесь к каждому элементу в получившемся списке: если первый его элемент — хэштег, тогда это цвет и нужно проверить:
если этого цвета еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.
если такой цвет уже есть в словаре из п.1, то нужно увеличить его значение на 1.
После цикла создайте пустой список — в него нужно будет добавить названия тех цветов, значение которых в словаре больше 1.
Обратитесь к парам ключ-значение в словаре: если значение больше или равно  2, то добавьте ключ в список из п.4.
Отсортируйте список в обратном алфавиту порядке и напечатайте его элементы через точку с запятой и пробел.","[nan, nan, nan]","['#FFFFFF; #BFBFBF; #3F3F3F; #000000', '#FA8072; #DC143C; #CD5C5C', nan]","punctuation = '!$%&()*+,-./:;<=>?@^_'

data = {}

with open('report.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip('\n')
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].startswith('#'):
                if w not in data:
                    data[w] = 1
                else:
                    data[w] += 1
                    
res = []

for k, v in data.items():
    if v >= 2:
        res.add(k)
        
print(*sorted(res, reverse = True), sep='; ')","punctuation = '!$%&()*+,-./:;<=>?@^_'

data = {}

with open('report.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip('\n')
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].startswith('#'):
                if w not in data:
                    data[w] = 1
                else:
                    data[w] += 1
                    
res = []

for k, v in data.items():
    if v >= 2:
        res.append(k)
        
print(*sorted(res, reverse = True), sep='; ')",Некорректно использован метод добавления элементов в список. Список не имеет метода .add().,"['open', 'closed', 'closed']","<Task description>: Роман изучает отчет по объекту, где упоминаются различные цвета, которые использовались в проекте. Помогите определить цвета, которые использовались не менее двух раз.

ФОРМАТ ВВОДА
Текстовый файл report.txt, в котором записан отчет по объекту. Гарантируется, что в тексте только названия цветов начинаются с хэштега (""#""). 
Гарантируется, что пустых строк в файле нет.
Гарантируется, что в файле будет упоминание хотя бы одного цвета.
Также дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.
ФОРМАТ ВЫВОДА
Названия цветов, которые использовались в проекте не менее двух раз. 
Названия должны быть записаны в обратном алфавитном порядке через точку с запятой и пробел.
ДОПОЛНИТЕЛЬНО
В открытом тесте используется файл report.txt  Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Создайте пустой словарь, в который будете записывать цвета и то, сколько раз их использовали в проекте.
Откройте файл в режиме чтения в кодировке utf-8.
Обратитесь к каждой строке в файле и выполните следующие действия:
уберите невидимые символы в конце строки (символ перехода на новую строку);
обратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;
разбейте строку по разделителю, в результате получите список;
обратитесь к каждому элементу в получившемся списке: если первый его элемент — хэштег, тогда это цвет и нужно проверить:
если этого цвета еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.
если такой цвет уже есть в словаре из п.1, то нужно увеличить его значение на 1.
После цикла создайте пустой список — в него нужно будет добавить названия тех цветов, значение которых в словаре больше 1.
Обратитесь к парам ключ-значение в словаре: если значение больше или равно  2, то добавьте ключ в список из п.4.
Отсортируйте список в обратном алфавиту порядке и напечатайте его элементы через точку с запятой и пробел. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: nan 
<Вывод>: #FFFFFF; #BFBFBF; #3F3F3F; #000000 
<Example 2>: 
<Тип теста 2>: closed 
<Ввод>: nan 
<Вывод>: #FA8072; #DC143C; #CD5C5C 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: nan 
<Вывод>: nan 
<Решение студента>: punctuation = '!$%&()*+,-./:;<=>?@^_'

data = {}

with open('report.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip('\n')
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].startswith('#'):
                if w not in data:
                    data[w] = 1
                else:
                    data[w] += 1
                    
res = []

for k, v in data.items():
    if v >= 2:
        res.add(k)
        
print(*sorted(res, reverse = True), sep='; ') 
<Идеальное решение>: punctuation = '!$%&()*+,-./:;<=>?@^_'

data = {}

with open('report.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip('\n')
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].startswith('#'):
                if w not in data:
                    data[w] = 1
                else:
                    data[w] += 1
                    
res = []

for k, v in data.items():
    if v >= 2:
        res.append(k)
        
print(*sorted(res, reverse = True), sep='; ') 


<Комментарий эксперта>:"
144,384,23,"Роман изучает отчет по объекту, где упоминаются различные цвета, которые использовались в проекте. Помогите определить цвета, которые использовались не менее двух раз.

ФОРМАТ ВВОДА
Текстовый файл report.txt, в котором записан отчет по объекту. Гарантируется, что в тексте только названия цветов начинаются с хэштега (""#""). 
Гарантируется, что пустых строк в файле нет.
Гарантируется, что в файле будет упоминание хотя бы одного цвета.
Также дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.
ФОРМАТ ВЫВОДА
Названия цветов, которые использовались в проекте не менее двух раз. 
Названия должны быть записаны в обратном алфавитном порядке через точку с запятой и пробел.
ДОПОЛНИТЕЛЬНО
В открытом тесте используется файл report.txt  Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Создайте пустой словарь, в который будете записывать цвета и то, сколько раз их использовали в проекте.
Откройте файл в режиме чтения в кодировке utf-8.
Обратитесь к каждой строке в файле и выполните следующие действия:
уберите невидимые символы в конце строки (символ перехода на новую строку);
обратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;
разбейте строку по разделителю, в результате получите список;
обратитесь к каждому элементу в получившемся списке: если первый его элемент — хэштег, тогда это цвет и нужно проверить:
если этого цвета еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.
если такой цвет уже есть в словаре из п.1, то нужно увеличить его значение на 1.
После цикла создайте пустой список — в него нужно будет добавить названия тех цветов, значение которых в словаре больше 1.
Обратитесь к парам ключ-значение в словаре: если значение больше или равно  2, то добавьте ключ в список из п.4.
Отсортируйте список в обратном алфавиту порядке и напечатайте его элементы через точку с запятой и пробел.","[nan, nan, nan]","['#FFFFFF; #BFBFBF; #3F3F3F; #000000', '#FA8072; #DC143C; #CD5C5C', nan]","punctuation = '!$%&()*+,-./:;<=>?@^_'

data = {}

with open('report.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip('\n')
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].startswith('#'):
                if w not in data:
                    data[w] = 1
                else:
                    data[w] += 1
                    
res = []

for k, v in data.items():
    if v >= 2:
        res.append(k)
        
print(*res)","punctuation = '!$%&()*+,-./:;<=>?@^_'

data = {}

with open('report.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip('\n')
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].startswith('#'):
                if w not in data:
                    data[w] = 1
                else:
                    data[w] += 1
                    
res = []

for k, v in data.items():
    if v >= 2:
        res.append(k)
        
print(*sorted(res, reverse = True), sep='; ')","Ошибка в открытых и скрытых тестах. 

Ваш код некорректно выполняет условия задания. Так, он некорректно выполянет условия ""названия должны быть записаны в обратном алфавитном порядке через точку с запятой и пробел"". Попробуйте изменить условие print() для исправления ошибки.","['open', 'closed', 'closed']","<Task description>: Роман изучает отчет по объекту, где упоминаются различные цвета, которые использовались в проекте. Помогите определить цвета, которые использовались не менее двух раз.

ФОРМАТ ВВОДА
Текстовый файл report.txt, в котором записан отчет по объекту. Гарантируется, что в тексте только названия цветов начинаются с хэштега (""#""). 
Гарантируется, что пустых строк в файле нет.
Гарантируется, что в файле будет упоминание хотя бы одного цвета.
Также дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.
ФОРМАТ ВЫВОДА
Названия цветов, которые использовались в проекте не менее двух раз. 
Названия должны быть записаны в обратном алфавитном порядке через точку с запятой и пробел.
ДОПОЛНИТЕЛЬНО
В открытом тесте используется файл report.txt  Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Создайте пустой словарь, в который будете записывать цвета и то, сколько раз их использовали в проекте.
Откройте файл в режиме чтения в кодировке utf-8.
Обратитесь к каждой строке в файле и выполните следующие действия:
уберите невидимые символы в конце строки (символ перехода на новую строку);
обратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;
разбейте строку по разделителю, в результате получите список;
обратитесь к каждому элементу в получившемся списке: если первый его элемент — хэштег, тогда это цвет и нужно проверить:
если этого цвета еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.
если такой цвет уже есть в словаре из п.1, то нужно увеличить его значение на 1.
После цикла создайте пустой список — в него нужно будет добавить названия тех цветов, значение которых в словаре больше 1.
Обратитесь к парам ключ-значение в словаре: если значение больше или равно  2, то добавьте ключ в список из п.4.
Отсортируйте список в обратном алфавиту порядке и напечатайте его элементы через точку с запятой и пробел. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: nan 
<Вывод>: #FFFFFF; #BFBFBF; #3F3F3F; #000000 
<Example 2>: 
<Тип теста 2>: closed 
<Ввод>: nan 
<Вывод>: #FA8072; #DC143C; #CD5C5C 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: nan 
<Вывод>: nan 
<Решение студента>: punctuation = '!$%&()*+,-./:;<=>?@^_'

data = {}

with open('report.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip('\n')
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].startswith('#'):
                if w not in data:
                    data[w] = 1
                else:
                    data[w] += 1
                    
res = []

for k, v in data.items():
    if v >= 2:
        res.append(k)
        
print(*res) 
<Идеальное решение>: punctuation = '!$%&()*+,-./:;<=>?@^_'

data = {}

with open('report.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip('\n')
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].startswith('#'):
                if w not in data:
                    data[w] = 1
                else:
                    data[w] += 1
                    
res = []

for k, v in data.items():
    if v >= 2:
        res.append(k)
        
print(*sorted(res, reverse = True), sep='; ') 


<Комментарий эксперта>:"
145,385,23,"Роман изучает отчет по объекту, где упоминаются различные цвета, которые использовались в проекте. Помогите определить цвета, которые использовались не менее двух раз.

ФОРМАТ ВВОДА
Текстовый файл report.txt, в котором записан отчет по объекту. Гарантируется, что в тексте только названия цветов начинаются с хэштега (""#""). 
Гарантируется, что пустых строк в файле нет.
Гарантируется, что в файле будет упоминание хотя бы одного цвета.
Также дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.
ФОРМАТ ВЫВОДА
Названия цветов, которые использовались в проекте не менее двух раз. 
Названия должны быть записаны в обратном алфавитном порядке через точку с запятой и пробел.
ДОПОЛНИТЕЛЬНО
В открытом тесте используется файл report.txt  Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Создайте пустой словарь, в который будете записывать цвета и то, сколько раз их использовали в проекте.
Откройте файл в режиме чтения в кодировке utf-8.
Обратитесь к каждой строке в файле и выполните следующие действия:
уберите невидимые символы в конце строки (символ перехода на новую строку);
обратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;
разбейте строку по разделителю, в результате получите список;
обратитесь к каждому элементу в получившемся списке: если первый его элемент — хэштег, тогда это цвет и нужно проверить:
если этого цвета еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.
если такой цвет уже есть в словаре из п.1, то нужно увеличить его значение на 1.
После цикла создайте пустой список — в него нужно будет добавить названия тех цветов, значение которых в словаре больше 1.
Обратитесь к парам ключ-значение в словаре: если значение больше или равно  2, то добавьте ключ в список из п.4.
Отсортируйте список в обратном алфавиту порядке и напечатайте его элементы через точку с запятой и пробел.","[nan, nan, nan]","['#FFFFFF; #BFBFBF; #3F3F3F; #000000', '#FA8072; #DC143C; #CD5C5C', nan]","punctuation = '!$%&()*+,-./:;<=>?@^_'

data = {}

with open('report.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip('\n')
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].startswith('#'):
                if w not in data:
                    data[w] = 1
                else:
                    data[w] += 1
                    
res = []

for k, v in data.items():
    if v >= 2:
        res.append(k)
        
print(*sorted(res))","punctuation = '!$%&()*+,-./:;<=>?@^_'

data = {}

with open('report.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip('\n')
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].startswith('#'):
                if w not in data:
                    data[w] = 1
                else:
                    data[w] += 1
                    
res = []

for k, v in data.items():
    if v >= 2:
        res.append(k)
        
print(*sorted(res, reverse = True), sep='; ')","Ошибка в открытых и скрытых тестах. 

Ваш код некорректно выполняет условия задания. Так, он некорректно выполянет условия ""названия должны быть записаны в обратном алфавитном порядке через точку с запятой и пробел"". Попробуйте изменить условие print() исправления ошибки.","['open', 'closed', 'closed']","<Task description>: Роман изучает отчет по объекту, где упоминаются различные цвета, которые использовались в проекте. Помогите определить цвета, которые использовались не менее двух раз.

ФОРМАТ ВВОДА
Текстовый файл report.txt, в котором записан отчет по объекту. Гарантируется, что в тексте только названия цветов начинаются с хэштега (""#""). 
Гарантируется, что пустых строк в файле нет.
Гарантируется, что в файле будет упоминание хотя бы одного цвета.
Также дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.
ФОРМАТ ВЫВОДА
Названия цветов, которые использовались в проекте не менее двух раз. 
Названия должны быть записаны в обратном алфавитном порядке через точку с запятой и пробел.
ДОПОЛНИТЕЛЬНО
В открытом тесте используется файл report.txt  Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Создайте пустой словарь, в который будете записывать цвета и то, сколько раз их использовали в проекте.
Откройте файл в режиме чтения в кодировке utf-8.
Обратитесь к каждой строке в файле и выполните следующие действия:
уберите невидимые символы в конце строки (символ перехода на новую строку);
обратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;
разбейте строку по разделителю, в результате получите список;
обратитесь к каждому элементу в получившемся списке: если первый его элемент — хэштег, тогда это цвет и нужно проверить:
если этого цвета еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.
если такой цвет уже есть в словаре из п.1, то нужно увеличить его значение на 1.
После цикла создайте пустой список — в него нужно будет добавить названия тех цветов, значение которых в словаре больше 1.
Обратитесь к парам ключ-значение в словаре: если значение больше или равно  2, то добавьте ключ в список из п.4.
Отсортируйте список в обратном алфавиту порядке и напечатайте его элементы через точку с запятой и пробел. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: nan 
<Вывод>: #FFFFFF; #BFBFBF; #3F3F3F; #000000 
<Example 2>: 
<Тип теста 2>: closed 
<Ввод>: nan 
<Вывод>: #FA8072; #DC143C; #CD5C5C 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: nan 
<Вывод>: nan 
<Решение студента>: punctuation = '!$%&()*+,-./:;<=>?@^_'

data = {}

with open('report.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip('\n')
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].startswith('#'):
                if w not in data:
                    data[w] = 1
                else:
                    data[w] += 1
                    
res = []

for k, v in data.items():
    if v >= 2:
        res.append(k)
        
print(*sorted(res)) 
<Идеальное решение>: punctuation = '!$%&()*+,-./:;<=>?@^_'

data = {}

with open('report.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip('\n')
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].startswith('#'):
                if w not in data:
                    data[w] = 1
                else:
                    data[w] += 1
                    
res = []

for k, v in data.items():
    if v >= 2:
        res.append(k)
        
print(*sorted(res, reverse = True), sep='; ') 


<Комментарий эксперта>:"
146,386,23,"Роман изучает отчет по объекту, где упоминаются различные цвета, которые использовались в проекте. Помогите определить цвета, которые использовались не менее двух раз.

ФОРМАТ ВВОДА
Текстовый файл report.txt, в котором записан отчет по объекту. Гарантируется, что в тексте только названия цветов начинаются с хэштега (""#""). 
Гарантируется, что пустых строк в файле нет.
Гарантируется, что в файле будет упоминание хотя бы одного цвета.
Также дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.
ФОРМАТ ВЫВОДА
Названия цветов, которые использовались в проекте не менее двух раз. 
Названия должны быть записаны в обратном алфавитном порядке через точку с запятой и пробел.
ДОПОЛНИТЕЛЬНО
В открытом тесте используется файл report.txt  Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Создайте пустой словарь, в который будете записывать цвета и то, сколько раз их использовали в проекте.
Откройте файл в режиме чтения в кодировке utf-8.
Обратитесь к каждой строке в файле и выполните следующие действия:
уберите невидимые символы в конце строки (символ перехода на новую строку);
обратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;
разбейте строку по разделителю, в результате получите список;
обратитесь к каждому элементу в получившемся списке: если первый его элемент — хэштег, тогда это цвет и нужно проверить:
если этого цвета еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.
если такой цвет уже есть в словаре из п.1, то нужно увеличить его значение на 1.
После цикла создайте пустой список — в него нужно будет добавить названия тех цветов, значение которых в словаре больше 1.
Обратитесь к парам ключ-значение в словаре: если значение больше или равно  2, то добавьте ключ в список из п.4.
Отсортируйте список в обратном алфавиту порядке и напечатайте его элементы через точку с запятой и пробел.","[nan, nan, nan]","['#FFFFFF; #BFBFBF; #3F3F3F; #000000', '#FA8072; #DC143C; #CD5C5C', nan]","punctuation = '!$%&()*+,-./:;<=>?@^_'

data = {}

with open('report.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip('\n')
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].startswith('#'):
                if w not in data:
                    data[w] = 1
                else:
                    data[w] += 1
                    
res = []

for k, v in data.items():
    if v >= 2:
        res.append(k)
        
print(*sorted(res, reverse = True))","punctuation = '!$%&()*+,-./:;<=>?@^_'

data = {}

with open('report.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip('\n')
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].startswith('#'):
                if w not in data:
                    data[w] = 1
                else:
                    data[w] += 1
                    
res = []

for k, v in data.items():
    if v >= 2:
        res.append(k)
        
print(*sorted(res, reverse = True), sep='; ')","Ошибка в открытых и скрытых тестах. 

Ваш код некорректно выполняет условия задания. Так, он некорректно выполянет условия ""названия должны быть записаны в обратном алфавитном порядке через точку с запятой и пробел"". Попробуйте изменить условие print() для исправления ошибки.","['open', 'closed', 'closed']","<Task description>: Роман изучает отчет по объекту, где упоминаются различные цвета, которые использовались в проекте. Помогите определить цвета, которые использовались не менее двух раз.

ФОРМАТ ВВОДА
Текстовый файл report.txt, в котором записан отчет по объекту. Гарантируется, что в тексте только названия цветов начинаются с хэштега (""#""). 
Гарантируется, что пустых строк в файле нет.
Гарантируется, что в файле будет упоминание хотя бы одного цвета.
Также дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.
ФОРМАТ ВЫВОДА
Названия цветов, которые использовались в проекте не менее двух раз. 
Названия должны быть записаны в обратном алфавитном порядке через точку с запятой и пробел.
ДОПОЛНИТЕЛЬНО
В открытом тесте используется файл report.txt  Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Создайте пустой словарь, в который будете записывать цвета и то, сколько раз их использовали в проекте.
Откройте файл в режиме чтения в кодировке utf-8.
Обратитесь к каждой строке в файле и выполните следующие действия:
уберите невидимые символы в конце строки (символ перехода на новую строку);
обратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;
разбейте строку по разделителю, в результате получите список;
обратитесь к каждому элементу в получившемся списке: если первый его элемент — хэштег, тогда это цвет и нужно проверить:
если этого цвета еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.
если такой цвет уже есть в словаре из п.1, то нужно увеличить его значение на 1.
После цикла создайте пустой список — в него нужно будет добавить названия тех цветов, значение которых в словаре больше 1.
Обратитесь к парам ключ-значение в словаре: если значение больше или равно  2, то добавьте ключ в список из п.4.
Отсортируйте список в обратном алфавиту порядке и напечатайте его элементы через точку с запятой и пробел. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: nan 
<Вывод>: #FFFFFF; #BFBFBF; #3F3F3F; #000000 
<Example 2>: 
<Тип теста 2>: closed 
<Ввод>: nan 
<Вывод>: #FA8072; #DC143C; #CD5C5C 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: nan 
<Вывод>: nan 
<Решение студента>: punctuation = '!$%&()*+,-./:;<=>?@^_'

data = {}

with open('report.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip('\n')
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].startswith('#'):
                if w not in data:
                    data[w] = 1
                else:
                    data[w] += 1
                    
res = []

for k, v in data.items():
    if v >= 2:
        res.append(k)
        
print(*sorted(res, reverse = True)) 
<Идеальное решение>: punctuation = '!$%&()*+,-./:;<=>?@^_'

data = {}

with open('report.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip('\n')
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].startswith('#'):
                if w not in data:
                    data[w] = 1
                else:
                    data[w] += 1
                    
res = []

for k, v in data.items():
    if v >= 2:
        res.append(k)
        
print(*sorted(res, reverse = True), sep='; ') 


<Комментарий эксперта>:"
147,387,23,"Роман изучает отчет по объекту, где упоминаются различные цвета, которые использовались в проекте. Помогите определить цвета, которые использовались не менее двух раз.

ФОРМАТ ВВОДА
Текстовый файл report.txt, в котором записан отчет по объекту. Гарантируется, что в тексте только названия цветов начинаются с хэштега (""#""). 
Гарантируется, что пустых строк в файле нет.
Гарантируется, что в файле будет упоминание хотя бы одного цвета.
Также дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.
ФОРМАТ ВЫВОДА
Названия цветов, которые использовались в проекте не менее двух раз. 
Названия должны быть записаны в обратном алфавитном порядке через точку с запятой и пробел.
ДОПОЛНИТЕЛЬНО
В открытом тесте используется файл report.txt  Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Создайте пустой словарь, в который будете записывать цвета и то, сколько раз их использовали в проекте.
Откройте файл в режиме чтения в кодировке utf-8.
Обратитесь к каждой строке в файле и выполните следующие действия:
уберите невидимые символы в конце строки (символ перехода на новую строку);
обратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;
разбейте строку по разделителю, в результате получите список;
обратитесь к каждому элементу в получившемся списке: если первый его элемент — хэштег, тогда это цвет и нужно проверить:
если этого цвета еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.
если такой цвет уже есть в словаре из п.1, то нужно увеличить его значение на 1.
После цикла создайте пустой список — в него нужно будет добавить названия тех цветов, значение которых в словаре больше 1.
Обратитесь к парам ключ-значение в словаре: если значение больше или равно  2, то добавьте ключ в список из п.4.
Отсортируйте список в обратном алфавиту порядке и напечатайте его элементы через точку с запятой и пробел.","[nan, nan, nan]","['#FFFFFF; #BFBFBF; #3F3F3F; #000000', '#FA8072; #DC143C; #CD5C5C', nan]","punctuation = '!$%&()*+,-./:;<=>?@^_'

data = {}

with open('report.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip('\n')
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].startswith('#'):
                if w not in data:
                    data[w] = 1
                else:
                    data[w] += 1
                    
res = []

for k, v in data.items():
    if v >= 2:
        res.append(k)
        
print(*sorted(res), sep='; ')","punctuation = '!$%&()*+,-./:;<=>?@^_'

data = {}

with open('report.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip('\n')
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].startswith('#'):
                if w not in data:
                    data[w] = 1
                else:
                    data[w] += 1
                    
res = []

for k, v in data.items():
    if v >= 2:
        res.append(k)
        
print(*sorted(res, reverse = True), sep='; ')","Ошибка в открытых и скрытых тестах. 

Ваш код некорректно выполняет условия задания. Так, он некорректно выполянет условия ""названия должны быть записаны в обратном алфавитном порядке через точку с запятой и пробел"". Попробуйте изменить условие print() для исправления ошибки.","['open', 'closed', 'closed']","<Task description>: Роман изучает отчет по объекту, где упоминаются различные цвета, которые использовались в проекте. Помогите определить цвета, которые использовались не менее двух раз.

ФОРМАТ ВВОДА
Текстовый файл report.txt, в котором записан отчет по объекту. Гарантируется, что в тексте только названия цветов начинаются с хэштега (""#""). 
Гарантируется, что пустых строк в файле нет.
Гарантируется, что в файле будет упоминание хотя бы одного цвета.
Также дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.
ФОРМАТ ВЫВОДА
Названия цветов, которые использовались в проекте не менее двух раз. 
Названия должны быть записаны в обратном алфавитном порядке через точку с запятой и пробел.
ДОПОЛНИТЕЛЬНО
В открытом тесте используется файл report.txt  Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Создайте пустой словарь, в который будете записывать цвета и то, сколько раз их использовали в проекте.
Откройте файл в режиме чтения в кодировке utf-8.
Обратитесь к каждой строке в файле и выполните следующие действия:
уберите невидимые символы в конце строки (символ перехода на новую строку);
обратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;
разбейте строку по разделителю, в результате получите список;
обратитесь к каждому элементу в получившемся списке: если первый его элемент — хэштег, тогда это цвет и нужно проверить:
если этого цвета еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.
если такой цвет уже есть в словаре из п.1, то нужно увеличить его значение на 1.
После цикла создайте пустой список — в него нужно будет добавить названия тех цветов, значение которых в словаре больше 1.
Обратитесь к парам ключ-значение в словаре: если значение больше или равно  2, то добавьте ключ в список из п.4.
Отсортируйте список в обратном алфавиту порядке и напечатайте его элементы через точку с запятой и пробел. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: nan 
<Вывод>: #FFFFFF; #BFBFBF; #3F3F3F; #000000 
<Example 2>: 
<Тип теста 2>: closed 
<Ввод>: nan 
<Вывод>: #FA8072; #DC143C; #CD5C5C 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: nan 
<Вывод>: nan 
<Решение студента>: punctuation = '!$%&()*+,-./:;<=>?@^_'

data = {}

with open('report.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip('\n')
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].startswith('#'):
                if w not in data:
                    data[w] = 1
                else:
                    data[w] += 1
                    
res = []

for k, v in data.items():
    if v >= 2:
        res.append(k)
        
print(*sorted(res), sep='; ') 
<Идеальное решение>: punctuation = '!$%&()*+,-./:;<=>?@^_'

data = {}

with open('report.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip('\n')
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].startswith('#'):
                if w not in data:
                    data[w] = 1
                else:
                    data[w] += 1
                    
res = []

for k, v in data.items():
    if v >= 2:
        res.append(k)
        
print(*sorted(res, reverse = True), sep='; ') 


<Комментарий эксперта>:"
148,388,23,"Роман изучает отчет по объекту, где упоминаются различные цвета, которые использовались в проекте. Помогите определить цвета, которые использовались не менее двух раз.

ФОРМАТ ВВОДА
Текстовый файл report.txt, в котором записан отчет по объекту. Гарантируется, что в тексте только названия цветов начинаются с хэштега (""#""). 
Гарантируется, что пустых строк в файле нет.
Гарантируется, что в файле будет упоминание хотя бы одного цвета.
Также дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.
ФОРМАТ ВЫВОДА
Названия цветов, которые использовались в проекте не менее двух раз. 
Названия должны быть записаны в обратном алфавитном порядке через точку с запятой и пробел.
ДОПОЛНИТЕЛЬНО
В открытом тесте используется файл report.txt  Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Создайте пустой словарь, в который будете записывать цвета и то, сколько раз их использовали в проекте.
Откройте файл в режиме чтения в кодировке utf-8.
Обратитесь к каждой строке в файле и выполните следующие действия:
уберите невидимые символы в конце строки (символ перехода на новую строку);
обратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;
разбейте строку по разделителю, в результате получите список;
обратитесь к каждому элементу в получившемся списке: если первый его элемент — хэштег, тогда это цвет и нужно проверить:
если этого цвета еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.
если такой цвет уже есть в словаре из п.1, то нужно увеличить его значение на 1.
После цикла создайте пустой список — в него нужно будет добавить названия тех цветов, значение которых в словаре больше 1.
Обратитесь к парам ключ-значение в словаре: если значение больше или равно  2, то добавьте ключ в список из п.4.
Отсортируйте список в обратном алфавиту порядке и напечатайте его элементы через точку с запятой и пробел.","[nan, nan, nan]","['#FFFFFF; #BFBFBF; #3F3F3F; #000000', '#FA8072; #DC143C; #CD5C5C', nan]","punctuation = '!$%&()*+,-./:;<=>?@^_'

data = {}

with open('report.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip('\n')
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].startswith('#'):
                if w not in data:
                    data[w] = 1
                else:
                    data[w] += 1
                    
    res = []

    for k, v in data.items():
        if v >= 2:
            res.append(k)
        
print(*sorted(res, reverse = True), sep='; ')","punctuation = '!$%&()*+,-./:;<=>?@^_'

data = {}

with open('report.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip('\n')
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].startswith('#'):
                if w not in data:
                    data[w] = 1
                else:
                    data[w] += 1
                    
res = []

for k, v in data.items():
    if v >= 2:
        res.append(k)
        
print(*sorted(res, reverse = True), sep='; ')",Ошибка табуляции во второй конструкции цикла for.,"['open', 'closed', 'closed']","<Task description>: Роман изучает отчет по объекту, где упоминаются различные цвета, которые использовались в проекте. Помогите определить цвета, которые использовались не менее двух раз.

ФОРМАТ ВВОДА
Текстовый файл report.txt, в котором записан отчет по объекту. Гарантируется, что в тексте только названия цветов начинаются с хэштега (""#""). 
Гарантируется, что пустых строк в файле нет.
Гарантируется, что в файле будет упоминание хотя бы одного цвета.
Также дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.
ФОРМАТ ВЫВОДА
Названия цветов, которые использовались в проекте не менее двух раз. 
Названия должны быть записаны в обратном алфавитном порядке через точку с запятой и пробел.
ДОПОЛНИТЕЛЬНО
В открытом тесте используется файл report.txt  Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Создайте пустой словарь, в который будете записывать цвета и то, сколько раз их использовали в проекте.
Откройте файл в режиме чтения в кодировке utf-8.
Обратитесь к каждой строке в файле и выполните следующие действия:
уберите невидимые символы в конце строки (символ перехода на новую строку);
обратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;
разбейте строку по разделителю, в результате получите список;
обратитесь к каждому элементу в получившемся списке: если первый его элемент — хэштег, тогда это цвет и нужно проверить:
если этого цвета еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.
если такой цвет уже есть в словаре из п.1, то нужно увеличить его значение на 1.
После цикла создайте пустой список — в него нужно будет добавить названия тех цветов, значение которых в словаре больше 1.
Обратитесь к парам ключ-значение в словаре: если значение больше или равно  2, то добавьте ключ в список из п.4.
Отсортируйте список в обратном алфавиту порядке и напечатайте его элементы через точку с запятой и пробел. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: nan 
<Вывод>: #FFFFFF; #BFBFBF; #3F3F3F; #000000 
<Example 2>: 
<Тип теста 2>: closed 
<Ввод>: nan 
<Вывод>: #FA8072; #DC143C; #CD5C5C 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: nan 
<Вывод>: nan 
<Решение студента>: punctuation = '!$%&()*+,-./:;<=>?@^_'

data = {}

with open('report.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip('\n')
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].startswith('#'):
                if w not in data:
                    data[w] = 1
                else:
                    data[w] += 1
                    
    res = []

    for k, v in data.items():
        if v >= 2:
            res.append(k)
        
print(*sorted(res, reverse = True), sep='; ') 
<Идеальное решение>: punctuation = '!$%&()*+,-./:;<=>?@^_'

data = {}

with open('report.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip('\n')
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].startswith('#'):
                if w not in data:
                    data[w] = 1
                else:
                    data[w] += 1
                    
res = []

for k, v in data.items():
    if v >= 2:
        res.append(k)
        
print(*sorted(res, reverse = True), sep='; ') 


<Комментарий эксперта>:"
149,414,26,"Реализуйте программу, определяющую слова, которые нужно переводить:

В переменную N считывается целое число — количество записей, которые будут введены. Этот код уже написан.
В цикле while считывается N слов. 
Гарантируется, что будет введена как минимум одна строка.
Напечатайте количество слов, в которых буква ""а"" вне зависимости от регистра встречается не менее двух раз.","['8\nаркА\nриторика\nкультурА\nамфора\nантитезА\nАнтипод\nАтакА\nанглийский', '1\nэпитет', '9\nбалка\nраспоркА\nакр\nкронштейн\nАпалубкА\nарматура\nАрхитектор\nантифриз\nанАфорА', '8\nпрпрп\nлвоаимли\nфывшмыв\nфАвмтофф\nйнгшй\nфващм тм\nфвшмщйтим\nворот', '9\nААА\nааа\nАаА\nАа\nАА\nаа\nАББА\nПаПа\nПАПА']","['4', '0', '5', '0', '9']","N = input()

# ваш код ниже

result = 0

while N != 0:
    info = input()
    
    if  info.lower().count('а') >= 2:
        result += 1
    
    N -= 1
    
print(result)","N = int(input())

# ваш код ниже

result = 0

while N != 0:
    info = input()
    
    if  info.lower().count('а') >= 2:
        result += 1
    
    N -= 1
    
print(result)",В данном случае следует сохранить функцию int() для преобразования входных данных.,"['open', 'open', 'closed', 'closed', 'closed']","<Task description>: Реализуйте программу, определяющую слова, которые нужно переводить:

В переменную N считывается целое число — количество записей, которые будут введены. Этот код уже написан.
В цикле while считывается N слов. 
Гарантируется, что будет введена как минимум одна строка.
Напечатайте количество слов, в которых буква ""а"" вне зависимости от регистра встречается не менее двух раз. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: 8
аркА
риторика
культурА
амфора
антитезА
Антипод
АтакА
английский 
<Вывод>: 4 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: 1
эпитет 
<Вывод>: 0 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: 9
балка
распоркА
акр
кронштейн
АпалубкА
арматура
Архитектор
антифриз
анАфорА 
<Вывод>: 5 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: 8
прпрп
лвоаимли
фывшмыв
фАвмтофф
йнгшй
фващм тм
фвшмщйтим
ворот 
<Вывод>: 0 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: 9
ААА
ааа
АаА
Аа
АА
аа
АББА
ПаПа
ПАПА 
<Вывод>: 9 
<Решение студента>: N = input()

# ваш код ниже

result = 0

while N != 0:
    info = input()
    
    if  info.lower().count('а') >= 2:
        result += 1
    
    N -= 1
    
print(result) 
<Идеальное решение>: N = int(input())

# ваш код ниже

result = 0

while N != 0:
    info = input()
    
    if  info.lower().count('а') >= 2:
        result += 1
    
    N -= 1
    
print(result) 


<Комментарий эксперта>:"
150,415,26,"Реализуйте программу, определяющую слова, которые нужно переводить:

В переменную N считывается целое число — количество записей, которые будут введены. Этот код уже написан.
В цикле while считывается N слов. 
Гарантируется, что будет введена как минимум одна строка.
Напечатайте количество слов, в которых буква ""а"" вне зависимости от регистра встречается не менее двух раз.","['8\nаркА\nриторика\nкультурА\nамфора\nантитезА\nАнтипод\nАтакА\nанглийский', '1\nэпитет', '9\nбалка\nраспоркА\nакр\nкронштейн\nАпалубкА\nарматура\nАрхитектор\nантифриз\nанАфорА', '8\nпрпрп\nлвоаимли\nфывшмыв\nфАвмтофф\nйнгшй\nфващм тм\nфвшмщйтим\nворот', '9\nААА\nааа\nАаА\nАа\nАА\nаа\nАББА\nПаПа\nПАПА']","['4', '0', '5', '0', '9']","N = int(input())

# ваш код ниже

while N != 0:
    info = input()
    
    if  info.lower().count('а') >= 2:
        result += 1
    
    N -= 1
    
print(result)","N = int(input())

# ваш код ниже

result = 0

while N != 0:
    info = input()
    
    if  info.lower().count('а') >= 2:
        result += 1
    
    N -= 1
    
print(result)","Вы обращаетесь к переменной, которая не была определена ранее. Убедитесь, что вы корректно задали все переменные.","['open', 'open', 'closed', 'closed', 'closed']","<Task description>: Реализуйте программу, определяющую слова, которые нужно переводить:

В переменную N считывается целое число — количество записей, которые будут введены. Этот код уже написан.
В цикле while считывается N слов. 
Гарантируется, что будет введена как минимум одна строка.
Напечатайте количество слов, в которых буква ""а"" вне зависимости от регистра встречается не менее двух раз. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: 8
аркА
риторика
культурА
амфора
антитезА
Антипод
АтакА
английский 
<Вывод>: 4 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: 1
эпитет 
<Вывод>: 0 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: 9
балка
распоркА
акр
кронштейн
АпалубкА
арматура
Архитектор
антифриз
анАфорА 
<Вывод>: 5 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: 8
прпрп
лвоаимли
фывшмыв
фАвмтофф
йнгшй
фващм тм
фвшмщйтим
ворот 
<Вывод>: 0 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: 9
ААА
ааа
АаА
Аа
АА
аа
АББА
ПаПа
ПАПА 
<Вывод>: 9 
<Решение студента>: N = int(input())

# ваш код ниже

while N != 0:
    info = input()
    
    if  info.lower().count('а') >= 2:
        result += 1
    
    N -= 1
    
print(result) 
<Идеальное решение>: N = int(input())

# ваш код ниже

result = 0

while N != 0:
    info = input()
    
    if  info.lower().count('а') >= 2:
        result += 1
    
    N -= 1
    
print(result) 


<Комментарий эксперта>:"
151,416,26,"Реализуйте программу, определяющую слова, которые нужно переводить:

В переменную N считывается целое число — количество записей, которые будут введены. Этот код уже написан.
В цикле while считывается N слов. 
Гарантируется, что будет введена как минимум одна строка.
Напечатайте количество слов, в которых буква ""а"" вне зависимости от регистра встречается не менее двух раз.","['8\nаркА\nриторика\nкультурА\nамфора\nантитезА\nАнтипод\nАтакА\nанглийский', '1\nэпитет', '9\nбалка\nраспоркА\nакр\nкронштейн\nАпалубкА\nарматура\nАрхитектор\nантифриз\nанАфорА', '8\nпрпрп\nлвоаимли\nфывшмыв\nфАвмтофф\nйнгшй\nфващм тм\nфвшмщйтим\nворот', '9\nААА\nааа\nАаА\nАа\nАА\nаа\nАББА\nПаПа\nПАПА']","['4', '0', '5', '0', '9']","N = int(input())

# ваш код ниже

result = 0

while N != '0':
    info = input()
    
    if  info.lower().count('а') >= 2:
        result += 1
    
    N -= 1
    
print(result)","N = int(input())

# ваш код ниже

result = 0

while N != 0:
    info = input()
    
    if  info.lower().count('а') >= 2:
        result += 1
    
    N -= 1
    
print(result)",Ошибка при сравнении данных типа integer с данными типа string.,"['open', 'open', 'closed', 'closed', 'closed']","<Task description>: Реализуйте программу, определяющую слова, которые нужно переводить:

В переменную N считывается целое число — количество записей, которые будут введены. Этот код уже написан.
В цикле while считывается N слов. 
Гарантируется, что будет введена как минимум одна строка.
Напечатайте количество слов, в которых буква ""а"" вне зависимости от регистра встречается не менее двух раз. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: 8
аркА
риторика
культурА
амфора
антитезА
Антипод
АтакА
английский 
<Вывод>: 4 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: 1
эпитет 
<Вывод>: 0 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: 9
балка
распоркА
акр
кронштейн
АпалубкА
арматура
Архитектор
антифриз
анАфорА 
<Вывод>: 5 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: 8
прпрп
лвоаимли
фывшмыв
фАвмтофф
йнгшй
фващм тм
фвшмщйтим
ворот 
<Вывод>: 0 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: 9
ААА
ааа
АаА
Аа
АА
аа
АББА
ПаПа
ПАПА 
<Вывод>: 9 
<Решение студента>: N = int(input())

# ваш код ниже

result = 0

while N != '0':
    info = input()
    
    if  info.lower().count('а') >= 2:
        result += 1
    
    N -= 1
    
print(result) 
<Идеальное решение>: N = int(input())

# ваш код ниже

result = 0

while N != 0:
    info = input()
    
    if  info.lower().count('а') >= 2:
        result += 1
    
    N -= 1
    
print(result) 


<Комментарий эксперта>:"
152,417,26,"Реализуйте программу, определяющую слова, которые нужно переводить:

В переменную N считывается целое число — количество записей, которые будут введены. Этот код уже написан.
В цикле while считывается N слов. 
Гарантируется, что будет введена как минимум одна строка.
Напечатайте количество слов, в которых буква ""а"" вне зависимости от регистра встречается не менее двух раз.","['8\nаркА\nриторика\nкультурА\nамфора\nантитезА\nАнтипод\nАтакА\nанглийский', '1\nэпитет', '9\nбалка\nраспоркА\nакр\nкронштейн\nАпалубкА\nарматура\nАрхитектор\nантифриз\nанАфорА', '8\nпрпрп\nлвоаимли\nфывшмыв\nфАвмтофф\nйнгшй\nфващм тм\nфвшмщйтим\nворот', '9\nААА\nааа\nАаА\nАа\nАА\nаа\nАББА\nПаПа\nПАПА']","['4', '0', '5', '0', '9']","N = int(input())

# ваш код ниже

result = 0

while N != 0:
    info = input()
    
    if  inf.lower().count('а') >= 2:
        result += 1
    
    N -= 1
    
print(result)","N = int(input())

# ваш код ниже

result = 0

while N != 0:
    info = input()
    
    if  info.lower().count('а') >= 2:
        result += 1
    
    N -= 1
    
print(result)","Синтаксическая ошибка. Вы пытаетесь обратиться к переменной, которую не определили ранее. Убедитесь, что корректно написали все переменные.","['open', 'open', 'closed', 'closed', 'closed']","<Task description>: Реализуйте программу, определяющую слова, которые нужно переводить:

В переменную N считывается целое число — количество записей, которые будут введены. Этот код уже написан.
В цикле while считывается N слов. 
Гарантируется, что будет введена как минимум одна строка.
Напечатайте количество слов, в которых буква ""а"" вне зависимости от регистра встречается не менее двух раз. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: 8
аркА
риторика
культурА
амфора
антитезА
Антипод
АтакА
английский 
<Вывод>: 4 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: 1
эпитет 
<Вывод>: 0 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: 9
балка
распоркА
акр
кронштейн
АпалубкА
арматура
Архитектор
антифриз
анАфорА 
<Вывод>: 5 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: 8
прпрп
лвоаимли
фывшмыв
фАвмтофф
йнгшй
фващм тм
фвшмщйтим
ворот 
<Вывод>: 0 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: 9
ААА
ааа
АаА
Аа
АА
аа
АББА
ПаПа
ПАПА 
<Вывод>: 9 
<Решение студента>: N = int(input())

# ваш код ниже

result = 0

while N != 0:
    info = input()
    
    if  inf.lower().count('а') >= 2:
        result += 1
    
    N -= 1
    
print(result) 
<Идеальное решение>: N = int(input())

# ваш код ниже

result = 0

while N != 0:
    info = input()
    
    if  info.lower().count('а') >= 2:
        result += 1
    
    N -= 1
    
print(result) 


<Комментарий эксперта>:"
153,418,26,"Реализуйте программу, определяющую слова, которые нужно переводить:

В переменную N считывается целое число — количество записей, которые будут введены. Этот код уже написан.
В цикле while считывается N слов. 
Гарантируется, что будет введена как минимум одна строка.
Напечатайте количество слов, в которых буква ""а"" вне зависимости от регистра встречается не менее двух раз.","['8\nаркА\nриторика\nкультурА\nамфора\nантитезА\nАнтипод\nАтакА\nанглийский', '1\nэпитет', '9\nбалка\nраспоркА\nакр\nкронштейн\nАпалубкА\nарматура\nАрхитектор\nантифриз\nанАфорА', '8\nпрпрп\nлвоаимли\nфывшмыв\nфАвмтофф\nйнгшй\nфващм тм\nфвшмщйтим\nворот', '9\nААА\nааа\nАаА\nАа\nАА\nаа\nАББА\nПаПа\nПАПА']","['4', '0', '5', '0', '9']","N = int(input())

# ваш код ниже

result = 0

while N != 0:
    info = input()
    
    if  info.islower().count('а') >= 2:
        result += 1
    
    N -= 1
    
print(result)","N = int(input())

# ваш код ниже

result = 0

while N != 0:
    info = input()
    
    if  info.lower().count('а') >= 2:
        result += 1
    
    N -= 1
    
print(result)",Ошибка в использовании метода islower(). Метод islower() возвращает значение типа bool. Используйте другой метод для анализа вводных данных.,"['open', 'open', 'closed', 'closed', 'closed']","<Task description>: Реализуйте программу, определяющую слова, которые нужно переводить:

В переменную N считывается целое число — количество записей, которые будут введены. Этот код уже написан.
В цикле while считывается N слов. 
Гарантируется, что будет введена как минимум одна строка.
Напечатайте количество слов, в которых буква ""а"" вне зависимости от регистра встречается не менее двух раз. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: 8
аркА
риторика
культурА
амфора
антитезА
Антипод
АтакА
английский 
<Вывод>: 4 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: 1
эпитет 
<Вывод>: 0 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: 9
балка
распоркА
акр
кронштейн
АпалубкА
арматура
Архитектор
антифриз
анАфорА 
<Вывод>: 5 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: 8
прпрп
лвоаимли
фывшмыв
фАвмтофф
йнгшй
фващм тм
фвшмщйтим
ворот 
<Вывод>: 0 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: 9
ААА
ааа
АаА
Аа
АА
аа
АББА
ПаПа
ПАПА 
<Вывод>: 9 
<Решение студента>: N = int(input())

# ваш код ниже

result = 0

while N != 0:
    info = input()
    
    if  info.islower().count('а') >= 2:
        result += 1
    
    N -= 1
    
print(result) 
<Идеальное решение>: N = int(input())

# ваш код ниже

result = 0

while N != 0:
    info = input()
    
    if  info.lower().count('а') >= 2:
        result += 1
    
    N -= 1
    
print(result) 


<Комментарий эксперта>:"
154,419,26,"Реализуйте программу, определяющую слова, которые нужно переводить:

В переменную N считывается целое число — количество записей, которые будут введены. Этот код уже написан.
В цикле while считывается N слов. 
Гарантируется, что будет введена как минимум одна строка.
Напечатайте количество слов, в которых буква ""а"" вне зависимости от регистра встречается не менее двух раз.","['8\nаркА\nриторика\nкультурА\nамфора\nантитезА\nАнтипод\nАтакА\nанглийский', '1\nэпитет', '9\nбалка\nраспоркА\nакр\nкронштейн\nАпалубкА\nарматура\nАрхитектор\nантифриз\nанАфорА', '8\nпрпрп\nлвоаимли\nфывшмыв\nфАвмтофф\nйнгшй\nфващм тм\nфвшмщйтим\nворот', '9\nААА\nааа\nАаА\nАа\nАА\nаа\nАББА\nПаПа\nПАПА']","['4', '0', '5', '0', '9']","N = int(input())

# ваш код ниже

result = 0

while N != 0:
    info = input()
    
    if  info.count('а') >= 2:
        result += 1
    
    N -= 1
    
print(result)","N = int(input())

# ваш код ниже

result = 0

while N != 0:
    info = input()
    
    if  info.lower().count('а') >= 2:
        result += 1
    
    N -= 1
    
print(result)","Ошибки в скрытых и открытых тестах.

Ваш код некорректно обрабатывает данные. Обратите внимание на условие ""вне зависимости от регистра"".","['open', 'open', 'closed', 'closed', 'closed']","<Task description>: Реализуйте программу, определяющую слова, которые нужно переводить:

В переменную N считывается целое число — количество записей, которые будут введены. Этот код уже написан.
В цикле while считывается N слов. 
Гарантируется, что будет введена как минимум одна строка.
Напечатайте количество слов, в которых буква ""а"" вне зависимости от регистра встречается не менее двух раз. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: 8
аркА
риторика
культурА
амфора
антитезА
Антипод
АтакА
английский 
<Вывод>: 4 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: 1
эпитет 
<Вывод>: 0 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: 9
балка
распоркА
акр
кронштейн
АпалубкА
арматура
Архитектор
антифриз
анАфорА 
<Вывод>: 5 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: 8
прпрп
лвоаимли
фывшмыв
фАвмтофф
йнгшй
фващм тм
фвшмщйтим
ворот 
<Вывод>: 0 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: 9
ААА
ааа
АаА
Аа
АА
аа
АББА
ПаПа
ПАПА 
<Вывод>: 9 
<Решение студента>: N = int(input())

# ваш код ниже

result = 0

while N != 0:
    info = input()
    
    if  info.count('а') >= 2:
        result += 1
    
    N -= 1
    
print(result) 
<Идеальное решение>: N = int(input())

# ваш код ниже

result = 0

while N != 0:
    info = input()
    
    if  info.lower().count('а') >= 2:
        result += 1
    
    N -= 1
    
print(result) 


<Комментарий эксперта>:"
155,420,26,"Реализуйте программу, определяющую слова, которые нужно переводить:

В переменную N считывается целое число — количество записей, которые будут введены. Этот код уже написан.
В цикле while считывается N слов. 
Гарантируется, что будет введена как минимум одна строка.
Напечатайте количество слов, в которых буква ""а"" вне зависимости от регистра встречается не менее двух раз.","['8\nаркА\nриторика\nкультурА\nамфора\nантитезА\nАнтипод\nАтакА\nанглийский', '1\nэпитет', '9\nбалка\nраспоркА\nакр\nкронштейн\nАпалубкА\nарматура\nАрхитектор\nантифриз\nанАфорА', '8\nпрпрп\nлвоаимли\nфывшмыв\nфАвмтофф\nйнгшй\nфващм тм\nфвшмщйтим\nворот', '9\nААА\nааа\nАаА\nАа\nАА\nаа\nАББА\nПаПа\nПАПА']","['4', '0', '5', '0', '9']","N = int(input())

# ваш код ниже

result = 0

while N != 0:
    info = input()
    
    if  info.lower().count('а') > 2:
        result += 1
    
    N -= 1
    
print(result)","N = int(input())

# ваш код ниже

result = 0

while N != 0:
    info = input()
    
    if  info.lower().count('а') >= 2:
        result += 1
    
    N -= 1
    
print(result)","Ошибка в скрытых и открытых тестах.

Ваш код охватываает не все возможные случаи. Код некорректно работает с условием ""встречается не менее двух раз"".","['open', 'open', 'closed', 'closed', 'closed']","<Task description>: Реализуйте программу, определяющую слова, которые нужно переводить:

В переменную N считывается целое число — количество записей, которые будут введены. Этот код уже написан.
В цикле while считывается N слов. 
Гарантируется, что будет введена как минимум одна строка.
Напечатайте количество слов, в которых буква ""а"" вне зависимости от регистра встречается не менее двух раз. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: 8
аркА
риторика
культурА
амфора
антитезА
Антипод
АтакА
английский 
<Вывод>: 4 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: 1
эпитет 
<Вывод>: 0 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: 9
балка
распоркА
акр
кронштейн
АпалубкА
арматура
Архитектор
антифриз
анАфорА 
<Вывод>: 5 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: 8
прпрп
лвоаимли
фывшмыв
фАвмтофф
йнгшй
фващм тм
фвшмщйтим
ворот 
<Вывод>: 0 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: 9
ААА
ааа
АаА
Аа
АА
аа
АББА
ПаПа
ПАПА 
<Вывод>: 9 
<Решение студента>: N = int(input())

# ваш код ниже

result = 0

while N != 0:
    info = input()
    
    if  info.lower().count('а') > 2:
        result += 1
    
    N -= 1
    
print(result) 
<Идеальное решение>: N = int(input())

# ваш код ниже

result = 0

while N != 0:
    info = input()
    
    if  info.lower().count('а') >= 2:
        result += 1
    
    N -= 1
    
print(result) 


<Комментарий эксперта>:"
156,421,26,"Реализуйте программу, определяющую слова, которые нужно переводить:

В переменную N считывается целое число — количество записей, которые будут введены. Этот код уже написан.
В цикле while считывается N слов. 
Гарантируется, что будет введена как минимум одна строка.
Напечатайте количество слов, в которых буква ""а"" вне зависимости от регистра встречается не менее двух раз.","['8\nаркА\nриторика\nкультурА\nамфора\nантитезА\nАнтипод\nАтакА\nанглийский', '1\nэпитет', '9\nбалка\nраспоркА\nакр\nкронштейн\nАпалубкА\nарматура\nАрхитектор\nантифриз\nанАфорА', '8\nпрпрп\nлвоаимли\nфывшмыв\nфАвмтофф\nйнгшй\nфващм тм\nфвшмщйтим\nворот', '9\nААА\nааа\nАаА\nАа\nАА\nаа\nАББА\nПаПа\nПАПА']","['4', '0', '5', '0', '9']","N = int(input())

# ваш код ниже

result = 0

while N != 0:
    info = input()
    
    if  info.lower().count('а') <= 2:
        result += 1
    
    N -= 1
    
print(result)","N = int(input())

# ваш код ниже

result = 0

while N != 0:
    info = input()
    
    if  info.lower().count('а') >= 2:
        result += 1
    
    N -= 1
    
print(result)","Ошибка в скрытых и открытых тестах.

Ваш код охватываает не все возможные случаи. Код некорректно работает с условием ""встречается не менее двух раз"".","['open', 'open', 'closed', 'closed', 'closed']","<Task description>: Реализуйте программу, определяющую слова, которые нужно переводить:

В переменную N считывается целое число — количество записей, которые будут введены. Этот код уже написан.
В цикле while считывается N слов. 
Гарантируется, что будет введена как минимум одна строка.
Напечатайте количество слов, в которых буква ""а"" вне зависимости от регистра встречается не менее двух раз. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: 8
аркА
риторика
культурА
амфора
антитезА
Антипод
АтакА
английский 
<Вывод>: 4 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: 1
эпитет 
<Вывод>: 0 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: 9
балка
распоркА
акр
кронштейн
АпалубкА
арматура
Архитектор
антифриз
анАфорА 
<Вывод>: 5 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: 8
прпрп
лвоаимли
фывшмыв
фАвмтофф
йнгшй
фващм тм
фвшмщйтим
ворот 
<Вывод>: 0 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: 9
ААА
ааа
АаА
Аа
АА
аа
АББА
ПаПа
ПАПА 
<Вывод>: 9 
<Решение студента>: N = int(input())

# ваш код ниже

result = 0

while N != 0:
    info = input()
    
    if  info.lower().count('а') <= 2:
        result += 1
    
    N -= 1
    
print(result) 
<Идеальное решение>: N = int(input())

# ваш код ниже

result = 0

while N != 0:
    info = input()
    
    if  info.lower().count('а') >= 2:
        result += 1
    
    N -= 1
    
print(result) 


<Комментарий эксперта>:"
157,422,26,"Реализуйте программу, определяющую слова, которые нужно переводить:

В переменную N считывается целое число — количество записей, которые будут введены. Этот код уже написан.
В цикле while считывается N слов. 
Гарантируется, что будет введена как минимум одна строка.
Напечатайте количество слов, в которых буква ""а"" вне зависимости от регистра встречается не менее двух раз.","['8\nаркА\nриторика\nкультурА\nамфора\nантитезА\nАнтипод\nАтакА\nанглийский', '1\nэпитет', '9\nбалка\nраспоркА\nакр\nкронштейн\nАпалубкА\nарматура\nАрхитектор\nантифриз\nанАфорА', '8\nпрпрп\nлвоаимли\nфывшмыв\nфАвмтофф\nйнгшй\nфващм тм\nфвшмщйтим\nворот', '9\nААА\nааа\nАаА\nАа\nАА\nаа\nАББА\nПаПа\nПАПА']","['4', '0', '5', '0', '9']","N = int(input())

# ваш код ниже

result = 0

while N != 0:
    info = input()
    
    if  info.lower().count('а') >= 2:
        result += 1
    
print(result)","N = int(input())

# ваш код ниже

result = 0

while N != 0:
    info = input()
    
    if  info.lower().count('а') >= 2:
        result += 1
    
    N -= 1
    
print(result)",Вы забыли добавить условие для изменение значения переменной-счетчика.,"['open', 'open', 'closed', 'closed', 'closed']","<Task description>: Реализуйте программу, определяющую слова, которые нужно переводить:

В переменную N считывается целое число — количество записей, которые будут введены. Этот код уже написан.
В цикле while считывается N слов. 
Гарантируется, что будет введена как минимум одна строка.
Напечатайте количество слов, в которых буква ""а"" вне зависимости от регистра встречается не менее двух раз. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: 8
аркА
риторика
культурА
амфора
антитезА
Антипод
АтакА
английский 
<Вывод>: 4 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: 1
эпитет 
<Вывод>: 0 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: 9
балка
распоркА
акр
кронштейн
АпалубкА
арматура
Архитектор
антифриз
анАфорА 
<Вывод>: 5 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: 8
прпрп
лвоаимли
фывшмыв
фАвмтофф
йнгшй
фващм тм
фвшмщйтим
ворот 
<Вывод>: 0 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: 9
ААА
ааа
АаА
Аа
АА
аа
АББА
ПаПа
ПАПА 
<Вывод>: 9 
<Решение студента>: N = int(input())

# ваш код ниже

result = 0

while N != 0:
    info = input()
    
    if  info.lower().count('а') >= 2:
        result += 1
    
print(result) 
<Идеальное решение>: N = int(input())

# ваш код ниже

result = 0

while N != 0:
    info = input()
    
    if  info.lower().count('а') >= 2:
        result += 1
    
    N -= 1
    
print(result) 


<Комментарий эксперта>:"
158,423,26,"Реализуйте программу, определяющую слова, которые нужно переводить:

В переменную N считывается целое число — количество записей, которые будут введены. Этот код уже написан.
В цикле while считывается N слов. 
Гарантируется, что будет введена как минимум одна строка.
Напечатайте количество слов, в которых буква ""а"" вне зависимости от регистра встречается не менее двух раз.","['8\nаркА\nриторика\nкультурА\nамфора\nантитезА\nАнтипод\nАтакА\nанглийский', '1\nэпитет', '9\nбалка\nраспоркА\nакр\nкронштейн\nАпалубкА\nарматура\nАрхитектор\nантифриз\nанАфорА', '8\nпрпрп\nлвоаимли\nфывшмыв\nфАвмтофф\nйнгшй\nфващм тм\nфвшмщйтим\nворот', '9\nААА\nааа\nАаА\nАа\nАА\nаа\nАББА\nПаПа\nПАПА']","['4', '0', '5', '0', '9']","N = int(input())

# ваш код ниже

result = 0

while N != 0:
    info = input()
    
    if  info.lower().count('а') >= 2:
        result += 1
    
    N += 1
    
print(result)","N = int(input())

# ваш код ниже

result = 0

while N != 0:
    info = input()
    
    if  info.lower().count('а') >= 2:
        result += 1
    
    N -= 1
    
print(result)",Вы некорректно обновляете значение переменной-счетчика.,"['open', 'open', 'closed', 'closed', 'closed']","<Task description>: Реализуйте программу, определяющую слова, которые нужно переводить:

В переменную N считывается целое число — количество записей, которые будут введены. Этот код уже написан.
В цикле while считывается N слов. 
Гарантируется, что будет введена как минимум одна строка.
Напечатайте количество слов, в которых буква ""а"" вне зависимости от регистра встречается не менее двух раз. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: 8
аркА
риторика
культурА
амфора
антитезА
Антипод
АтакА
английский 
<Вывод>: 4 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: 1
эпитет 
<Вывод>: 0 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: 9
балка
распоркА
акр
кронштейн
АпалубкА
арматура
Архитектор
антифриз
анАфорА 
<Вывод>: 5 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: 8
прпрп
лвоаимли
фывшмыв
фАвмтофф
йнгшй
фващм тм
фвшмщйтим
ворот 
<Вывод>: 0 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: 9
ААА
ааа
АаА
Аа
АА
аа
АББА
ПаПа
ПАПА 
<Вывод>: 9 
<Решение студента>: N = int(input())

# ваш код ниже

result = 0

while N != 0:
    info = input()
    
    if  info.lower().count('а') >= 2:
        result += 1
    
    N += 1
    
print(result) 
<Идеальное решение>: N = int(input())

# ваш код ниже

result = 0

while N != 0:
    info = input()
    
    if  info.lower().count('а') >= 2:
        result += 1
    
    N -= 1
    
print(result) 


<Комментарий эксперта>:"
159,424,26,"Реализуйте программу, определяющую слова, которые нужно переводить:

В переменную N считывается целое число — количество записей, которые будут введены. Этот код уже написан.
В цикле while считывается N слов. 
Гарантируется, что будет введена как минимум одна строка.
Напечатайте количество слов, в которых буква ""а"" вне зависимости от регистра встречается не менее двух раз.","['8\nаркА\nриторика\nкультурА\nамфора\nантитезА\nАнтипод\nАтакА\nанглийский', '1\nэпитет', '9\nбалка\nраспоркА\nакр\nкронштейн\nАпалубкА\nарматура\nАрхитектор\nантифриз\nанАфорА', '8\nпрпрп\nлвоаимли\nфывшмыв\nфАвмтофф\nйнгшй\nфващм тм\nфвшмщйтим\nворот', '9\nААА\nааа\nАаА\nАа\nАА\nаа\nАББА\nПаПа\nПАПА']","['4', '0', '5', '0', '9']","N = int(input())

# ваш код ниже

result = 0

while N != 0:
    info = input()
    
    if  info.lower().count('а') >= 2:
        result += 1
    
    N -= 1
    
print(info)","N = int(input())

# ваш код ниже

result = 0

while N != 0:
    info = input()
    
    if  info.lower().count('а') >= 2:
        result += 1
    
    N -= 1
    
print(result)","Ошибка в открытых и скрытых тестах. 

Ваш код выводит некорректную переменную. Убедитесь в том, что вы выводите только те данные, что требуются по заданию.","['open', 'open', 'closed', 'closed', 'closed']","<Task description>: Реализуйте программу, определяющую слова, которые нужно переводить:

В переменную N считывается целое число — количество записей, которые будут введены. Этот код уже написан.
В цикле while считывается N слов. 
Гарантируется, что будет введена как минимум одна строка.
Напечатайте количество слов, в которых буква ""а"" вне зависимости от регистра встречается не менее двух раз. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: 8
аркА
риторика
культурА
амфора
антитезА
Антипод
АтакА
английский 
<Вывод>: 4 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: 1
эпитет 
<Вывод>: 0 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: 9
балка
распоркА
акр
кронштейн
АпалубкА
арматура
Архитектор
антифриз
анАфорА 
<Вывод>: 5 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: 8
прпрп
лвоаимли
фывшмыв
фАвмтофф
йнгшй
фващм тм
фвшмщйтим
ворот 
<Вывод>: 0 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: 9
ААА
ааа
АаА
Аа
АА
аа
АББА
ПаПа
ПАПА 
<Вывод>: 9 
<Решение студента>: N = int(input())

# ваш код ниже

result = 0

while N != 0:
    info = input()
    
    if  info.lower().count('а') >= 2:
        result += 1
    
    N -= 1
    
print(info) 
<Идеальное решение>: N = int(input())

# ваш код ниже

result = 0

while N != 0:
    info = input()
    
    if  info.lower().count('а') >= 2:
        result += 1
    
    N -= 1
    
print(result) 


<Комментарий эксперта>:"
160,425,26,"Реализуйте программу, определяющую слова, которые нужно переводить:

В переменную N считывается целое число — количество записей, которые будут введены. Этот код уже написан.
В цикле while считывается N слов. 
Гарантируется, что будет введена как минимум одна строка.
Напечатайте количество слов, в которых буква ""а"" вне зависимости от регистра встречается не менее двух раз.","['8\nаркА\nриторика\nкультурА\nамфора\nантитезА\nАнтипод\nАтакА\nанглийский', '1\nэпитет', '9\nбалка\nраспоркА\nакр\nкронштейн\nАпалубкА\nарматура\nАрхитектор\nантифриз\nанАфорА', '8\nпрпрп\nлвоаимли\nфывшмыв\nфАвмтофф\nйнгшй\nфващм тм\nфвшмщйтим\nворот', '9\nААА\nааа\nАаА\nАа\nАА\nаа\nАББА\nПаПа\nПАПА']","['4', '0', '5', '0', '9']","N = int(input())

# ваш код ниже

result = 0

while N != 0:
    info = input()
    
    if  info.lower().count('а') >= 2:
        result += 1
    
N -= 1
    
print(result)","N = int(input())

# ваш код ниже

result = 0

while N != 0:
    info = input()
    
    if  info.lower().count('а') >= 2:
        result += 1
    
    N -= 1
    
print(result)","Ошибка в табуляции. Убедитесь, что переменная-счетчик обновляется внутри цикла.","['open', 'open', 'closed', 'closed', 'closed']","<Task description>: Реализуйте программу, определяющую слова, которые нужно переводить:

В переменную N считывается целое число — количество записей, которые будут введены. Этот код уже написан.
В цикле while считывается N слов. 
Гарантируется, что будет введена как минимум одна строка.
Напечатайте количество слов, в которых буква ""а"" вне зависимости от регистра встречается не менее двух раз. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: 8
аркА
риторика
культурА
амфора
антитезА
Антипод
АтакА
английский 
<Вывод>: 4 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: 1
эпитет 
<Вывод>: 0 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: 9
балка
распоркА
акр
кронштейн
АпалубкА
арматура
Архитектор
антифриз
анАфорА 
<Вывод>: 5 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: 8
прпрп
лвоаимли
фывшмыв
фАвмтофф
йнгшй
фващм тм
фвшмщйтим
ворот 
<Вывод>: 0 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: 9
ААА
ааа
АаА
Аа
АА
аа
АББА
ПаПа
ПАПА 
<Вывод>: 9 
<Решение студента>: N = int(input())

# ваш код ниже

result = 0

while N != 0:
    info = input()
    
    if  info.lower().count('а') >= 2:
        result += 1
    
N -= 1
    
print(result) 
<Идеальное решение>: N = int(input())

# ваш код ниже

result = 0

while N != 0:
    info = input()
    
    if  info.lower().count('а') >= 2:
        result += 1
    
    N -= 1
    
print(result) 


<Комментарий эксперта>:"
161,426,26,"Реализуйте программу, определяющую слова, которые нужно переводить:

В переменную N считывается целое число — количество записей, которые будут введены. Этот код уже написан.
В цикле while считывается N слов. 
Гарантируется, что будет введена как минимум одна строка.
Напечатайте количество слов, в которых буква ""а"" вне зависимости от регистра встречается не менее двух раз.","['8\nаркА\nриторика\nкультурА\nамфора\nантитезА\nАнтипод\nАтакА\nанглийский', '1\nэпитет', '9\nбалка\nраспоркА\nакр\nкронштейн\nАпалубкА\nарматура\nАрхитектор\nантифриз\nанАфорА', '8\nпрпрп\nлвоаимли\nфывшмыв\nфАвмтофф\nйнгшй\nфващм тм\nфвшмщйтим\nворот', '9\nААА\nааа\nАаА\nАа\nАА\nаа\nАББА\nПаПа\nПАПА']","['4', '0', '5', '0', '9']","N = int(input())

# ваш код ниже

result = 0

while N != 0:
    info = input()
    
    if  info.lower().count('а') >= 2:
        result += 1
    
    N -= 1
    
    print(result)","N = int(input())

# ваш код ниже

result = 0

while N != 0:
    info = input()
    
    if  info.lower().count('а') >= 2:
        result += 1
    
    N -= 1
    
print(result)","Ошибка в табуляции. По условию задания, данные необходимо напечатать только один раз.","['open', 'open', 'closed', 'closed', 'closed']","<Task description>: Реализуйте программу, определяющую слова, которые нужно переводить:

В переменную N считывается целое число — количество записей, которые будут введены. Этот код уже написан.
В цикле while считывается N слов. 
Гарантируется, что будет введена как минимум одна строка.
Напечатайте количество слов, в которых буква ""а"" вне зависимости от регистра встречается не менее двух раз. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: 8
аркА
риторика
культурА
амфора
антитезА
Антипод
АтакА
английский 
<Вывод>: 4 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: 1
эпитет 
<Вывод>: 0 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: 9
балка
распоркА
акр
кронштейн
АпалубкА
арматура
Архитектор
антифриз
анАфорА 
<Вывод>: 5 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: 8
прпрп
лвоаимли
фывшмыв
фАвмтофф
йнгшй
фващм тм
фвшмщйтим
ворот 
<Вывод>: 0 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: 9
ААА
ааа
АаА
Аа
АА
аа
АББА
ПаПа
ПАПА 
<Вывод>: 9 
<Решение студента>: N = int(input())

# ваш код ниже

result = 0

while N != 0:
    info = input()
    
    if  info.lower().count('а') >= 2:
        result += 1
    
    N -= 1
    
    print(result) 
<Идеальное решение>: N = int(input())

# ваш код ниже

result = 0

while N != 0:
    info = input()
    
    if  info.lower().count('а') >= 2:
        result += 1
    
    N -= 1
    
print(result) 


<Комментарий эксперта>:"
162,427,26,"Реализуйте программу, определяющую слова, которые нужно переводить:

В переменную N считывается целое число — количество записей, которые будут введены. Этот код уже написан.
В цикле while считывается N слов. 
Гарантируется, что будет введена как минимум одна строка.
Напечатайте количество слов, в которых буква ""а"" вне зависимости от регистра встречается не менее двух раз.","['8\nаркА\nриторика\nкультурА\nамфора\nантитезА\nАнтипод\nАтакА\nанглийский', '1\nэпитет', '9\nбалка\nраспоркА\nакр\nкронштейн\nАпалубкА\nарматура\nАрхитектор\nантифриз\nанАфорА', '8\nпрпрп\nлвоаимли\nфывшмыв\nфАвмтофф\nйнгшй\nфващм тм\nфвшмщйтим\nворот', '9\nААА\nааа\nАаА\nАа\nАА\nаа\nАББА\nПаПа\nПАПА']","['4', '0', '5', '0', '9']","N = int(input())

# ваш код ниже

result = 0

while N != 0:
    info = input()
    
    if  info.lower().count('а') >= 2
        result += 1
    
    N -= 1
    
print(result)","N = int(input())

# ваш код ниже

result = 0

while N != 0:
    info = input()
    
    if  info.lower().count('а') >= 2:
        result += 1
    
    N -= 1
    
print(result)",Вы забыли поставить двоеточие после условия.,"['open', 'open', 'closed', 'closed', 'closed']","<Task description>: Реализуйте программу, определяющую слова, которые нужно переводить:

В переменную N считывается целое число — количество записей, которые будут введены. Этот код уже написан.
В цикле while считывается N слов. 
Гарантируется, что будет введена как минимум одна строка.
Напечатайте количество слов, в которых буква ""а"" вне зависимости от регистра встречается не менее двух раз. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: 8
аркА
риторика
культурА
амфора
антитезА
Антипод
АтакА
английский 
<Вывод>: 4 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: 1
эпитет 
<Вывод>: 0 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: 9
балка
распоркА
акр
кронштейн
АпалубкА
арматура
Архитектор
антифриз
анАфорА 
<Вывод>: 5 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: 8
прпрп
лвоаимли
фывшмыв
фАвмтофф
йнгшй
фващм тм
фвшмщйтим
ворот 
<Вывод>: 0 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: 9
ААА
ааа
АаА
Аа
АА
аа
АББА
ПаПа
ПАПА 
<Вывод>: 9 
<Решение студента>: N = int(input())

# ваш код ниже

result = 0

while N != 0:
    info = input()
    
    if  info.lower().count('а') >= 2
        result += 1
    
    N -= 1
    
print(result) 
<Идеальное решение>: N = int(input())

# ваш код ниже

result = 0

while N != 0:
    info = input()
    
    if  info.lower().count('а') >= 2:
        result += 1
    
    N -= 1
    
print(result) 


<Комментарий эксперта>:"
163,428,27,"Реализуйте программу, которая напечатает количество тюркизмов, встречающихся в тексте: 

В переменную sentence считывается текст. Этот код уже написан.
Программа проверяет, есть ли в этом тексте тюркизмы. Гарантируется, что тюркизмы — это всегда слова, которые отделены от другого текста пробелом, состоящие только из букв, в которых встречается буквосочетание ""аз"" или которые заканчиваются на буквосочетание ""ук"". 
Гарантируется, что тюркизмы не повторяются.
В конце программа печатает количество всех тюркизмов, встречающихся в тексте. 
Если названий тюркизмов в тексте нет, программа печатает строку ""Тюркизмов в тексте нет"".","['Открыв сундук , исследователи увидели сюртук , который сиял как алмаз', 'Переводчик переводит текст', 'Казна была потрачена на строительство сооружения под названием акведук . Наступил пра1з1дник !', 'латук тулук дудук чубук укроп празденство барсук азора рука', 'укрытие укор раз1бор луковица азы! зазор123']","['3', 'Тюркизмов в тексте нет', '3', '7', 'Тюркизмов в тексте нет']","sentence = input()

res = 0
for info in sentence:
    if info.isalpha() and (info.endswith('ук') or 'аз' in info):      
        res += 1
        
if res == 0:
    res = ""Тюркизмов в тексте нет""

print(res)","sentence = input()

res = 0
for info in sentence.split():
    if info.isalpha() and (info.endswith('ук') or 'аз' in info):      
        res += 1
        
if res == 0:
    res = ""Тюркизмов в тексте нет""

print(res)","Ошибка в скрытых и открытых тестах.

Ваш код некорректно обрабатывает данные. Для обращения к каждому элементу строки необходимо ее разделить.","['open', 'open', 'open', 'closed', 'closed']","<Task description>: Реализуйте программу, которая напечатает количество тюркизмов, встречающихся в тексте: 

В переменную sentence считывается текст. Этот код уже написан.
Программа проверяет, есть ли в этом тексте тюркизмы. Гарантируется, что тюркизмы — это всегда слова, которые отделены от другого текста пробелом, состоящие только из букв, в которых встречается буквосочетание ""аз"" или которые заканчиваются на буквосочетание ""ук"". 
Гарантируется, что тюркизмы не повторяются.
В конце программа печатает количество всех тюркизмов, встречающихся в тексте. 
Если названий тюркизмов в тексте нет, программа печатает строку ""Тюркизмов в тексте нет"". 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: Открыв сундук , исследователи увидели сюртук , который сиял как алмаз 
<Вывод>: 3 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: Переводчик переводит текст 
<Вывод>: Тюркизмов в тексте нет 
<Example 3>: 
<Тип теста 3>: open 
<Ввод>: Казна была потрачена на строительство сооружения под названием акведук . Наступил пра1з1дник ! 
<Вывод>: 3 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: латук тулук дудук чубук укроп празденство барсук азора рука 
<Вывод>: 7 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: укрытие укор раз1бор луковица азы! зазор123 
<Вывод>: Тюркизмов в тексте нет 
<Решение студента>: sentence = input()

res = 0
for info in sentence:
    if info.isalpha() and (info.endswith('ук') or 'аз' in info):      
        res += 1
        
if res == 0:
    res = ""Тюркизмов в тексте нет""

print(res) 
<Идеальное решение>: sentence = input()

res = 0
for info in sentence.split():
    if info.isalpha() and (info.endswith('ук') or 'аз' in info):      
        res += 1
        
if res == 0:
    res = ""Тюркизмов в тексте нет""

print(res) 


<Комментарий эксперта>:"
164,429,27,"Реализуйте программу, которая напечатает количество тюркизмов, встречающихся в тексте: 

В переменную sentence считывается текст. Этот код уже написан.
Программа проверяет, есть ли в этом тексте тюркизмы. Гарантируется, что тюркизмы — это всегда слова, которые отделены от другого текста пробелом, состоящие только из букв, в которых встречается буквосочетание ""аз"" или которые заканчиваются на буквосочетание ""ук"". 
Гарантируется, что тюркизмы не повторяются.
В конце программа печатает количество всех тюркизмов, встречающихся в тексте. 
Если названий тюркизмов в тексте нет, программа печатает строку ""Тюркизмов в тексте нет"".","['Открыв сундук , исследователи увидели сюртук , который сиял как алмаз', 'Переводчик переводит текст', 'Казна была потрачена на строительство сооружения под названием акведук . Наступил пра1з1дник !', 'латук тулук дудук чубук укроп празденство барсук азора рука', 'укрытие укор раз1бор луковица азы! зазор123']","['3', 'Тюркизмов в тексте нет', '3', '7', 'Тюркизмов в тексте нет']","sentence = input()

res = 0
for info in sentence.split():
    if not(info.isnumeric()) and (info.endswith('ук') or 'аз' in info):      
        res += 1
        
if res == 0:
    res = ""Тюркизмов в тексте нет""

print(res)","sentence = input()

res = 0
for info in sentence.split():
    if info.isalpha() and (info.endswith('ук') or 'аз' in info):      
        res += 1
        
if res == 0:
    res = ""Тюркизмов в тексте нет""

print(res)","Ошибка в скрытых тестах.

Вы некорректно реализуете условие задания. Ваш код некорректно работает с условеим ""состоящие только из букв"".","['open', 'open', 'open', 'closed', 'closed']","<Task description>: Реализуйте программу, которая напечатает количество тюркизмов, встречающихся в тексте: 

В переменную sentence считывается текст. Этот код уже написан.
Программа проверяет, есть ли в этом тексте тюркизмы. Гарантируется, что тюркизмы — это всегда слова, которые отделены от другого текста пробелом, состоящие только из букв, в которых встречается буквосочетание ""аз"" или которые заканчиваются на буквосочетание ""ук"". 
Гарантируется, что тюркизмы не повторяются.
В конце программа печатает количество всех тюркизмов, встречающихся в тексте. 
Если названий тюркизмов в тексте нет, программа печатает строку ""Тюркизмов в тексте нет"". 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: Открыв сундук , исследователи увидели сюртук , который сиял как алмаз 
<Вывод>: 3 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: Переводчик переводит текст 
<Вывод>: Тюркизмов в тексте нет 
<Example 3>: 
<Тип теста 3>: open 
<Ввод>: Казна была потрачена на строительство сооружения под названием акведук . Наступил пра1з1дник ! 
<Вывод>: 3 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: латук тулук дудук чубук укроп празденство барсук азора рука 
<Вывод>: 7 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: укрытие укор раз1бор луковица азы! зазор123 
<Вывод>: Тюркизмов в тексте нет 
<Решение студента>: sentence = input()

res = 0
for info in sentence.split():
    if not(info.isnumeric()) and (info.endswith('ук') or 'аз' in info):      
        res += 1
        
if res == 0:
    res = ""Тюркизмов в тексте нет""

print(res) 
<Идеальное решение>: sentence = input()

res = 0
for info in sentence.split():
    if info.isalpha() and (info.endswith('ук') or 'аз' in info):      
        res += 1
        
if res == 0:
    res = ""Тюркизмов в тексте нет""

print(res) 


<Комментарий эксперта>:"
165,430,27,"Реализуйте программу, которая напечатает количество тюркизмов, встречающихся в тексте: 

В переменную sentence считывается текст. Этот код уже написан.
Программа проверяет, есть ли в этом тексте тюркизмы. Гарантируется, что тюркизмы — это всегда слова, которые отделены от другого текста пробелом, состоящие только из букв, в которых встречается буквосочетание ""аз"" или которые заканчиваются на буквосочетание ""ук"". 
Гарантируется, что тюркизмы не повторяются.
В конце программа печатает количество всех тюркизмов, встречающихся в тексте. 
Если названий тюркизмов в тексте нет, программа печатает строку ""Тюркизмов в тексте нет"".","['Открыв сундук , исследователи увидели сюртук , который сиял как алмаз', 'Переводчик переводит текст', 'Казна была потрачена на строительство сооружения под названием акведук . Наступил пра1з1дник !', 'латук тулук дудук чубук укроп празденство барсук азора рука', 'укрытие укор раз1бор луковица азы! зазор123']","['3', 'Тюркизмов в тексте нет', '3', '7', 'Тюркизмов в тексте нет']","sentence = input()

res = 0
for info in sentence.split():
    if info.isalpha and (info.endswith('ук') or 'аз' in info):      
        res += 1
        
if res == 0:
    res = ""Тюркизмов в тексте нет""

print(res)","sentence = input()

res = 0
for info in sentence.split():
    if info.isalpha() and (info.endswith('ук') or 'аз' in info):      
        res += 1
        
if res == 0:
    res = ""Тюркизмов в тексте нет""

print(res)","Ошибка в скрытых тестах.

Вы забыли поставить скобки после функции isalpha().","['open', 'open', 'open', 'closed', 'closed']","<Task description>: Реализуйте программу, которая напечатает количество тюркизмов, встречающихся в тексте: 

В переменную sentence считывается текст. Этот код уже написан.
Программа проверяет, есть ли в этом тексте тюркизмы. Гарантируется, что тюркизмы — это всегда слова, которые отделены от другого текста пробелом, состоящие только из букв, в которых встречается буквосочетание ""аз"" или которые заканчиваются на буквосочетание ""ук"". 
Гарантируется, что тюркизмы не повторяются.
В конце программа печатает количество всех тюркизмов, встречающихся в тексте. 
Если названий тюркизмов в тексте нет, программа печатает строку ""Тюркизмов в тексте нет"". 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: Открыв сундук , исследователи увидели сюртук , который сиял как алмаз 
<Вывод>: 3 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: Переводчик переводит текст 
<Вывод>: Тюркизмов в тексте нет 
<Example 3>: 
<Тип теста 3>: open 
<Ввод>: Казна была потрачена на строительство сооружения под названием акведук . Наступил пра1з1дник ! 
<Вывод>: 3 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: латук тулук дудук чубук укроп празденство барсук азора рука 
<Вывод>: 7 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: укрытие укор раз1бор луковица азы! зазор123 
<Вывод>: Тюркизмов в тексте нет 
<Решение студента>: sentence = input()

res = 0
for info in sentence.split():
    if info.isalpha and (info.endswith('ук') or 'аз' in info):      
        res += 1
        
if res == 0:
    res = ""Тюркизмов в тексте нет""

print(res) 
<Идеальное решение>: sentence = input()

res = 0
for info in sentence.split():
    if info.isalpha() and (info.endswith('ук') or 'аз' in info):      
        res += 1
        
if res == 0:
    res = ""Тюркизмов в тексте нет""

print(res) 


<Комментарий эксперта>:"
166,431,27,"Реализуйте программу, которая напечатает количество тюркизмов, встречающихся в тексте: 

В переменную sentence считывается текст. Этот код уже написан.
Программа проверяет, есть ли в этом тексте тюркизмы. Гарантируется, что тюркизмы — это всегда слова, которые отделены от другого текста пробелом, состоящие только из букв, в которых встречается буквосочетание ""аз"" или которые заканчиваются на буквосочетание ""ук"". 
Гарантируется, что тюркизмы не повторяются.
В конце программа печатает количество всех тюркизмов, встречающихся в тексте. 
Если названий тюркизмов в тексте нет, программа печатает строку ""Тюркизмов в тексте нет"".","['Открыв сундук , исследователи увидели сюртук , который сиял как алмаз', 'Переводчик переводит текст', 'Казна была потрачена на строительство сооружения под названием акведук . Наступил пра1з1дник !', 'латук тулук дудук чубук укроп празденство барсук азора рука', 'укрытие укор раз1бор луковица азы! зазор123']","['3', 'Тюркизмов в тексте нет', '3', '7', 'Тюркизмов в тексте нет']","sentence = input()

res = 0
for info in sentence.split():
    if info.isalpha() or (info.endswith('ук') or 'аз' in info):      
        res += 1
        
if res == 0:
    res = ""Тюркизмов в тексте нет""

print(res)","sentence = input()

res = 0
for info in sentence.split():
    if info.isalpha() and (info.endswith('ук') or 'аз' in info):      
        res += 1
        
if res == 0:
    res = ""Тюркизмов в тексте нет""

print(res)","Ошибка в открытых и скрытых тестах. 

Обратите внимание, что вы должны проверить, что условия ""состоящие только из букв, в которых встречается буквосочетание ""аз"" или которые заканчиваются на буквосочетание ""ук"""" выполняются одновременно.","['open', 'open', 'open', 'closed', 'closed']","<Task description>: Реализуйте программу, которая напечатает количество тюркизмов, встречающихся в тексте: 

В переменную sentence считывается текст. Этот код уже написан.
Программа проверяет, есть ли в этом тексте тюркизмы. Гарантируется, что тюркизмы — это всегда слова, которые отделены от другого текста пробелом, состоящие только из букв, в которых встречается буквосочетание ""аз"" или которые заканчиваются на буквосочетание ""ук"". 
Гарантируется, что тюркизмы не повторяются.
В конце программа печатает количество всех тюркизмов, встречающихся в тексте. 
Если названий тюркизмов в тексте нет, программа печатает строку ""Тюркизмов в тексте нет"". 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: Открыв сундук , исследователи увидели сюртук , который сиял как алмаз 
<Вывод>: 3 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: Переводчик переводит текст 
<Вывод>: Тюркизмов в тексте нет 
<Example 3>: 
<Тип теста 3>: open 
<Ввод>: Казна была потрачена на строительство сооружения под названием акведук . Наступил пра1з1дник ! 
<Вывод>: 3 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: латук тулук дудук чубук укроп празденство барсук азора рука 
<Вывод>: 7 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: укрытие укор раз1бор луковица азы! зазор123 
<Вывод>: Тюркизмов в тексте нет 
<Решение студента>: sentence = input()

res = 0
for info in sentence.split():
    if info.isalpha() or (info.endswith('ук') or 'аз' in info):      
        res += 1
        
if res == 0:
    res = ""Тюркизмов в тексте нет""

print(res) 
<Идеальное решение>: sentence = input()

res = 0
for info in sentence.split():
    if info.isalpha() and (info.endswith('ук') or 'аз' in info):      
        res += 1
        
if res == 0:
    res = ""Тюркизмов в тексте нет""

print(res) 


<Комментарий эксперта>:"
167,432,27,"Реализуйте программу, которая напечатает количество тюркизмов, встречающихся в тексте: 

В переменную sentence считывается текст. Этот код уже написан.
Программа проверяет, есть ли в этом тексте тюркизмы. Гарантируется, что тюркизмы — это всегда слова, которые отделены от другого текста пробелом, состоящие только из букв, в которых встречается буквосочетание ""аз"" или которые заканчиваются на буквосочетание ""ук"". 
Гарантируется, что тюркизмы не повторяются.
В конце программа печатает количество всех тюркизмов, встречающихся в тексте. 
Если названий тюркизмов в тексте нет, программа печатает строку ""Тюркизмов в тексте нет"".","['Открыв сундук , исследователи увидели сюртук , который сиял как алмаз', 'Переводчик переводит текст', 'Казна была потрачена на строительство сооружения под названием акведук . Наступил пра1з1дник !', 'латук тулук дудук чубук укроп празденство барсук азора рука', 'укрытие укор раз1бор луковица азы! зазор123']","['3', 'Тюркизмов в тексте нет', '3', '7', 'Тюркизмов в тексте нет']","sentence = input()

res = 0
for info in sentence.split():
    if info.isalpha() and (info.endswith('ук') and 'аз' in info):      
        res += 1
        
if res == 0:
    res = ""Тюркизмов в тексте нет""

print(res)","sentence = input()

res = 0
for info in sentence.split():
    if info.isalpha() and (info.endswith('ук') or 'аз' in info):      
        res += 1
        
if res == 0:
    res = ""Тюркизмов в тексте нет""

print(res)","Ошибка в открытых и скрытых тестах. 

Обратите внимание, что условия ""в которых встречается буквосочетание ""аз"" или которые заканчиваются на буквосочетание ""ук"" могут выполняться не одновременно.","['open', 'open', 'open', 'closed', 'closed']","<Task description>: Реализуйте программу, которая напечатает количество тюркизмов, встречающихся в тексте: 

В переменную sentence считывается текст. Этот код уже написан.
Программа проверяет, есть ли в этом тексте тюркизмы. Гарантируется, что тюркизмы — это всегда слова, которые отделены от другого текста пробелом, состоящие только из букв, в которых встречается буквосочетание ""аз"" или которые заканчиваются на буквосочетание ""ук"". 
Гарантируется, что тюркизмы не повторяются.
В конце программа печатает количество всех тюркизмов, встречающихся в тексте. 
Если названий тюркизмов в тексте нет, программа печатает строку ""Тюркизмов в тексте нет"". 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: Открыв сундук , исследователи увидели сюртук , который сиял как алмаз 
<Вывод>: 3 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: Переводчик переводит текст 
<Вывод>: Тюркизмов в тексте нет 
<Example 3>: 
<Тип теста 3>: open 
<Ввод>: Казна была потрачена на строительство сооружения под названием акведук . Наступил пра1з1дник ! 
<Вывод>: 3 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: латук тулук дудук чубук укроп празденство барсук азора рука 
<Вывод>: 7 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: укрытие укор раз1бор луковица азы! зазор123 
<Вывод>: Тюркизмов в тексте нет 
<Решение студента>: sentence = input()

res = 0
for info in sentence.split():
    if info.isalpha() and (info.endswith('ук') and 'аз' in info):      
        res += 1
        
if res == 0:
    res = ""Тюркизмов в тексте нет""

print(res) 
<Идеальное решение>: sentence = input()

res = 0
for info in sentence.split():
    if info.isalpha() and (info.endswith('ук') or 'аз' in info):      
        res += 1
        
if res == 0:
    res = ""Тюркизмов в тексте нет""

print(res) 


<Комментарий эксперта>:"
168,433,27,"Реализуйте программу, которая напечатает количество тюркизмов, встречающихся в тексте: 

В переменную sentence считывается текст. Этот код уже написан.
Программа проверяет, есть ли в этом тексте тюркизмы. Гарантируется, что тюркизмы — это всегда слова, которые отделены от другого текста пробелом, состоящие только из букв, в которых встречается буквосочетание ""аз"" или которые заканчиваются на буквосочетание ""ук"". 
Гарантируется, что тюркизмы не повторяются.
В конце программа печатает количество всех тюркизмов, встречающихся в тексте. 
Если названий тюркизмов в тексте нет, программа печатает строку ""Тюркизмов в тексте нет"".","['Открыв сундук , исследователи увидели сюртук , который сиял как алмаз', 'Переводчик переводит текст', 'Казна была потрачена на строительство сооружения под названием акведук . Наступил пра1з1дник !', 'латук тулук дудук чубук укроп празденство барсук азора рука', 'укрытие укор раз1бор луковица азы! зазор123']","['3', 'Тюркизмов в тексте нет', '3', '7', 'Тюркизмов в тексте нет']","sentence = input()

res = 0
for info in sentence.split():
    if info.isalpha() and (info.endswith('ук') or 'аз' in info):      
        res += 1
        
print(res)","sentence = input()

res = 0
for info in sentence.split():
    if info.isalpha() and (info.endswith('ук') or 'аз' in info):      
        res += 1
        
if res == 0:
    res = ""Тюркизмов в тексте нет""

print(res)","Ошибка в открытых и скрытых тестах. 

Обратите внимание, что Ваш код не выполняет условие ""если названий тюркизмов в тексте нет, программа печатает строку ""Тюркизмов в тексте нет"".","['open', 'open', 'open', 'closed', 'closed']","<Task description>: Реализуйте программу, которая напечатает количество тюркизмов, встречающихся в тексте: 

В переменную sentence считывается текст. Этот код уже написан.
Программа проверяет, есть ли в этом тексте тюркизмы. Гарантируется, что тюркизмы — это всегда слова, которые отделены от другого текста пробелом, состоящие только из букв, в которых встречается буквосочетание ""аз"" или которые заканчиваются на буквосочетание ""ук"". 
Гарантируется, что тюркизмы не повторяются.
В конце программа печатает количество всех тюркизмов, встречающихся в тексте. 
Если названий тюркизмов в тексте нет, программа печатает строку ""Тюркизмов в тексте нет"". 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: Открыв сундук , исследователи увидели сюртук , который сиял как алмаз 
<Вывод>: 3 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: Переводчик переводит текст 
<Вывод>: Тюркизмов в тексте нет 
<Example 3>: 
<Тип теста 3>: open 
<Ввод>: Казна была потрачена на строительство сооружения под названием акведук . Наступил пра1з1дник ! 
<Вывод>: 3 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: латук тулук дудук чубук укроп празденство барсук азора рука 
<Вывод>: 7 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: укрытие укор раз1бор луковица азы! зазор123 
<Вывод>: Тюркизмов в тексте нет 
<Решение студента>: sentence = input()

res = 0
for info in sentence.split():
    if info.isalpha() and (info.endswith('ук') or 'аз' in info):      
        res += 1
        
print(res) 
<Идеальное решение>: sentence = input()

res = 0
for info in sentence.split():
    if info.isalpha() and (info.endswith('ук') or 'аз' in info):      
        res += 1
        
if res == 0:
    res = ""Тюркизмов в тексте нет""

print(res) 


<Комментарий эксперта>:"
169,434,27,"Реализуйте программу, которая напечатает количество тюркизмов, встречающихся в тексте: 

В переменную sentence считывается текст. Этот код уже написан.
Программа проверяет, есть ли в этом тексте тюркизмы. Гарантируется, что тюркизмы — это всегда слова, которые отделены от другого текста пробелом, состоящие только из букв, в которых встречается буквосочетание ""аз"" или которые заканчиваются на буквосочетание ""ук"". 
Гарантируется, что тюркизмы не повторяются.
В конце программа печатает количество всех тюркизмов, встречающихся в тексте. 
Если названий тюркизмов в тексте нет, программа печатает строку ""Тюркизмов в тексте нет"".","['Открыв сундук , исследователи увидели сюртук , который сиял как алмаз', 'Переводчик переводит текст', 'Казна была потрачена на строительство сооружения под названием акведук . Наступил пра1з1дник !', 'латук тулук дудук чубук укроп празденство барсук азора рука', 'укрытие укор раз1бор луковица азы! зазор123']","['3', 'Тюркизмов в тексте нет', '3', '7', 'Тюркизмов в тексте нет']","sentence = input()

res = 0
for info in sentence.split():
    if info.isalpha() and (info.endswith('ук') or 'аз' in info):      
        res += 1
    else:
        print('Тюркизмов в тексте нет')
print(res)","sentence = input()

res = 0
for info in sentence.split():
    if info.isalpha() and (info.endswith('ук') or 'аз' in info):      
        res += 1
        
if res == 0:
    res = ""Тюркизмов в тексте нет""

print(res)","Ошибка в открытых и скрытых тестах. 

Обратите внимание, что фразу ""Тюркизмов в тексте нет"" следует печатать только тогда, когда все вводные данные не отвечают поставленным условиям.","['open', 'open', 'open', 'closed', 'closed']","<Task description>: Реализуйте программу, которая напечатает количество тюркизмов, встречающихся в тексте: 

В переменную sentence считывается текст. Этот код уже написан.
Программа проверяет, есть ли в этом тексте тюркизмы. Гарантируется, что тюркизмы — это всегда слова, которые отделены от другого текста пробелом, состоящие только из букв, в которых встречается буквосочетание ""аз"" или которые заканчиваются на буквосочетание ""ук"". 
Гарантируется, что тюркизмы не повторяются.
В конце программа печатает количество всех тюркизмов, встречающихся в тексте. 
Если названий тюркизмов в тексте нет, программа печатает строку ""Тюркизмов в тексте нет"". 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: Открыв сундук , исследователи увидели сюртук , который сиял как алмаз 
<Вывод>: 3 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: Переводчик переводит текст 
<Вывод>: Тюркизмов в тексте нет 
<Example 3>: 
<Тип теста 3>: open 
<Ввод>: Казна была потрачена на строительство сооружения под названием акведук . Наступил пра1з1дник ! 
<Вывод>: 3 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: латук тулук дудук чубук укроп празденство барсук азора рука 
<Вывод>: 7 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: укрытие укор раз1бор луковица азы! зазор123 
<Вывод>: Тюркизмов в тексте нет 
<Решение студента>: sentence = input()

res = 0
for info in sentence.split():
    if info.isalpha() and (info.endswith('ук') or 'аз' in info):      
        res += 1
    else:
        print('Тюркизмов в тексте нет')
print(res) 
<Идеальное решение>: sentence = input()

res = 0
for info in sentence.split():
    if info.isalpha() and (info.endswith('ук') or 'аз' in info):      
        res += 1
        
if res == 0:
    res = ""Тюркизмов в тексте нет""

print(res) 


<Комментарий эксперта>:"
170,435,27,"Реализуйте программу, которая напечатает количество тюркизмов, встречающихся в тексте: 

В переменную sentence считывается текст. Этот код уже написан.
Программа проверяет, есть ли в этом тексте тюркизмы. Гарантируется, что тюркизмы — это всегда слова, которые отделены от другого текста пробелом, состоящие только из букв, в которых встречается буквосочетание ""аз"" или которые заканчиваются на буквосочетание ""ук"". 
Гарантируется, что тюркизмы не повторяются.
В конце программа печатает количество всех тюркизмов, встречающихся в тексте. 
Если названий тюркизмов в тексте нет, программа печатает строку ""Тюркизмов в тексте нет"".","['Открыв сундук , исследователи увидели сюртук , который сиял как алмаз', 'Переводчик переводит текст', 'Казна была потрачена на строительство сооружения под названием акведук . Наступил пра1з1дник !', 'латук тулук дудук чубук укроп празденство барсук азора рука', 'укрытие укор раз1бор луковица азы! зазор123']","['3', 'Тюркизмов в тексте нет', '3', '7', 'Тюркизмов в тексте нет']","sentence = input()

res = 0
for info in sentence.split():
    if info.isalpha() and (info.endswith('ук') or 'аз' in info):      
        res += 1
        
if res = 0:
    res = ""Тюркизмов в тексте нет""

print(res)","sentence = input()

res = 0
for info in sentence.split():
    if info.isalpha() and (info.endswith('ук') or 'аз' in info):      
        res += 1
        
if res == 0:
    res = ""Тюркизмов в тексте нет""

print(res)",Синтаксическая ошибка. При сравнении двух значений используйте знак двойного равенства.,"['open', 'open', 'open', 'closed', 'closed']","<Task description>: Реализуйте программу, которая напечатает количество тюркизмов, встречающихся в тексте: 

В переменную sentence считывается текст. Этот код уже написан.
Программа проверяет, есть ли в этом тексте тюркизмы. Гарантируется, что тюркизмы — это всегда слова, которые отделены от другого текста пробелом, состоящие только из букв, в которых встречается буквосочетание ""аз"" или которые заканчиваются на буквосочетание ""ук"". 
Гарантируется, что тюркизмы не повторяются.
В конце программа печатает количество всех тюркизмов, встречающихся в тексте. 
Если названий тюркизмов в тексте нет, программа печатает строку ""Тюркизмов в тексте нет"". 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: Открыв сундук , исследователи увидели сюртук , который сиял как алмаз 
<Вывод>: 3 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: Переводчик переводит текст 
<Вывод>: Тюркизмов в тексте нет 
<Example 3>: 
<Тип теста 3>: open 
<Ввод>: Казна была потрачена на строительство сооружения под названием акведук . Наступил пра1з1дник ! 
<Вывод>: 3 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: латук тулук дудук чубук укроп празденство барсук азора рука 
<Вывод>: 7 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: укрытие укор раз1бор луковица азы! зазор123 
<Вывод>: Тюркизмов в тексте нет 
<Решение студента>: sentence = input()

res = 0
for info in sentence.split():
    if info.isalpha() and (info.endswith('ук') or 'аз' in info):      
        res += 1
        
if res = 0:
    res = ""Тюркизмов в тексте нет""

print(res) 
<Идеальное решение>: sentence = input()

res = 0
for info in sentence.split():
    if info.isalpha() and (info.endswith('ук') or 'аз' in info):      
        res += 1
        
if res == 0:
    res = ""Тюркизмов в тексте нет""

print(res) 


<Комментарий эксперта>:"
171,436,27,"Реализуйте программу, которая напечатает количество тюркизмов, встречающихся в тексте: 

В переменную sentence считывается текст. Этот код уже написан.
Программа проверяет, есть ли в этом тексте тюркизмы. Гарантируется, что тюркизмы — это всегда слова, которые отделены от другого текста пробелом, состоящие только из букв, в которых встречается буквосочетание ""аз"" или которые заканчиваются на буквосочетание ""ук"". 
Гарантируется, что тюркизмы не повторяются.
В конце программа печатает количество всех тюркизмов, встречающихся в тексте. 
Если названий тюркизмов в тексте нет, программа печатает строку ""Тюркизмов в тексте нет"".","['Открыв сундук , исследователи увидели сюртук , который сиял как алмаз', 'Переводчик переводит текст', 'Казна была потрачена на строительство сооружения под названием акведук . Наступил пра1з1дник !', 'латук тулук дудук чубук укроп празденство барсук азора рука', 'укрытие укор раз1бор луковица азы! зазор123']","['3', 'Тюркизмов в тексте нет', '3', '7', 'Тюркизмов в тексте нет']","sentence = input()

res = 0
for info in sentence.split():
    if info.isalpha() and (info.endswith('ук') or 'аз' in info)  
        res += 1
        
if res == 0:
    res = ""Тюркизмов в тексте нет""

print(res)","sentence = input()

res = 0
for info in sentence.split():
    if info.isalpha() and (info.endswith('ук') or 'аз' in info):      
        res += 1
        
if res == 0:
    res = ""Тюркизмов в тексте нет""

print(res)",Вы забыли поставить двоеточие после условия.,"['open', 'open', 'open', 'closed', 'closed']","<Task description>: Реализуйте программу, которая напечатает количество тюркизмов, встречающихся в тексте: 

В переменную sentence считывается текст. Этот код уже написан.
Программа проверяет, есть ли в этом тексте тюркизмы. Гарантируется, что тюркизмы — это всегда слова, которые отделены от другого текста пробелом, состоящие только из букв, в которых встречается буквосочетание ""аз"" или которые заканчиваются на буквосочетание ""ук"". 
Гарантируется, что тюркизмы не повторяются.
В конце программа печатает количество всех тюркизмов, встречающихся в тексте. 
Если названий тюркизмов в тексте нет, программа печатает строку ""Тюркизмов в тексте нет"". 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: Открыв сундук , исследователи увидели сюртук , который сиял как алмаз 
<Вывод>: 3 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: Переводчик переводит текст 
<Вывод>: Тюркизмов в тексте нет 
<Example 3>: 
<Тип теста 3>: open 
<Ввод>: Казна была потрачена на строительство сооружения под названием акведук . Наступил пра1з1дник ! 
<Вывод>: 3 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: латук тулук дудук чубук укроп празденство барсук азора рука 
<Вывод>: 7 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: укрытие укор раз1бор луковица азы! зазор123 
<Вывод>: Тюркизмов в тексте нет 
<Решение студента>: sentence = input()

res = 0
for info in sentence.split():
    if info.isalpha() and (info.endswith('ук') or 'аз' in info)  
        res += 1
        
if res == 0:
    res = ""Тюркизмов в тексте нет""

print(res) 
<Идеальное решение>: sentence = input()

res = 0
for info in sentence.split():
    if info.isalpha() and (info.endswith('ук') or 'аз' in info):      
        res += 1
        
if res == 0:
    res = ""Тюркизмов в тексте нет""

print(res) 


<Комментарий эксперта>:"
172,437,27,"Реализуйте программу, которая напечатает количество тюркизмов, встречающихся в тексте: 

В переменную sentence считывается текст. Этот код уже написан.
Программа проверяет, есть ли в этом тексте тюркизмы. Гарантируется, что тюркизмы — это всегда слова, которые отделены от другого текста пробелом, состоящие только из букв, в которых встречается буквосочетание ""аз"" или которые заканчиваются на буквосочетание ""ук"". 
Гарантируется, что тюркизмы не повторяются.
В конце программа печатает количество всех тюркизмов, встречающихся в тексте. 
Если названий тюркизмов в тексте нет, программа печатает строку ""Тюркизмов в тексте нет"".","['Открыв сундук , исследователи увидели сюртук , который сиял как алмаз', 'Переводчик переводит текст', 'Казна была потрачена на строительство сооружения под названием акведук . Наступил пра1з1дник !', 'латук тулук дудук чубук укроп празденство барсук азора рука', 'укрытие укор раз1бор луковица азы! зазор123']","['3', 'Тюркизмов в тексте нет', '3', '7', 'Тюркизмов в тексте нет']","sentence = input()

res = 0
for info in sentence.split():
    if info.isalpha() and (info.endswith('ук') or 'аз' in info):      
        res += 1
        
    if res == 0:
        res = ""Тюркизмов в тексте нет""

print(res)","sentence = input()

res = 0
for info in sentence.split():
    if info.isalpha() and (info.endswith('ук') or 'аз' in info):      
        res += 1
        
if res == 0:
    res = ""Тюркизмов в тексте нет""

print(res)","Ошибка в табуляции. Проверять количество слов, соответствующих условию задания, следует только в конце.","['open', 'open', 'open', 'closed', 'closed']","<Task description>: Реализуйте программу, которая напечатает количество тюркизмов, встречающихся в тексте: 

В переменную sentence считывается текст. Этот код уже написан.
Программа проверяет, есть ли в этом тексте тюркизмы. Гарантируется, что тюркизмы — это всегда слова, которые отделены от другого текста пробелом, состоящие только из букв, в которых встречается буквосочетание ""аз"" или которые заканчиваются на буквосочетание ""ук"". 
Гарантируется, что тюркизмы не повторяются.
В конце программа печатает количество всех тюркизмов, встречающихся в тексте. 
Если названий тюркизмов в тексте нет, программа печатает строку ""Тюркизмов в тексте нет"". 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: Открыв сундук , исследователи увидели сюртук , который сиял как алмаз 
<Вывод>: 3 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: Переводчик переводит текст 
<Вывод>: Тюркизмов в тексте нет 
<Example 3>: 
<Тип теста 3>: open 
<Ввод>: Казна была потрачена на строительство сооружения под названием акведук . Наступил пра1з1дник ! 
<Вывод>: 3 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: латук тулук дудук чубук укроп празденство барсук азора рука 
<Вывод>: 7 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: укрытие укор раз1бор луковица азы! зазор123 
<Вывод>: Тюркизмов в тексте нет 
<Решение студента>: sentence = input()

res = 0
for info in sentence.split():
    if info.isalpha() and (info.endswith('ук') or 'аз' in info):      
        res += 1
        
    if res == 0:
        res = ""Тюркизмов в тексте нет""

print(res) 
<Идеальное решение>: sentence = input()

res = 0
for info in sentence.split():
    if info.isalpha() and (info.endswith('ук') or 'аз' in info):      
        res += 1
        
if res == 0:
    res = ""Тюркизмов в тексте нет""

print(res) 


<Комментарий эксперта>:"
173,438,27,"Реализуйте программу, которая напечатает количество тюркизмов, встречающихся в тексте: 

В переменную sentence считывается текст. Этот код уже написан.
Программа проверяет, есть ли в этом тексте тюркизмы. Гарантируется, что тюркизмы — это всегда слова, которые отделены от другого текста пробелом, состоящие только из букв, в которых встречается буквосочетание ""аз"" или которые заканчиваются на буквосочетание ""ук"". 
Гарантируется, что тюркизмы не повторяются.
В конце программа печатает количество всех тюркизмов, встречающихся в тексте. 
Если названий тюркизмов в тексте нет, программа печатает строку ""Тюркизмов в тексте нет"".","['Открыв сундук , исследователи увидели сюртук , который сиял как алмаз', 'Переводчик переводит текст', 'Казна была потрачена на строительство сооружения под названием акведук . Наступил пра1з1дник !', 'латук тулук дудук чубук укроп празденство барсук азора рука', 'укрытие укор раз1бор луковица азы! зазор123']","['3', 'Тюркизмов в тексте нет', '3', '7', 'Тюркизмов в тексте нет']","sentence = input()

res = 0
for i in sentence.split():
    if info.isalpha() and (info.endswith('ук') or 'аз' in info):      
        res += 1
        
if res == 0:
    res = ""Тюркизмов в тексте нет""

print(res)","sentence = input()

res = 0
for info in sentence.split():
    if info.isalpha() and (info.endswith('ук') or 'аз' in info):      
        res += 1
        
if res == 0:
    res = ""Тюркизмов в тексте нет""

print(res)","Синтаксическая ошибка. Вы пытаетесь обратиться к переменной, которую не определили ранее. Убедитесь, что корректно написали все переменные.","['open', 'open', 'open', 'closed', 'closed']","<Task description>: Реализуйте программу, которая напечатает количество тюркизмов, встречающихся в тексте: 

В переменную sentence считывается текст. Этот код уже написан.
Программа проверяет, есть ли в этом тексте тюркизмы. Гарантируется, что тюркизмы — это всегда слова, которые отделены от другого текста пробелом, состоящие только из букв, в которых встречается буквосочетание ""аз"" или которые заканчиваются на буквосочетание ""ук"". 
Гарантируется, что тюркизмы не повторяются.
В конце программа печатает количество всех тюркизмов, встречающихся в тексте. 
Если названий тюркизмов в тексте нет, программа печатает строку ""Тюркизмов в тексте нет"". 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: Открыв сундук , исследователи увидели сюртук , который сиял как алмаз 
<Вывод>: 3 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: Переводчик переводит текст 
<Вывод>: Тюркизмов в тексте нет 
<Example 3>: 
<Тип теста 3>: open 
<Ввод>: Казна была потрачена на строительство сооружения под названием акведук . Наступил пра1з1дник ! 
<Вывод>: 3 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: латук тулук дудук чубук укроп празденство барсук азора рука 
<Вывод>: 7 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: укрытие укор раз1бор луковица азы! зазор123 
<Вывод>: Тюркизмов в тексте нет 
<Решение студента>: sentence = input()

res = 0
for i in sentence.split():
    if info.isalpha() and (info.endswith('ук') or 'аз' in info):      
        res += 1
        
if res == 0:
    res = ""Тюркизмов в тексте нет""

print(res) 
<Идеальное решение>: sentence = input()

res = 0
for info in sentence.split():
    if info.isalpha() and (info.endswith('ук') or 'аз' in info):      
        res += 1
        
if res == 0:
    res = ""Тюркизмов в тексте нет""

print(res) 


<Комментарий эксперта>:"
174,439,27,"Реализуйте программу, которая напечатает количество тюркизмов, встречающихся в тексте: 

В переменную sentence считывается текст. Этот код уже написан.
Программа проверяет, есть ли в этом тексте тюркизмы. Гарантируется, что тюркизмы — это всегда слова, которые отделены от другого текста пробелом, состоящие только из букв, в которых встречается буквосочетание ""аз"" или которые заканчиваются на буквосочетание ""ук"". 
Гарантируется, что тюркизмы не повторяются.
В конце программа печатает количество всех тюркизмов, встречающихся в тексте. 
Если названий тюркизмов в тексте нет, программа печатает строку ""Тюркизмов в тексте нет"".","['Открыв сундук , исследователи увидели сюртук , который сиял как алмаз', 'Переводчик переводит текст', 'Казна была потрачена на строительство сооружения под названием акведук . Наступил пра1з1дник !', 'латук тулук дудук чубук укроп празденство барсук азора рука', 'укрытие укор раз1бор луковица азы! зазор123']","['3', 'Тюркизмов в тексте нет', '3', '7', 'Тюркизмов в тексте нет']","sentence = input()

res = 0
for info in sentence.split():
    if info.isalpha() and (info.endswith('ук') or 'аз' in info):      
        res += 1
        
if res == 0:
    res = ""Тюркизмов в тексте нет""

print(sentence)","sentence = input()

res = 0
for info in sentence.split():
    if info.isalpha() and (info.endswith('ук') or 'аз' in info):      
        res += 1
        
if res == 0:
    res = ""Тюркизмов в тексте нет""

print(res)","Ошибка в открытых и скрытых тестах. 

Обратите внимание, что Вы выводите некорректную переменную.","['open', 'open', 'open', 'closed', 'closed']","<Task description>: Реализуйте программу, которая напечатает количество тюркизмов, встречающихся в тексте: 

В переменную sentence считывается текст. Этот код уже написан.
Программа проверяет, есть ли в этом тексте тюркизмы. Гарантируется, что тюркизмы — это всегда слова, которые отделены от другого текста пробелом, состоящие только из букв, в которых встречается буквосочетание ""аз"" или которые заканчиваются на буквосочетание ""ук"". 
Гарантируется, что тюркизмы не повторяются.
В конце программа печатает количество всех тюркизмов, встречающихся в тексте. 
Если названий тюркизмов в тексте нет, программа печатает строку ""Тюркизмов в тексте нет"". 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: Открыв сундук , исследователи увидели сюртук , который сиял как алмаз 
<Вывод>: 3 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: Переводчик переводит текст 
<Вывод>: Тюркизмов в тексте нет 
<Example 3>: 
<Тип теста 3>: open 
<Ввод>: Казна была потрачена на строительство сооружения под названием акведук . Наступил пра1з1дник ! 
<Вывод>: 3 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: латук тулук дудук чубук укроп празденство барсук азора рука 
<Вывод>: 7 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: укрытие укор раз1бор луковица азы! зазор123 
<Вывод>: Тюркизмов в тексте нет 
<Решение студента>: sentence = input()

res = 0
for info in sentence.split():
    if info.isalpha() and (info.endswith('ук') or 'аз' in info):      
        res += 1
        
if res == 0:
    res = ""Тюркизмов в тексте нет""

print(sentence) 
<Идеальное решение>: sentence = input()

res = 0
for info in sentence.split():
    if info.isalpha() and (info.endswith('ук') or 'аз' in info):      
        res += 1
        
if res == 0:
    res = ""Тюркизмов в тексте нет""

print(res) 


<Комментарий эксперта>:"
175,440,27,"Реализуйте программу, которая напечатает количество тюркизмов, встречающихся в тексте: 

В переменную sentence считывается текст. Этот код уже написан.
Программа проверяет, есть ли в этом тексте тюркизмы. Гарантируется, что тюркизмы — это всегда слова, которые отделены от другого текста пробелом, состоящие только из букв, в которых встречается буквосочетание ""аз"" или которые заканчиваются на буквосочетание ""ук"". 
Гарантируется, что тюркизмы не повторяются.
В конце программа печатает количество всех тюркизмов, встречающихся в тексте. 
Если названий тюркизмов в тексте нет, программа печатает строку ""Тюркизмов в тексте нет"".","['Открыв сундук , исследователи увидели сюртук , который сиял как алмаз', 'Переводчик переводит текст', 'Казна была потрачена на строительство сооружения под названием акведук . Наступил пра1з1дник !', 'латук тулук дудук чубук укроп празденство барсук азора рука', 'укрытие укор раз1бор луковица азы! зазор123']","['3', 'Тюркизмов в тексте нет', '3', '7', 'Тюркизмов в тексте нет']","sentence = input()

res = 0
for info in sentence.split():
    if info.isalpha() and (info.endswith('ук') or 'аз' in info):      
        res += 1
        
if res == 0:
    res = ""Тюркизмов в тексте нет""

    print(res)","sentence = input()

res = 0
for info in sentence.split():
    if info.isalpha() and (info.endswith('ук') or 'аз' in info):      
        res += 1
        
if res == 0:
    res = ""Тюркизмов в тексте нет""

print(res)",Ошибка в табуляции. Проверьте табуляцию оператора print().,"['open', 'open', 'open', 'closed', 'closed']","<Task description>: Реализуйте программу, которая напечатает количество тюркизмов, встречающихся в тексте: 

В переменную sentence считывается текст. Этот код уже написан.
Программа проверяет, есть ли в этом тексте тюркизмы. Гарантируется, что тюркизмы — это всегда слова, которые отделены от другого текста пробелом, состоящие только из букв, в которых встречается буквосочетание ""аз"" или которые заканчиваются на буквосочетание ""ук"". 
Гарантируется, что тюркизмы не повторяются.
В конце программа печатает количество всех тюркизмов, встречающихся в тексте. 
Если названий тюркизмов в тексте нет, программа печатает строку ""Тюркизмов в тексте нет"". 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: Открыв сундук , исследователи увидели сюртук , который сиял как алмаз 
<Вывод>: 3 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: Переводчик переводит текст 
<Вывод>: Тюркизмов в тексте нет 
<Example 3>: 
<Тип теста 3>: open 
<Ввод>: Казна была потрачена на строительство сооружения под названием акведук . Наступил пра1з1дник ! 
<Вывод>: 3 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: латук тулук дудук чубук укроп празденство барсук азора рука 
<Вывод>: 7 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: укрытие укор раз1бор луковица азы! зазор123 
<Вывод>: Тюркизмов в тексте нет 
<Решение студента>: sentence = input()

res = 0
for info in sentence.split():
    if info.isalpha() and (info.endswith('ук') or 'аз' in info):      
        res += 1
        
if res == 0:
    res = ""Тюркизмов в тексте нет""

    print(res) 
<Идеальное решение>: sentence = input()

res = 0
for info in sentence.split():
    if info.isalpha() and (info.endswith('ук') or 'аз' in info):      
        res += 1
        
if res == 0:
    res = ""Тюркизмов в тексте нет""

print(res) 


<Комментарий эксперта>:"
176,441,27,"Реализуйте программу, которая напечатает количество тюркизмов, встречающихся в тексте: 

В переменную sentence считывается текст. Этот код уже написан.
Программа проверяет, есть ли в этом тексте тюркизмы. Гарантируется, что тюркизмы — это всегда слова, которые отделены от другого текста пробелом, состоящие только из букв, в которых встречается буквосочетание ""аз"" или которые заканчиваются на буквосочетание ""ук"". 
Гарантируется, что тюркизмы не повторяются.
В конце программа печатает количество всех тюркизмов, встречающихся в тексте. 
Если названий тюркизмов в тексте нет, программа печатает строку ""Тюркизмов в тексте нет"".","['Открыв сундук , исследователи увидели сюртук , который сиял как алмаз', 'Переводчик переводит текст', 'Казна была потрачена на строительство сооружения под названием акведук . Наступил пра1з1дник !', 'латук тулук дудук чубук укроп празденство барсук азора рука', 'укрытие укор раз1бор луковица азы! зазор123']","['3', 'Тюркизмов в тексте нет', '3', '7', 'Тюркизмов в тексте нет']","sentence = input()

res = 0
for info in sentence.split():
    if info.isalpha():      
        res += 1
        
if res == 0:
    res = ""Тюркизмов в тексте нет""

print(res)","sentence = input()

res = 0
for info in sentence.split():
    if info.isalpha() and (info.endswith('ук') or 'аз' in info):      
        res += 1
        
if res == 0:
    res = ""Тюркизмов в тексте нет""

print(res)","Ошибка в открытых и скрытых тестах. 

Ваш код некорректно выполняет условия задания. Например, он не выполняет условие ""в которых встречается буквосочетание ""аз"" или которые заканчиваются на буквосочетание ""ук"""". Попробуйте изменить условие if, чтобы скорректировать ошибку.","['open', 'open', 'open', 'closed', 'closed']","<Task description>: Реализуйте программу, которая напечатает количество тюркизмов, встречающихся в тексте: 

В переменную sentence считывается текст. Этот код уже написан.
Программа проверяет, есть ли в этом тексте тюркизмы. Гарантируется, что тюркизмы — это всегда слова, которые отделены от другого текста пробелом, состоящие только из букв, в которых встречается буквосочетание ""аз"" или которые заканчиваются на буквосочетание ""ук"". 
Гарантируется, что тюркизмы не повторяются.
В конце программа печатает количество всех тюркизмов, встречающихся в тексте. 
Если названий тюркизмов в тексте нет, программа печатает строку ""Тюркизмов в тексте нет"". 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: Открыв сундук , исследователи увидели сюртук , который сиял как алмаз 
<Вывод>: 3 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: Переводчик переводит текст 
<Вывод>: Тюркизмов в тексте нет 
<Example 3>: 
<Тип теста 3>: open 
<Ввод>: Казна была потрачена на строительство сооружения под названием акведук . Наступил пра1з1дник ! 
<Вывод>: 3 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: латук тулук дудук чубук укроп празденство барсук азора рука 
<Вывод>: 7 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: укрытие укор раз1бор луковица азы! зазор123 
<Вывод>: Тюркизмов в тексте нет 
<Решение студента>: sentence = input()

res = 0
for info in sentence.split():
    if info.isalpha():      
        res += 1
        
if res == 0:
    res = ""Тюркизмов в тексте нет""

print(res) 
<Идеальное решение>: sentence = input()

res = 0
for info in sentence.split():
    if info.isalpha() and (info.endswith('ук') or 'аз' in info):      
        res += 1
        
if res == 0:
    res = ""Тюркизмов в тексте нет""

print(res) 


<Комментарий эксперта>:"
177,442,27,"Реализуйте программу, которая напечатает количество тюркизмов, встречающихся в тексте: 

В переменную sentence считывается текст. Этот код уже написан.
Программа проверяет, есть ли в этом тексте тюркизмы. Гарантируется, что тюркизмы — это всегда слова, которые отделены от другого текста пробелом, состоящие только из букв, в которых встречается буквосочетание ""аз"" или которые заканчиваются на буквосочетание ""ук"". 
Гарантируется, что тюркизмы не повторяются.
В конце программа печатает количество всех тюркизмов, встречающихся в тексте. 
Если названий тюркизмов в тексте нет, программа печатает строку ""Тюркизмов в тексте нет"".","['Открыв сундук , исследователи увидели сюртук , который сиял как алмаз', 'Переводчик переводит текст', 'Казна была потрачена на строительство сооружения под названием акведук . Наступил пра1з1дник !', 'латук тулук дудук чубук укроп празденство барсук азора рука', 'укрытие укор раз1бор луковица азы! зазор123']","['3', 'Тюркизмов в тексте нет', '3', '7', 'Тюркизмов в тексте нет']","sentence = input()

res = 0
for info in sentence.split():
    if info.endswith('ук') or 'аз' in info:      
        res += 1
        
if res == 0:
    res = ""Тюркизмов в тексте нет""

print(res)","sentence = input()

res = 0
for info in sentence.split():
    if info.isalpha() and (info.endswith('ук') or 'аз' in info):      
        res += 1
        
if res == 0:
    res = ""Тюркизмов в тексте нет""

print(res)","Ошибка в открытых и скрытых тестах. 

Ваш код некорректно выполняет условия задания. Например, он не выполняет условие ""состоящие только из букв"". Попробуйте изменить условие if, чтобы скорректировать ошибку.","['open', 'open', 'open', 'closed', 'closed']","<Task description>: Реализуйте программу, которая напечатает количество тюркизмов, встречающихся в тексте: 

В переменную sentence считывается текст. Этот код уже написан.
Программа проверяет, есть ли в этом тексте тюркизмы. Гарантируется, что тюркизмы — это всегда слова, которые отделены от другого текста пробелом, состоящие только из букв, в которых встречается буквосочетание ""аз"" или которые заканчиваются на буквосочетание ""ук"". 
Гарантируется, что тюркизмы не повторяются.
В конце программа печатает количество всех тюркизмов, встречающихся в тексте. 
Если названий тюркизмов в тексте нет, программа печатает строку ""Тюркизмов в тексте нет"". 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: Открыв сундук , исследователи увидели сюртук , который сиял как алмаз 
<Вывод>: 3 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: Переводчик переводит текст 
<Вывод>: Тюркизмов в тексте нет 
<Example 3>: 
<Тип теста 3>: open 
<Ввод>: Казна была потрачена на строительство сооружения под названием акведук . Наступил пра1з1дник ! 
<Вывод>: 3 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: латук тулук дудук чубук укроп празденство барсук азора рука 
<Вывод>: 7 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: укрытие укор раз1бор луковица азы! зазор123 
<Вывод>: Тюркизмов в тексте нет 
<Решение студента>: sentence = input()

res = 0
for info in sentence.split():
    if info.endswith('ук') or 'аз' in info:      
        res += 1
        
if res == 0:
    res = ""Тюркизмов в тексте нет""

print(res) 
<Идеальное решение>: sentence = input()

res = 0
for info in sentence.split():
    if info.isalpha() and (info.endswith('ук') or 'аз' in info):      
        res += 1
        
if res == 0:
    res = ""Тюркизмов в тексте нет""

print(res) 


<Комментарий эксперта>:"
178,443,27,"Реализуйте программу, которая напечатает количество тюркизмов, встречающихся в тексте: 

В переменную sentence считывается текст. Этот код уже написан.
Программа проверяет, есть ли в этом тексте тюркизмы. Гарантируется, что тюркизмы — это всегда слова, которые отделены от другого текста пробелом, состоящие только из букв, в которых встречается буквосочетание ""аз"" или которые заканчиваются на буквосочетание ""ук"". 
Гарантируется, что тюркизмы не повторяются.
В конце программа печатает количество всех тюркизмов, встречающихся в тексте. 
Если названий тюркизмов в тексте нет, программа печатает строку ""Тюркизмов в тексте нет"".","['Открыв сундук , исследователи увидели сюртук , который сиял как алмаз', 'Переводчик переводит текст', 'Казна была потрачена на строительство сооружения под названием акведук . Наступил пра1з1дник !', 'латук тулук дудук чубук укроп празденство барсук азора рука', 'укрытие укор раз1бор луковица азы! зазор123']","['3', 'Тюркизмов в тексте нет', '3', '7', 'Тюркизмов в тексте нет']","sentence = input()

res = 0
for info in sentence.split():
    if info.isalpha():      
        res += 1
    elif info.endswith('ук') or 'аз' in info:
        res += 1

if res == 0:
    res = ""Тюркизмов в тексте нет""

print(res)","sentence = input()

res = 0
for info in sentence.split():
    if info.isalpha() and (info.endswith('ук') or 'аз' in info):      
        res += 1
        
if res == 0:
    res = ""Тюркизмов в тексте нет""

print(res)","Ошибка в открытых и скрытых тестах. 

Ваш код некорректно выполняет условия задания. Например, условия ""состоящие только из букв, в которых встречается буквосочетание ""аз"" или которые заканчиваются на буквосочетание ""ук"""" должны выполняться одновременно. Попробуйте изменить условие if, чтобы скорректировать ошибку.","['open', 'open', 'open', 'closed', 'closed']","<Task description>: Реализуйте программу, которая напечатает количество тюркизмов, встречающихся в тексте: 

В переменную sentence считывается текст. Этот код уже написан.
Программа проверяет, есть ли в этом тексте тюркизмы. Гарантируется, что тюркизмы — это всегда слова, которые отделены от другого текста пробелом, состоящие только из букв, в которых встречается буквосочетание ""аз"" или которые заканчиваются на буквосочетание ""ук"". 
Гарантируется, что тюркизмы не повторяются.
В конце программа печатает количество всех тюркизмов, встречающихся в тексте. 
Если названий тюркизмов в тексте нет, программа печатает строку ""Тюркизмов в тексте нет"". 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: Открыв сундук , исследователи увидели сюртук , который сиял как алмаз 
<Вывод>: 3 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: Переводчик переводит текст 
<Вывод>: Тюркизмов в тексте нет 
<Example 3>: 
<Тип теста 3>: open 
<Ввод>: Казна была потрачена на строительство сооружения под названием акведук . Наступил пра1з1дник ! 
<Вывод>: 3 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: латук тулук дудук чубук укроп празденство барсук азора рука 
<Вывод>: 7 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: укрытие укор раз1бор луковица азы! зазор123 
<Вывод>: Тюркизмов в тексте нет 
<Решение студента>: sentence = input()

res = 0
for info in sentence.split():
    if info.isalpha():      
        res += 1
    elif info.endswith('ук') or 'аз' in info:
        res += 1

if res == 0:
    res = ""Тюркизмов в тексте нет""

print(res) 
<Идеальное решение>: sentence = input()

res = 0
for info in sentence.split():
    if info.isalpha() and (info.endswith('ук') or 'аз' in info):      
        res += 1
        
if res == 0:
    res = ""Тюркизмов в тексте нет""

print(res) 


<Комментарий эксперта>:"
179,444,27,"Реализуйте программу, которая напечатает количество тюркизмов, встречающихся в тексте: 

В переменную sentence считывается текст. Этот код уже написан.
Программа проверяет, есть ли в этом тексте тюркизмы. Гарантируется, что тюркизмы — это всегда слова, которые отделены от другого текста пробелом, состоящие только из букв, в которых встречается буквосочетание ""аз"" или которые заканчиваются на буквосочетание ""ук"". 
Гарантируется, что тюркизмы не повторяются.
В конце программа печатает количество всех тюркизмов, встречающихся в тексте. 
Если названий тюркизмов в тексте нет, программа печатает строку ""Тюркизмов в тексте нет"".","['Открыв сундук , исследователи увидели сюртук , который сиял как алмаз', 'Переводчик переводит текст', 'Казна была потрачена на строительство сооружения под названием акведук . Наступил пра1з1дник !', 'латук тулук дудук чубук укроп празденство барсук азора рука', 'укрытие укор раз1бор луковица азы! зазор123']","['3', 'Тюркизмов в тексте нет', '3', '7', 'Тюркизмов в тексте нет']","sentence = input()

res = 0
for info in sentence.split():
    if info.isalpha() and info.endswith('ук'):      
        res += 1
    elif info.isalpha() and 'аз' in info:
        res += 1
        
if res == 0:
    res = ""Тюркизмов в тексте нет""

print(res)","sentence = input()

res = 0
for info in sentence.split():
    if info.isalpha() and (info.endswith('ук') or 'аз' in info):      
        res += 1
        
if res == 0:
    res = ""Тюркизмов в тексте нет""

print(res)","Ошибка в открытых и скрытых тестах. 

Ваш код некорректно выполняет условия задания. Например, условия ""состоящие только из букв, в которых встречается буквосочетание ""аз"" или которые заканчиваются на буквосочетание ""ук"""" должны выполняться одновременно. Попробуйте изменить условие if, чтобы скорректировать ошибку.","['open', 'open', 'open', 'closed', 'closed']","<Task description>: Реализуйте программу, которая напечатает количество тюркизмов, встречающихся в тексте: 

В переменную sentence считывается текст. Этот код уже написан.
Программа проверяет, есть ли в этом тексте тюркизмы. Гарантируется, что тюркизмы — это всегда слова, которые отделены от другого текста пробелом, состоящие только из букв, в которых встречается буквосочетание ""аз"" или которые заканчиваются на буквосочетание ""ук"". 
Гарантируется, что тюркизмы не повторяются.
В конце программа печатает количество всех тюркизмов, встречающихся в тексте. 
Если названий тюркизмов в тексте нет, программа печатает строку ""Тюркизмов в тексте нет"". 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: Открыв сундук , исследователи увидели сюртук , который сиял как алмаз 
<Вывод>: 3 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: Переводчик переводит текст 
<Вывод>: Тюркизмов в тексте нет 
<Example 3>: 
<Тип теста 3>: open 
<Ввод>: Казна была потрачена на строительство сооружения под названием акведук . Наступил пра1з1дник ! 
<Вывод>: 3 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: латук тулук дудук чубук укроп празденство барсук азора рука 
<Вывод>: 7 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: укрытие укор раз1бор луковица азы! зазор123 
<Вывод>: Тюркизмов в тексте нет 
<Решение студента>: sentence = input()

res = 0
for info in sentence.split():
    if info.isalpha() and info.endswith('ук'):      
        res += 1
    elif info.isalpha() and 'аз' in info:
        res += 1
        
if res == 0:
    res = ""Тюркизмов в тексте нет""

print(res) 
<Идеальное решение>: sentence = input()

res = 0
for info in sentence.split():
    if info.isalpha() and (info.endswith('ук') or 'аз' in info):      
        res += 1
        
if res == 0:
    res = ""Тюркизмов в тексте нет""

print(res) 


<Комментарий эксперта>:"
180,445,28,"Студент хочет определить языки, которые он будет изучать на втором курсе. Реализуйте программу, которая поможет ему сделать выбор:

В переменную course считывается список языков, которые изучаются в рамках учебной программы. Этот код уже написан.
В переменную favorite считывается список языков, которые нравятся студенту. Этот код уже написан.
В переменную free считывается список языков, которые можно изучать в университете бесплатно. Этот код уже написан.
Гарантируется, что языки в каждом списке уникальны.
Любой список может оказаться пустым.
Программа выводит через точку с запятой и пробел языки, которые изучаются в рамках программы, нравятся студенту и их можно изучать в университете бесплатно.
Языки должны быть отсортированы в обратном алфавиту порядке.
Если таких языков нет, программа ничего не выводит. ","['Английский, Французский, Немецкий, Китайский, Арабский, Норвежский\nФранцузский, Немецкий, Английский, Китайский\nФранцузский, Английский, Китайский', 'Испанский, Шведский\n\nАнглисйкий, Греческий', 'тайский\nтайский\nтайский', 'иврит, хинди, индонезийский, ирландский, итальянский\nитальянский, индонезийский, хинди, казахский\nлаосский, индонезийский, хинди', 'хинди\n\nкитайский, японский, корейский']","['Французский; Китайский; Английский', nan, 'тайский', 'хинди; индонезийский', nan]","course = input().split(', ')
favorite = input().split(', ')
free = input().split(', ')

print(*sorted(free&course&favorite, reverse = True), sep = '; ')","course = set(input().split(', '))
favorite = set(input().split(', '))
free = set(input().split(', '))

print(*sorted(free&course&favorite, reverse = True), sep = '; ')","Ошибка при сравнении данных. Оператор ""&"" не используется для сравнения данных типа list.","['open', 'open', 'closed', 'closed', 'closed']","<Task description>: Студент хочет определить языки, которые он будет изучать на втором курсе. Реализуйте программу, которая поможет ему сделать выбор:

В переменную course считывается список языков, которые изучаются в рамках учебной программы. Этот код уже написан.
В переменную favorite считывается список языков, которые нравятся студенту. Этот код уже написан.
В переменную free считывается список языков, которые можно изучать в университете бесплатно. Этот код уже написан.
Гарантируется, что языки в каждом списке уникальны.
Любой список может оказаться пустым.
Программа выводит через точку с запятой и пробел языки, которые изучаются в рамках программы, нравятся студенту и их можно изучать в университете бесплатно.
Языки должны быть отсортированы в обратном алфавиту порядке.
Если таких языков нет, программа ничего не выводит.  
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: Английский, Французский, Немецкий, Китайский, Арабский, Норвежский
Французский, Немецкий, Английский, Китайский
Французский, Английский, Китайский 
<Вывод>: Французский; Китайский; Английский 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: Испанский, Шведский

Англисйкий, Греческий 
<Вывод>: nan 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: тайский
тайский
тайский 
<Вывод>: тайский 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: иврит, хинди, индонезийский, ирландский, итальянский
итальянский, индонезийский, хинди, казахский
лаосский, индонезийский, хинди 
<Вывод>: хинди; индонезийский 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: хинди

китайский, японский, корейский 
<Вывод>: nan 
<Решение студента>: course = input().split(', ')
favorite = input().split(', ')
free = input().split(', ')

print(*sorted(free&course&favorite, reverse = True), sep = '; ') 
<Идеальное решение>: course = set(input().split(', '))
favorite = set(input().split(', '))
free = set(input().split(', '))

print(*sorted(free&course&favorite, reverse = True), sep = '; ') 


<Комментарий эксперта>:"
181,446,28,"Студент хочет определить языки, которые он будет изучать на втором курсе. Реализуйте программу, которая поможет ему сделать выбор:

В переменную course считывается список языков, которые изучаются в рамках учебной программы. Этот код уже написан.
В переменную favorite считывается список языков, которые нравятся студенту. Этот код уже написан.
В переменную free считывается список языков, которые можно изучать в университете бесплатно. Этот код уже написан.
Гарантируется, что языки в каждом списке уникальны.
Любой список может оказаться пустым.
Программа выводит через точку с запятой и пробел языки, которые изучаются в рамках программы, нравятся студенту и их можно изучать в университете бесплатно.
Языки должны быть отсортированы в обратном алфавиту порядке.
Если таких языков нет, программа ничего не выводит. ","['Английский, Французский, Немецкий, Китайский, Арабский, Норвежский\nФранцузский, Немецкий, Английский, Китайский\nФранцузский, Английский, Китайский', 'Испанский, Шведский\n\nАнглисйкий, Греческий', 'тайский\nтайский\nтайский', 'иврит, хинди, индонезийский, ирландский, итальянский\nитальянский, индонезийский, хинди, казахский\nлаосский, индонезийский, хинди', 'хинди\n\nкитайский, японский, корейский']","['Французский; Китайский; Английский', nan, 'тайский', 'хинди; индонезийский', nan]","course = set(input().split(', '))
favorite = set(input().split(', '))
free = set(input().split(', '))

print(*sorted(free - course - favorite, reverse = True), sep = '; ')","course = set(input().split(', '))
favorite = set(input().split(', '))
free = set(input().split(', '))

print(*sorted(free&course&favorite, reverse = True), sep = '; ')","Ошибка в открытых и скрытых тестах. 

Ваш код некорректно выполняет условия задания. Например, он не выполняет условия ""Программа выводит через точку с запятой и пробел языки, которые изучаются в рамках программы, нравятся студенту и их можно изучать в университете бесплатно"". Попробуйте изменить print() чтобы скорректировать ошибку.","['open', 'open', 'closed', 'closed', 'closed']","<Task description>: Студент хочет определить языки, которые он будет изучать на втором курсе. Реализуйте программу, которая поможет ему сделать выбор:

В переменную course считывается список языков, которые изучаются в рамках учебной программы. Этот код уже написан.
В переменную favorite считывается список языков, которые нравятся студенту. Этот код уже написан.
В переменную free считывается список языков, которые можно изучать в университете бесплатно. Этот код уже написан.
Гарантируется, что языки в каждом списке уникальны.
Любой список может оказаться пустым.
Программа выводит через точку с запятой и пробел языки, которые изучаются в рамках программы, нравятся студенту и их можно изучать в университете бесплатно.
Языки должны быть отсортированы в обратном алфавиту порядке.
Если таких языков нет, программа ничего не выводит.  
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: Английский, Французский, Немецкий, Китайский, Арабский, Норвежский
Французский, Немецкий, Английский, Китайский
Французский, Английский, Китайский 
<Вывод>: Французский; Китайский; Английский 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: Испанский, Шведский

Англисйкий, Греческий 
<Вывод>: nan 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: тайский
тайский
тайский 
<Вывод>: тайский 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: иврит, хинди, индонезийский, ирландский, итальянский
итальянский, индонезийский, хинди, казахский
лаосский, индонезийский, хинди 
<Вывод>: хинди; индонезийский 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: хинди

китайский, японский, корейский 
<Вывод>: nan 
<Решение студента>: course = set(input().split(', '))
favorite = set(input().split(', '))
free = set(input().split(', '))

print(*sorted(free - course - favorite, reverse = True), sep = '; ') 
<Идеальное решение>: course = set(input().split(', '))
favorite = set(input().split(', '))
free = set(input().split(', '))

print(*sorted(free&course&favorite, reverse = True), sep = '; ') 


<Комментарий эксперта>:"
182,447,28,"Студент хочет определить языки, которые он будет изучать на втором курсе. Реализуйте программу, которая поможет ему сделать выбор:

В переменную course считывается список языков, которые изучаются в рамках учебной программы. Этот код уже написан.
В переменную favorite считывается список языков, которые нравятся студенту. Этот код уже написан.
В переменную free считывается список языков, которые можно изучать в университете бесплатно. Этот код уже написан.
Гарантируется, что языки в каждом списке уникальны.
Любой список может оказаться пустым.
Программа выводит через точку с запятой и пробел языки, которые изучаются в рамках программы, нравятся студенту и их можно изучать в университете бесплатно.
Языки должны быть отсортированы в обратном алфавиту порядке.
Если таких языков нет, программа ничего не выводит. ","['Английский, Французский, Немецкий, Китайский, Арабский, Норвежский\nФранцузский, Немецкий, Английский, Китайский\nФранцузский, Английский, Китайский', 'Испанский, Шведский\n\nАнглисйкий, Греческий', 'тайский\nтайский\nтайский', 'иврит, хинди, индонезийский, ирландский, итальянский\nитальянский, индонезийский, хинди, казахский\nлаосский, индонезийский, хинди', 'хинди\n\nкитайский, японский, корейский']","['Французский; Китайский; Английский', nan, 'тайский', 'хинди; индонезийский', nan]","course = set(input().split(', '))
favorite = set(input().split(', '))
free = set(input().split(', '))

print(*sorted(free - course & favorite, reverse = True), sep = '; ')","course = set(input().split(', '))
favorite = set(input().split(', '))
free = set(input().split(', '))

print(*sorted(free&course&favorite, reverse = True), sep = '; ')","Ошибка в открытых и скрытых тестах. 

Ваш код некорректно выполняет условия задания. Например, он не выполняет условия ""Программа выводит через точку с запятой и пробел языки, которые изучаются в рамках программы, нравятся студенту и их можно изучать в университете бесплатно"". Попробуйте изменить print() чтобы скорректировать ошибку.","['open', 'open', 'closed', 'closed', 'closed']","<Task description>: Студент хочет определить языки, которые он будет изучать на втором курсе. Реализуйте программу, которая поможет ему сделать выбор:

В переменную course считывается список языков, которые изучаются в рамках учебной программы. Этот код уже написан.
В переменную favorite считывается список языков, которые нравятся студенту. Этот код уже написан.
В переменную free считывается список языков, которые можно изучать в университете бесплатно. Этот код уже написан.
Гарантируется, что языки в каждом списке уникальны.
Любой список может оказаться пустым.
Программа выводит через точку с запятой и пробел языки, которые изучаются в рамках программы, нравятся студенту и их можно изучать в университете бесплатно.
Языки должны быть отсортированы в обратном алфавиту порядке.
Если таких языков нет, программа ничего не выводит.  
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: Английский, Французский, Немецкий, Китайский, Арабский, Норвежский
Французский, Немецкий, Английский, Китайский
Французский, Английский, Китайский 
<Вывод>: Французский; Китайский; Английский 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: Испанский, Шведский

Англисйкий, Греческий 
<Вывод>: nan 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: тайский
тайский
тайский 
<Вывод>: тайский 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: иврит, хинди, индонезийский, ирландский, итальянский
итальянский, индонезийский, хинди, казахский
лаосский, индонезийский, хинди 
<Вывод>: хинди; индонезийский 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: хинди

китайский, японский, корейский 
<Вывод>: nan 
<Решение студента>: course = set(input().split(', '))
favorite = set(input().split(', '))
free = set(input().split(', '))

print(*sorted(free - course & favorite, reverse = True), sep = '; ') 
<Идеальное решение>: course = set(input().split(', '))
favorite = set(input().split(', '))
free = set(input().split(', '))

print(*sorted(free&course&favorite, reverse = True), sep = '; ') 


<Комментарий эксперта>:"
183,448,28,"Студент хочет определить языки, которые он будет изучать на втором курсе. Реализуйте программу, которая поможет ему сделать выбор:

В переменную course считывается список языков, которые изучаются в рамках учебной программы. Этот код уже написан.
В переменную favorite считывается список языков, которые нравятся студенту. Этот код уже написан.
В переменную free считывается список языков, которые можно изучать в университете бесплатно. Этот код уже написан.
Гарантируется, что языки в каждом списке уникальны.
Любой список может оказаться пустым.
Программа выводит через точку с запятой и пробел языки, которые изучаются в рамках программы, нравятся студенту и их можно изучать в университете бесплатно.
Языки должны быть отсортированы в обратном алфавиту порядке.
Если таких языков нет, программа ничего не выводит. ","['Английский, Французский, Немецкий, Китайский, Арабский, Норвежский\nФранцузский, Немецкий, Английский, Китайский\nФранцузский, Английский, Китайский', 'Испанский, Шведский\n\nАнглисйкий, Греческий', 'тайский\nтайский\nтайский', 'иврит, хинди, индонезийский, ирландский, итальянский\nитальянский, индонезийский, хинди, казахский\nлаосский, индонезийский, хинди', 'хинди\n\nкитайский, японский, корейский']","['Французский; Китайский; Английский', nan, 'тайский', 'хинди; индонезийский', nan]","course = set(input().split(', '))
favorite = set(input().split(', '))
free = set(input().split(', '))

print(*sorted(course & favorite, reverse = True), sep = '; ')","course = set(input().split(', '))
favorite = set(input().split(', '))
free = set(input().split(', '))

print(*sorted(free&course&favorite, reverse = True), sep = '; ')","Ошибка в открытых и скрытых тестах. 

Ваш код некорректно выполняет условия задания. Например, он не выполняет условия ""Программа выводит через точку с запятой и пробел языки, которые изучаются в рамках программы, нравятся студенту и их можно изучать в университете бесплатно"". Попробуйте изменить print() чтобы скорректировать ошибку.","['open', 'open', 'closed', 'closed', 'closed']","<Task description>: Студент хочет определить языки, которые он будет изучать на втором курсе. Реализуйте программу, которая поможет ему сделать выбор:

В переменную course считывается список языков, которые изучаются в рамках учебной программы. Этот код уже написан.
В переменную favorite считывается список языков, которые нравятся студенту. Этот код уже написан.
В переменную free считывается список языков, которые можно изучать в университете бесплатно. Этот код уже написан.
Гарантируется, что языки в каждом списке уникальны.
Любой список может оказаться пустым.
Программа выводит через точку с запятой и пробел языки, которые изучаются в рамках программы, нравятся студенту и их можно изучать в университете бесплатно.
Языки должны быть отсортированы в обратном алфавиту порядке.
Если таких языков нет, программа ничего не выводит.  
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: Английский, Французский, Немецкий, Китайский, Арабский, Норвежский
Французский, Немецкий, Английский, Китайский
Французский, Английский, Китайский 
<Вывод>: Французский; Китайский; Английский 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: Испанский, Шведский

Англисйкий, Греческий 
<Вывод>: nan 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: тайский
тайский
тайский 
<Вывод>: тайский 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: иврит, хинди, индонезийский, ирландский, итальянский
итальянский, индонезийский, хинди, казахский
лаосский, индонезийский, хинди 
<Вывод>: хинди; индонезийский 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: хинди

китайский, японский, корейский 
<Вывод>: nan 
<Решение студента>: course = set(input().split(', '))
favorite = set(input().split(', '))
free = set(input().split(', '))

print(*sorted(course & favorite, reverse = True), sep = '; ') 
<Идеальное решение>: course = set(input().split(', '))
favorite = set(input().split(', '))
free = set(input().split(', '))

print(*sorted(free&course&favorite, reverse = True), sep = '; ') 


<Комментарий эксперта>:"
184,449,28,"Студент хочет определить языки, которые он будет изучать на втором курсе. Реализуйте программу, которая поможет ему сделать выбор:

В переменную course считывается список языков, которые изучаются в рамках учебной программы. Этот код уже написан.
В переменную favorite считывается список языков, которые нравятся студенту. Этот код уже написан.
В переменную free считывается список языков, которые можно изучать в университете бесплатно. Этот код уже написан.
Гарантируется, что языки в каждом списке уникальны.
Любой список может оказаться пустым.
Программа выводит через точку с запятой и пробел языки, которые изучаются в рамках программы, нравятся студенту и их можно изучать в университете бесплатно.
Языки должны быть отсортированы в обратном алфавиту порядке.
Если таких языков нет, программа ничего не выводит. ","['Английский, Французский, Немецкий, Китайский, Арабский, Норвежский\nФранцузский, Немецкий, Английский, Китайский\nФранцузский, Английский, Китайский', 'Испанский, Шведский\n\nАнглисйкий, Греческий', 'тайский\nтайский\nтайский', 'иврит, хинди, индонезийский, ирландский, итальянский\nитальянский, индонезийский, хинди, казахский\nлаосский, индонезийский, хинди', 'хинди\n\nкитайский, японский, корейский']","['Французский; Китайский; Английский', nan, 'тайский', 'хинди; индонезийский', nan]","course = set(input().split(', '))
favorite = set(input().split(', '))
free = set(input().split(', '))

print(*sorted(free & course, reverse = True), sep = '; ')","course = set(input().split(', '))
favorite = set(input().split(', '))
free = set(input().split(', '))

print(*sorted(free&course&favorite, reverse = True), sep = '; ')","Ошибка в открытых и скрытых тестах. 

Ваш код некорректно выполняет условия задания. Например, он не выполняет условия ""Программа выводит через точку с запятой и пробел языки, которые изучаются в рамках программы, нравятся студенту и их можно изучать в университете бесплатно"". Попробуйте изменить print() чтобы скорректировать ошибку.","['open', 'open', 'closed', 'closed', 'closed']","<Task description>: Студент хочет определить языки, которые он будет изучать на втором курсе. Реализуйте программу, которая поможет ему сделать выбор:

В переменную course считывается список языков, которые изучаются в рамках учебной программы. Этот код уже написан.
В переменную favorite считывается список языков, которые нравятся студенту. Этот код уже написан.
В переменную free считывается список языков, которые можно изучать в университете бесплатно. Этот код уже написан.
Гарантируется, что языки в каждом списке уникальны.
Любой список может оказаться пустым.
Программа выводит через точку с запятой и пробел языки, которые изучаются в рамках программы, нравятся студенту и их можно изучать в университете бесплатно.
Языки должны быть отсортированы в обратном алфавиту порядке.
Если таких языков нет, программа ничего не выводит.  
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: Английский, Французский, Немецкий, Китайский, Арабский, Норвежский
Французский, Немецкий, Английский, Китайский
Французский, Английский, Китайский 
<Вывод>: Французский; Китайский; Английский 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: Испанский, Шведский

Англисйкий, Греческий 
<Вывод>: nan 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: тайский
тайский
тайский 
<Вывод>: тайский 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: иврит, хинди, индонезийский, ирландский, итальянский
итальянский, индонезийский, хинди, казахский
лаосский, индонезийский, хинди 
<Вывод>: хинди; индонезийский 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: хинди

китайский, японский, корейский 
<Вывод>: nan 
<Решение студента>: course = set(input().split(', '))
favorite = set(input().split(', '))
free = set(input().split(', '))

print(*sorted(free & course, reverse = True), sep = '; ') 
<Идеальное решение>: course = set(input().split(', '))
favorite = set(input().split(', '))
free = set(input().split(', '))

print(*sorted(free&course&favorite, reverse = True), sep = '; ') 


<Комментарий эксперта>:"
185,450,28,"Студент хочет определить языки, которые он будет изучать на втором курсе. Реализуйте программу, которая поможет ему сделать выбор:

В переменную course считывается список языков, которые изучаются в рамках учебной программы. Этот код уже написан.
В переменную favorite считывается список языков, которые нравятся студенту. Этот код уже написан.
В переменную free считывается список языков, которые можно изучать в университете бесплатно. Этот код уже написан.
Гарантируется, что языки в каждом списке уникальны.
Любой список может оказаться пустым.
Программа выводит через точку с запятой и пробел языки, которые изучаются в рамках программы, нравятся студенту и их можно изучать в университете бесплатно.
Языки должны быть отсортированы в обратном алфавиту порядке.
Если таких языков нет, программа ничего не выводит. ","['Английский, Французский, Немецкий, Китайский, Арабский, Норвежский\nФранцузский, Немецкий, Английский, Китайский\nФранцузский, Английский, Китайский', 'Испанский, Шведский\n\nАнглисйкий, Греческий', 'тайский\nтайский\nтайский', 'иврит, хинди, индонезийский, ирландский, итальянский\nитальянский, индонезийский, хинди, казахский\nлаосский, индонезийский, хинди', 'хинди\n\nкитайский, японский, корейский']","['Французский; Китайский; Английский', nan, 'тайский', 'хинди; индонезийский', nan]","course = set(input().split(', '))
favorite = set(input().split(', '))
free = set(input().split(', '))

print(*sorted(free & cuorse & favorite, reverse = True), sep = '; ')","course = set(input().split(', '))
favorite = set(input().split(', '))
free = set(input().split(', '))

print(*sorted(free&course&favorite, reverse = True), sep = '; ')","Синтаксическая ошибка, попытка обратиться к ранее не заданной переменной. Проверьте, что Вы правильно указали все переменные, к которым обращаетесь в коде.","['open', 'open', 'closed', 'closed', 'closed']","<Task description>: Студент хочет определить языки, которые он будет изучать на втором курсе. Реализуйте программу, которая поможет ему сделать выбор:

В переменную course считывается список языков, которые изучаются в рамках учебной программы. Этот код уже написан.
В переменную favorite считывается список языков, которые нравятся студенту. Этот код уже написан.
В переменную free считывается список языков, которые можно изучать в университете бесплатно. Этот код уже написан.
Гарантируется, что языки в каждом списке уникальны.
Любой список может оказаться пустым.
Программа выводит через точку с запятой и пробел языки, которые изучаются в рамках программы, нравятся студенту и их можно изучать в университете бесплатно.
Языки должны быть отсортированы в обратном алфавиту порядке.
Если таких языков нет, программа ничего не выводит.  
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: Английский, Французский, Немецкий, Китайский, Арабский, Норвежский
Французский, Немецкий, Английский, Китайский
Французский, Английский, Китайский 
<Вывод>: Французский; Китайский; Английский 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: Испанский, Шведский

Англисйкий, Греческий 
<Вывод>: nan 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: тайский
тайский
тайский 
<Вывод>: тайский 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: иврит, хинди, индонезийский, ирландский, итальянский
итальянский, индонезийский, хинди, казахский
лаосский, индонезийский, хинди 
<Вывод>: хинди; индонезийский 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: хинди

китайский, японский, корейский 
<Вывод>: nan 
<Решение студента>: course = set(input().split(', '))
favorite = set(input().split(', '))
free = set(input().split(', '))

print(*sorted(free & cuorse & favorite, reverse = True), sep = '; ') 
<Идеальное решение>: course = set(input().split(', '))
favorite = set(input().split(', '))
free = set(input().split(', '))

print(*sorted(free&course&favorite, reverse = True), sep = '; ') 


<Комментарий эксперта>:"
186,451,28,"Студент хочет определить языки, которые он будет изучать на втором курсе. Реализуйте программу, которая поможет ему сделать выбор:

В переменную course считывается список языков, которые изучаются в рамках учебной программы. Этот код уже написан.
В переменную favorite считывается список языков, которые нравятся студенту. Этот код уже написан.
В переменную free считывается список языков, которые можно изучать в университете бесплатно. Этот код уже написан.
Гарантируется, что языки в каждом списке уникальны.
Любой список может оказаться пустым.
Программа выводит через точку с запятой и пробел языки, которые изучаются в рамках программы, нравятся студенту и их можно изучать в университете бесплатно.
Языки должны быть отсортированы в обратном алфавиту порядке.
Если таких языков нет, программа ничего не выводит. ","['Английский, Французский, Немецкий, Китайский, Арабский, Норвежский\nФранцузский, Немецкий, Английский, Китайский\nФранцузский, Английский, Китайский', 'Испанский, Шведский\n\nАнглисйкий, Греческий', 'тайский\nтайский\nтайский', 'иврит, хинди, индонезийский, ирландский, итальянский\nитальянский, индонезийский, хинди, казахский\nлаосский, индонезийский, хинди', 'хинди\n\nкитайский, японский, корейский']","['Французский; Китайский; Английский', nan, 'тайский', 'хинди; индонезийский', nan]","course = set(input().split(', '))
favorite = set(input().split(', '))
free = set(input().split(', '))

print(*sorted(free and course and favorite, reverse = True), sep = '; ')","course = set(input().split(', '))
favorite = set(input().split(', '))
free = set(input().split(', '))

print(*sorted(free&course&favorite, reverse = True), sep = '; ')","Ошибка в открытых и скрытых тестах. 

Обратите внимание, что оператор сравнения and не применим при сравнении множеств.","['open', 'open', 'closed', 'closed', 'closed']","<Task description>: Студент хочет определить языки, которые он будет изучать на втором курсе. Реализуйте программу, которая поможет ему сделать выбор:

В переменную course считывается список языков, которые изучаются в рамках учебной программы. Этот код уже написан.
В переменную favorite считывается список языков, которые нравятся студенту. Этот код уже написан.
В переменную free считывается список языков, которые можно изучать в университете бесплатно. Этот код уже написан.
Гарантируется, что языки в каждом списке уникальны.
Любой список может оказаться пустым.
Программа выводит через точку с запятой и пробел языки, которые изучаются в рамках программы, нравятся студенту и их можно изучать в университете бесплатно.
Языки должны быть отсортированы в обратном алфавиту порядке.
Если таких языков нет, программа ничего не выводит.  
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: Английский, Французский, Немецкий, Китайский, Арабский, Норвежский
Французский, Немецкий, Английский, Китайский
Французский, Английский, Китайский 
<Вывод>: Французский; Китайский; Английский 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: Испанский, Шведский

Англисйкий, Греческий 
<Вывод>: nan 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: тайский
тайский
тайский 
<Вывод>: тайский 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: иврит, хинди, индонезийский, ирландский, итальянский
итальянский, индонезийский, хинди, казахский
лаосский, индонезийский, хинди 
<Вывод>: хинди; индонезийский 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: хинди

китайский, японский, корейский 
<Вывод>: nan 
<Решение студента>: course = set(input().split(', '))
favorite = set(input().split(', '))
free = set(input().split(', '))

print(*sorted(free and course and favorite, reverse = True), sep = '; ') 
<Идеальное решение>: course = set(input().split(', '))
favorite = set(input().split(', '))
free = set(input().split(', '))

print(*sorted(free&course&favorite, reverse = True), sep = '; ') 


<Комментарий эксперта>:"
187,452,28,"Студент хочет определить языки, которые он будет изучать на втором курсе. Реализуйте программу, которая поможет ему сделать выбор:

В переменную course считывается список языков, которые изучаются в рамках учебной программы. Этот код уже написан.
В переменную favorite считывается список языков, которые нравятся студенту. Этот код уже написан.
В переменную free считывается список языков, которые можно изучать в университете бесплатно. Этот код уже написан.
Гарантируется, что языки в каждом списке уникальны.
Любой список может оказаться пустым.
Программа выводит через точку с запятой и пробел языки, которые изучаются в рамках программы, нравятся студенту и их можно изучать в университете бесплатно.
Языки должны быть отсортированы в обратном алфавиту порядке.
Если таких языков нет, программа ничего не выводит. ","['Английский, Французский, Немецкий, Китайский, Арабский, Норвежский\nФранцузский, Немецкий, Английский, Китайский\nФранцузский, Английский, Китайский', 'Испанский, Шведский\n\nАнглисйкий, Греческий', 'тайский\nтайский\nтайский', 'иврит, хинди, индонезийский, ирландский, итальянский\nитальянский, индонезийский, хинди, казахский\nлаосский, индонезийский, хинди', 'хинди\n\nкитайский, японский, корейский']","['Французский; Китайский; Английский', nan, 'тайский', 'хинди; индонезийский', nan]","course = set(input().split(', '))
favorite = set(input().split(', '))
free = set(input().split(', '))

print(*sorted(free + course + favorite, reverse = True), sep = '; ')","course = set(input().split(', '))
favorite = set(input().split(', '))
free = set(input().split(', '))

print(*sorted(free&course&favorite, reverse = True), sep = '; ')","Ошибка в открытых и скрытых тестах. 

Обратите внимание, что оператор ""+"" не применим при сравнении множеств.","['open', 'open', 'closed', 'closed', 'closed']","<Task description>: Студент хочет определить языки, которые он будет изучать на втором курсе. Реализуйте программу, которая поможет ему сделать выбор:

В переменную course считывается список языков, которые изучаются в рамках учебной программы. Этот код уже написан.
В переменную favorite считывается список языков, которые нравятся студенту. Этот код уже написан.
В переменную free считывается список языков, которые можно изучать в университете бесплатно. Этот код уже написан.
Гарантируется, что языки в каждом списке уникальны.
Любой список может оказаться пустым.
Программа выводит через точку с запятой и пробел языки, которые изучаются в рамках программы, нравятся студенту и их можно изучать в университете бесплатно.
Языки должны быть отсортированы в обратном алфавиту порядке.
Если таких языков нет, программа ничего не выводит.  
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: Английский, Французский, Немецкий, Китайский, Арабский, Норвежский
Французский, Немецкий, Английский, Китайский
Французский, Английский, Китайский 
<Вывод>: Французский; Китайский; Английский 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: Испанский, Шведский

Англисйкий, Греческий 
<Вывод>: nan 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: тайский
тайский
тайский 
<Вывод>: тайский 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: иврит, хинди, индонезийский, ирландский, итальянский
итальянский, индонезийский, хинди, казахский
лаосский, индонезийский, хинди 
<Вывод>: хинди; индонезийский 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: хинди

китайский, японский, корейский 
<Вывод>: nan 
<Решение студента>: course = set(input().split(', '))
favorite = set(input().split(', '))
free = set(input().split(', '))

print(*sorted(free + course + favorite, reverse = True), sep = '; ') 
<Идеальное решение>: course = set(input().split(', '))
favorite = set(input().split(', '))
free = set(input().split(', '))

print(*sorted(free&course&favorite, reverse = True), sep = '; ') 


<Комментарий эксперта>:"
188,453,28,"Студент хочет определить языки, которые он будет изучать на втором курсе. Реализуйте программу, которая поможет ему сделать выбор:

В переменную course считывается список языков, которые изучаются в рамках учебной программы. Этот код уже написан.
В переменную favorite считывается список языков, которые нравятся студенту. Этот код уже написан.
В переменную free считывается список языков, которые можно изучать в университете бесплатно. Этот код уже написан.
Гарантируется, что языки в каждом списке уникальны.
Любой список может оказаться пустым.
Программа выводит через точку с запятой и пробел языки, которые изучаются в рамках программы, нравятся студенту и их можно изучать в университете бесплатно.
Языки должны быть отсортированы в обратном алфавиту порядке.
Если таких языков нет, программа ничего не выводит. ","['Английский, Французский, Немецкий, Китайский, Арабский, Норвежский\nФранцузский, Немецкий, Английский, Китайский\nФранцузский, Английский, Китайский', 'Испанский, Шведский\n\nАнглисйкий, Греческий', 'тайский\nтайский\nтайский', 'иврит, хинди, индонезийский, ирландский, итальянский\nитальянский, индонезийский, хинди, казахский\nлаосский, индонезийский, хинди', 'хинди\n\nкитайский, японский, корейский']","['Французский; Китайский; Английский', nan, 'тайский', 'хинди; индонезийский', nan]","course = set(input().split(', '))
favorite = set(input().split(', '))
free = set(input().split(', '))

print(free & course & favorite)","course = set(input().split(', '))
favorite = set(input().split(', '))
free = set(input().split(', '))

print(*sorted(free&course&favorite, reverse = True), sep = '; ')","Ошибка в открытых и скрытых тестах. 

Ваш код некорректно выполняет условия задания. Например, он не выполняет условия ""программа выводит через точку с запятой и пробел языки, которые изучаются в рамках программы, нравятся студенту и их можно изучать в университете бесплатно. Языки должны быть отсортированы в обратном алфавиту порядке"". Попробуйте изменить print() чтобы скорректировать ошибку.","['open', 'open', 'closed', 'closed', 'closed']","<Task description>: Студент хочет определить языки, которые он будет изучать на втором курсе. Реализуйте программу, которая поможет ему сделать выбор:

В переменную course считывается список языков, которые изучаются в рамках учебной программы. Этот код уже написан.
В переменную favorite считывается список языков, которые нравятся студенту. Этот код уже написан.
В переменную free считывается список языков, которые можно изучать в университете бесплатно. Этот код уже написан.
Гарантируется, что языки в каждом списке уникальны.
Любой список может оказаться пустым.
Программа выводит через точку с запятой и пробел языки, которые изучаются в рамках программы, нравятся студенту и их можно изучать в университете бесплатно.
Языки должны быть отсортированы в обратном алфавиту порядке.
Если таких языков нет, программа ничего не выводит.  
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: Английский, Французский, Немецкий, Китайский, Арабский, Норвежский
Французский, Немецкий, Английский, Китайский
Французский, Английский, Китайский 
<Вывод>: Французский; Китайский; Английский 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: Испанский, Шведский

Англисйкий, Греческий 
<Вывод>: nan 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: тайский
тайский
тайский 
<Вывод>: тайский 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: иврит, хинди, индонезийский, ирландский, итальянский
итальянский, индонезийский, хинди, казахский
лаосский, индонезийский, хинди 
<Вывод>: хинди; индонезийский 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: хинди

китайский, японский, корейский 
<Вывод>: nan 
<Решение студента>: course = set(input().split(', '))
favorite = set(input().split(', '))
free = set(input().split(', '))

print(free & course & favorite) 
<Идеальное решение>: course = set(input().split(', '))
favorite = set(input().split(', '))
free = set(input().split(', '))

print(*sorted(free&course&favorite, reverse = True), sep = '; ') 


<Комментарий эксперта>:"
189,454,28,"Студент хочет определить языки, которые он будет изучать на втором курсе. Реализуйте программу, которая поможет ему сделать выбор:

В переменную course считывается список языков, которые изучаются в рамках учебной программы. Этот код уже написан.
В переменную favorite считывается список языков, которые нравятся студенту. Этот код уже написан.
В переменную free считывается список языков, которые можно изучать в университете бесплатно. Этот код уже написан.
Гарантируется, что языки в каждом списке уникальны.
Любой список может оказаться пустым.
Программа выводит через точку с запятой и пробел языки, которые изучаются в рамках программы, нравятся студенту и их можно изучать в университете бесплатно.
Языки должны быть отсортированы в обратном алфавиту порядке.
Если таких языков нет, программа ничего не выводит. ","['Английский, Французский, Немецкий, Китайский, Арабский, Норвежский\nФранцузский, Немецкий, Английский, Китайский\nФранцузский, Английский, Китайский', 'Испанский, Шведский\n\nАнглисйкий, Греческий', 'тайский\nтайский\nтайский', 'иврит, хинди, индонезийский, ирландский, итальянский\nитальянский, индонезийский, хинди, казахский\nлаосский, индонезийский, хинди', 'хинди\n\nкитайский, японский, корейский']","['Французский; Китайский; Английский', nan, 'тайский', 'хинди; индонезийский', nan]","course = set(input().split(', '))
favorite = set(input().split(', '))
free = set(input().split(', '))

print(*sorted(free & course & favorite))","course = set(input().split(', '))
favorite = set(input().split(', '))
free = set(input().split(', '))

print(*sorted(free&course&favorite, reverse = True), sep = '; ')","Ошибка в открытых и скрытых тестах. 

Ваш код некорректно выполняет условия задания. Например, он не выполняет условия ""программа выводит через точку с запятой и пробел языки, которые изучаются в рамках программы, нравятся студенту и их можно изучать в университете бесплатно. Языки должны быть отсортированы в обратном алфавиту порядке"". Попробуйте изменить print() чтобы скорректировать ошибку.","['open', 'open', 'closed', 'closed', 'closed']","<Task description>: Студент хочет определить языки, которые он будет изучать на втором курсе. Реализуйте программу, которая поможет ему сделать выбор:

В переменную course считывается список языков, которые изучаются в рамках учебной программы. Этот код уже написан.
В переменную favorite считывается список языков, которые нравятся студенту. Этот код уже написан.
В переменную free считывается список языков, которые можно изучать в университете бесплатно. Этот код уже написан.
Гарантируется, что языки в каждом списке уникальны.
Любой список может оказаться пустым.
Программа выводит через точку с запятой и пробел языки, которые изучаются в рамках программы, нравятся студенту и их можно изучать в университете бесплатно.
Языки должны быть отсортированы в обратном алфавиту порядке.
Если таких языков нет, программа ничего не выводит.  
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: Английский, Французский, Немецкий, Китайский, Арабский, Норвежский
Французский, Немецкий, Английский, Китайский
Французский, Английский, Китайский 
<Вывод>: Французский; Китайский; Английский 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: Испанский, Шведский

Англисйкий, Греческий 
<Вывод>: nan 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: тайский
тайский
тайский 
<Вывод>: тайский 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: иврит, хинди, индонезийский, ирландский, итальянский
итальянский, индонезийский, хинди, казахский
лаосский, индонезийский, хинди 
<Вывод>: хинди; индонезийский 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: хинди

китайский, японский, корейский 
<Вывод>: nan 
<Решение студента>: course = set(input().split(', '))
favorite = set(input().split(', '))
free = set(input().split(', '))

print(*sorted(free & course & favorite)) 
<Идеальное решение>: course = set(input().split(', '))
favorite = set(input().split(', '))
free = set(input().split(', '))

print(*sorted(free&course&favorite, reverse = True), sep = '; ') 


<Комментарий эксперта>:"
190,455,28,"Студент хочет определить языки, которые он будет изучать на втором курсе. Реализуйте программу, которая поможет ему сделать выбор:

В переменную course считывается список языков, которые изучаются в рамках учебной программы. Этот код уже написан.
В переменную favorite считывается список языков, которые нравятся студенту. Этот код уже написан.
В переменную free считывается список языков, которые можно изучать в университете бесплатно. Этот код уже написан.
Гарантируется, что языки в каждом списке уникальны.
Любой список может оказаться пустым.
Программа выводит через точку с запятой и пробел языки, которые изучаются в рамках программы, нравятся студенту и их можно изучать в университете бесплатно.
Языки должны быть отсортированы в обратном алфавиту порядке.
Если таких языков нет, программа ничего не выводит. ","['Английский, Французский, Немецкий, Китайский, Арабский, Норвежский\nФранцузский, Немецкий, Английский, Китайский\nФранцузский, Английский, Китайский', 'Испанский, Шведский\n\nАнглисйкий, Греческий', 'тайский\nтайский\nтайский', 'иврит, хинди, индонезийский, ирландский, итальянский\nитальянский, индонезийский, хинди, казахский\nлаосский, индонезийский, хинди', 'хинди\n\nкитайский, японский, корейский']","['Французский; Китайский; Английский', nan, 'тайский', 'хинди; индонезийский', nan]","course = set(input().split(', '))
favorite = set(input().split(', '))
free = set(input().split(', '))

print(*sorted(free & course & favorite), sep = '; ')","course = set(input().split(', '))
favorite = set(input().split(', '))
free = set(input().split(', '))

print(*sorted(free&course&favorite, reverse = True), sep = '; ')","Ошибка в открытых и скрытых тестах. 

Ваш код некорректно выполняет условия задания. Например, он не выполняет условия ""Языки должны быть отсортированы в обратном алфавиту порядке"". Попробуйте изменить print() чтобы скорректировать ошибку.","['open', 'open', 'closed', 'closed', 'closed']","<Task description>: Студент хочет определить языки, которые он будет изучать на втором курсе. Реализуйте программу, которая поможет ему сделать выбор:

В переменную course считывается список языков, которые изучаются в рамках учебной программы. Этот код уже написан.
В переменную favorite считывается список языков, которые нравятся студенту. Этот код уже написан.
В переменную free считывается список языков, которые можно изучать в университете бесплатно. Этот код уже написан.
Гарантируется, что языки в каждом списке уникальны.
Любой список может оказаться пустым.
Программа выводит через точку с запятой и пробел языки, которые изучаются в рамках программы, нравятся студенту и их можно изучать в университете бесплатно.
Языки должны быть отсортированы в обратном алфавиту порядке.
Если таких языков нет, программа ничего не выводит.  
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: Английский, Французский, Немецкий, Китайский, Арабский, Норвежский
Французский, Немецкий, Английский, Китайский
Французский, Английский, Китайский 
<Вывод>: Французский; Китайский; Английский 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: Испанский, Шведский

Англисйкий, Греческий 
<Вывод>: nan 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: тайский
тайский
тайский 
<Вывод>: тайский 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: иврит, хинди, индонезийский, ирландский, итальянский
итальянский, индонезийский, хинди, казахский
лаосский, индонезийский, хинди 
<Вывод>: хинди; индонезийский 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: хинди

китайский, японский, корейский 
<Вывод>: nan 
<Решение студента>: course = set(input().split(', '))
favorite = set(input().split(', '))
free = set(input().split(', '))

print(*sorted(free & course & favorite), sep = '; ') 
<Идеальное решение>: course = set(input().split(', '))
favorite = set(input().split(', '))
free = set(input().split(', '))

print(*sorted(free&course&favorite, reverse = True), sep = '; ') 


<Комментарий эксперта>:"
191,456,28,"Студент хочет определить языки, которые он будет изучать на втором курсе. Реализуйте программу, которая поможет ему сделать выбор:

В переменную course считывается список языков, которые изучаются в рамках учебной программы. Этот код уже написан.
В переменную favorite считывается список языков, которые нравятся студенту. Этот код уже написан.
В переменную free считывается список языков, которые можно изучать в университете бесплатно. Этот код уже написан.
Гарантируется, что языки в каждом списке уникальны.
Любой список может оказаться пустым.
Программа выводит через точку с запятой и пробел языки, которые изучаются в рамках программы, нравятся студенту и их можно изучать в университете бесплатно.
Языки должны быть отсортированы в обратном алфавиту порядке.
Если таких языков нет, программа ничего не выводит. ","['Английский, Французский, Немецкий, Китайский, Арабский, Норвежский\nФранцузский, Немецкий, Английский, Китайский\nФранцузский, Английский, Китайский', 'Испанский, Шведский\n\nАнглисйкий, Греческий', 'тайский\nтайский\nтайский', 'иврит, хинди, индонезийский, ирландский, итальянский\nитальянский, индонезийский, хинди, казахский\nлаосский, индонезийский, хинди', 'хинди\n\nкитайский, японский, корейский']","['Французский; Китайский; Английский', nan, 'тайский', 'хинди; индонезийский', nan]","course = set(input().split(', '))
favorite = set(input().split(', '))
free = set(input().split(', '))

print(*sorted(free & course & favorite, reverse = True))","course = set(input().split(', '))
favorite = set(input().split(', '))
free = set(input().split(', '))

print(*sorted(free&course&favorite, reverse = True), sep = '; ')","Ошибка в открытых и скрытых тестах. 

Ваш код некорректно выполняет условия задания. Например, он не выполняет условия ""программа выводит через точку с запятой и пробел языки, которые изучаются в рамках программы, нравятся студенту и их можно изучать в университете бесплатно"". Попробуйте изменить print() чтобы скорректировать ошибку.","['open', 'open', 'closed', 'closed', 'closed']","<Task description>: Студент хочет определить языки, которые он будет изучать на втором курсе. Реализуйте программу, которая поможет ему сделать выбор:

В переменную course считывается список языков, которые изучаются в рамках учебной программы. Этот код уже написан.
В переменную favorite считывается список языков, которые нравятся студенту. Этот код уже написан.
В переменную free считывается список языков, которые можно изучать в университете бесплатно. Этот код уже написан.
Гарантируется, что языки в каждом списке уникальны.
Любой список может оказаться пустым.
Программа выводит через точку с запятой и пробел языки, которые изучаются в рамках программы, нравятся студенту и их можно изучать в университете бесплатно.
Языки должны быть отсортированы в обратном алфавиту порядке.
Если таких языков нет, программа ничего не выводит.  
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: Английский, Французский, Немецкий, Китайский, Арабский, Норвежский
Французский, Немецкий, Английский, Китайский
Французский, Английский, Китайский 
<Вывод>: Французский; Китайский; Английский 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: Испанский, Шведский

Англисйкий, Греческий 
<Вывод>: nan 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: тайский
тайский
тайский 
<Вывод>: тайский 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: иврит, хинди, индонезийский, ирландский, итальянский
итальянский, индонезийский, хинди, казахский
лаосский, индонезийский, хинди 
<Вывод>: хинди; индонезийский 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: хинди

китайский, японский, корейский 
<Вывод>: nan 
<Решение студента>: course = set(input().split(', '))
favorite = set(input().split(', '))
free = set(input().split(', '))

print(*sorted(free & course & favorite, reverse = True)) 
<Идеальное решение>: course = set(input().split(', '))
favorite = set(input().split(', '))
free = set(input().split(', '))

print(*sorted(free&course&favorite, reverse = True), sep = '; ') 


<Комментарий эксперта>:"
192,457,28,"Студент хочет определить языки, которые он будет изучать на втором курсе. Реализуйте программу, которая поможет ему сделать выбор:

В переменную course считывается список языков, которые изучаются в рамках учебной программы. Этот код уже написан.
В переменную favorite считывается список языков, которые нравятся студенту. Этот код уже написан.
В переменную free считывается список языков, которые можно изучать в университете бесплатно. Этот код уже написан.
Гарантируется, что языки в каждом списке уникальны.
Любой список может оказаться пустым.
Программа выводит через точку с запятой и пробел языки, которые изучаются в рамках программы, нравятся студенту и их можно изучать в университете бесплатно.
Языки должны быть отсортированы в обратном алфавиту порядке.
Если таких языков нет, программа ничего не выводит. ","['Английский, Французский, Немецкий, Китайский, Арабский, Норвежский\nФранцузский, Немецкий, Английский, Китайский\nФранцузский, Английский, Китайский', 'Испанский, Шведский\n\nАнглисйкий, Греческий', 'тайский\nтайский\nтайский', 'иврит, хинди, индонезийский, ирландский, итальянский\nитальянский, индонезийский, хинди, казахский\nлаосский, индонезийский, хинди', 'хинди\n\nкитайский, японский, корейский']","['Французский; Китайский; Английский', nan, 'тайский', 'хинди; индонезийский', nan]","course = set(input().split(', '))
favorite = set(input().split(', '))
free = set(input().split(', '))

print(*sorted(free & course & favorite, reverse = true), sep = '; ')","course = set(input().split(', '))
favorite = set(input().split(', '))
free = set(input().split(', '))

print(*sorted(free&course&favorite, reverse = True), sep = '; ')",Обратите внимание на неверный синтаксис булевых значений.,"['open', 'open', 'closed', 'closed', 'closed']","<Task description>: Студент хочет определить языки, которые он будет изучать на втором курсе. Реализуйте программу, которая поможет ему сделать выбор:

В переменную course считывается список языков, которые изучаются в рамках учебной программы. Этот код уже написан.
В переменную favorite считывается список языков, которые нравятся студенту. Этот код уже написан.
В переменную free считывается список языков, которые можно изучать в университете бесплатно. Этот код уже написан.
Гарантируется, что языки в каждом списке уникальны.
Любой список может оказаться пустым.
Программа выводит через точку с запятой и пробел языки, которые изучаются в рамках программы, нравятся студенту и их можно изучать в университете бесплатно.
Языки должны быть отсортированы в обратном алфавиту порядке.
Если таких языков нет, программа ничего не выводит.  
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: Английский, Французский, Немецкий, Китайский, Арабский, Норвежский
Французский, Немецкий, Английский, Китайский
Французский, Английский, Китайский 
<Вывод>: Французский; Китайский; Английский 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: Испанский, Шведский

Англисйкий, Греческий 
<Вывод>: nan 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: тайский
тайский
тайский 
<Вывод>: тайский 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: иврит, хинди, индонезийский, ирландский, итальянский
итальянский, индонезийский, хинди, казахский
лаосский, индонезийский, хинди 
<Вывод>: хинди; индонезийский 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: хинди

китайский, японский, корейский 
<Вывод>: nan 
<Решение студента>: course = set(input().split(', '))
favorite = set(input().split(', '))
free = set(input().split(', '))

print(*sorted(free & course & favorite, reverse = true), sep = '; ') 
<Идеальное решение>: course = set(input().split(', '))
favorite = set(input().split(', '))
free = set(input().split(', '))

print(*sorted(free&course&favorite, reverse = True), sep = '; ') 


<Комментарий эксперта>:"
193,458,28,"Студент хочет определить языки, которые он будет изучать на втором курсе. Реализуйте программу, которая поможет ему сделать выбор:

В переменную course считывается список языков, которые изучаются в рамках учебной программы. Этот код уже написан.
В переменную favorite считывается список языков, которые нравятся студенту. Этот код уже написан.
В переменную free считывается список языков, которые можно изучать в университете бесплатно. Этот код уже написан.
Гарантируется, что языки в каждом списке уникальны.
Любой список может оказаться пустым.
Программа выводит через точку с запятой и пробел языки, которые изучаются в рамках программы, нравятся студенту и их можно изучать в университете бесплатно.
Языки должны быть отсортированы в обратном алфавиту порядке.
Если таких языков нет, программа ничего не выводит. ","['Английский, Французский, Немецкий, Китайский, Арабский, Норвежский\nФранцузский, Немецкий, Английский, Китайский\nФранцузский, Английский, Китайский', 'Испанский, Шведский\n\nАнглисйкий, Греческий', 'тайский\nтайский\nтайский', 'иврит, хинди, индонезийский, ирландский, итальянский\nитальянский, индонезийский, хинди, казахский\nлаосский, индонезийский, хинди', 'хинди\n\nкитайский, японский, корейский']","['Французский; Китайский; Английский', nan, 'тайский', 'хинди; индонезийский', nan]","course = set(input().split(', '))
favorite = set(input().split(', '))
free = set(input().split(', '))

print(*sorted(free & course & favorite, reverse = True), sep = '; ', end = '.')","course = set(input().split(', '))
favorite = set(input().split(', '))
free = set(input().split(', '))

print(*sorted(free&course&favorite, reverse = True), sep = '; ')","Ошибка в открытых и скрытых тестах. 

Обратите внимание, что по условию задания, в случае, если соответствующих условиям языков нет, программа ничего не выводит.","['open', 'open', 'closed', 'closed', 'closed']","<Task description>: Студент хочет определить языки, которые он будет изучать на втором курсе. Реализуйте программу, которая поможет ему сделать выбор:

В переменную course считывается список языков, которые изучаются в рамках учебной программы. Этот код уже написан.
В переменную favorite считывается список языков, которые нравятся студенту. Этот код уже написан.
В переменную free считывается список языков, которые можно изучать в университете бесплатно. Этот код уже написан.
Гарантируется, что языки в каждом списке уникальны.
Любой список может оказаться пустым.
Программа выводит через точку с запятой и пробел языки, которые изучаются в рамках программы, нравятся студенту и их можно изучать в университете бесплатно.
Языки должны быть отсортированы в обратном алфавиту порядке.
Если таких языков нет, программа ничего не выводит.  
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: Английский, Французский, Немецкий, Китайский, Арабский, Норвежский
Французский, Немецкий, Английский, Китайский
Французский, Английский, Китайский 
<Вывод>: Французский; Китайский; Английский 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: Испанский, Шведский

Англисйкий, Греческий 
<Вывод>: nan 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: тайский
тайский
тайский 
<Вывод>: тайский 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: иврит, хинди, индонезийский, ирландский, итальянский
итальянский, индонезийский, хинди, казахский
лаосский, индонезийский, хинди 
<Вывод>: хинди; индонезийский 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: хинди

китайский, японский, корейский 
<Вывод>: nan 
<Решение студента>: course = set(input().split(', '))
favorite = set(input().split(', '))
free = set(input().split(', '))

print(*sorted(free & course & favorite, reverse = True), sep = '; ', end = '.') 
<Идеальное решение>: course = set(input().split(', '))
favorite = set(input().split(', '))
free = set(input().split(', '))

print(*sorted(free&course&favorite, reverse = True), sep = '; ') 


<Комментарий эксперта>:"
194,459,29,"Реализуйте программу, определяющую переводчиков, которые знают определенные языки:

Дан словарь interpreter, где ключи — это названия компаний, в которых работают переводчики, а значения — словари (где ключи — фамилии и имена переводчиков, разделенные пробелом, а значения — списки с языками, которые они знают). Этот код уже написан.
В переменную language считывается язык (строка). Этот код уже написан.
Определите, какие переводчики не знают введенный язык и напечатайте их фамилии в верхнем регистре через точку с запятой и пробел. Фамилии должны идти в том же порядке, что и в словаре.
Если язык никто не знает, то программа ничего не печатает.","['английский', 'албанский', 'иврит', 'немецкий', 'китайский', 'арабский']","['ИВАНОВ; РАСКИН; РОДИОНОВ; ГРОМОВ', 'ПЕТРОВ; ИВАНОВ; РАСКИН; МАРТЫНОВ; ПРАВДИН; ИГНАТОВ; РОДИОНОВ; ГРОМОВ', 'ПЕТРОВ; ИВАНОВ; МАРТЫНОВ; ПРАВДИН; ИГНАТОВ; РОДИОНОВ; ГРОМОВ', 'ИВАНОВ; РАСКИН; МАРТЫНОВ; ПРАВДИН; РОДИОНОВ', 'РАСКИН; МАРТЫНОВ; ПРАВДИН; ИГНАТОВ; РОДИОНОВ; ГРОМОВ', 'ПЕТРОВ; ИВАНОВ; РАСКИН; МАРТЫНОВ; ПРАВДИН; ИГНАТОВ; РОДИОНОВ; ГРОМОВ']","language = input() 

count_list = {}
for key, value in interpreter.items():
    for k, v in value.items():
        if language not in v:
            count_list.append(k.split()[0].upper())
    
print(*count_list, sep='; ')","interpreter = {
    'Профперевод': {'Петров Александр': [""английский"", ""немецкий"", ""китайский""], 'Иванов Кирилл': [""китайский"", ""шведский""]},
    'Экспресс_перевод': {'Раскин Николай': [""иврит"", ""казахский"", ""португальский"" ], 'Мартынов Аркадий': [""шведский"", ""испанский"", ""английский""], 'Правдин Петр': [""английский""]},
    'Альфапер': {'Игнатов Максим': [""немецкий"", ""английский"", ""хинди""], 'Родионов Олег': [""шведский"", ""испанский""]},
    'Переводы24': {'Громов Игорь': [""немецкий"", ""португальский""]}
}

language = input() 

count_list = []
for key, value in interpreter.items():
    for k, v in value.items():
        if language not in v:
            count_list.append(k.split()[0].upper())
    
print(*count_list, sep='; ')",Некорректно задана переменная. Словарь не имеет метода .append().,"['open', 'open', 'closed', 'closed', 'closed', 'closed']","<Task description>: Реализуйте программу, определяющую переводчиков, которые знают определенные языки:

Дан словарь interpreter, где ключи — это названия компаний, в которых работают переводчики, а значения — словари (где ключи — фамилии и имена переводчиков, разделенные пробелом, а значения — списки с языками, которые они знают). Этот код уже написан.
В переменную language считывается язык (строка). Этот код уже написан.
Определите, какие переводчики не знают введенный язык и напечатайте их фамилии в верхнем регистре через точку с запятой и пробел. Фамилии должны идти в том же порядке, что и в словаре.
Если язык никто не знает, то программа ничего не печатает. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: английский 
<Вывод>: ИВАНОВ; РАСКИН; РОДИОНОВ; ГРОМОВ 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: албанский 
<Вывод>: ПЕТРОВ; ИВАНОВ; РАСКИН; МАРТЫНОВ; ПРАВДИН; ИГНАТОВ; РОДИОНОВ; ГРОМОВ 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: иврит 
<Вывод>: ПЕТРОВ; ИВАНОВ; МАРТЫНОВ; ПРАВДИН; ИГНАТОВ; РОДИОНОВ; ГРОМОВ 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: немецкий 
<Вывод>: ИВАНОВ; РАСКИН; МАРТЫНОВ; ПРАВДИН; РОДИОНОВ 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: китайский 
<Вывод>: РАСКИН; МАРТЫНОВ; ПРАВДИН; ИГНАТОВ; РОДИОНОВ; ГРОМОВ 
<Example 6>: 
<Тип теста 6>: closed 
<Ввод>: арабский 
<Вывод>: ПЕТРОВ; ИВАНОВ; РАСКИН; МАРТЫНОВ; ПРАВДИН; ИГНАТОВ; РОДИОНОВ; ГРОМОВ 
<Решение студента>: language = input() 

count_list = {}
for key, value in interpreter.items():
    for k, v in value.items():
        if language not in v:
            count_list.append(k.split()[0].upper())
    
print(*count_list, sep='; ') 
<Идеальное решение>: interpreter = {
    'Профперевод': {'Петров Александр': [""английский"", ""немецкий"", ""китайский""], 'Иванов Кирилл': [""китайский"", ""шведский""]},
    'Экспресс_перевод': {'Раскин Николай': [""иврит"", ""казахский"", ""португальский"" ], 'Мартынов Аркадий': [""шведский"", ""испанский"", ""английский""], 'Правдин Петр': [""английский""]},
    'Альфапер': {'Игнатов Максим': [""немецкий"", ""английский"", ""хинди""], 'Родионов Олег': [""шведский"", ""испанский""]},
    'Переводы24': {'Громов Игорь': [""немецкий"", ""португальский""]}
}

language = input() 

count_list = []
for key, value in interpreter.items():
    for k, v in value.items():
        if language not in v:
            count_list.append(k.split()[0].upper())
    
print(*count_list, sep='; ') 


<Комментарий эксперта>:"
195,460,29,"Реализуйте программу, определяющую переводчиков, которые знают определенные языки:

Дан словарь interpreter, где ключи — это названия компаний, в которых работают переводчики, а значения — словари (где ключи — фамилии и имена переводчиков, разделенные пробелом, а значения — списки с языками, которые они знают). Этот код уже написан.
В переменную language считывается язык (строка). Этот код уже написан.
Определите, какие переводчики не знают введенный язык и напечатайте их фамилии в верхнем регистре через точку с запятой и пробел. Фамилии должны идти в том же порядке, что и в словаре.
Если язык никто не знает, то программа ничего не печатает.","['английский', 'албанский', 'иврит', 'немецкий', 'китайский', 'арабский']","['ИВАНОВ; РАСКИН; РОДИОНОВ; ГРОМОВ', 'ПЕТРОВ; ИВАНОВ; РАСКИН; МАРТЫНОВ; ПРАВДИН; ИГНАТОВ; РОДИОНОВ; ГРОМОВ', 'ПЕТРОВ; ИВАНОВ; МАРТЫНОВ; ПРАВДИН; ИГНАТОВ; РОДИОНОВ; ГРОМОВ', 'ИВАНОВ; РАСКИН; МАРТЫНОВ; ПРАВДИН; РОДИОНОВ', 'РАСКИН; МАРТЫНОВ; ПРАВДИН; ИГНАТОВ; РОДИОНОВ; ГРОМОВ', 'ПЕТРОВ; ИВАНОВ; РАСКИН; МАРТЫНОВ; ПРАВДИН; ИГНАТОВ; РОДИОНОВ; ГРОМОВ']","language = input() 

for key, value in interpreter.items():
    for k, v in value.items():
        if language not in v:
            count_list.append(k.split()[0].upper())
    
print(*count_list, sep='; ')","interpreter = {
    'Профперевод': {'Петров Александр': [""английский"", ""немецкий"", ""китайский""], 'Иванов Кирилл': [""китайский"", ""шведский""]},
    'Экспресс_перевод': {'Раскин Николай': [""иврит"", ""казахский"", ""португальский"" ], 'Мартынов Аркадий': [""шведский"", ""испанский"", ""английский""], 'Правдин Петр': [""английский""]},
    'Альфапер': {'Игнатов Максим': [""немецкий"", ""английский"", ""хинди""], 'Родионов Олег': [""шведский"", ""испанский""]},
    'Переводы24': {'Громов Игорь': [""немецкий"", ""португальский""]}
}

language = input() 

count_list = []
for key, value in interpreter.items():
    for k, v in value.items():
        if language not in v:
            count_list.append(k.split()[0].upper())
    
print(*count_list, sep='; ')","Ошибка при обращении к ранее не заданным переменным. Проверьте, что все Ваши переменные написаны корректно.","['open', 'open', 'closed', 'closed', 'closed', 'closed']","<Task description>: Реализуйте программу, определяющую переводчиков, которые знают определенные языки:

Дан словарь interpreter, где ключи — это названия компаний, в которых работают переводчики, а значения — словари (где ключи — фамилии и имена переводчиков, разделенные пробелом, а значения — списки с языками, которые они знают). Этот код уже написан.
В переменную language считывается язык (строка). Этот код уже написан.
Определите, какие переводчики не знают введенный язык и напечатайте их фамилии в верхнем регистре через точку с запятой и пробел. Фамилии должны идти в том же порядке, что и в словаре.
Если язык никто не знает, то программа ничего не печатает. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: английский 
<Вывод>: ИВАНОВ; РАСКИН; РОДИОНОВ; ГРОМОВ 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: албанский 
<Вывод>: ПЕТРОВ; ИВАНОВ; РАСКИН; МАРТЫНОВ; ПРАВДИН; ИГНАТОВ; РОДИОНОВ; ГРОМОВ 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: иврит 
<Вывод>: ПЕТРОВ; ИВАНОВ; МАРТЫНОВ; ПРАВДИН; ИГНАТОВ; РОДИОНОВ; ГРОМОВ 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: немецкий 
<Вывод>: ИВАНОВ; РАСКИН; МАРТЫНОВ; ПРАВДИН; РОДИОНОВ 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: китайский 
<Вывод>: РАСКИН; МАРТЫНОВ; ПРАВДИН; ИГНАТОВ; РОДИОНОВ; ГРОМОВ 
<Example 6>: 
<Тип теста 6>: closed 
<Ввод>: арабский 
<Вывод>: ПЕТРОВ; ИВАНОВ; РАСКИН; МАРТЫНОВ; ПРАВДИН; ИГНАТОВ; РОДИОНОВ; ГРОМОВ 
<Решение студента>: language = input() 

for key, value in interpreter.items():
    for k, v in value.items():
        if language not in v:
            count_list.append(k.split()[0].upper())
    
print(*count_list, sep='; ') 
<Идеальное решение>: interpreter = {
    'Профперевод': {'Петров Александр': [""английский"", ""немецкий"", ""китайский""], 'Иванов Кирилл': [""китайский"", ""шведский""]},
    'Экспресс_перевод': {'Раскин Николай': [""иврит"", ""казахский"", ""португальский"" ], 'Мартынов Аркадий': [""шведский"", ""испанский"", ""английский""], 'Правдин Петр': [""английский""]},
    'Альфапер': {'Игнатов Максим': [""немецкий"", ""английский"", ""хинди""], 'Родионов Олег': [""шведский"", ""испанский""]},
    'Переводы24': {'Громов Игорь': [""немецкий"", ""португальский""]}
}

language = input() 

count_list = []
for key, value in interpreter.items():
    for k, v in value.items():
        if language not in v:
            count_list.append(k.split()[0].upper())
    
print(*count_list, sep='; ') 


<Комментарий эксперта>:"
196,461,29,"Реализуйте программу, определяющую переводчиков, которые знают определенные языки:

Дан словарь interpreter, где ключи — это названия компаний, в которых работают переводчики, а значения — словари (где ключи — фамилии и имена переводчиков, разделенные пробелом, а значения — списки с языками, которые они знают). Этот код уже написан.
В переменную language считывается язык (строка). Этот код уже написан.
Определите, какие переводчики не знают введенный язык и напечатайте их фамилии в верхнем регистре через точку с запятой и пробел. Фамилии должны идти в том же порядке, что и в словаре.
Если язык никто не знает, то программа ничего не печатает.","['английский', 'албанский', 'иврит', 'немецкий', 'китайский', 'арабский']","['ИВАНОВ; РАСКИН; РОДИОНОВ; ГРОМОВ', 'ПЕТРОВ; ИВАНОВ; РАСКИН; МАРТЫНОВ; ПРАВДИН; ИГНАТОВ; РОДИОНОВ; ГРОМОВ', 'ПЕТРОВ; ИВАНОВ; МАРТЫНОВ; ПРАВДИН; ИГНАТОВ; РОДИОНОВ; ГРОМОВ', 'ИВАНОВ; РАСКИН; МАРТЫНОВ; ПРАВДИН; РОДИОНОВ', 'РАСКИН; МАРТЫНОВ; ПРАВДИН; ИГНАТОВ; РОДИОНОВ; ГРОМОВ', 'ПЕТРОВ; ИВАНОВ; РАСКИН; МАРТЫНОВ; ПРАВДИН; ИГНАТОВ; РОДИОНОВ; ГРОМОВ']","language = input() 

count_list = []
for key, value in interpreter:
    for k, v in value.items():
        if language not in v:
            count_list.append(k.split()[0].upper())
    
print(*count_list, sep='; ')","interpreter = {
    'Профперевод': {'Петров Александр': [""английский"", ""немецкий"", ""китайский""], 'Иванов Кирилл': [""китайский"", ""шведский""]},
    'Экспресс_перевод': {'Раскин Николай': [""иврит"", ""казахский"", ""португальский"" ], 'Мартынов Аркадий': [""шведский"", ""испанский"", ""английский""], 'Правдин Петр': [""английский""]},
    'Альфапер': {'Игнатов Максим': [""немецкий"", ""английский"", ""хинди""], 'Родионов Олег': [""шведский"", ""испанский""]},
    'Переводы24': {'Громов Игорь': [""немецкий"", ""португальский""]}
}

language = input() 

count_list = []
for key, value in interpreter.items():
    for k, v in value.items():
        if language not in v:
            count_list.append(k.split()[0].upper())
    
print(*count_list, sep='; ')","Ошибка при обращении к элементам словаря interpreter. Попытка обратиться к двум значениям, вместо одного. Используйте опреатор .items().","['open', 'open', 'closed', 'closed', 'closed', 'closed']","<Task description>: Реализуйте программу, определяющую переводчиков, которые знают определенные языки:

Дан словарь interpreter, где ключи — это названия компаний, в которых работают переводчики, а значения — словари (где ключи — фамилии и имена переводчиков, разделенные пробелом, а значения — списки с языками, которые они знают). Этот код уже написан.
В переменную language считывается язык (строка). Этот код уже написан.
Определите, какие переводчики не знают введенный язык и напечатайте их фамилии в верхнем регистре через точку с запятой и пробел. Фамилии должны идти в том же порядке, что и в словаре.
Если язык никто не знает, то программа ничего не печатает. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: английский 
<Вывод>: ИВАНОВ; РАСКИН; РОДИОНОВ; ГРОМОВ 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: албанский 
<Вывод>: ПЕТРОВ; ИВАНОВ; РАСКИН; МАРТЫНОВ; ПРАВДИН; ИГНАТОВ; РОДИОНОВ; ГРОМОВ 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: иврит 
<Вывод>: ПЕТРОВ; ИВАНОВ; МАРТЫНОВ; ПРАВДИН; ИГНАТОВ; РОДИОНОВ; ГРОМОВ 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: немецкий 
<Вывод>: ИВАНОВ; РАСКИН; МАРТЫНОВ; ПРАВДИН; РОДИОНОВ 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: китайский 
<Вывод>: РАСКИН; МАРТЫНОВ; ПРАВДИН; ИГНАТОВ; РОДИОНОВ; ГРОМОВ 
<Example 6>: 
<Тип теста 6>: closed 
<Ввод>: арабский 
<Вывод>: ПЕТРОВ; ИВАНОВ; РАСКИН; МАРТЫНОВ; ПРАВДИН; ИГНАТОВ; РОДИОНОВ; ГРОМОВ 
<Решение студента>: language = input() 

count_list = []
for key, value in interpreter:
    for k, v in value.items():
        if language not in v:
            count_list.append(k.split()[0].upper())
    
print(*count_list, sep='; ') 
<Идеальное решение>: interpreter = {
    'Профперевод': {'Петров Александр': [""английский"", ""немецкий"", ""китайский""], 'Иванов Кирилл': [""китайский"", ""шведский""]},
    'Экспресс_перевод': {'Раскин Николай': [""иврит"", ""казахский"", ""португальский"" ], 'Мартынов Аркадий': [""шведский"", ""испанский"", ""английский""], 'Правдин Петр': [""английский""]},
    'Альфапер': {'Игнатов Максим': [""немецкий"", ""английский"", ""хинди""], 'Родионов Олег': [""шведский"", ""испанский""]},
    'Переводы24': {'Громов Игорь': [""немецкий"", ""португальский""]}
}

language = input() 

count_list = []
for key, value in interpreter.items():
    for k, v in value.items():
        if language not in v:
            count_list.append(k.split()[0].upper())
    
print(*count_list, sep='; ') 


<Комментарий эксперта>:"
197,462,29,"Реализуйте программу, определяющую переводчиков, которые знают определенные языки:

Дан словарь interpreter, где ключи — это названия компаний, в которых работают переводчики, а значения — словари (где ключи — фамилии и имена переводчиков, разделенные пробелом, а значения — списки с языками, которые они знают). Этот код уже написан.
В переменную language считывается язык (строка). Этот код уже написан.
Определите, какие переводчики не знают введенный язык и напечатайте их фамилии в верхнем регистре через точку с запятой и пробел. Фамилии должны идти в том же порядке, что и в словаре.
Если язык никто не знает, то программа ничего не печатает.","['английский', 'албанский', 'иврит', 'немецкий', 'китайский', 'арабский']","['ИВАНОВ; РАСКИН; РОДИОНОВ; ГРОМОВ', 'ПЕТРОВ; ИВАНОВ; РАСКИН; МАРТЫНОВ; ПРАВДИН; ИГНАТОВ; РОДИОНОВ; ГРОМОВ', 'ПЕТРОВ; ИВАНОВ; МАРТЫНОВ; ПРАВДИН; ИГНАТОВ; РОДИОНОВ; ГРОМОВ', 'ИВАНОВ; РАСКИН; МАРТЫНОВ; ПРАВДИН; РОДИОНОВ', 'РАСКИН; МАРТЫНОВ; ПРАВДИН; ИГНАТОВ; РОДИОНОВ; ГРОМОВ', 'ПЕТРОВ; ИВАНОВ; РАСКИН; МАРТЫНОВ; ПРАВДИН; ИГНАТОВ; РОДИОНОВ; ГРОМОВ']","language = input() 

count_list = []
for key, value in interpreter.items():
    for k, v in value:
        if language not in v:
            count_list.append(k.split()[0].upper())
    
print(*count_list, sep='; ')","interpreter = {
    'Профперевод': {'Петров Александр': [""английский"", ""немецкий"", ""китайский""], 'Иванов Кирилл': [""китайский"", ""шведский""]},
    'Экспресс_перевод': {'Раскин Николай': [""иврит"", ""казахский"", ""португальский"" ], 'Мартынов Аркадий': [""шведский"", ""испанский"", ""английский""], 'Правдин Петр': [""английский""]},
    'Альфапер': {'Игнатов Максим': [""немецкий"", ""английский"", ""хинди""], 'Родионов Олег': [""шведский"", ""испанский""]},
    'Переводы24': {'Громов Игорь': [""немецкий"", ""португальский""]}
}

language = input() 

count_list = []
for key, value in interpreter.items():
    for k, v in value.items():
        if language not in v:
            count_list.append(k.split()[0].upper())
    
print(*count_list, sep='; ')","Ошибка при обращении к элементам словаря value. Попытка обратиться к двум значениям, вместо одного. Используйте опреатор .items().","['open', 'open', 'closed', 'closed', 'closed', 'closed']","<Task description>: Реализуйте программу, определяющую переводчиков, которые знают определенные языки:

Дан словарь interpreter, где ключи — это названия компаний, в которых работают переводчики, а значения — словари (где ключи — фамилии и имена переводчиков, разделенные пробелом, а значения — списки с языками, которые они знают). Этот код уже написан.
В переменную language считывается язык (строка). Этот код уже написан.
Определите, какие переводчики не знают введенный язык и напечатайте их фамилии в верхнем регистре через точку с запятой и пробел. Фамилии должны идти в том же порядке, что и в словаре.
Если язык никто не знает, то программа ничего не печатает. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: английский 
<Вывод>: ИВАНОВ; РАСКИН; РОДИОНОВ; ГРОМОВ 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: албанский 
<Вывод>: ПЕТРОВ; ИВАНОВ; РАСКИН; МАРТЫНОВ; ПРАВДИН; ИГНАТОВ; РОДИОНОВ; ГРОМОВ 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: иврит 
<Вывод>: ПЕТРОВ; ИВАНОВ; МАРТЫНОВ; ПРАВДИН; ИГНАТОВ; РОДИОНОВ; ГРОМОВ 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: немецкий 
<Вывод>: ИВАНОВ; РАСКИН; МАРТЫНОВ; ПРАВДИН; РОДИОНОВ 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: китайский 
<Вывод>: РАСКИН; МАРТЫНОВ; ПРАВДИН; ИГНАТОВ; РОДИОНОВ; ГРОМОВ 
<Example 6>: 
<Тип теста 6>: closed 
<Ввод>: арабский 
<Вывод>: ПЕТРОВ; ИВАНОВ; РАСКИН; МАРТЫНОВ; ПРАВДИН; ИГНАТОВ; РОДИОНОВ; ГРОМОВ 
<Решение студента>: language = input() 

count_list = []
for key, value in interpreter.items():
    for k, v in value:
        if language not in v:
            count_list.append(k.split()[0].upper())
    
print(*count_list, sep='; ') 
<Идеальное решение>: interpreter = {
    'Профперевод': {'Петров Александр': [""английский"", ""немецкий"", ""китайский""], 'Иванов Кирилл': [""китайский"", ""шведский""]},
    'Экспресс_перевод': {'Раскин Николай': [""иврит"", ""казахский"", ""португальский"" ], 'Мартынов Аркадий': [""шведский"", ""испанский"", ""английский""], 'Правдин Петр': [""английский""]},
    'Альфапер': {'Игнатов Максим': [""немецкий"", ""английский"", ""хинди""], 'Родионов Олег': [""шведский"", ""испанский""]},
    'Переводы24': {'Громов Игорь': [""немецкий"", ""португальский""]}
}

language = input() 

count_list = []
for key, value in interpreter.items():
    for k, v in value.items():
        if language not in v:
            count_list.append(k.split()[0].upper())
    
print(*count_list, sep='; ') 


<Комментарий эксперта>:"
198,463,29,"Реализуйте программу, определяющую переводчиков, которые знают определенные языки:

Дан словарь interpreter, где ключи — это названия компаний, в которых работают переводчики, а значения — словари (где ключи — фамилии и имена переводчиков, разделенные пробелом, а значения — списки с языками, которые они знают). Этот код уже написан.
В переменную language считывается язык (строка). Этот код уже написан.
Определите, какие переводчики не знают введенный язык и напечатайте их фамилии в верхнем регистре через точку с запятой и пробел. Фамилии должны идти в том же порядке, что и в словаре.
Если язык никто не знает, то программа ничего не печатает.","['английский', 'албанский', 'иврит', 'немецкий', 'китайский', 'арабский']","['ИВАНОВ; РАСКИН; РОДИОНОВ; ГРОМОВ', 'ПЕТРОВ; ИВАНОВ; РАСКИН; МАРТЫНОВ; ПРАВДИН; ИГНАТОВ; РОДИОНОВ; ГРОМОВ', 'ПЕТРОВ; ИВАНОВ; МАРТЫНОВ; ПРАВДИН; ИГНАТОВ; РОДИОНОВ; ГРОМОВ', 'ИВАНОВ; РАСКИН; МАРТЫНОВ; ПРАВДИН; РОДИОНОВ', 'РАСКИН; МАРТЫНОВ; ПРАВДИН; ИГНАТОВ; РОДИОНОВ; ГРОМОВ', 'ПЕТРОВ; ИВАНОВ; РАСКИН; МАРТЫНОВ; ПРАВДИН; ИГНАТОВ; РОДИОНОВ; ГРОМОВ']","language = input() 

count_list = []
for key, value in interpreter.items():
    for k, v in key.items():
        if language not in v:
            count_list.append(k.split()[0].upper())
    
print(*count_list, sep='; ')","interpreter = {
    'Профперевод': {'Петров Александр': [""английский"", ""немецкий"", ""китайский""], 'Иванов Кирилл': [""китайский"", ""шведский""]},
    'Экспресс_перевод': {'Раскин Николай': [""иврит"", ""казахский"", ""португальский"" ], 'Мартынов Аркадий': [""шведский"", ""испанский"", ""английский""], 'Правдин Петр': [""английский""]},
    'Альфапер': {'Игнатов Максим': [""немецкий"", ""английский"", ""хинди""], 'Родионов Олег': [""шведский"", ""испанский""]},
    'Переводы24': {'Громов Игорь': [""немецкий"", ""португальский""]}
}

language = input() 

count_list = []
for key, value in interpreter.items():
    for k, v in value.items():
        if language not in v:
            count_list.append(k.split()[0].upper())
    
print(*count_list, sep='; ')",Ошибка при обращении к элементам словаря value. Вы пытаетесь обратиться к неверному элементу пары ключ-значение.,"['open', 'open', 'closed', 'closed', 'closed', 'closed']","<Task description>: Реализуйте программу, определяющую переводчиков, которые знают определенные языки:

Дан словарь interpreter, где ключи — это названия компаний, в которых работают переводчики, а значения — словари (где ключи — фамилии и имена переводчиков, разделенные пробелом, а значения — списки с языками, которые они знают). Этот код уже написан.
В переменную language считывается язык (строка). Этот код уже написан.
Определите, какие переводчики не знают введенный язык и напечатайте их фамилии в верхнем регистре через точку с запятой и пробел. Фамилии должны идти в том же порядке, что и в словаре.
Если язык никто не знает, то программа ничего не печатает. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: английский 
<Вывод>: ИВАНОВ; РАСКИН; РОДИОНОВ; ГРОМОВ 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: албанский 
<Вывод>: ПЕТРОВ; ИВАНОВ; РАСКИН; МАРТЫНОВ; ПРАВДИН; ИГНАТОВ; РОДИОНОВ; ГРОМОВ 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: иврит 
<Вывод>: ПЕТРОВ; ИВАНОВ; МАРТЫНОВ; ПРАВДИН; ИГНАТОВ; РОДИОНОВ; ГРОМОВ 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: немецкий 
<Вывод>: ИВАНОВ; РАСКИН; МАРТЫНОВ; ПРАВДИН; РОДИОНОВ 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: китайский 
<Вывод>: РАСКИН; МАРТЫНОВ; ПРАВДИН; ИГНАТОВ; РОДИОНОВ; ГРОМОВ 
<Example 6>: 
<Тип теста 6>: closed 
<Ввод>: арабский 
<Вывод>: ПЕТРОВ; ИВАНОВ; РАСКИН; МАРТЫНОВ; ПРАВДИН; ИГНАТОВ; РОДИОНОВ; ГРОМОВ 
<Решение студента>: language = input() 

count_list = []
for key, value in interpreter.items():
    for k, v in key.items():
        if language not in v:
            count_list.append(k.split()[0].upper())
    
print(*count_list, sep='; ') 
<Идеальное решение>: interpreter = {
    'Профперевод': {'Петров Александр': [""английский"", ""немецкий"", ""китайский""], 'Иванов Кирилл': [""китайский"", ""шведский""]},
    'Экспресс_перевод': {'Раскин Николай': [""иврит"", ""казахский"", ""португальский"" ], 'Мартынов Аркадий': [""шведский"", ""испанский"", ""английский""], 'Правдин Петр': [""английский""]},
    'Альфапер': {'Игнатов Максим': [""немецкий"", ""английский"", ""хинди""], 'Родионов Олег': [""шведский"", ""испанский""]},
    'Переводы24': {'Громов Игорь': [""немецкий"", ""португальский""]}
}

language = input() 

count_list = []
for key, value in interpreter.items():
    for k, v in value.items():
        if language not in v:
            count_list.append(k.split()[0].upper())
    
print(*count_list, sep='; ') 


<Комментарий эксперта>:"
199,464,29,"Реализуйте программу, определяющую переводчиков, которые знают определенные языки:

Дан словарь interpreter, где ключи — это названия компаний, в которых работают переводчики, а значения — словари (где ключи — фамилии и имена переводчиков, разделенные пробелом, а значения — списки с языками, которые они знают). Этот код уже написан.
В переменную language считывается язык (строка). Этот код уже написан.
Определите, какие переводчики не знают введенный язык и напечатайте их фамилии в верхнем регистре через точку с запятой и пробел. Фамилии должны идти в том же порядке, что и в словаре.
Если язык никто не знает, то программа ничего не печатает.","['английский', 'албанский', 'иврит', 'немецкий', 'китайский', 'арабский']","['ИВАНОВ; РАСКИН; РОДИОНОВ; ГРОМОВ', 'ПЕТРОВ; ИВАНОВ; РАСКИН; МАРТЫНОВ; ПРАВДИН; ИГНАТОВ; РОДИОНОВ; ГРОМОВ', 'ПЕТРОВ; ИВАНОВ; МАРТЫНОВ; ПРАВДИН; ИГНАТОВ; РОДИОНОВ; ГРОМОВ', 'ИВАНОВ; РАСКИН; МАРТЫНОВ; ПРАВДИН; РОДИОНОВ', 'РАСКИН; МАРТЫНОВ; ПРАВДИН; ИГНАТОВ; РОДИОНОВ; ГРОМОВ', 'ПЕТРОВ; ИВАНОВ; РАСКИН; МАРТЫНОВ; ПРАВДИН; ИГНАТОВ; РОДИОНОВ; ГРОМОВ']","language = input() 

count_list = []
for key, value in interpreter.items():
    for k, v in value.items():
        if language in v:
            count_list.append(k.split()[0].upper())
    
print(*count_list, sep='; ')","interpreter = {
    'Профперевод': {'Петров Александр': [""английский"", ""немецкий"", ""китайский""], 'Иванов Кирилл': [""китайский"", ""шведский""]},
    'Экспресс_перевод': {'Раскин Николай': [""иврит"", ""казахский"", ""португальский"" ], 'Мартынов Аркадий': [""шведский"", ""испанский"", ""английский""], 'Правдин Петр': [""английский""]},
    'Альфапер': {'Игнатов Максим': [""немецкий"", ""английский"", ""хинди""], 'Родионов Олег': [""шведский"", ""испанский""]},
    'Переводы24': {'Громов Игорь': [""немецкий"", ""португальский""]}
}

language = input() 

count_list = []
for key, value in interpreter.items():
    for k, v in value.items():
        if language not in v:
            count_list.append(k.split()[0].upper())
    
print(*count_list, sep='; ')","Ошибка в открытых и скрытых тестах. 

Ваш код некорректно выполняет условия задания. Например, он не выполняет условия ""определите, какие переводчики не знают введенный язык"". Попробуйте изменить условную конструкцию if, чтобы скорректировать ошибку.","['open', 'open', 'closed', 'closed', 'closed', 'closed']","<Task description>: Реализуйте программу, определяющую переводчиков, которые знают определенные языки:

Дан словарь interpreter, где ключи — это названия компаний, в которых работают переводчики, а значения — словари (где ключи — фамилии и имена переводчиков, разделенные пробелом, а значения — списки с языками, которые они знают). Этот код уже написан.
В переменную language считывается язык (строка). Этот код уже написан.
Определите, какие переводчики не знают введенный язык и напечатайте их фамилии в верхнем регистре через точку с запятой и пробел. Фамилии должны идти в том же порядке, что и в словаре.
Если язык никто не знает, то программа ничего не печатает. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: английский 
<Вывод>: ИВАНОВ; РАСКИН; РОДИОНОВ; ГРОМОВ 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: албанский 
<Вывод>: ПЕТРОВ; ИВАНОВ; РАСКИН; МАРТЫНОВ; ПРАВДИН; ИГНАТОВ; РОДИОНОВ; ГРОМОВ 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: иврит 
<Вывод>: ПЕТРОВ; ИВАНОВ; МАРТЫНОВ; ПРАВДИН; ИГНАТОВ; РОДИОНОВ; ГРОМОВ 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: немецкий 
<Вывод>: ИВАНОВ; РАСКИН; МАРТЫНОВ; ПРАВДИН; РОДИОНОВ 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: китайский 
<Вывод>: РАСКИН; МАРТЫНОВ; ПРАВДИН; ИГНАТОВ; РОДИОНОВ; ГРОМОВ 
<Example 6>: 
<Тип теста 6>: closed 
<Ввод>: арабский 
<Вывод>: ПЕТРОВ; ИВАНОВ; РАСКИН; МАРТЫНОВ; ПРАВДИН; ИГНАТОВ; РОДИОНОВ; ГРОМОВ 
<Решение студента>: language = input() 

count_list = []
for key, value in interpreter.items():
    for k, v in value.items():
        if language in v:
            count_list.append(k.split()[0].upper())
    
print(*count_list, sep='; ') 
<Идеальное решение>: interpreter = {
    'Профперевод': {'Петров Александр': [""английский"", ""немецкий"", ""китайский""], 'Иванов Кирилл': [""китайский"", ""шведский""]},
    'Экспресс_перевод': {'Раскин Николай': [""иврит"", ""казахский"", ""португальский"" ], 'Мартынов Аркадий': [""шведский"", ""испанский"", ""английский""], 'Правдин Петр': [""английский""]},
    'Альфапер': {'Игнатов Максим': [""немецкий"", ""английский"", ""хинди""], 'Родионов Олег': [""шведский"", ""испанский""]},
    'Переводы24': {'Громов Игорь': [""немецкий"", ""португальский""]}
}

language = input() 

count_list = []
for key, value in interpreter.items():
    for k, v in value.items():
        if language not in v:
            count_list.append(k.split()[0].upper())
    
print(*count_list, sep='; ') 


<Комментарий эксперта>:"
200,465,29,"Реализуйте программу, определяющую переводчиков, которые знают определенные языки:

Дан словарь interpreter, где ключи — это названия компаний, в которых работают переводчики, а значения — словари (где ключи — фамилии и имена переводчиков, разделенные пробелом, а значения — списки с языками, которые они знают). Этот код уже написан.
В переменную language считывается язык (строка). Этот код уже написан.
Определите, какие переводчики не знают введенный язык и напечатайте их фамилии в верхнем регистре через точку с запятой и пробел. Фамилии должны идти в том же порядке, что и в словаре.
Если язык никто не знает, то программа ничего не печатает.","['английский', 'албанский', 'иврит', 'немецкий', 'китайский', 'арабский']","['ИВАНОВ; РАСКИН; РОДИОНОВ; ГРОМОВ', 'ПЕТРОВ; ИВАНОВ; РАСКИН; МАРТЫНОВ; ПРАВДИН; ИГНАТОВ; РОДИОНОВ; ГРОМОВ', 'ПЕТРОВ; ИВАНОВ; МАРТЫНОВ; ПРАВДИН; ИГНАТОВ; РОДИОНОВ; ГРОМОВ', 'ИВАНОВ; РАСКИН; МАРТЫНОВ; ПРАВДИН; РОДИОНОВ', 'РАСКИН; МАРТЫНОВ; ПРАВДИН; ИГНАТОВ; РОДИОНОВ; ГРОМОВ', 'ПЕТРОВ; ИВАНОВ; РАСКИН; МАРТЫНОВ; ПРАВДИН; ИГНАТОВ; РОДИОНОВ; ГРОМОВ']","language = input() 

count_list = []
for key, value in interpreter.items():
    for k, v in value.items():
        if language not in v
            count_list.append(k.split()[0].upper())
    
print(*count_list, sep='; ')","interpreter = {
    'Профперевод': {'Петров Александр': [""английский"", ""немецкий"", ""китайский""], 'Иванов Кирилл': [""китайский"", ""шведский""]},
    'Экспресс_перевод': {'Раскин Николай': [""иврит"", ""казахский"", ""португальский"" ], 'Мартынов Аркадий': [""шведский"", ""испанский"", ""английский""], 'Правдин Петр': [""английский""]},
    'Альфапер': {'Игнатов Максим': [""немецкий"", ""английский"", ""хинди""], 'Родионов Олег': [""шведский"", ""испанский""]},
    'Переводы24': {'Громов Игорь': [""немецкий"", ""португальский""]}
}

language = input() 

count_list = []
for key, value in interpreter.items():
    for k, v in value.items():
        if language not in v:
            count_list.append(k.split()[0].upper())
    
print(*count_list, sep='; ')",Вы забыли поставить двоеточие после условия if.,"['open', 'open', 'closed', 'closed', 'closed', 'closed']","<Task description>: Реализуйте программу, определяющую переводчиков, которые знают определенные языки:

Дан словарь interpreter, где ключи — это названия компаний, в которых работают переводчики, а значения — словари (где ключи — фамилии и имена переводчиков, разделенные пробелом, а значения — списки с языками, которые они знают). Этот код уже написан.
В переменную language считывается язык (строка). Этот код уже написан.
Определите, какие переводчики не знают введенный язык и напечатайте их фамилии в верхнем регистре через точку с запятой и пробел. Фамилии должны идти в том же порядке, что и в словаре.
Если язык никто не знает, то программа ничего не печатает. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: английский 
<Вывод>: ИВАНОВ; РАСКИН; РОДИОНОВ; ГРОМОВ 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: албанский 
<Вывод>: ПЕТРОВ; ИВАНОВ; РАСКИН; МАРТЫНОВ; ПРАВДИН; ИГНАТОВ; РОДИОНОВ; ГРОМОВ 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: иврит 
<Вывод>: ПЕТРОВ; ИВАНОВ; МАРТЫНОВ; ПРАВДИН; ИГНАТОВ; РОДИОНОВ; ГРОМОВ 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: немецкий 
<Вывод>: ИВАНОВ; РАСКИН; МАРТЫНОВ; ПРАВДИН; РОДИОНОВ 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: китайский 
<Вывод>: РАСКИН; МАРТЫНОВ; ПРАВДИН; ИГНАТОВ; РОДИОНОВ; ГРОМОВ 
<Example 6>: 
<Тип теста 6>: closed 
<Ввод>: арабский 
<Вывод>: ПЕТРОВ; ИВАНОВ; РАСКИН; МАРТЫНОВ; ПРАВДИН; ИГНАТОВ; РОДИОНОВ; ГРОМОВ 
<Решение студента>: language = input() 

count_list = []
for key, value in interpreter.items():
    for k, v in value.items():
        if language not in v
            count_list.append(k.split()[0].upper())
    
print(*count_list, sep='; ') 
<Идеальное решение>: interpreter = {
    'Профперевод': {'Петров Александр': [""английский"", ""немецкий"", ""китайский""], 'Иванов Кирилл': [""китайский"", ""шведский""]},
    'Экспресс_перевод': {'Раскин Николай': [""иврит"", ""казахский"", ""португальский"" ], 'Мартынов Аркадий': [""шведский"", ""испанский"", ""английский""], 'Правдин Петр': [""английский""]},
    'Альфапер': {'Игнатов Максим': [""немецкий"", ""английский"", ""хинди""], 'Родионов Олег': [""шведский"", ""испанский""]},
    'Переводы24': {'Громов Игорь': [""немецкий"", ""португальский""]}
}

language = input() 

count_list = []
for key, value in interpreter.items():
    for k, v in value.items():
        if language not in v:
            count_list.append(k.split()[0].upper())
    
print(*count_list, sep='; ') 


<Комментарий эксперта>:"
201,466,29,"Реализуйте программу, определяющую переводчиков, которые знают определенные языки:

Дан словарь interpreter, где ключи — это названия компаний, в которых работают переводчики, а значения — словари (где ключи — фамилии и имена переводчиков, разделенные пробелом, а значения — списки с языками, которые они знают). Этот код уже написан.
В переменную language считывается язык (строка). Этот код уже написан.
Определите, какие переводчики не знают введенный язык и напечатайте их фамилии в верхнем регистре через точку с запятой и пробел. Фамилии должны идти в том же порядке, что и в словаре.
Если язык никто не знает, то программа ничего не печатает.","['английский', 'албанский', 'иврит', 'немецкий', 'китайский', 'арабский']","['ИВАНОВ; РАСКИН; РОДИОНОВ; ГРОМОВ', 'ПЕТРОВ; ИВАНОВ; РАСКИН; МАРТЫНОВ; ПРАВДИН; ИГНАТОВ; РОДИОНОВ; ГРОМОВ', 'ПЕТРОВ; ИВАНОВ; МАРТЫНОВ; ПРАВДИН; ИГНАТОВ; РОДИОНОВ; ГРОМОВ', 'ИВАНОВ; РАСКИН; МАРТЫНОВ; ПРАВДИН; РОДИОНОВ', 'РАСКИН; МАРТЫНОВ; ПРАВДИН; ИГНАТОВ; РОДИОНОВ; ГРОМОВ', 'ПЕТРОВ; ИВАНОВ; РАСКИН; МАРТЫНОВ; ПРАВДИН; ИГНАТОВ; РОДИОНОВ; ГРОМОВ']","language = input() 

count_list = []
for key, value in interpreter.items():
    for k, v in value.items():
        if language not in v:
            count_list.add(k.split()[0].upper())
    
print(*count_list, sep='; ')","interpreter = {
    'Профперевод': {'Петров Александр': [""английский"", ""немецкий"", ""китайский""], 'Иванов Кирилл': [""китайский"", ""шведский""]},
    'Экспресс_перевод': {'Раскин Николай': [""иврит"", ""казахский"", ""португальский"" ], 'Мартынов Аркадий': [""шведский"", ""испанский"", ""английский""], 'Правдин Петр': [""английский""]},
    'Альфапер': {'Игнатов Максим': [""немецкий"", ""английский"", ""хинди""], 'Родионов Олег': [""шведский"", ""испанский""]},
    'Переводы24': {'Громов Игорь': [""немецкий"", ""португальский""]}
}

language = input() 

count_list = []
for key, value in interpreter.items():
    for k, v in value.items():
        if language not in v:
            count_list.append(k.split()[0].upper())
    
print(*count_list, sep='; ')",Некорректно задана переменная. Список не имеет метода .add().,"['open', 'open', 'closed', 'closed', 'closed', 'closed']","<Task description>: Реализуйте программу, определяющую переводчиков, которые знают определенные языки:

Дан словарь interpreter, где ключи — это названия компаний, в которых работают переводчики, а значения — словари (где ключи — фамилии и имена переводчиков, разделенные пробелом, а значения — списки с языками, которые они знают). Этот код уже написан.
В переменную language считывается язык (строка). Этот код уже написан.
Определите, какие переводчики не знают введенный язык и напечатайте их фамилии в верхнем регистре через точку с запятой и пробел. Фамилии должны идти в том же порядке, что и в словаре.
Если язык никто не знает, то программа ничего не печатает. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: английский 
<Вывод>: ИВАНОВ; РАСКИН; РОДИОНОВ; ГРОМОВ 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: албанский 
<Вывод>: ПЕТРОВ; ИВАНОВ; РАСКИН; МАРТЫНОВ; ПРАВДИН; ИГНАТОВ; РОДИОНОВ; ГРОМОВ 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: иврит 
<Вывод>: ПЕТРОВ; ИВАНОВ; МАРТЫНОВ; ПРАВДИН; ИГНАТОВ; РОДИОНОВ; ГРОМОВ 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: немецкий 
<Вывод>: ИВАНОВ; РАСКИН; МАРТЫНОВ; ПРАВДИН; РОДИОНОВ 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: китайский 
<Вывод>: РАСКИН; МАРТЫНОВ; ПРАВДИН; ИГНАТОВ; РОДИОНОВ; ГРОМОВ 
<Example 6>: 
<Тип теста 6>: closed 
<Ввод>: арабский 
<Вывод>: ПЕТРОВ; ИВАНОВ; РАСКИН; МАРТЫНОВ; ПРАВДИН; ИГНАТОВ; РОДИОНОВ; ГРОМОВ 
<Решение студента>: language = input() 

count_list = []
for key, value in interpreter.items():
    for k, v in value.items():
        if language not in v:
            count_list.add(k.split()[0].upper())
    
print(*count_list, sep='; ') 
<Идеальное решение>: interpreter = {
    'Профперевод': {'Петров Александр': [""английский"", ""немецкий"", ""китайский""], 'Иванов Кирилл': [""китайский"", ""шведский""]},
    'Экспресс_перевод': {'Раскин Николай': [""иврит"", ""казахский"", ""португальский"" ], 'Мартынов Аркадий': [""шведский"", ""испанский"", ""английский""], 'Правдин Петр': [""английский""]},
    'Альфапер': {'Игнатов Максим': [""немецкий"", ""английский"", ""хинди""], 'Родионов Олег': [""шведский"", ""испанский""]},
    'Переводы24': {'Громов Игорь': [""немецкий"", ""португальский""]}
}

language = input() 

count_list = []
for key, value in interpreter.items():
    for k, v in value.items():
        if language not in v:
            count_list.append(k.split()[0].upper())
    
print(*count_list, sep='; ') 


<Комментарий эксперта>:"
202,467,29,"Реализуйте программу, определяющую переводчиков, которые знают определенные языки:

Дан словарь interpreter, где ключи — это названия компаний, в которых работают переводчики, а значения — словари (где ключи — фамилии и имена переводчиков, разделенные пробелом, а значения — списки с языками, которые они знают). Этот код уже написан.
В переменную language считывается язык (строка). Этот код уже написан.
Определите, какие переводчики не знают введенный язык и напечатайте их фамилии в верхнем регистре через точку с запятой и пробел. Фамилии должны идти в том же порядке, что и в словаре.
Если язык никто не знает, то программа ничего не печатает.","['английский', 'албанский', 'иврит', 'немецкий', 'китайский', 'арабский']","['ИВАНОВ; РАСКИН; РОДИОНОВ; ГРОМОВ', 'ПЕТРОВ; ИВАНОВ; РАСКИН; МАРТЫНОВ; ПРАВДИН; ИГНАТОВ; РОДИОНОВ; ГРОМОВ', 'ПЕТРОВ; ИВАНОВ; МАРТЫНОВ; ПРАВДИН; ИГНАТОВ; РОДИОНОВ; ГРОМОВ', 'ИВАНОВ; РАСКИН; МАРТЫНОВ; ПРАВДИН; РОДИОНОВ', 'РАСКИН; МАРТЫНОВ; ПРАВДИН; ИГНАТОВ; РОДИОНОВ; ГРОМОВ', 'ПЕТРОВ; ИВАНОВ; РАСКИН; МАРТЫНОВ; ПРАВДИН; ИГНАТОВ; РОДИОНОВ; ГРОМОВ']","language = input() 

count_list = []
for key, value in interpreter.items():
    for k, v in value.items():
        if language not in v:
            count_list.append(k)
    
print(*count_list, sep='; ')","interpreter = {
    'Профперевод': {'Петров Александр': [""английский"", ""немецкий"", ""китайский""], 'Иванов Кирилл': [""китайский"", ""шведский""]},
    'Экспресс_перевод': {'Раскин Николай': [""иврит"", ""казахский"", ""португальский"" ], 'Мартынов Аркадий': [""шведский"", ""испанский"", ""английский""], 'Правдин Петр': [""английский""]},
    'Альфапер': {'Игнатов Максим': [""немецкий"", ""английский"", ""хинди""], 'Родионов Олег': [""шведский"", ""испанский""]},
    'Переводы24': {'Громов Игорь': [""немецкий"", ""португальский""]}
}

language = input() 

count_list = []
for key, value in interpreter.items():
    for k, v in value.items():
        if language not in v:
            count_list.append(k.split()[0].upper())
    
print(*count_list, sep='; ')","Ошибка в открытых и скрытых тестах. 

Ваш код некорректно выполняет условия задания. Например, он не выполняет условия ""напечатайте их фамилии"". Попробуйте изменить условие if, чтобы скорректировать ошибку.","['open', 'open', 'closed', 'closed', 'closed', 'closed']","<Task description>: Реализуйте программу, определяющую переводчиков, которые знают определенные языки:

Дан словарь interpreter, где ключи — это названия компаний, в которых работают переводчики, а значения — словари (где ключи — фамилии и имена переводчиков, разделенные пробелом, а значения — списки с языками, которые они знают). Этот код уже написан.
В переменную language считывается язык (строка). Этот код уже написан.
Определите, какие переводчики не знают введенный язык и напечатайте их фамилии в верхнем регистре через точку с запятой и пробел. Фамилии должны идти в том же порядке, что и в словаре.
Если язык никто не знает, то программа ничего не печатает. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: английский 
<Вывод>: ИВАНОВ; РАСКИН; РОДИОНОВ; ГРОМОВ 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: албанский 
<Вывод>: ПЕТРОВ; ИВАНОВ; РАСКИН; МАРТЫНОВ; ПРАВДИН; ИГНАТОВ; РОДИОНОВ; ГРОМОВ 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: иврит 
<Вывод>: ПЕТРОВ; ИВАНОВ; МАРТЫНОВ; ПРАВДИН; ИГНАТОВ; РОДИОНОВ; ГРОМОВ 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: немецкий 
<Вывод>: ИВАНОВ; РАСКИН; МАРТЫНОВ; ПРАВДИН; РОДИОНОВ 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: китайский 
<Вывод>: РАСКИН; МАРТЫНОВ; ПРАВДИН; ИГНАТОВ; РОДИОНОВ; ГРОМОВ 
<Example 6>: 
<Тип теста 6>: closed 
<Ввод>: арабский 
<Вывод>: ПЕТРОВ; ИВАНОВ; РАСКИН; МАРТЫНОВ; ПРАВДИН; ИГНАТОВ; РОДИОНОВ; ГРОМОВ 
<Решение студента>: language = input() 

count_list = []
for key, value in interpreter.items():
    for k, v in value.items():
        if language not in v:
            count_list.append(k)
    
print(*count_list, sep='; ') 
<Идеальное решение>: interpreter = {
    'Профперевод': {'Петров Александр': [""английский"", ""немецкий"", ""китайский""], 'Иванов Кирилл': [""китайский"", ""шведский""]},
    'Экспресс_перевод': {'Раскин Николай': [""иврит"", ""казахский"", ""португальский"" ], 'Мартынов Аркадий': [""шведский"", ""испанский"", ""английский""], 'Правдин Петр': [""английский""]},
    'Альфапер': {'Игнатов Максим': [""немецкий"", ""английский"", ""хинди""], 'Родионов Олег': [""шведский"", ""испанский""]},
    'Переводы24': {'Громов Игорь': [""немецкий"", ""португальский""]}
}

language = input() 

count_list = []
for key, value in interpreter.items():
    for k, v in value.items():
        if language not in v:
            count_list.append(k.split()[0].upper())
    
print(*count_list, sep='; ') 


<Комментарий эксперта>:"
203,468,29,"Реализуйте программу, определяющую переводчиков, которые знают определенные языки:

Дан словарь interpreter, где ключи — это названия компаний, в которых работают переводчики, а значения — словари (где ключи — фамилии и имена переводчиков, разделенные пробелом, а значения — списки с языками, которые они знают). Этот код уже написан.
В переменную language считывается язык (строка). Этот код уже написан.
Определите, какие переводчики не знают введенный язык и напечатайте их фамилии в верхнем регистре через точку с запятой и пробел. Фамилии должны идти в том же порядке, что и в словаре.
Если язык никто не знает, то программа ничего не печатает.","['английский', 'албанский', 'иврит', 'немецкий', 'китайский', 'арабский']","['ИВАНОВ; РАСКИН; РОДИОНОВ; ГРОМОВ', 'ПЕТРОВ; ИВАНОВ; РАСКИН; МАРТЫНОВ; ПРАВДИН; ИГНАТОВ; РОДИОНОВ; ГРОМОВ', 'ПЕТРОВ; ИВАНОВ; МАРТЫНОВ; ПРАВДИН; ИГНАТОВ; РОДИОНОВ; ГРОМОВ', 'ИВАНОВ; РАСКИН; МАРТЫНОВ; ПРАВДИН; РОДИОНОВ', 'РАСКИН; МАРТЫНОВ; ПРАВДИН; ИГНАТОВ; РОДИОНОВ; ГРОМОВ', 'ПЕТРОВ; ИВАНОВ; РАСКИН; МАРТЫНОВ; ПРАВДИН; ИГНАТОВ; РОДИОНОВ; ГРОМОВ']","language = input() 

count_list = []
for key, value in interpreter.items():
    for k, v in value.items():
        if language not in v:
            count_list.append(k.split()[1].upper())
    
print(*count_list, sep='; ')","interpreter = {
    'Профперевод': {'Петров Александр': [""английский"", ""немецкий"", ""китайский""], 'Иванов Кирилл': [""китайский"", ""шведский""]},
    'Экспресс_перевод': {'Раскин Николай': [""иврит"", ""казахский"", ""португальский"" ], 'Мартынов Аркадий': [""шведский"", ""испанский"", ""английский""], 'Правдин Петр': [""английский""]},
    'Альфапер': {'Игнатов Максим': [""немецкий"", ""английский"", ""хинди""], 'Родионов Олег': [""шведский"", ""испанский""]},
    'Переводы24': {'Громов Игорь': [""немецкий"", ""португальский""]}
}

language = input() 

count_list = []
for key, value in interpreter.items():
    for k, v in value.items():
        if language not in v:
            count_list.append(k.split()[0].upper())
    
print(*count_list, sep='; ')","Ошибка в открытых и скрытых тестах. 

Ваш код некорректно выполняет условия задания. Например, он не выполняет условия ""напечатайте их фамилии"". Попробуйте изменить условие if, чтобы скорректировать ошибку.","['open', 'open', 'closed', 'closed', 'closed', 'closed']","<Task description>: Реализуйте программу, определяющую переводчиков, которые знают определенные языки:

Дан словарь interpreter, где ключи — это названия компаний, в которых работают переводчики, а значения — словари (где ключи — фамилии и имена переводчиков, разделенные пробелом, а значения — списки с языками, которые они знают). Этот код уже написан.
В переменную language считывается язык (строка). Этот код уже написан.
Определите, какие переводчики не знают введенный язык и напечатайте их фамилии в верхнем регистре через точку с запятой и пробел. Фамилии должны идти в том же порядке, что и в словаре.
Если язык никто не знает, то программа ничего не печатает. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: английский 
<Вывод>: ИВАНОВ; РАСКИН; РОДИОНОВ; ГРОМОВ 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: албанский 
<Вывод>: ПЕТРОВ; ИВАНОВ; РАСКИН; МАРТЫНОВ; ПРАВДИН; ИГНАТОВ; РОДИОНОВ; ГРОМОВ 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: иврит 
<Вывод>: ПЕТРОВ; ИВАНОВ; МАРТЫНОВ; ПРАВДИН; ИГНАТОВ; РОДИОНОВ; ГРОМОВ 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: немецкий 
<Вывод>: ИВАНОВ; РАСКИН; МАРТЫНОВ; ПРАВДИН; РОДИОНОВ 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: китайский 
<Вывод>: РАСКИН; МАРТЫНОВ; ПРАВДИН; ИГНАТОВ; РОДИОНОВ; ГРОМОВ 
<Example 6>: 
<Тип теста 6>: closed 
<Ввод>: арабский 
<Вывод>: ПЕТРОВ; ИВАНОВ; РАСКИН; МАРТЫНОВ; ПРАВДИН; ИГНАТОВ; РОДИОНОВ; ГРОМОВ 
<Решение студента>: language = input() 

count_list = []
for key, value in interpreter.items():
    for k, v in value.items():
        if language not in v:
            count_list.append(k.split()[1].upper())
    
print(*count_list, sep='; ') 
<Идеальное решение>: interpreter = {
    'Профперевод': {'Петров Александр': [""английский"", ""немецкий"", ""китайский""], 'Иванов Кирилл': [""китайский"", ""шведский""]},
    'Экспресс_перевод': {'Раскин Николай': [""иврит"", ""казахский"", ""португальский"" ], 'Мартынов Аркадий': [""шведский"", ""испанский"", ""английский""], 'Правдин Петр': [""английский""]},
    'Альфапер': {'Игнатов Максим': [""немецкий"", ""английский"", ""хинди""], 'Родионов Олег': [""шведский"", ""испанский""]},
    'Переводы24': {'Громов Игорь': [""немецкий"", ""португальский""]}
}

language = input() 

count_list = []
for key, value in interpreter.items():
    for k, v in value.items():
        if language not in v:
            count_list.append(k.split()[0].upper())
    
print(*count_list, sep='; ') 


<Комментарий эксперта>:"
204,469,29,"Реализуйте программу, определяющую переводчиков, которые знают определенные языки:

Дан словарь interpreter, где ключи — это названия компаний, в которых работают переводчики, а значения — словари (где ключи — фамилии и имена переводчиков, разделенные пробелом, а значения — списки с языками, которые они знают). Этот код уже написан.
В переменную language считывается язык (строка). Этот код уже написан.
Определите, какие переводчики не знают введенный язык и напечатайте их фамилии в верхнем регистре через точку с запятой и пробел. Фамилии должны идти в том же порядке, что и в словаре.
Если язык никто не знает, то программа ничего не печатает.","['английский', 'албанский', 'иврит', 'немецкий', 'китайский', 'арабский']","['ИВАНОВ; РАСКИН; РОДИОНОВ; ГРОМОВ', 'ПЕТРОВ; ИВАНОВ; РАСКИН; МАРТЫНОВ; ПРАВДИН; ИГНАТОВ; РОДИОНОВ; ГРОМОВ', 'ПЕТРОВ; ИВАНОВ; МАРТЫНОВ; ПРАВДИН; ИГНАТОВ; РОДИОНОВ; ГРОМОВ', 'ИВАНОВ; РАСКИН; МАРТЫНОВ; ПРАВДИН; РОДИОНОВ', 'РАСКИН; МАРТЫНОВ; ПРАВДИН; ИГНАТОВ; РОДИОНОВ; ГРОМОВ', 'ПЕТРОВ; ИВАНОВ; РАСКИН; МАРТЫНОВ; ПРАВДИН; ИГНАТОВ; РОДИОНОВ; ГРОМОВ']","language = input() 

count_list = []
for key, value in interpreter.items():
    for k, v in value.items():
        if language not in v:
            count_list.append(k.split()[0])
    
print(*count_list, sep='; ')","interpreter = {
    'Профперевод': {'Петров Александр': [""английский"", ""немецкий"", ""китайский""], 'Иванов Кирилл': [""китайский"", ""шведский""]},
    'Экспресс_перевод': {'Раскин Николай': [""иврит"", ""казахский"", ""португальский"" ], 'Мартынов Аркадий': [""шведский"", ""испанский"", ""английский""], 'Правдин Петр': [""английский""]},
    'Альфапер': {'Игнатов Максим': [""немецкий"", ""английский"", ""хинди""], 'Родионов Олег': [""шведский"", ""испанский""]},
    'Переводы24': {'Громов Игорь': [""немецкий"", ""португальский""]}
}

language = input() 

count_list = []
for key, value in interpreter.items():
    for k, v in value.items():
        if language not in v:
            count_list.append(k.split()[0].upper())
    
print(*count_list, sep='; ')","Ошибка в открытых и скрытых тестах. 

Ваш код некорректно выполняет условия задания. Например, он не выполняет условия ""напечатайте их фамилии в верхнем регистре"". Попробуйте изменить условие if, чтобы скорректировать ошибку.","['open', 'open', 'closed', 'closed', 'closed', 'closed']","<Task description>: Реализуйте программу, определяющую переводчиков, которые знают определенные языки:

Дан словарь interpreter, где ключи — это названия компаний, в которых работают переводчики, а значения — словари (где ключи — фамилии и имена переводчиков, разделенные пробелом, а значения — списки с языками, которые они знают). Этот код уже написан.
В переменную language считывается язык (строка). Этот код уже написан.
Определите, какие переводчики не знают введенный язык и напечатайте их фамилии в верхнем регистре через точку с запятой и пробел. Фамилии должны идти в том же порядке, что и в словаре.
Если язык никто не знает, то программа ничего не печатает. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: английский 
<Вывод>: ИВАНОВ; РАСКИН; РОДИОНОВ; ГРОМОВ 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: албанский 
<Вывод>: ПЕТРОВ; ИВАНОВ; РАСКИН; МАРТЫНОВ; ПРАВДИН; ИГНАТОВ; РОДИОНОВ; ГРОМОВ 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: иврит 
<Вывод>: ПЕТРОВ; ИВАНОВ; МАРТЫНОВ; ПРАВДИН; ИГНАТОВ; РОДИОНОВ; ГРОМОВ 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: немецкий 
<Вывод>: ИВАНОВ; РАСКИН; МАРТЫНОВ; ПРАВДИН; РОДИОНОВ 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: китайский 
<Вывод>: РАСКИН; МАРТЫНОВ; ПРАВДИН; ИГНАТОВ; РОДИОНОВ; ГРОМОВ 
<Example 6>: 
<Тип теста 6>: closed 
<Ввод>: арабский 
<Вывод>: ПЕТРОВ; ИВАНОВ; РАСКИН; МАРТЫНОВ; ПРАВДИН; ИГНАТОВ; РОДИОНОВ; ГРОМОВ 
<Решение студента>: language = input() 

count_list = []
for key, value in interpreter.items():
    for k, v in value.items():
        if language not in v:
            count_list.append(k.split()[0])
    
print(*count_list, sep='; ') 
<Идеальное решение>: interpreter = {
    'Профперевод': {'Петров Александр': [""английский"", ""немецкий"", ""китайский""], 'Иванов Кирилл': [""китайский"", ""шведский""]},
    'Экспресс_перевод': {'Раскин Николай': [""иврит"", ""казахский"", ""португальский"" ], 'Мартынов Аркадий': [""шведский"", ""испанский"", ""английский""], 'Правдин Петр': [""английский""]},
    'Альфапер': {'Игнатов Максим': [""немецкий"", ""английский"", ""хинди""], 'Родионов Олег': [""шведский"", ""испанский""]},
    'Переводы24': {'Громов Игорь': [""немецкий"", ""португальский""]}
}

language = input() 

count_list = []
for key, value in interpreter.items():
    for k, v in value.items():
        if language not in v:
            count_list.append(k.split()[0].upper())
    
print(*count_list, sep='; ') 


<Комментарий эксперта>:"
205,470,29,"Реализуйте программу, определяющую переводчиков, которые знают определенные языки:

Дан словарь interpreter, где ключи — это названия компаний, в которых работают переводчики, а значения — словари (где ключи — фамилии и имена переводчиков, разделенные пробелом, а значения — списки с языками, которые они знают). Этот код уже написан.
В переменную language считывается язык (строка). Этот код уже написан.
Определите, какие переводчики не знают введенный язык и напечатайте их фамилии в верхнем регистре через точку с запятой и пробел. Фамилии должны идти в том же порядке, что и в словаре.
Если язык никто не знает, то программа ничего не печатает.","['английский', 'албанский', 'иврит', 'немецкий', 'китайский', 'арабский']","['ИВАНОВ; РАСКИН; РОДИОНОВ; ГРОМОВ', 'ПЕТРОВ; ИВАНОВ; РАСКИН; МАРТЫНОВ; ПРАВДИН; ИГНАТОВ; РОДИОНОВ; ГРОМОВ', 'ПЕТРОВ; ИВАНОВ; МАРТЫНОВ; ПРАВДИН; ИГНАТОВ; РОДИОНОВ; ГРОМОВ', 'ИВАНОВ; РАСКИН; МАРТЫНОВ; ПРАВДИН; РОДИОНОВ', 'РАСКИН; МАРТЫНОВ; ПРАВДИН; ИГНАТОВ; РОДИОНОВ; ГРОМОВ', 'ПЕТРОВ; ИВАНОВ; РАСКИН; МАРТЫНОВ; ПРАВДИН; ИГНАТОВ; РОДИОНОВ; ГРОМОВ']","language = input() 

count_list = []
for key, value in interpreter.items():
    for k, v in value.items():
        if language not in v:
            count_list.append(k.split()[0].upper())
    
print(count_list)","interpreter = {
    'Профперевод': {'Петров Александр': [""английский"", ""немецкий"", ""китайский""], 'Иванов Кирилл': [""китайский"", ""шведский""]},
    'Экспресс_перевод': {'Раскин Николай': [""иврит"", ""казахский"", ""португальский"" ], 'Мартынов Аркадий': [""шведский"", ""испанский"", ""английский""], 'Правдин Петр': [""английский""]},
    'Альфапер': {'Игнатов Максим': [""немецкий"", ""английский"", ""хинди""], 'Родионов Олег': [""шведский"", ""испанский""]},
    'Переводы24': {'Громов Игорь': [""немецкий"", ""португальский""]}
}

language = input() 

count_list = []
for key, value in interpreter.items():
    for k, v in value.items():
        if language not in v:
            count_list.append(k.split()[0].upper())
    
print(*count_list, sep='; ')","Ошибка в открытых и скрытых тестах. 

Ваш код некорректно выполняет условия задания. Так, он некорректно выполянет условия ""напечатайте их фамилии в верхнем регистре через точку с запятой и пробел"". Попробуйте изменить условие print() для исправления ошибки.","['open', 'open', 'closed', 'closed', 'closed', 'closed']","<Task description>: Реализуйте программу, определяющую переводчиков, которые знают определенные языки:

Дан словарь interpreter, где ключи — это названия компаний, в которых работают переводчики, а значения — словари (где ключи — фамилии и имена переводчиков, разделенные пробелом, а значения — списки с языками, которые они знают). Этот код уже написан.
В переменную language считывается язык (строка). Этот код уже написан.
Определите, какие переводчики не знают введенный язык и напечатайте их фамилии в верхнем регистре через точку с запятой и пробел. Фамилии должны идти в том же порядке, что и в словаре.
Если язык никто не знает, то программа ничего не печатает. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: английский 
<Вывод>: ИВАНОВ; РАСКИН; РОДИОНОВ; ГРОМОВ 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: албанский 
<Вывод>: ПЕТРОВ; ИВАНОВ; РАСКИН; МАРТЫНОВ; ПРАВДИН; ИГНАТОВ; РОДИОНОВ; ГРОМОВ 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: иврит 
<Вывод>: ПЕТРОВ; ИВАНОВ; МАРТЫНОВ; ПРАВДИН; ИГНАТОВ; РОДИОНОВ; ГРОМОВ 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: немецкий 
<Вывод>: ИВАНОВ; РАСКИН; МАРТЫНОВ; ПРАВДИН; РОДИОНОВ 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: китайский 
<Вывод>: РАСКИН; МАРТЫНОВ; ПРАВДИН; ИГНАТОВ; РОДИОНОВ; ГРОМОВ 
<Example 6>: 
<Тип теста 6>: closed 
<Ввод>: арабский 
<Вывод>: ПЕТРОВ; ИВАНОВ; РАСКИН; МАРТЫНОВ; ПРАВДИН; ИГНАТОВ; РОДИОНОВ; ГРОМОВ 
<Решение студента>: language = input() 

count_list = []
for key, value in interpreter.items():
    for k, v in value.items():
        if language not in v:
            count_list.append(k.split()[0].upper())
    
print(count_list) 
<Идеальное решение>: interpreter = {
    'Профперевод': {'Петров Александр': [""английский"", ""немецкий"", ""китайский""], 'Иванов Кирилл': [""китайский"", ""шведский""]},
    'Экспресс_перевод': {'Раскин Николай': [""иврит"", ""казахский"", ""португальский"" ], 'Мартынов Аркадий': [""шведский"", ""испанский"", ""английский""], 'Правдин Петр': [""английский""]},
    'Альфапер': {'Игнатов Максим': [""немецкий"", ""английский"", ""хинди""], 'Родионов Олег': [""шведский"", ""испанский""]},
    'Переводы24': {'Громов Игорь': [""немецкий"", ""португальский""]}
}

language = input() 

count_list = []
for key, value in interpreter.items():
    for k, v in value.items():
        if language not in v:
            count_list.append(k.split()[0].upper())
    
print(*count_list, sep='; ') 


<Комментарий эксперта>:"
206,471,29,"Реализуйте программу, определяющую переводчиков, которые знают определенные языки:

Дан словарь interpreter, где ключи — это названия компаний, в которых работают переводчики, а значения — словари (где ключи — фамилии и имена переводчиков, разделенные пробелом, а значения — списки с языками, которые они знают). Этот код уже написан.
В переменную language считывается язык (строка). Этот код уже написан.
Определите, какие переводчики не знают введенный язык и напечатайте их фамилии в верхнем регистре через точку с запятой и пробел. Фамилии должны идти в том же порядке, что и в словаре.
Если язык никто не знает, то программа ничего не печатает.","['английский', 'албанский', 'иврит', 'немецкий', 'китайский', 'арабский']","['ИВАНОВ; РАСКИН; РОДИОНОВ; ГРОМОВ', 'ПЕТРОВ; ИВАНОВ; РАСКИН; МАРТЫНОВ; ПРАВДИН; ИГНАТОВ; РОДИОНОВ; ГРОМОВ', 'ПЕТРОВ; ИВАНОВ; МАРТЫНОВ; ПРАВДИН; ИГНАТОВ; РОДИОНОВ; ГРОМОВ', 'ИВАНОВ; РАСКИН; МАРТЫНОВ; ПРАВДИН; РОДИОНОВ', 'РАСКИН; МАРТЫНОВ; ПРАВДИН; ИГНАТОВ; РОДИОНОВ; ГРОМОВ', 'ПЕТРОВ; ИВАНОВ; РАСКИН; МАРТЫНОВ; ПРАВДИН; ИГНАТОВ; РОДИОНОВ; ГРОМОВ']","language = input() 

count_list = []
for key, value in interpreter.items():
    for k, v in value.items():
        if language not in v:
            count_list.append(k.split()[0].upper())
    
print(*count_list)","interpreter = {
    'Профперевод': {'Петров Александр': [""английский"", ""немецкий"", ""китайский""], 'Иванов Кирилл': [""китайский"", ""шведский""]},
    'Экспресс_перевод': {'Раскин Николай': [""иврит"", ""казахский"", ""португальский"" ], 'Мартынов Аркадий': [""шведский"", ""испанский"", ""английский""], 'Правдин Петр': [""английский""]},
    'Альфапер': {'Игнатов Максим': [""немецкий"", ""английский"", ""хинди""], 'Родионов Олег': [""шведский"", ""испанский""]},
    'Переводы24': {'Громов Игорь': [""немецкий"", ""португальский""]}
}

language = input() 

count_list = []
for key, value in interpreter.items():
    for k, v in value.items():
        if language not in v:
            count_list.append(k.split()[0].upper())
    
print(*count_list, sep='; ')","Ошибка в открытых и скрытых тестах. 

Ваш код некорректно выполняет условия задания. Так, он некорректно выполянет условия ""напечатайте их фамилии в верхнем регистре через точку с запятой и пробел"". Попробуйте изменить условие print() для исправления ошибки.","['open', 'open', 'closed', 'closed', 'closed', 'closed']","<Task description>: Реализуйте программу, определяющую переводчиков, которые знают определенные языки:

Дан словарь interpreter, где ключи — это названия компаний, в которых работают переводчики, а значения — словари (где ключи — фамилии и имена переводчиков, разделенные пробелом, а значения — списки с языками, которые они знают). Этот код уже написан.
В переменную language считывается язык (строка). Этот код уже написан.
Определите, какие переводчики не знают введенный язык и напечатайте их фамилии в верхнем регистре через точку с запятой и пробел. Фамилии должны идти в том же порядке, что и в словаре.
Если язык никто не знает, то программа ничего не печатает. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: английский 
<Вывод>: ИВАНОВ; РАСКИН; РОДИОНОВ; ГРОМОВ 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: албанский 
<Вывод>: ПЕТРОВ; ИВАНОВ; РАСКИН; МАРТЫНОВ; ПРАВДИН; ИГНАТОВ; РОДИОНОВ; ГРОМОВ 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: иврит 
<Вывод>: ПЕТРОВ; ИВАНОВ; МАРТЫНОВ; ПРАВДИН; ИГНАТОВ; РОДИОНОВ; ГРОМОВ 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: немецкий 
<Вывод>: ИВАНОВ; РАСКИН; МАРТЫНОВ; ПРАВДИН; РОДИОНОВ 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: китайский 
<Вывод>: РАСКИН; МАРТЫНОВ; ПРАВДИН; ИГНАТОВ; РОДИОНОВ; ГРОМОВ 
<Example 6>: 
<Тип теста 6>: closed 
<Ввод>: арабский 
<Вывод>: ПЕТРОВ; ИВАНОВ; РАСКИН; МАРТЫНОВ; ПРАВДИН; ИГНАТОВ; РОДИОНОВ; ГРОМОВ 
<Решение студента>: language = input() 

count_list = []
for key, value in interpreter.items():
    for k, v in value.items():
        if language not in v:
            count_list.append(k.split()[0].upper())
    
print(*count_list) 
<Идеальное решение>: interpreter = {
    'Профперевод': {'Петров Александр': [""английский"", ""немецкий"", ""китайский""], 'Иванов Кирилл': [""китайский"", ""шведский""]},
    'Экспресс_перевод': {'Раскин Николай': [""иврит"", ""казахский"", ""португальский"" ], 'Мартынов Аркадий': [""шведский"", ""испанский"", ""английский""], 'Правдин Петр': [""английский""]},
    'Альфапер': {'Игнатов Максим': [""немецкий"", ""английский"", ""хинди""], 'Родионов Олег': [""шведский"", ""испанский""]},
    'Переводы24': {'Громов Игорь': [""немецкий"", ""португальский""]}
}

language = input() 

count_list = []
for key, value in interpreter.items():
    for k, v in value.items():
        if language not in v:
            count_list.append(k.split()[0].upper())
    
print(*count_list, sep='; ') 


<Комментарий эксперта>:"
207,472,29,"Реализуйте программу, определяющую переводчиков, которые знают определенные языки:

Дан словарь interpreter, где ключи — это названия компаний, в которых работают переводчики, а значения — словари (где ключи — фамилии и имена переводчиков, разделенные пробелом, а значения — списки с языками, которые они знают). Этот код уже написан.
В переменную language считывается язык (строка). Этот код уже написан.
Определите, какие переводчики не знают введенный язык и напечатайте их фамилии в верхнем регистре через точку с запятой и пробел. Фамилии должны идти в том же порядке, что и в словаре.
Если язык никто не знает, то программа ничего не печатает.","['английский', 'албанский', 'иврит', 'немецкий', 'китайский', 'арабский']","['ИВАНОВ; РАСКИН; РОДИОНОВ; ГРОМОВ', 'ПЕТРОВ; ИВАНОВ; РАСКИН; МАРТЫНОВ; ПРАВДИН; ИГНАТОВ; РОДИОНОВ; ГРОМОВ', 'ПЕТРОВ; ИВАНОВ; МАРТЫНОВ; ПРАВДИН; ИГНАТОВ; РОДИОНОВ; ГРОМОВ', 'ИВАНОВ; РАСКИН; МАРТЫНОВ; ПРАВДИН; РОДИОНОВ', 'РАСКИН; МАРТЫНОВ; ПРАВДИН; ИГНАТОВ; РОДИОНОВ; ГРОМОВ', 'ПЕТРОВ; ИВАНОВ; РАСКИН; МАРТЫНОВ; ПРАВДИН; ИГНАТОВ; РОДИОНОВ; ГРОМОВ']","language = input() 

count_list = []
for key, value in interpreter.items():
    for k, v in value.items():
        if language not in v:
            count_list.append(k.split()[0].upper())
    
    print(*count_list, sep='; ')","interpreter = {
    'Профперевод': {'Петров Александр': [""английский"", ""немецкий"", ""китайский""], 'Иванов Кирилл': [""китайский"", ""шведский""]},
    'Экспресс_перевод': {'Раскин Николай': [""иврит"", ""казахский"", ""португальский"" ], 'Мартынов Аркадий': [""шведский"", ""испанский"", ""английский""], 'Правдин Петр': [""английский""]},
    'Альфапер': {'Игнатов Максим': [""немецкий"", ""английский"", ""хинди""], 'Родионов Олег': [""шведский"", ""испанский""]},
    'Переводы24': {'Громов Игорь': [""немецкий"", ""португальский""]}
}

language = input() 

count_list = []
for key, value in interpreter.items():
    for k, v in value.items():
        if language not in v:
            count_list.append(k.split()[0].upper())
    
print(*count_list, sep='; ')","Ошибка в открытых и скрытых тестах. 

Ваш код некорректно выполняет условия задания. Так, он некорректно выполянет условия ""напечатайте их фамилии в верхнем регистре через точку с запятой и пробел"". Попробуйте изменить условие print() для исправления ошибки.","['open', 'open', 'closed', 'closed', 'closed', 'closed']","<Task description>: Реализуйте программу, определяющую переводчиков, которые знают определенные языки:

Дан словарь interpreter, где ключи — это названия компаний, в которых работают переводчики, а значения — словари (где ключи — фамилии и имена переводчиков, разделенные пробелом, а значения — списки с языками, которые они знают). Этот код уже написан.
В переменную language считывается язык (строка). Этот код уже написан.
Определите, какие переводчики не знают введенный язык и напечатайте их фамилии в верхнем регистре через точку с запятой и пробел. Фамилии должны идти в том же порядке, что и в словаре.
Если язык никто не знает, то программа ничего не печатает. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: английский 
<Вывод>: ИВАНОВ; РАСКИН; РОДИОНОВ; ГРОМОВ 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: албанский 
<Вывод>: ПЕТРОВ; ИВАНОВ; РАСКИН; МАРТЫНОВ; ПРАВДИН; ИГНАТОВ; РОДИОНОВ; ГРОМОВ 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: иврит 
<Вывод>: ПЕТРОВ; ИВАНОВ; МАРТЫНОВ; ПРАВДИН; ИГНАТОВ; РОДИОНОВ; ГРОМОВ 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: немецкий 
<Вывод>: ИВАНОВ; РАСКИН; МАРТЫНОВ; ПРАВДИН; РОДИОНОВ 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: китайский 
<Вывод>: РАСКИН; МАРТЫНОВ; ПРАВДИН; ИГНАТОВ; РОДИОНОВ; ГРОМОВ 
<Example 6>: 
<Тип теста 6>: closed 
<Ввод>: арабский 
<Вывод>: ПЕТРОВ; ИВАНОВ; РАСКИН; МАРТЫНОВ; ПРАВДИН; ИГНАТОВ; РОДИОНОВ; ГРОМОВ 
<Решение студента>: language = input() 

count_list = []
for key, value in interpreter.items():
    for k, v in value.items():
        if language not in v:
            count_list.append(k.split()[0].upper())
    
    print(*count_list, sep='; ') 
<Идеальное решение>: interpreter = {
    'Профперевод': {'Петров Александр': [""английский"", ""немецкий"", ""китайский""], 'Иванов Кирилл': [""китайский"", ""шведский""]},
    'Экспресс_перевод': {'Раскин Николай': [""иврит"", ""казахский"", ""португальский"" ], 'Мартынов Аркадий': [""шведский"", ""испанский"", ""английский""], 'Правдин Петр': [""английский""]},
    'Альфапер': {'Игнатов Максим': [""немецкий"", ""английский"", ""хинди""], 'Родионов Олег': [""шведский"", ""испанский""]},
    'Переводы24': {'Громов Игорь': [""немецкий"", ""португальский""]}
}

language = input() 

count_list = []
for key, value in interpreter.items():
    for k, v in value.items():
        if language not in v:
            count_list.append(k.split()[0].upper())
    
print(*count_list, sep='; ') 


<Комментарий эксперта>:"
208,473,29,"Реализуйте программу, определяющую переводчиков, которые знают определенные языки:

Дан словарь interpreter, где ключи — это названия компаний, в которых работают переводчики, а значения — словари (где ключи — фамилии и имена переводчиков, разделенные пробелом, а значения — списки с языками, которые они знают). Этот код уже написан.
В переменную language считывается язык (строка). Этот код уже написан.
Определите, какие переводчики не знают введенный язык и напечатайте их фамилии в верхнем регистре через точку с запятой и пробел. Фамилии должны идти в том же порядке, что и в словаре.
Если язык никто не знает, то программа ничего не печатает.","['английский', 'албанский', 'иврит', 'немецкий', 'китайский', 'арабский']","['ИВАНОВ; РАСКИН; РОДИОНОВ; ГРОМОВ', 'ПЕТРОВ; ИВАНОВ; РАСКИН; МАРТЫНОВ; ПРАВДИН; ИГНАТОВ; РОДИОНОВ; ГРОМОВ', 'ПЕТРОВ; ИВАНОВ; МАРТЫНОВ; ПРАВДИН; ИГНАТОВ; РОДИОНОВ; ГРОМОВ', 'ИВАНОВ; РАСКИН; МАРТЫНОВ; ПРАВДИН; РОДИОНОВ', 'РАСКИН; МАРТЫНОВ; ПРАВДИН; ИГНАТОВ; РОДИОНОВ; ГРОМОВ', 'ПЕТРОВ; ИВАНОВ; РАСКИН; МАРТЫНОВ; ПРАВДИН; ИГНАТОВ; РОДИОНОВ; ГРОМОВ']","language = input() 

count_list = []
for key, value in interpreter.items():
    for k, v in value.items():
        if language not in v:
            count_list.append(k.split()[0].upper())
    
print(*sorted(count_list), sep='; ')","interpreter = {
    'Профперевод': {'Петров Александр': [""английский"", ""немецкий"", ""китайский""], 'Иванов Кирилл': [""китайский"", ""шведский""]},
    'Экспресс_перевод': {'Раскин Николай': [""иврит"", ""казахский"", ""португальский"" ], 'Мартынов Аркадий': [""шведский"", ""испанский"", ""английский""], 'Правдин Петр': [""английский""]},
    'Альфапер': {'Игнатов Максим': [""немецкий"", ""английский"", ""хинди""], 'Родионов Олег': [""шведский"", ""испанский""]},
    'Переводы24': {'Громов Игорь': [""немецкий"", ""португальский""]}
}

language = input() 

count_list = []
for key, value in interpreter.items():
    for k, v in value.items():
        if language not in v:
            count_list.append(k.split()[0].upper())
    
print(*count_list, sep='; ')","Ошибка в открытых и скрытых тестах. 

Ваш код некорректно выполняет условия задания. Так, он некорректно выполянет условие ""фамилии должны идти в том же порядке, что и в словаре"". Попробуйте изменить условие print() для исправления ошибки.","['open', 'open', 'closed', 'closed', 'closed', 'closed']","<Task description>: Реализуйте программу, определяющую переводчиков, которые знают определенные языки:

Дан словарь interpreter, где ключи — это названия компаний, в которых работают переводчики, а значения — словари (где ключи — фамилии и имена переводчиков, разделенные пробелом, а значения — списки с языками, которые они знают). Этот код уже написан.
В переменную language считывается язык (строка). Этот код уже написан.
Определите, какие переводчики не знают введенный язык и напечатайте их фамилии в верхнем регистре через точку с запятой и пробел. Фамилии должны идти в том же порядке, что и в словаре.
Если язык никто не знает, то программа ничего не печатает. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: английский 
<Вывод>: ИВАНОВ; РАСКИН; РОДИОНОВ; ГРОМОВ 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: албанский 
<Вывод>: ПЕТРОВ; ИВАНОВ; РАСКИН; МАРТЫНОВ; ПРАВДИН; ИГНАТОВ; РОДИОНОВ; ГРОМОВ 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: иврит 
<Вывод>: ПЕТРОВ; ИВАНОВ; МАРТЫНОВ; ПРАВДИН; ИГНАТОВ; РОДИОНОВ; ГРОМОВ 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: немецкий 
<Вывод>: ИВАНОВ; РАСКИН; МАРТЫНОВ; ПРАВДИН; РОДИОНОВ 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: китайский 
<Вывод>: РАСКИН; МАРТЫНОВ; ПРАВДИН; ИГНАТОВ; РОДИОНОВ; ГРОМОВ 
<Example 6>: 
<Тип теста 6>: closed 
<Ввод>: арабский 
<Вывод>: ПЕТРОВ; ИВАНОВ; РАСКИН; МАРТЫНОВ; ПРАВДИН; ИГНАТОВ; РОДИОНОВ; ГРОМОВ 
<Решение студента>: language = input() 

count_list = []
for key, value in interpreter.items():
    for k, v in value.items():
        if language not in v:
            count_list.append(k.split()[0].upper())
    
print(*sorted(count_list), sep='; ') 
<Идеальное решение>: interpreter = {
    'Профперевод': {'Петров Александр': [""английский"", ""немецкий"", ""китайский""], 'Иванов Кирилл': [""китайский"", ""шведский""]},
    'Экспресс_перевод': {'Раскин Николай': [""иврит"", ""казахский"", ""португальский"" ], 'Мартынов Аркадий': [""шведский"", ""испанский"", ""английский""], 'Правдин Петр': [""английский""]},
    'Альфапер': {'Игнатов Максим': [""немецкий"", ""английский"", ""хинди""], 'Родионов Олег': [""шведский"", ""испанский""]},
    'Переводы24': {'Громов Игорь': [""немецкий"", ""португальский""]}
}

language = input() 

count_list = []
for key, value in interpreter.items():
    for k, v in value.items():
        if language not in v:
            count_list.append(k.split()[0].upper())
    
print(*count_list, sep='; ') 


<Комментарий эксперта>:"
209,474,30,"Витя хочет определить язык, алфавит которого состоит из минимального количества букв. Напишите функцию, которая ему в этом поможет.

Определите функцию count_letters, которая принимает на вход два аргумента:
строку, где через запятую и пробел перечислены языки;
строку, где через запятую и пробел перечислены числа, обозначающие количество букв в алфавите каждого языка;
Гарантируется, что языки и количество букв не повторяются. 
Функция должна возвращать строку — название языка, в алфавите которого минимальное количество букв. 
Важно! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке.","[""'английский, казахский, русский, испанский, польский', '26, 42, 33, 27, 29'"", ""'французский', '26'"", ""'Греческий, Русский, Иврит, Хинди', '24, 33, 22, 47'"", ""'лаосский, прусский, китайский', '100, 29, 87'"", ""'корейский', '676'""]","['английский', 'французский', 'Иврит', 'прусский', 'корейский']","def count_letters(langs, letters)
    sp = []
    langs = langs.split(', ')
    letters = list(map(int, letters.split(', ')))
    mn = min(letters)
    ind = letters.index(mn)
    return langs[ind]","def count_letters(langs, letters):
    sp = []
    langs = langs.split(', ')
    letters = list(map(int, letters.split(', ')))
    mn = min(letters)
    ind = letters.index(mn)
    return langs[ind]",Вы забыли поставить двоеточие после определения функции.,"['open', 'open', 'closed', 'closed', 'closed']","<Task description>: Витя хочет определить язык, алфавит которого состоит из минимального количества букв. Напишите функцию, которая ему в этом поможет.

Определите функцию count_letters, которая принимает на вход два аргумента:
строку, где через запятую и пробел перечислены языки;
строку, где через запятую и пробел перечислены числа, обозначающие количество букв в алфавите каждого языка;
Гарантируется, что языки и количество букв не повторяются. 
Функция должна возвращать строку — название языка, в алфавите которого минимальное количество букв. 
Важно! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: 'английский, казахский, русский, испанский, польский', '26, 42, 33, 27, 29' 
<Вывод>: английский 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: 'французский', '26' 
<Вывод>: французский 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: 'Греческий, Русский, Иврит, Хинди', '24, 33, 22, 47' 
<Вывод>: Иврит 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: 'лаосский, прусский, китайский', '100, 29, 87' 
<Вывод>: прусский 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: 'корейский', '676' 
<Вывод>: корейский 
<Решение студента>: def count_letters(langs, letters)
    sp = []
    langs = langs.split(', ')
    letters = list(map(int, letters.split(', ')))
    mn = min(letters)
    ind = letters.index(mn)
    return langs[ind] 
<Идеальное решение>: def count_letters(langs, letters):
    sp = []
    langs = langs.split(', ')
    letters = list(map(int, letters.split(', ')))
    mn = min(letters)
    ind = letters.index(mn)
    return langs[ind] 


<Комментарий эксперта>:"
210,475,30,"Витя хочет определить язык, алфавит которого состоит из минимального количества букв. Напишите функцию, которая ему в этом поможет.

Определите функцию count_letters, которая принимает на вход два аргумента:
строку, где через запятую и пробел перечислены языки;
строку, где через запятую и пробел перечислены числа, обозначающие количество букв в алфавите каждого языка;
Гарантируется, что языки и количество букв не повторяются. 
Функция должна возвращать строку — название языка, в алфавите которого минимальное количество букв. 
Важно! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке.","[""'английский, казахский, русский, испанский, польский', '26, 42, 33, 27, 29'"", ""'французский', '26'"", ""'Греческий, Русский, Иврит, Хинди', '24, 33, 22, 47'"", ""'лаосский, прусский, китайский', '100, 29, 87'"", ""'корейский', '676'""]","['английский', 'французский', 'Иврит', 'прусский', 'корейский']","def count_letters():
    sp = []
    langs = langs.split(', ')
    letters = list(map(int, letters.split(', ')))
    mn = min(letters)
    ind = letters.index(mn)
    return langs[ind]","def count_letters(langs, letters):
    sp = []
    langs = langs.split(', ')
    letters = list(map(int, letters.split(', ')))
    mn = min(letters)
    ind = letters.index(mn)
    return langs[ind]","Вы не добавили переменные, которые функция будет принимать как аргументы.","['open', 'open', 'closed', 'closed', 'closed']","<Task description>: Витя хочет определить язык, алфавит которого состоит из минимального количества букв. Напишите функцию, которая ему в этом поможет.

Определите функцию count_letters, которая принимает на вход два аргумента:
строку, где через запятую и пробел перечислены языки;
строку, где через запятую и пробел перечислены числа, обозначающие количество букв в алфавите каждого языка;
Гарантируется, что языки и количество букв не повторяются. 
Функция должна возвращать строку — название языка, в алфавите которого минимальное количество букв. 
Важно! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: 'английский, казахский, русский, испанский, польский', '26, 42, 33, 27, 29' 
<Вывод>: английский 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: 'французский', '26' 
<Вывод>: французский 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: 'Греческий, Русский, Иврит, Хинди', '24, 33, 22, 47' 
<Вывод>: Иврит 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: 'лаосский, прусский, китайский', '100, 29, 87' 
<Вывод>: прусский 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: 'корейский', '676' 
<Вывод>: корейский 
<Решение студента>: def count_letters():
    sp = []
    langs = langs.split(', ')
    letters = list(map(int, letters.split(', ')))
    mn = min(letters)
    ind = letters.index(mn)
    return langs[ind] 
<Идеальное решение>: def count_letters(langs, letters):
    sp = []
    langs = langs.split(', ')
    letters = list(map(int, letters.split(', ')))
    mn = min(letters)
    ind = letters.index(mn)
    return langs[ind] 


<Комментарий эксперта>:"
211,476,30,"Витя хочет определить язык, алфавит которого состоит из минимального количества букв. Напишите функцию, которая ему в этом поможет.

Определите функцию count_letters, которая принимает на вход два аргумента:
строку, где через запятую и пробел перечислены языки;
строку, где через запятую и пробел перечислены числа, обозначающие количество букв в алфавите каждого языка;
Гарантируется, что языки и количество букв не повторяются. 
Функция должна возвращать строку — название языка, в алфавите которого минимальное количество букв. 
Важно! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке.","[""'английский, казахский, русский, испанский, польский', '26, 42, 33, 27, 29'"", ""'французский', '26'"", ""'Греческий, Русский, Иврит, Хинди', '24, 33, 22, 47'"", ""'лаосский, прусский, китайский', '100, 29, 87'"", ""'корейский', '676'""]","['английский', 'французский', 'Иврит', 'прусский', 'корейский']","def count_letters(langs, letters):
    langs = langs.split(', ')
    letters = list(map(int, letters.split(', ')))
    mn = min(letters)
    ind = letters.index(mn)
    return langs[ind]","def count_letters(langs, letters):
    sp = []
    langs = langs.split(', ')
    letters = list(map(int, letters.split(', ')))
    mn = min(letters)
    ind = letters.index(mn)
    return langs[ind]","Вы использовали переменную, которая не была задана ранее. Проверьте, что все переменные, которые вы используете, были заданы.","['open', 'open', 'closed', 'closed', 'closed']","<Task description>: Витя хочет определить язык, алфавит которого состоит из минимального количества букв. Напишите функцию, которая ему в этом поможет.

Определите функцию count_letters, которая принимает на вход два аргумента:
строку, где через запятую и пробел перечислены языки;
строку, где через запятую и пробел перечислены числа, обозначающие количество букв в алфавите каждого языка;
Гарантируется, что языки и количество букв не повторяются. 
Функция должна возвращать строку — название языка, в алфавите которого минимальное количество букв. 
Важно! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: 'английский, казахский, русский, испанский, польский', '26, 42, 33, 27, 29' 
<Вывод>: английский 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: 'французский', '26' 
<Вывод>: французский 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: 'Греческий, Русский, Иврит, Хинди', '24, 33, 22, 47' 
<Вывод>: Иврит 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: 'лаосский, прусский, китайский', '100, 29, 87' 
<Вывод>: прусский 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: 'корейский', '676' 
<Вывод>: корейский 
<Решение студента>: def count_letters(langs, letters):
    langs = langs.split(', ')
    letters = list(map(int, letters.split(', ')))
    mn = min(letters)
    ind = letters.index(mn)
    return langs[ind] 
<Идеальное решение>: def count_letters(langs, letters):
    sp = []
    langs = langs.split(', ')
    letters = list(map(int, letters.split(', ')))
    mn = min(letters)
    ind = letters.index(mn)
    return langs[ind] 


<Комментарий эксперта>:"
212,477,30,"Витя хочет определить язык, алфавит которого состоит из минимального количества букв. Напишите функцию, которая ему в этом поможет.

Определите функцию count_letters, которая принимает на вход два аргумента:
строку, где через запятую и пробел перечислены языки;
строку, где через запятую и пробел перечислены числа, обозначающие количество букв в алфавите каждого языка;
Гарантируется, что языки и количество букв не повторяются. 
Функция должна возвращать строку — название языка, в алфавите которого минимальное количество букв. 
Важно! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке.","[""'английский, казахский, русский, испанский, польский', '26, 42, 33, 27, 29'"", ""'французский', '26'"", ""'Греческий, Русский, Иврит, Хинди', '24, 33, 22, 47'"", ""'лаосский, прусский, китайский', '100, 29, 87'"", ""'корейский', '676'""]","['английский', 'французский', 'Иврит', 'прусский', 'корейский']","def count_letters(langs, letters):
    sp = []
    langs = langs.split()
    letters = list(map(int, letters.split(', ')))
    mn = min(letters)
    ind = letters.index(mn)
    return langs[ind]","def count_letters(langs, letters):
    sp = []
    langs = langs.split(', ')
    letters = list(map(int, letters.split(', ')))
    mn = min(letters)
    ind = letters.index(mn)
    return langs[ind]","Ошибка в открытых и скрытых тестах. 

Ваш код использует неверный параметр в функции split().","['open', 'open', 'closed', 'closed', 'closed']","<Task description>: Витя хочет определить язык, алфавит которого состоит из минимального количества букв. Напишите функцию, которая ему в этом поможет.

Определите функцию count_letters, которая принимает на вход два аргумента:
строку, где через запятую и пробел перечислены языки;
строку, где через запятую и пробел перечислены числа, обозначающие количество букв в алфавите каждого языка;
Гарантируется, что языки и количество букв не повторяются. 
Функция должна возвращать строку — название языка, в алфавите которого минимальное количество букв. 
Важно! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: 'английский, казахский, русский, испанский, польский', '26, 42, 33, 27, 29' 
<Вывод>: английский 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: 'французский', '26' 
<Вывод>: французский 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: 'Греческий, Русский, Иврит, Хинди', '24, 33, 22, 47' 
<Вывод>: Иврит 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: 'лаосский, прусский, китайский', '100, 29, 87' 
<Вывод>: прусский 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: 'корейский', '676' 
<Вывод>: корейский 
<Решение студента>: def count_letters(langs, letters):
    sp = []
    langs = langs.split()
    letters = list(map(int, letters.split(', ')))
    mn = min(letters)
    ind = letters.index(mn)
    return langs[ind] 
<Идеальное решение>: def count_letters(langs, letters):
    sp = []
    langs = langs.split(', ')
    letters = list(map(int, letters.split(', ')))
    mn = min(letters)
    ind = letters.index(mn)
    return langs[ind] 


<Комментарий эксперта>:"
213,478,30,"Витя хочет определить язык, алфавит которого состоит из минимального количества букв. Напишите функцию, которая ему в этом поможет.

Определите функцию count_letters, которая принимает на вход два аргумента:
строку, где через запятую и пробел перечислены языки;
строку, где через запятую и пробел перечислены числа, обозначающие количество букв в алфавите каждого языка;
Гарантируется, что языки и количество букв не повторяются. 
Функция должна возвращать строку — название языка, в алфавите которого минимальное количество букв. 
Важно! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке.","[""'английский, казахский, русский, испанский, польский', '26, 42, 33, 27, 29'"", ""'французский', '26'"", ""'Греческий, Русский, Иврит, Хинди', '24, 33, 22, 47'"", ""'лаосский, прусский, китайский', '100, 29, 87'"", ""'корейский', '676'""]","['английский', 'французский', 'Иврит', 'прусский', 'корейский']","def count_letters(langs, letters):
    sp = []
    langs = langs.split(', ')
    letters = list(map(int, letters))
    mn = min(letters)
    ind = letters.index(mn)
    return langs[ind]","def count_letters(langs, letters):
    sp = []
    langs = langs.split(', ')
    letters = list(map(int, letters.split(', ')))
    mn = min(letters)
    ind = letters.index(mn)
    return langs[ind]",Ошибка при попытке применить функцию int к данным. Вы забыли разделить список letters.,"['open', 'open', 'closed', 'closed', 'closed']","<Task description>: Витя хочет определить язык, алфавит которого состоит из минимального количества букв. Напишите функцию, которая ему в этом поможет.

Определите функцию count_letters, которая принимает на вход два аргумента:
строку, где через запятую и пробел перечислены языки;
строку, где через запятую и пробел перечислены числа, обозначающие количество букв в алфавите каждого языка;
Гарантируется, что языки и количество букв не повторяются. 
Функция должна возвращать строку — название языка, в алфавите которого минимальное количество букв. 
Важно! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: 'английский, казахский, русский, испанский, польский', '26, 42, 33, 27, 29' 
<Вывод>: английский 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: 'французский', '26' 
<Вывод>: французский 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: 'Греческий, Русский, Иврит, Хинди', '24, 33, 22, 47' 
<Вывод>: Иврит 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: 'лаосский, прусский, китайский', '100, 29, 87' 
<Вывод>: прусский 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: 'корейский', '676' 
<Вывод>: корейский 
<Решение студента>: def count_letters(langs, letters):
    sp = []
    langs = langs.split(', ')
    letters = list(map(int, letters))
    mn = min(letters)
    ind = letters.index(mn)
    return langs[ind] 
<Идеальное решение>: def count_letters(langs, letters):
    sp = []
    langs = langs.split(', ')
    letters = list(map(int, letters.split(', ')))
    mn = min(letters)
    ind = letters.index(mn)
    return langs[ind] 


<Комментарий эксперта>:"
214,479,30,"Витя хочет определить язык, алфавит которого состоит из минимального количества букв. Напишите функцию, которая ему в этом поможет.

Определите функцию count_letters, которая принимает на вход два аргумента:
строку, где через запятую и пробел перечислены языки;
строку, где через запятую и пробел перечислены числа, обозначающие количество букв в алфавите каждого языка;
Гарантируется, что языки и количество букв не повторяются. 
Функция должна возвращать строку — название языка, в алфавите которого минимальное количество букв. 
Важно! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке.","[""'английский, казахский, русский, испанский, польский', '26, 42, 33, 27, 29'"", ""'французский', '26'"", ""'Греческий, Русский, Иврит, Хинди', '24, 33, 22, 47'"", ""'лаосский, прусский, китайский', '100, 29, 87'"", ""'корейский', '676'""]","['английский', 'французский', 'Иврит', 'прусский', 'корейский']","def count_letters(langs, letters):
    sp = []
    langs = langs.split(', ')
    letters = list(map(letters.split(', ')))
    mn = min(letters)
    ind = letters.index(mn)
    return langs[ind]","def count_letters(langs, letters):
    sp = []
    langs = langs.split(', ')
    letters = list(map(int, letters.split(', ')))
    mn = min(letters)
    ind = letters.index(mn)
    return langs[ind]",Вы не добавили первый аргумент в функцию map.,"['open', 'open', 'closed', 'closed', 'closed']","<Task description>: Витя хочет определить язык, алфавит которого состоит из минимального количества букв. Напишите функцию, которая ему в этом поможет.

Определите функцию count_letters, которая принимает на вход два аргумента:
строку, где через запятую и пробел перечислены языки;
строку, где через запятую и пробел перечислены числа, обозначающие количество букв в алфавите каждого языка;
Гарантируется, что языки и количество букв не повторяются. 
Функция должна возвращать строку — название языка, в алфавите которого минимальное количество букв. 
Важно! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: 'английский, казахский, русский, испанский, польский', '26, 42, 33, 27, 29' 
<Вывод>: английский 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: 'французский', '26' 
<Вывод>: французский 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: 'Греческий, Русский, Иврит, Хинди', '24, 33, 22, 47' 
<Вывод>: Иврит 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: 'лаосский, прусский, китайский', '100, 29, 87' 
<Вывод>: прусский 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: 'корейский', '676' 
<Вывод>: корейский 
<Решение студента>: def count_letters(langs, letters):
    sp = []
    langs = langs.split(', ')
    letters = list(map(letters.split(', ')))
    mn = min(letters)
    ind = letters.index(mn)
    return langs[ind] 
<Идеальное решение>: def count_letters(langs, letters):
    sp = []
    langs = langs.split(', ')
    letters = list(map(int, letters.split(', ')))
    mn = min(letters)
    ind = letters.index(mn)
    return langs[ind] 


<Комментарий эксперта>:"
215,480,30,"Витя хочет определить язык, алфавит которого состоит из минимального количества букв. Напишите функцию, которая ему в этом поможет.

Определите функцию count_letters, которая принимает на вход два аргумента:
строку, где через запятую и пробел перечислены языки;
строку, где через запятую и пробел перечислены числа, обозначающие количество букв в алфавите каждого языка;
Гарантируется, что языки и количество букв не повторяются. 
Функция должна возвращать строку — название языка, в алфавите которого минимальное количество букв. 
Важно! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке.","[""'английский, казахский, русский, испанский, польский', '26, 42, 33, 27, 29'"", ""'французский', '26'"", ""'Греческий, Русский, Иврит, Хинди', '24, 33, 22, 47'"", ""'лаосский, прусский, китайский', '100, 29, 87'"", ""'корейский', '676'""]","['английский', 'французский', 'Иврит', 'прусский', 'корейский']","def count_letters(langs, letters):
    sp = []
    langs = langs.split(', ')
    letters = list(map(int, letters.split(', ')))
    mn = min(letters)
    ind = letters.index(mn)
    print(langs[ind])","def count_letters(langs, letters):
    sp = []
    langs = langs.split(', ')
    letters = list(map(int, letters.split(', ')))
    mn = min(letters)
    ind = letters.index(mn)
    return langs[ind]",Ошибка при выборе метода для возвращения данных. В данном задании ненльзя использовать print().,"['open', 'open', 'closed', 'closed', 'closed']","<Task description>: Витя хочет определить язык, алфавит которого состоит из минимального количества букв. Напишите функцию, которая ему в этом поможет.

Определите функцию count_letters, которая принимает на вход два аргумента:
строку, где через запятую и пробел перечислены языки;
строку, где через запятую и пробел перечислены числа, обозначающие количество букв в алфавите каждого языка;
Гарантируется, что языки и количество букв не повторяются. 
Функция должна возвращать строку — название языка, в алфавите которого минимальное количество букв. 
Важно! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: 'английский, казахский, русский, испанский, польский', '26, 42, 33, 27, 29' 
<Вывод>: английский 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: 'французский', '26' 
<Вывод>: французский 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: 'Греческий, Русский, Иврит, Хинди', '24, 33, 22, 47' 
<Вывод>: Иврит 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: 'лаосский, прусский, китайский', '100, 29, 87' 
<Вывод>: прусский 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: 'корейский', '676' 
<Вывод>: корейский 
<Решение студента>: def count_letters(langs, letters):
    sp = []
    langs = langs.split(', ')
    letters = list(map(int, letters.split(', ')))
    mn = min(letters)
    ind = letters.index(mn)
    print(langs[ind]) 
<Идеальное решение>: def count_letters(langs, letters):
    sp = []
    langs = langs.split(', ')
    letters = list(map(int, letters.split(', ')))
    mn = min(letters)
    ind = letters.index(mn)
    return langs[ind] 


<Комментарий эксперта>:"
216,481,30,"Витя хочет определить язык, алфавит которого состоит из минимального количества букв. Напишите функцию, которая ему в этом поможет.

Определите функцию count_letters, которая принимает на вход два аргумента:
строку, где через запятую и пробел перечислены языки;
строку, где через запятую и пробел перечислены числа, обозначающие количество букв в алфавите каждого языка;
Гарантируется, что языки и количество букв не повторяются. 
Функция должна возвращать строку — название языка, в алфавите которого минимальное количество букв. 
Важно! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке.","[""'английский, казахский, русский, испанский, польский', '26, 42, 33, 27, 29'"", ""'французский', '26'"", ""'Греческий, Русский, Иврит, Хинди', '24, 33, 22, 47'"", ""'лаосский, прусский, китайский', '100, 29, 87'"", ""'корейский', '676'""]","['английский', 'французский', 'Иврит', 'прусский', 'корейский']","def count_letters(langs, letters):
    sp = []
    langs = langs.split(', ')
    letters = list(map(int, letters.split(', ')))
    mn = min(letters)
    ind = letters.index(mn)
    return ind","def count_letters(langs, letters):
    sp = []
    langs = langs.split(', ')
    letters = list(map(int, letters.split(', ')))
    mn = min(letters)
    ind = letters.index(mn)
    return langs[ind]","Ошибка в открытых и скрытых тестах. 

Ваш код некорректно выполняет условия задания. Например, он не выполняет условие ""выведите название языка, в алфавите которого минимальное количество букв"". Попробуйте изменить условие return, чтобы скорректировать ошибку.","['open', 'open', 'closed', 'closed', 'closed']","<Task description>: Витя хочет определить язык, алфавит которого состоит из минимального количества букв. Напишите функцию, которая ему в этом поможет.

Определите функцию count_letters, которая принимает на вход два аргумента:
строку, где через запятую и пробел перечислены языки;
строку, где через запятую и пробел перечислены числа, обозначающие количество букв в алфавите каждого языка;
Гарантируется, что языки и количество букв не повторяются. 
Функция должна возвращать строку — название языка, в алфавите которого минимальное количество букв. 
Важно! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: 'английский, казахский, русский, испанский, польский', '26, 42, 33, 27, 29' 
<Вывод>: английский 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: 'французский', '26' 
<Вывод>: французский 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: 'Греческий, Русский, Иврит, Хинди', '24, 33, 22, 47' 
<Вывод>: Иврит 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: 'лаосский, прусский, китайский', '100, 29, 87' 
<Вывод>: прусский 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: 'корейский', '676' 
<Вывод>: корейский 
<Решение студента>: def count_letters(langs, letters):
    sp = []
    langs = langs.split(', ')
    letters = list(map(int, letters.split(', ')))
    mn = min(letters)
    ind = letters.index(mn)
    return ind 
<Идеальное решение>: def count_letters(langs, letters):
    sp = []
    langs = langs.split(', ')
    letters = list(map(int, letters.split(', ')))
    mn = min(letters)
    ind = letters.index(mn)
    return langs[ind] 


<Комментарий эксперта>:"
217,482,30,"Витя хочет определить язык, алфавит которого состоит из минимального количества букв. Напишите функцию, которая ему в этом поможет.

Определите функцию count_letters, которая принимает на вход два аргумента:
строку, где через запятую и пробел перечислены языки;
строку, где через запятую и пробел перечислены числа, обозначающие количество букв в алфавите каждого языка;
Гарантируется, что языки и количество букв не повторяются. 
Функция должна возвращать строку — название языка, в алфавите которого минимальное количество букв. 
Важно! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке.","[""'английский, казахский, русский, испанский, польский', '26, 42, 33, 27, 29'"", ""'французский', '26'"", ""'Греческий, Русский, Иврит, Хинди', '24, 33, 22, 47'"", ""'лаосский, прусский, китайский', '100, 29, 87'"", ""'корейский', '676'""]","['английский', 'французский', 'Иврит', 'прусский', 'корейский']","def count_letters(langs, letters):
    sp = []
    langs = langs.split(', ')
    letters = list(map(int, letters.split(', ')))
    ind = letters.index(letters)
    return langs[ind]","def count_letters(langs, letters):
    sp = []
    langs = langs.split(', ')
    letters = list(map(int, letters.split(', ')))
    mn = min(letters)
    ind = letters.index(mn)
    return langs[ind]",Ошибка при вычислении индекса. Невозможно получить индекс из значения типа list.,"['open', 'open', 'closed', 'closed', 'closed']","<Task description>: Витя хочет определить язык, алфавит которого состоит из минимального количества букв. Напишите функцию, которая ему в этом поможет.

Определите функцию count_letters, которая принимает на вход два аргумента:
строку, где через запятую и пробел перечислены языки;
строку, где через запятую и пробел перечислены числа, обозначающие количество букв в алфавите каждого языка;
Гарантируется, что языки и количество букв не повторяются. 
Функция должна возвращать строку — название языка, в алфавите которого минимальное количество букв. 
Важно! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: 'английский, казахский, русский, испанский, польский', '26, 42, 33, 27, 29' 
<Вывод>: английский 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: 'французский', '26' 
<Вывод>: французский 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: 'Греческий, Русский, Иврит, Хинди', '24, 33, 22, 47' 
<Вывод>: Иврит 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: 'лаосский, прусский, китайский', '100, 29, 87' 
<Вывод>: прусский 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: 'корейский', '676' 
<Вывод>: корейский 
<Решение студента>: def count_letters(langs, letters):
    sp = []
    langs = langs.split(', ')
    letters = list(map(int, letters.split(', ')))
    ind = letters.index(letters)
    return langs[ind] 
<Идеальное решение>: def count_letters(langs, letters):
    sp = []
    langs = langs.split(', ')
    letters = list(map(int, letters.split(', ')))
    mn = min(letters)
    ind = letters.index(mn)
    return langs[ind] 


<Комментарий эксперта>:"
218,501,32,"Мария хочет проверить, какое минимальное количество слов встречается в трех разделах книги. Напишите программу, которая поможет девушке. 

ФОРМАТ ВВОДА 
Вводятся три строки (за каждый раздел книги) в формате '<название главы>: <количество слов> слов'.  Между собой информация о главах разделена прямым слэшем (""/""). 
Гарантируется, что каждая строка состоит из информации минимум об одной главе.
ФОРМАТ ВЫВОДА 
Целое число — минимальное число слов, встречающееся в трех разделах книги. 
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Считайте строки в три разных переменных. Затем объедините эти строки в одну, в качестве разделителя используйте прямой слэш. Сохраните результат в новую переменную.
Создайте переменную-счетчик для определения минимального количества слов.
Разбейте созданную в п.1 переменную по разделителю и обратитесь к каждому элементу полученного списка — из каждой строки вытащите количество слов (не забудьте преобразовать в целое число). Если данное значение числа слов меньше переменной-счетчика, то обновите переменную-счетчик.
Напечатайте значение переменной-счетчика.","['История, литература и искусство древнего периода: 50000 слов/История и искусство XI - XIII вв.: 30000 слов/История, литература и искусство конца XIII - XV в.: 90000 слов\nИстория, литература и искусство тюдоровского периода: 15000 слов\nСемнадцатый век: 50000 слов/Восемнадцатый век: 60000 слов', 'Поэзия и проза Древнего Востока: 5000 слов\nМахабхарата: 900000 слов\nГомер: 17000 слов', 'Глава 1: 5000 слов/Глава 2: 5000 слов/Глава 3: 5000 слов\nГлава 4: 50200 слов\nГлава 5: 507872500 слов/Глава 6: 10 слова', 'Г1: 1700 слов\nГ2: 1700 слов\nГ3: 1700 слов']","['15000', '5000', '10', '1700.0']","ch1 = input()
ch2 = input()
ch3 = input()

res = '{ch1}/{ch2}/{ch3}'.split('/')

counter = 10000000

for item in res:
    item = int(item.split(': ')[1].split()[0])

    if item < counter:
        counter = item
    
print(counter)","ch1 = input()
ch2 = input()
ch3 = input()

res = f'{ch1}/{ch2}/{ch3}'.split('/')

counter = 10000000

for item in res:
    item = int(item.split(': ')[1].split()[0])

    if item < counter:
        counter = item
    
print(counter)","Вы забыли поставить префикс f перед строкой, переданной переменной res.","['open', 'open', 'closed', 'closed']","<Task description>: Мария хочет проверить, какое минимальное количество слов встречается в трех разделах книги. Напишите программу, которая поможет девушке. 

ФОРМАТ ВВОДА 
Вводятся три строки (за каждый раздел книги) в формате '<название главы>: <количество слов> слов'.  Между собой информация о главах разделена прямым слэшем (""/""). 
Гарантируется, что каждая строка состоит из информации минимум об одной главе.
ФОРМАТ ВЫВОДА 
Целое число — минимальное число слов, встречающееся в трех разделах книги. 
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Считайте строки в три разных переменных. Затем объедините эти строки в одну, в качестве разделителя используйте прямой слэш. Сохраните результат в новую переменную.
Создайте переменную-счетчик для определения минимального количества слов.
Разбейте созданную в п.1 переменную по разделителю и обратитесь к каждому элементу полученного списка — из каждой строки вытащите количество слов (не забудьте преобразовать в целое число). Если данное значение числа слов меньше переменной-счетчика, то обновите переменную-счетчик.
Напечатайте значение переменной-счетчика. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: История, литература и искусство древнего периода: 50000 слов/История и искусство XI - XIII вв.: 30000 слов/История, литература и искусство конца XIII - XV в.: 90000 слов
История, литература и искусство тюдоровского периода: 15000 слов
Семнадцатый век: 50000 слов/Восемнадцатый век: 60000 слов 
<Вывод>: 15000 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: Поэзия и проза Древнего Востока: 5000 слов
Махабхарата: 900000 слов
Гомер: 17000 слов 
<Вывод>: 5000 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: Глава 1: 5000 слов/Глава 2: 5000 слов/Глава 3: 5000 слов
Глава 4: 50200 слов
Глава 5: 507872500 слов/Глава 6: 10 слова 
<Вывод>: 10 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: Г1: 1700 слов
Г2: 1700 слов
Г3: 1700 слов 
<Вывод>: 1700.0 
<Решение студента>: ch1 = input()
ch2 = input()
ch3 = input()

res = '{ch1}/{ch2}/{ch3}'.split('/')

counter = 10000000

for item in res:
    item = int(item.split(': ')[1].split()[0])

    if item < counter:
        counter = item
    
print(counter) 
<Идеальное решение>: ch1 = input()
ch2 = input()
ch3 = input()

res = f'{ch1}/{ch2}/{ch3}'.split('/')

counter = 10000000

for item in res:
    item = int(item.split(': ')[1].split()[0])

    if item < counter:
        counter = item
    
print(counter) 


<Комментарий эксперта>:"
219,502,32,"Мария хочет проверить, какое минимальное количество слов встречается в трех разделах книги. Напишите программу, которая поможет девушке. 

ФОРМАТ ВВОДА 
Вводятся три строки (за каждый раздел книги) в формате '<название главы>: <количество слов> слов'.  Между собой информация о главах разделена прямым слэшем (""/""). 
Гарантируется, что каждая строка состоит из информации минимум об одной главе.
ФОРМАТ ВЫВОДА 
Целое число — минимальное число слов, встречающееся в трех разделах книги. 
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Считайте строки в три разных переменных. Затем объедините эти строки в одну, в качестве разделителя используйте прямой слэш. Сохраните результат в новую переменную.
Создайте переменную-счетчик для определения минимального количества слов.
Разбейте созданную в п.1 переменную по разделителю и обратитесь к каждому элементу полученного списка — из каждой строки вытащите количество слов (не забудьте преобразовать в целое число). Если данное значение числа слов меньше переменной-счетчика, то обновите переменную-счетчик.
Напечатайте значение переменной-счетчика.","['История, литература и искусство древнего периода: 50000 слов/История и искусство XI - XIII вв.: 30000 слов/История, литература и искусство конца XIII - XV в.: 90000 слов\nИстория, литература и искусство тюдоровского периода: 15000 слов\nСемнадцатый век: 50000 слов/Восемнадцатый век: 60000 слов', 'Поэзия и проза Древнего Востока: 5000 слов\nМахабхарата: 900000 слов\nГомер: 17000 слов', 'Глава 1: 5000 слов/Глава 2: 5000 слов/Глава 3: 5000 слов\nГлава 4: 50200 слов\nГлава 5: 507872500 слов/Глава 6: 10 слова', 'Г1: 1700 слов\nГ2: 1700 слов\nГ3: 1700 слов']","['15000', '5000', '10', '1700.0']","ch1 = input()
ch2 = input()
ch3 = input()

res = f'{ch1}/{ch2}/{ch3}.split('/')

counter = 10000000

for item in res:
    item = int(item.split(': ')[1].split()[0])

    if item < counter:
        counter = item
    
print(counter)","ch1 = input()
ch2 = input()
ch3 = input()

res = f'{ch1}/{ch2}/{ch3}'.split('/')

counter = 10000000

for item in res:
    item = int(item.split(': ')[1].split()[0])

    if item < counter:
        counter = item
    
print(counter)",Вы забыли поставить закрывающую кавычку в f-строке.,"['open', 'open', 'closed', 'closed']","<Task description>: Мария хочет проверить, какое минимальное количество слов встречается в трех разделах книги. Напишите программу, которая поможет девушке. 

ФОРМАТ ВВОДА 
Вводятся три строки (за каждый раздел книги) в формате '<название главы>: <количество слов> слов'.  Между собой информация о главах разделена прямым слэшем (""/""). 
Гарантируется, что каждая строка состоит из информации минимум об одной главе.
ФОРМАТ ВЫВОДА 
Целое число — минимальное число слов, встречающееся в трех разделах книги. 
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Считайте строки в три разных переменных. Затем объедините эти строки в одну, в качестве разделителя используйте прямой слэш. Сохраните результат в новую переменную.
Создайте переменную-счетчик для определения минимального количества слов.
Разбейте созданную в п.1 переменную по разделителю и обратитесь к каждому элементу полученного списка — из каждой строки вытащите количество слов (не забудьте преобразовать в целое число). Если данное значение числа слов меньше переменной-счетчика, то обновите переменную-счетчик.
Напечатайте значение переменной-счетчика. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: История, литература и искусство древнего периода: 50000 слов/История и искусство XI - XIII вв.: 30000 слов/История, литература и искусство конца XIII - XV в.: 90000 слов
История, литература и искусство тюдоровского периода: 15000 слов
Семнадцатый век: 50000 слов/Восемнадцатый век: 60000 слов 
<Вывод>: 15000 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: Поэзия и проза Древнего Востока: 5000 слов
Махабхарата: 900000 слов
Гомер: 17000 слов 
<Вывод>: 5000 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: Глава 1: 5000 слов/Глава 2: 5000 слов/Глава 3: 5000 слов
Глава 4: 50200 слов
Глава 5: 507872500 слов/Глава 6: 10 слова 
<Вывод>: 10 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: Г1: 1700 слов
Г2: 1700 слов
Г3: 1700 слов 
<Вывод>: 1700.0 
<Решение студента>: ch1 = input()
ch2 = input()
ch3 = input()

res = f'{ch1}/{ch2}/{ch3}.split('/')

counter = 10000000

for item in res:
    item = int(item.split(': ')[1].split()[0])

    if item < counter:
        counter = item
    
print(counter) 
<Идеальное решение>: ch1 = input()
ch2 = input()
ch3 = input()

res = f'{ch1}/{ch2}/{ch3}'.split('/')

counter = 10000000

for item in res:
    item = int(item.split(': ')[1].split()[0])

    if item < counter:
        counter = item
    
print(counter) 


<Комментарий эксперта>:"
220,503,32,"Мария хочет проверить, какое минимальное количество слов встречается в трех разделах книги. Напишите программу, которая поможет девушке. 

ФОРМАТ ВВОДА 
Вводятся три строки (за каждый раздел книги) в формате '<название главы>: <количество слов> слов'.  Между собой информация о главах разделена прямым слэшем (""/""). 
Гарантируется, что каждая строка состоит из информации минимум об одной главе.
ФОРМАТ ВЫВОДА 
Целое число — минимальное число слов, встречающееся в трех разделах книги. 
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Считайте строки в три разных переменных. Затем объедините эти строки в одну, в качестве разделителя используйте прямой слэш. Сохраните результат в новую переменную.
Создайте переменную-счетчик для определения минимального количества слов.
Разбейте созданную в п.1 переменную по разделителю и обратитесь к каждому элементу полученного списка — из каждой строки вытащите количество слов (не забудьте преобразовать в целое число). Если данное значение числа слов меньше переменной-счетчика, то обновите переменную-счетчик.
Напечатайте значение переменной-счетчика.","['История, литература и искусство древнего периода: 50000 слов/История и искусство XI - XIII вв.: 30000 слов/История, литература и искусство конца XIII - XV в.: 90000 слов\nИстория, литература и искусство тюдоровского периода: 15000 слов\nСемнадцатый век: 50000 слов/Восемнадцатый век: 60000 слов', 'Поэзия и проза Древнего Востока: 5000 слов\nМахабхарата: 900000 слов\nГомер: 17000 слов', 'Глава 1: 5000 слов/Глава 2: 5000 слов/Глава 3: 5000 слов\nГлава 4: 50200 слов\nГлава 5: 507872500 слов/Глава 6: 10 слова', 'Г1: 1700 слов\nГ2: 1700 слов\nГ3: 1700 слов']","['15000', '5000', '10', '1700.0']","ch1 = input()
ch2 = input()
ch3 = input()

res = f{ch1}/{ch2}/{ch3}'.split('/')

counter = 10000000

for item in res:
    item = int(item.split(': ')[1].split()[0])

    if item < counter:
        counter = item
    
print(counter)","ch1 = input()
ch2 = input()
ch3 = input()

res = f'{ch1}/{ch2}/{ch3}'.split('/')

counter = 10000000

for item in res:
    item = int(item.split(': ')[1].split()[0])

    if item < counter:
        counter = item
    
print(counter)",Вы забыли поставить открывающую кавычку в f-строке.,"['open', 'open', 'closed', 'closed']","<Task description>: Мария хочет проверить, какое минимальное количество слов встречается в трех разделах книги. Напишите программу, которая поможет девушке. 

ФОРМАТ ВВОДА 
Вводятся три строки (за каждый раздел книги) в формате '<название главы>: <количество слов> слов'.  Между собой информация о главах разделена прямым слэшем (""/""). 
Гарантируется, что каждая строка состоит из информации минимум об одной главе.
ФОРМАТ ВЫВОДА 
Целое число — минимальное число слов, встречающееся в трех разделах книги. 
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Считайте строки в три разных переменных. Затем объедините эти строки в одну, в качестве разделителя используйте прямой слэш. Сохраните результат в новую переменную.
Создайте переменную-счетчик для определения минимального количества слов.
Разбейте созданную в п.1 переменную по разделителю и обратитесь к каждому элементу полученного списка — из каждой строки вытащите количество слов (не забудьте преобразовать в целое число). Если данное значение числа слов меньше переменной-счетчика, то обновите переменную-счетчик.
Напечатайте значение переменной-счетчика. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: История, литература и искусство древнего периода: 50000 слов/История и искусство XI - XIII вв.: 30000 слов/История, литература и искусство конца XIII - XV в.: 90000 слов
История, литература и искусство тюдоровского периода: 15000 слов
Семнадцатый век: 50000 слов/Восемнадцатый век: 60000 слов 
<Вывод>: 15000 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: Поэзия и проза Древнего Востока: 5000 слов
Махабхарата: 900000 слов
Гомер: 17000 слов 
<Вывод>: 5000 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: Глава 1: 5000 слов/Глава 2: 5000 слов/Глава 3: 5000 слов
Глава 4: 50200 слов
Глава 5: 507872500 слов/Глава 6: 10 слова 
<Вывод>: 10 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: Г1: 1700 слов
Г2: 1700 слов
Г3: 1700 слов 
<Вывод>: 1700.0 
<Решение студента>: ch1 = input()
ch2 = input()
ch3 = input()

res = f{ch1}/{ch2}/{ch3}'.split('/')

counter = 10000000

for item in res:
    item = int(item.split(': ')[1].split()[0])

    if item < counter:
        counter = item
    
print(counter) 
<Идеальное решение>: ch1 = input()
ch2 = input()
ch3 = input()

res = f'{ch1}/{ch2}/{ch3}'.split('/')

counter = 10000000

for item in res:
    item = int(item.split(': ')[1].split()[0])

    if item < counter:
        counter = item
    
print(counter) 


<Комментарий эксперта>:"
221,504,32,"Мария хочет проверить, какое минимальное количество слов встречается в трех разделах книги. Напишите программу, которая поможет девушке. 

ФОРМАТ ВВОДА 
Вводятся три строки (за каждый раздел книги) в формате '<название главы>: <количество слов> слов'.  Между собой информация о главах разделена прямым слэшем (""/""). 
Гарантируется, что каждая строка состоит из информации минимум об одной главе.
ФОРМАТ ВЫВОДА 
Целое число — минимальное число слов, встречающееся в трех разделах книги. 
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Считайте строки в три разных переменных. Затем объедините эти строки в одну, в качестве разделителя используйте прямой слэш. Сохраните результат в новую переменную.
Создайте переменную-счетчик для определения минимального количества слов.
Разбейте созданную в п.1 переменную по разделителю и обратитесь к каждому элементу полученного списка — из каждой строки вытащите количество слов (не забудьте преобразовать в целое число). Если данное значение числа слов меньше переменной-счетчика, то обновите переменную-счетчик.
Напечатайте значение переменной-счетчика.","['История, литература и искусство древнего периода: 50000 слов/История и искусство XI - XIII вв.: 30000 слов/История, литература и искусство конца XIII - XV в.: 90000 слов\nИстория, литература и искусство тюдоровского периода: 15000 слов\nСемнадцатый век: 50000 слов/Восемнадцатый век: 60000 слов', 'Поэзия и проза Древнего Востока: 5000 слов\nМахабхарата: 900000 слов\nГомер: 17000 слов', 'Глава 1: 5000 слов/Глава 2: 5000 слов/Глава 3: 5000 слов\nГлава 4: 50200 слов\nГлава 5: 507872500 слов/Глава 6: 10 слова', 'Г1: 1700 слов\nГ2: 1700 слов\nГ3: 1700 слов']","['15000', '5000', '10', '1700.0']","ch1 = input()
ch2 = input()
ch3 = input()

res = f'{ch}/{ch1}/{ch2}'.split('/')

counter = 10000000

for item in res:
    item = int(item.split(': ')[1].split()[0])

    if item < counter:
        counter = item
    
print(counter)","ch1 = input()
ch2 = input()
ch3 = input()

res = f'{ch1}/{ch2}/{ch3}'.split('/')

counter = 10000000

for item in res:
    item = int(item.split(': ')[1].split()[0])

    if item < counter:
        counter = item
    
print(counter)","Ошибка при обращении к незаданной переменной. Проверьте, что все Ваши переменные корректно заданы.","['open', 'open', 'closed', 'closed']","<Task description>: Мария хочет проверить, какое минимальное количество слов встречается в трех разделах книги. Напишите программу, которая поможет девушке. 

ФОРМАТ ВВОДА 
Вводятся три строки (за каждый раздел книги) в формате '<название главы>: <количество слов> слов'.  Между собой информация о главах разделена прямым слэшем (""/""). 
Гарантируется, что каждая строка состоит из информации минимум об одной главе.
ФОРМАТ ВЫВОДА 
Целое число — минимальное число слов, встречающееся в трех разделах книги. 
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Считайте строки в три разных переменных. Затем объедините эти строки в одну, в качестве разделителя используйте прямой слэш. Сохраните результат в новую переменную.
Создайте переменную-счетчик для определения минимального количества слов.
Разбейте созданную в п.1 переменную по разделителю и обратитесь к каждому элементу полученного списка — из каждой строки вытащите количество слов (не забудьте преобразовать в целое число). Если данное значение числа слов меньше переменной-счетчика, то обновите переменную-счетчик.
Напечатайте значение переменной-счетчика. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: История, литература и искусство древнего периода: 50000 слов/История и искусство XI - XIII вв.: 30000 слов/История, литература и искусство конца XIII - XV в.: 90000 слов
История, литература и искусство тюдоровского периода: 15000 слов
Семнадцатый век: 50000 слов/Восемнадцатый век: 60000 слов 
<Вывод>: 15000 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: Поэзия и проза Древнего Востока: 5000 слов
Махабхарата: 900000 слов
Гомер: 17000 слов 
<Вывод>: 5000 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: Глава 1: 5000 слов/Глава 2: 5000 слов/Глава 3: 5000 слов
Глава 4: 50200 слов
Глава 5: 507872500 слов/Глава 6: 10 слова 
<Вывод>: 10 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: Г1: 1700 слов
Г2: 1700 слов
Г3: 1700 слов 
<Вывод>: 1700.0 
<Решение студента>: ch1 = input()
ch2 = input()
ch3 = input()

res = f'{ch}/{ch1}/{ch2}'.split('/')

counter = 10000000

for item in res:
    item = int(item.split(': ')[1].split()[0])

    if item < counter:
        counter = item
    
print(counter) 
<Идеальное решение>: ch1 = input()
ch2 = input()
ch3 = input()

res = f'{ch1}/{ch2}/{ch3}'.split('/')

counter = 10000000

for item in res:
    item = int(item.split(': ')[1].split()[0])

    if item < counter:
        counter = item
    
print(counter) 


<Комментарий эксперта>:"
222,505,32,"Мария хочет проверить, какое минимальное количество слов встречается в трех разделах книги. Напишите программу, которая поможет девушке. 

ФОРМАТ ВВОДА 
Вводятся три строки (за каждый раздел книги) в формате '<название главы>: <количество слов> слов'.  Между собой информация о главах разделена прямым слэшем (""/""). 
Гарантируется, что каждая строка состоит из информации минимум об одной главе.
ФОРМАТ ВЫВОДА 
Целое число — минимальное число слов, встречающееся в трех разделах книги. 
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Считайте строки в три разных переменных. Затем объедините эти строки в одну, в качестве разделителя используйте прямой слэш. Сохраните результат в новую переменную.
Создайте переменную-счетчик для определения минимального количества слов.
Разбейте созданную в п.1 переменную по разделителю и обратитесь к каждому элементу полученного списка — из каждой строки вытащите количество слов (не забудьте преобразовать в целое число). Если данное значение числа слов меньше переменной-счетчика, то обновите переменную-счетчик.
Напечатайте значение переменной-счетчика.","['История, литература и искусство древнего периода: 50000 слов/История и искусство XI - XIII вв.: 30000 слов/История, литература и искусство конца XIII - XV в.: 90000 слов\nИстория, литература и искусство тюдоровского периода: 15000 слов\nСемнадцатый век: 50000 слов/Восемнадцатый век: 60000 слов', 'Поэзия и проза Древнего Востока: 5000 слов\nМахабхарата: 900000 слов\nГомер: 17000 слов', 'Глава 1: 5000 слов/Глава 2: 5000 слов/Глава 3: 5000 слов\nГлава 4: 50200 слов\nГлава 5: 507872500 слов/Глава 6: 10 слова', 'Г1: 1700 слов\nГ2: 1700 слов\nГ3: 1700 слов']","['15000', '5000', '10', '1700.0']","ch1 = input()
ch2 = input()
ch3 = input()

res = f'{ch1}/{ch2}/{ch3}'.split()

counter = 10000000

for item in res:
    item = int(item.split(': ')[1].split()[0])

    if item < counter:
        counter = item
    
print(counter)","ch1 = input()
ch2 = input()
ch3 = input()

res = f'{ch1}/{ch2}/{ch3}'.split('/')

counter = 10000000

for item in res:
    item = int(item.split(': ')[1].split()[0])

    if item < counter:
        counter = item
    
print(counter)",Ошибка при использовании метода split(). Функция получила некорректный параметр для разделения элементов строки. ,"['open', 'open', 'closed', 'closed']","<Task description>: Мария хочет проверить, какое минимальное количество слов встречается в трех разделах книги. Напишите программу, которая поможет девушке. 

ФОРМАТ ВВОДА 
Вводятся три строки (за каждый раздел книги) в формате '<название главы>: <количество слов> слов'.  Между собой информация о главах разделена прямым слэшем (""/""). 
Гарантируется, что каждая строка состоит из информации минимум об одной главе.
ФОРМАТ ВЫВОДА 
Целое число — минимальное число слов, встречающееся в трех разделах книги. 
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Считайте строки в три разных переменных. Затем объедините эти строки в одну, в качестве разделителя используйте прямой слэш. Сохраните результат в новую переменную.
Создайте переменную-счетчик для определения минимального количества слов.
Разбейте созданную в п.1 переменную по разделителю и обратитесь к каждому элементу полученного списка — из каждой строки вытащите количество слов (не забудьте преобразовать в целое число). Если данное значение числа слов меньше переменной-счетчика, то обновите переменную-счетчик.
Напечатайте значение переменной-счетчика. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: История, литература и искусство древнего периода: 50000 слов/История и искусство XI - XIII вв.: 30000 слов/История, литература и искусство конца XIII - XV в.: 90000 слов
История, литература и искусство тюдоровского периода: 15000 слов
Семнадцатый век: 50000 слов/Восемнадцатый век: 60000 слов 
<Вывод>: 15000 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: Поэзия и проза Древнего Востока: 5000 слов
Махабхарата: 900000 слов
Гомер: 17000 слов 
<Вывод>: 5000 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: Глава 1: 5000 слов/Глава 2: 5000 слов/Глава 3: 5000 слов
Глава 4: 50200 слов
Глава 5: 507872500 слов/Глава 6: 10 слова 
<Вывод>: 10 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: Г1: 1700 слов
Г2: 1700 слов
Г3: 1700 слов 
<Вывод>: 1700.0 
<Решение студента>: ch1 = input()
ch2 = input()
ch3 = input()

res = f'{ch1}/{ch2}/{ch3}'.split()

counter = 10000000

for item in res:
    item = int(item.split(': ')[1].split()[0])

    if item < counter:
        counter = item
    
print(counter) 
<Идеальное решение>: ch1 = input()
ch2 = input()
ch3 = input()

res = f'{ch1}/{ch2}/{ch3}'.split('/')

counter = 10000000

for item in res:
    item = int(item.split(': ')[1].split()[0])

    if item < counter:
        counter = item
    
print(counter) 


<Комментарий эксперта>:"
223,506,32,"Мария хочет проверить, какое минимальное количество слов встречается в трех разделах книги. Напишите программу, которая поможет девушке. 

ФОРМАТ ВВОДА 
Вводятся три строки (за каждый раздел книги) в формате '<название главы>: <количество слов> слов'.  Между собой информация о главах разделена прямым слэшем (""/""). 
Гарантируется, что каждая строка состоит из информации минимум об одной главе.
ФОРМАТ ВЫВОДА 
Целое число — минимальное число слов, встречающееся в трех разделах книги. 
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Считайте строки в три разных переменных. Затем объедините эти строки в одну, в качестве разделителя используйте прямой слэш. Сохраните результат в новую переменную.
Создайте переменную-счетчик для определения минимального количества слов.
Разбейте созданную в п.1 переменную по разделителю и обратитесь к каждому элементу полученного списка — из каждой строки вытащите количество слов (не забудьте преобразовать в целое число). Если данное значение числа слов меньше переменной-счетчика, то обновите переменную-счетчик.
Напечатайте значение переменной-счетчика.","['История, литература и искусство древнего периода: 50000 слов/История и искусство XI - XIII вв.: 30000 слов/История, литература и искусство конца XIII - XV в.: 90000 слов\nИстория, литература и искусство тюдоровского периода: 15000 слов\nСемнадцатый век: 50000 слов/Восемнадцатый век: 60000 слов', 'Поэзия и проза Древнего Востока: 5000 слов\nМахабхарата: 900000 слов\nГомер: 17000 слов', 'Глава 1: 5000 слов/Глава 2: 5000 слов/Глава 3: 5000 слов\nГлава 4: 50200 слов\nГлава 5: 507872500 слов/Глава 6: 10 слова', 'Г1: 1700 слов\nГ2: 1700 слов\nГ3: 1700 слов']","['15000', '5000', '10', '1700.0']","ch1 = input()
ch2 = input()
ch3 = input()

res = f'{ch1}/{ch2}/{ch3}'

counter = 10000000

for item in res:
    item = int(item.split(': ')[1].split()[0])

    if item < counter:
        counter = item
    
print(counter)","ch1 = input()
ch2 = input()
ch3 = input()

res = f'{ch1}/{ch2}/{ch3}'.split('/')

counter = 10000000

for item in res:
    item = int(item.split(': ')[1].split()[0])

    if item < counter:
        counter = item
    
print(counter)",Вы забыли разделить элементы переменной res.,"['open', 'open', 'closed', 'closed']","<Task description>: Мария хочет проверить, какое минимальное количество слов встречается в трех разделах книги. Напишите программу, которая поможет девушке. 

ФОРМАТ ВВОДА 
Вводятся три строки (за каждый раздел книги) в формате '<название главы>: <количество слов> слов'.  Между собой информация о главах разделена прямым слэшем (""/""). 
Гарантируется, что каждая строка состоит из информации минимум об одной главе.
ФОРМАТ ВЫВОДА 
Целое число — минимальное число слов, встречающееся в трех разделах книги. 
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Считайте строки в три разных переменных. Затем объедините эти строки в одну, в качестве разделителя используйте прямой слэш. Сохраните результат в новую переменную.
Создайте переменную-счетчик для определения минимального количества слов.
Разбейте созданную в п.1 переменную по разделителю и обратитесь к каждому элементу полученного списка — из каждой строки вытащите количество слов (не забудьте преобразовать в целое число). Если данное значение числа слов меньше переменной-счетчика, то обновите переменную-счетчик.
Напечатайте значение переменной-счетчика. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: История, литература и искусство древнего периода: 50000 слов/История и искусство XI - XIII вв.: 30000 слов/История, литература и искусство конца XIII - XV в.: 90000 слов
История, литература и искусство тюдоровского периода: 15000 слов
Семнадцатый век: 50000 слов/Восемнадцатый век: 60000 слов 
<Вывод>: 15000 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: Поэзия и проза Древнего Востока: 5000 слов
Махабхарата: 900000 слов
Гомер: 17000 слов 
<Вывод>: 5000 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: Глава 1: 5000 слов/Глава 2: 5000 слов/Глава 3: 5000 слов
Глава 4: 50200 слов
Глава 5: 507872500 слов/Глава 6: 10 слова 
<Вывод>: 10 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: Г1: 1700 слов
Г2: 1700 слов
Г3: 1700 слов 
<Вывод>: 1700.0 
<Решение студента>: ch1 = input()
ch2 = input()
ch3 = input()

res = f'{ch1}/{ch2}/{ch3}'

counter = 10000000

for item in res:
    item = int(item.split(': ')[1].split()[0])

    if item < counter:
        counter = item
    
print(counter) 
<Идеальное решение>: ch1 = input()
ch2 = input()
ch3 = input()

res = f'{ch1}/{ch2}/{ch3}'.split('/')

counter = 10000000

for item in res:
    item = int(item.split(': ')[1].split()[0])

    if item < counter:
        counter = item
    
print(counter) 


<Комментарий эксперта>:"
224,507,32,"Мария хочет проверить, какое минимальное количество слов встречается в трех разделах книги. Напишите программу, которая поможет девушке. 

ФОРМАТ ВВОДА 
Вводятся три строки (за каждый раздел книги) в формате '<название главы>: <количество слов> слов'.  Между собой информация о главах разделена прямым слэшем (""/""). 
Гарантируется, что каждая строка состоит из информации минимум об одной главе.
ФОРМАТ ВЫВОДА 
Целое число — минимальное число слов, встречающееся в трех разделах книги. 
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Считайте строки в три разных переменных. Затем объедините эти строки в одну, в качестве разделителя используйте прямой слэш. Сохраните результат в новую переменную.
Создайте переменную-счетчик для определения минимального количества слов.
Разбейте созданную в п.1 переменную по разделителю и обратитесь к каждому элементу полученного списка — из каждой строки вытащите количество слов (не забудьте преобразовать в целое число). Если данное значение числа слов меньше переменной-счетчика, то обновите переменную-счетчик.
Напечатайте значение переменной-счетчика.","['История, литература и искусство древнего периода: 50000 слов/История и искусство XI - XIII вв.: 30000 слов/История, литература и искусство конца XIII - XV в.: 90000 слов\nИстория, литература и искусство тюдоровского периода: 15000 слов\nСемнадцатый век: 50000 слов/Восемнадцатый век: 60000 слов', 'Поэзия и проза Древнего Востока: 5000 слов\nМахабхарата: 900000 слов\nГомер: 17000 слов', 'Глава 1: 5000 слов/Глава 2: 5000 слов/Глава 3: 5000 слов\nГлава 4: 50200 слов\nГлава 5: 507872500 слов/Глава 6: 10 слова', 'Г1: 1700 слов\nГ2: 1700 слов\nГ3: 1700 слов']","['15000', '5000', '10', '1700.0']","ch1 = input()
ch2 = input()
ch3 = input()

res = f'{ch1}/{ch2}/{ch3}'.split('/')

counter = 10000000

for i in res:
    item = int(item.split(': ')[1].split()[0])

    if item < counter:
        counter = item
    
print(counter)","ch1 = input()
ch2 = input()
ch3 = input()

res = f'{ch1}/{ch2}/{ch3}'.split('/')

counter = 10000000

for item in res:
    item = int(item.split(': ')[1].split()[0])

    if item < counter:
        counter = item
    
print(counter)","Ошибка при обращении к незаданной переменной. Проверьте, что все Ваши переменные корректно заданы.","['open', 'open', 'closed', 'closed']","<Task description>: Мария хочет проверить, какое минимальное количество слов встречается в трех разделах книги. Напишите программу, которая поможет девушке. 

ФОРМАТ ВВОДА 
Вводятся три строки (за каждый раздел книги) в формате '<название главы>: <количество слов> слов'.  Между собой информация о главах разделена прямым слэшем (""/""). 
Гарантируется, что каждая строка состоит из информации минимум об одной главе.
ФОРМАТ ВЫВОДА 
Целое число — минимальное число слов, встречающееся в трех разделах книги. 
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Считайте строки в три разных переменных. Затем объедините эти строки в одну, в качестве разделителя используйте прямой слэш. Сохраните результат в новую переменную.
Создайте переменную-счетчик для определения минимального количества слов.
Разбейте созданную в п.1 переменную по разделителю и обратитесь к каждому элементу полученного списка — из каждой строки вытащите количество слов (не забудьте преобразовать в целое число). Если данное значение числа слов меньше переменной-счетчика, то обновите переменную-счетчик.
Напечатайте значение переменной-счетчика. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: История, литература и искусство древнего периода: 50000 слов/История и искусство XI - XIII вв.: 30000 слов/История, литература и искусство конца XIII - XV в.: 90000 слов
История, литература и искусство тюдоровского периода: 15000 слов
Семнадцатый век: 50000 слов/Восемнадцатый век: 60000 слов 
<Вывод>: 15000 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: Поэзия и проза Древнего Востока: 5000 слов
Махабхарата: 900000 слов
Гомер: 17000 слов 
<Вывод>: 5000 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: Глава 1: 5000 слов/Глава 2: 5000 слов/Глава 3: 5000 слов
Глава 4: 50200 слов
Глава 5: 507872500 слов/Глава 6: 10 слова 
<Вывод>: 10 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: Г1: 1700 слов
Г2: 1700 слов
Г3: 1700 слов 
<Вывод>: 1700.0 
<Решение студента>: ch1 = input()
ch2 = input()
ch3 = input()

res = f'{ch1}/{ch2}/{ch3}'.split('/')

counter = 10000000

for i in res:
    item = int(item.split(': ')[1].split()[0])

    if item < counter:
        counter = item
    
print(counter) 
<Идеальное решение>: ch1 = input()
ch2 = input()
ch3 = input()

res = f'{ch1}/{ch2}/{ch3}'.split('/')

counter = 10000000

for item in res:
    item = int(item.split(': ')[1].split()[0])

    if item < counter:
        counter = item
    
print(counter) 


<Комментарий эксперта>:"
225,508,32,"Мария хочет проверить, какое минимальное количество слов встречается в трех разделах книги. Напишите программу, которая поможет девушке. 

ФОРМАТ ВВОДА 
Вводятся три строки (за каждый раздел книги) в формате '<название главы>: <количество слов> слов'.  Между собой информация о главах разделена прямым слэшем (""/""). 
Гарантируется, что каждая строка состоит из информации минимум об одной главе.
ФОРМАТ ВЫВОДА 
Целое число — минимальное число слов, встречающееся в трех разделах книги. 
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Считайте строки в три разных переменных. Затем объедините эти строки в одну, в качестве разделителя используйте прямой слэш. Сохраните результат в новую переменную.
Создайте переменную-счетчик для определения минимального количества слов.
Разбейте созданную в п.1 переменную по разделителю и обратитесь к каждому элементу полученного списка — из каждой строки вытащите количество слов (не забудьте преобразовать в целое число). Если данное значение числа слов меньше переменной-счетчика, то обновите переменную-счетчик.
Напечатайте значение переменной-счетчика.","['История, литература и искусство древнего периода: 50000 слов/История и искусство XI - XIII вв.: 30000 слов/История, литература и искусство конца XIII - XV в.: 90000 слов\nИстория, литература и искусство тюдоровского периода: 15000 слов\nСемнадцатый век: 50000 слов/Восемнадцатый век: 60000 слов', 'Поэзия и проза Древнего Востока: 5000 слов\nМахабхарата: 900000 слов\nГомер: 17000 слов', 'Глава 1: 5000 слов/Глава 2: 5000 слов/Глава 3: 5000 слов\nГлава 4: 50200 слов\nГлава 5: 507872500 слов/Глава 6: 10 слова', 'Г1: 1700 слов\nГ2: 1700 слов\nГ3: 1700 слов']","['15000', '5000', '10', '1700.0']","ch1 = input()
ch2 = input()
ch3 = input()

res = f'{ch1}/{ch2}/{ch3}'.split('/')

counter = 10000000

for item in res
    item = int(item.split(': ')[1].split()[0])

    if item < counter:
        counter = item
    
print(counter)","ch1 = input()
ch2 = input()
ch3 = input()

res = f'{ch1}/{ch2}/{ch3}'.split('/')

counter = 10000000

for item in res:
    item = int(item.split(': ')[1].split()[0])

    if item < counter:
        counter = item
    
print(counter)",Вы забыли поставить двоеточие после условия цикла for.,"['open', 'open', 'closed', 'closed']","<Task description>: Мария хочет проверить, какое минимальное количество слов встречается в трех разделах книги. Напишите программу, которая поможет девушке. 

ФОРМАТ ВВОДА 
Вводятся три строки (за каждый раздел книги) в формате '<название главы>: <количество слов> слов'.  Между собой информация о главах разделена прямым слэшем (""/""). 
Гарантируется, что каждая строка состоит из информации минимум об одной главе.
ФОРМАТ ВЫВОДА 
Целое число — минимальное число слов, встречающееся в трех разделах книги. 
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Считайте строки в три разных переменных. Затем объедините эти строки в одну, в качестве разделителя используйте прямой слэш. Сохраните результат в новую переменную.
Создайте переменную-счетчик для определения минимального количества слов.
Разбейте созданную в п.1 переменную по разделителю и обратитесь к каждому элементу полученного списка — из каждой строки вытащите количество слов (не забудьте преобразовать в целое число). Если данное значение числа слов меньше переменной-счетчика, то обновите переменную-счетчик.
Напечатайте значение переменной-счетчика. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: История, литература и искусство древнего периода: 50000 слов/История и искусство XI - XIII вв.: 30000 слов/История, литература и искусство конца XIII - XV в.: 90000 слов
История, литература и искусство тюдоровского периода: 15000 слов
Семнадцатый век: 50000 слов/Восемнадцатый век: 60000 слов 
<Вывод>: 15000 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: Поэзия и проза Древнего Востока: 5000 слов
Махабхарата: 900000 слов
Гомер: 17000 слов 
<Вывод>: 5000 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: Глава 1: 5000 слов/Глава 2: 5000 слов/Глава 3: 5000 слов
Глава 4: 50200 слов
Глава 5: 507872500 слов/Глава 6: 10 слова 
<Вывод>: 10 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: Г1: 1700 слов
Г2: 1700 слов
Г3: 1700 слов 
<Вывод>: 1700.0 
<Решение студента>: ch1 = input()
ch2 = input()
ch3 = input()

res = f'{ch1}/{ch2}/{ch3}'.split('/')

counter = 10000000

for item in res
    item = int(item.split(': ')[1].split()[0])

    if item < counter:
        counter = item
    
print(counter) 
<Идеальное решение>: ch1 = input()
ch2 = input()
ch3 = input()

res = f'{ch1}/{ch2}/{ch3}'.split('/')

counter = 10000000

for item in res:
    item = int(item.split(': ')[1].split()[0])

    if item < counter:
        counter = item
    
print(counter) 


<Комментарий эксперта>:"
226,509,32,"Мария хочет проверить, какое минимальное количество слов встречается в трех разделах книги. Напишите программу, которая поможет девушке. 

ФОРМАТ ВВОДА 
Вводятся три строки (за каждый раздел книги) в формате '<название главы>: <количество слов> слов'.  Между собой информация о главах разделена прямым слэшем (""/""). 
Гарантируется, что каждая строка состоит из информации минимум об одной главе.
ФОРМАТ ВЫВОДА 
Целое число — минимальное число слов, встречающееся в трех разделах книги. 
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Считайте строки в три разных переменных. Затем объедините эти строки в одну, в качестве разделителя используйте прямой слэш. Сохраните результат в новую переменную.
Создайте переменную-счетчик для определения минимального количества слов.
Разбейте созданную в п.1 переменную по разделителю и обратитесь к каждому элементу полученного списка — из каждой строки вытащите количество слов (не забудьте преобразовать в целое число). Если данное значение числа слов меньше переменной-счетчика, то обновите переменную-счетчик.
Напечатайте значение переменной-счетчика.","['История, литература и искусство древнего периода: 50000 слов/История и искусство XI - XIII вв.: 30000 слов/История, литература и искусство конца XIII - XV в.: 90000 слов\nИстория, литература и искусство тюдоровского периода: 15000 слов\nСемнадцатый век: 50000 слов/Восемнадцатый век: 60000 слов', 'Поэзия и проза Древнего Востока: 5000 слов\nМахабхарата: 900000 слов\nГомер: 17000 слов', 'Глава 1: 5000 слов/Глава 2: 5000 слов/Глава 3: 5000 слов\nГлава 4: 50200 слов\nГлава 5: 507872500 слов/Глава 6: 10 слова', 'Г1: 1700 слов\nГ2: 1700 слов\nГ3: 1700 слов']","['15000', '5000', '10', '1700.0']","ch1 = input()
ch2 = input()
ch3 = input()

res = f'{ch1}/{ch2}/{ch3}'.split('/')

counter = 10000000

for item in res:
    item = item.split(': ')[1].split()[0]

    if item < counter:
        counter = item
    
print(counter)","ch1 = input()
ch2 = input()
ch3 = input()

res = f'{ch1}/{ch2}/{ch3}'.split('/')

counter = 10000000

for item in res:
    item = int(item.split(': ')[1].split()[0])

    if item < counter:
        counter = item
    
print(counter)","Ошибка при использовании оператора <. Сравнивать можно только переменные типа int. Скорректируйте условие if, для исправления ошибки.","['open', 'open', 'closed', 'closed']","<Task description>: Мария хочет проверить, какое минимальное количество слов встречается в трех разделах книги. Напишите программу, которая поможет девушке. 

ФОРМАТ ВВОДА 
Вводятся три строки (за каждый раздел книги) в формате '<название главы>: <количество слов> слов'.  Между собой информация о главах разделена прямым слэшем (""/""). 
Гарантируется, что каждая строка состоит из информации минимум об одной главе.
ФОРМАТ ВЫВОДА 
Целое число — минимальное число слов, встречающееся в трех разделах книги. 
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Считайте строки в три разных переменных. Затем объедините эти строки в одну, в качестве разделителя используйте прямой слэш. Сохраните результат в новую переменную.
Создайте переменную-счетчик для определения минимального количества слов.
Разбейте созданную в п.1 переменную по разделителю и обратитесь к каждому элементу полученного списка — из каждой строки вытащите количество слов (не забудьте преобразовать в целое число). Если данное значение числа слов меньше переменной-счетчика, то обновите переменную-счетчик.
Напечатайте значение переменной-счетчика. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: История, литература и искусство древнего периода: 50000 слов/История и искусство XI - XIII вв.: 30000 слов/История, литература и искусство конца XIII - XV в.: 90000 слов
История, литература и искусство тюдоровского периода: 15000 слов
Семнадцатый век: 50000 слов/Восемнадцатый век: 60000 слов 
<Вывод>: 15000 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: Поэзия и проза Древнего Востока: 5000 слов
Махабхарата: 900000 слов
Гомер: 17000 слов 
<Вывод>: 5000 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: Глава 1: 5000 слов/Глава 2: 5000 слов/Глава 3: 5000 слов
Глава 4: 50200 слов
Глава 5: 507872500 слов/Глава 6: 10 слова 
<Вывод>: 10 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: Г1: 1700 слов
Г2: 1700 слов
Г3: 1700 слов 
<Вывод>: 1700.0 
<Решение студента>: ch1 = input()
ch2 = input()
ch3 = input()

res = f'{ch1}/{ch2}/{ch3}'.split('/')

counter = 10000000

for item in res:
    item = item.split(': ')[1].split()[0]

    if item < counter:
        counter = item
    
print(counter) 
<Идеальное решение>: ch1 = input()
ch2 = input()
ch3 = input()

res = f'{ch1}/{ch2}/{ch3}'.split('/')

counter = 10000000

for item in res:
    item = int(item.split(': ')[1].split()[0])

    if item < counter:
        counter = item
    
print(counter) 


<Комментарий эксперта>:"
227,510,32,"Мария хочет проверить, какое минимальное количество слов встречается в трех разделах книги. Напишите программу, которая поможет девушке. 

ФОРМАТ ВВОДА 
Вводятся три строки (за каждый раздел книги) в формате '<название главы>: <количество слов> слов'.  Между собой информация о главах разделена прямым слэшем (""/""). 
Гарантируется, что каждая строка состоит из информации минимум об одной главе.
ФОРМАТ ВЫВОДА 
Целое число — минимальное число слов, встречающееся в трех разделах книги. 
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Считайте строки в три разных переменных. Затем объедините эти строки в одну, в качестве разделителя используйте прямой слэш. Сохраните результат в новую переменную.
Создайте переменную-счетчик для определения минимального количества слов.
Разбейте созданную в п.1 переменную по разделителю и обратитесь к каждому элементу полученного списка — из каждой строки вытащите количество слов (не забудьте преобразовать в целое число). Если данное значение числа слов меньше переменной-счетчика, то обновите переменную-счетчик.
Напечатайте значение переменной-счетчика.","['История, литература и искусство древнего периода: 50000 слов/История и искусство XI - XIII вв.: 30000 слов/История, литература и искусство конца XIII - XV в.: 90000 слов\nИстория, литература и искусство тюдоровского периода: 15000 слов\nСемнадцатый век: 50000 слов/Восемнадцатый век: 60000 слов', 'Поэзия и проза Древнего Востока: 5000 слов\nМахабхарата: 900000 слов\nГомер: 17000 слов', 'Глава 1: 5000 слов/Глава 2: 5000 слов/Глава 3: 5000 слов\nГлава 4: 50200 слов\nГлава 5: 507872500 слов/Глава 6: 10 слова', 'Г1: 1700 слов\nГ2: 1700 слов\nГ3: 1700 слов']","['15000', '5000', '10', '1700.0']","ch1 = input()
ch2 = input()
ch3 = input()

res = f'{ch1}/{ch2}/{ch3}'.split('/')

counter = 10000000

for item in res:
    item = int(item.split('; ')[1].split()[0])

    if item < counter:
        counter = item
    
print(counter)","ch1 = input()
ch2 = input()
ch3 = input()

res = f'{ch1}/{ch2}/{ch3}'.split('/')

counter = 10000000

for item in res:
    item = int(item.split(': ')[1].split()[0])

    if item < counter:
        counter = item
    
print(counter)",Ошибка при использовании метода split(). Функция получила некорректный параметр для разделения элементов строки. ,"['open', 'open', 'closed', 'closed']","<Task description>: Мария хочет проверить, какое минимальное количество слов встречается в трех разделах книги. Напишите программу, которая поможет девушке. 

ФОРМАТ ВВОДА 
Вводятся три строки (за каждый раздел книги) в формате '<название главы>: <количество слов> слов'.  Между собой информация о главах разделена прямым слэшем (""/""). 
Гарантируется, что каждая строка состоит из информации минимум об одной главе.
ФОРМАТ ВЫВОДА 
Целое число — минимальное число слов, встречающееся в трех разделах книги. 
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Считайте строки в три разных переменных. Затем объедините эти строки в одну, в качестве разделителя используйте прямой слэш. Сохраните результат в новую переменную.
Создайте переменную-счетчик для определения минимального количества слов.
Разбейте созданную в п.1 переменную по разделителю и обратитесь к каждому элементу полученного списка — из каждой строки вытащите количество слов (не забудьте преобразовать в целое число). Если данное значение числа слов меньше переменной-счетчика, то обновите переменную-счетчик.
Напечатайте значение переменной-счетчика. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: История, литература и искусство древнего периода: 50000 слов/История и искусство XI - XIII вв.: 30000 слов/История, литература и искусство конца XIII - XV в.: 90000 слов
История, литература и искусство тюдоровского периода: 15000 слов
Семнадцатый век: 50000 слов/Восемнадцатый век: 60000 слов 
<Вывод>: 15000 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: Поэзия и проза Древнего Востока: 5000 слов
Махабхарата: 900000 слов
Гомер: 17000 слов 
<Вывод>: 5000 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: Глава 1: 5000 слов/Глава 2: 5000 слов/Глава 3: 5000 слов
Глава 4: 50200 слов
Глава 5: 507872500 слов/Глава 6: 10 слова 
<Вывод>: 10 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: Г1: 1700 слов
Г2: 1700 слов
Г3: 1700 слов 
<Вывод>: 1700.0 
<Решение студента>: ch1 = input()
ch2 = input()
ch3 = input()

res = f'{ch1}/{ch2}/{ch3}'.split('/')

counter = 10000000

for item in res:
    item = int(item.split('; ')[1].split()[0])

    if item < counter:
        counter = item
    
print(counter) 
<Идеальное решение>: ch1 = input()
ch2 = input()
ch3 = input()

res = f'{ch1}/{ch2}/{ch3}'.split('/')

counter = 10000000

for item in res:
    item = int(item.split(': ')[1].split()[0])

    if item < counter:
        counter = item
    
print(counter) 


<Комментарий эксперта>:"
228,511,32,"Мария хочет проверить, какое минимальное количество слов встречается в трех разделах книги. Напишите программу, которая поможет девушке. 

ФОРМАТ ВВОДА 
Вводятся три строки (за каждый раздел книги) в формате '<название главы>: <количество слов> слов'.  Между собой информация о главах разделена прямым слэшем (""/""). 
Гарантируется, что каждая строка состоит из информации минимум об одной главе.
ФОРМАТ ВЫВОДА 
Целое число — минимальное число слов, встречающееся в трех разделах книги. 
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Считайте строки в три разных переменных. Затем объедините эти строки в одну, в качестве разделителя используйте прямой слэш. Сохраните результат в новую переменную.
Создайте переменную-счетчик для определения минимального количества слов.
Разбейте созданную в п.1 переменную по разделителю и обратитесь к каждому элементу полученного списка — из каждой строки вытащите количество слов (не забудьте преобразовать в целое число). Если данное значение числа слов меньше переменной-счетчика, то обновите переменную-счетчик.
Напечатайте значение переменной-счетчика.","['История, литература и искусство древнего периода: 50000 слов/История и искусство XI - XIII вв.: 30000 слов/История, литература и искусство конца XIII - XV в.: 90000 слов\nИстория, литература и искусство тюдоровского периода: 15000 слов\nСемнадцатый век: 50000 слов/Восемнадцатый век: 60000 слов', 'Поэзия и проза Древнего Востока: 5000 слов\nМахабхарата: 900000 слов\nГомер: 17000 слов', 'Глава 1: 5000 слов/Глава 2: 5000 слов/Глава 3: 5000 слов\nГлава 4: 50200 слов\nГлава 5: 507872500 слов/Глава 6: 10 слова', 'Г1: 1700 слов\nГ2: 1700 слов\nГ3: 1700 слов']","['15000', '5000', '10', '1700.0']","ch1 = input()
ch2 = input()
ch3 = input()

res = f'{ch1}/{ch2}/{ch3}'.split('/')

counter = 10000000

for item in res:
    item = int(item.split(': ')[2].split()[1])

    if item < counter:
        counter = item
    
print(counter)","ch1 = input()
ch2 = input()
ch3 = input()

res = f'{ch1}/{ch2}/{ch3}'.split('/')

counter = 10000000

for item in res:
    item = int(item.split(': ')[1].split()[0])

    if item < counter:
        counter = item
    
print(counter)","Ваш код обращается к неверному индексу разделенной переменной item. Помните, что отсчет индексов начинается с 0.","['open', 'open', 'closed', 'closed']","<Task description>: Мария хочет проверить, какое минимальное количество слов встречается в трех разделах книги. Напишите программу, которая поможет девушке. 

ФОРМАТ ВВОДА 
Вводятся три строки (за каждый раздел книги) в формате '<название главы>: <количество слов> слов'.  Между собой информация о главах разделена прямым слэшем (""/""). 
Гарантируется, что каждая строка состоит из информации минимум об одной главе.
ФОРМАТ ВЫВОДА 
Целое число — минимальное число слов, встречающееся в трех разделах книги. 
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Считайте строки в три разных переменных. Затем объедините эти строки в одну, в качестве разделителя используйте прямой слэш. Сохраните результат в новую переменную.
Создайте переменную-счетчик для определения минимального количества слов.
Разбейте созданную в п.1 переменную по разделителю и обратитесь к каждому элементу полученного списка — из каждой строки вытащите количество слов (не забудьте преобразовать в целое число). Если данное значение числа слов меньше переменной-счетчика, то обновите переменную-счетчик.
Напечатайте значение переменной-счетчика. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: История, литература и искусство древнего периода: 50000 слов/История и искусство XI - XIII вв.: 30000 слов/История, литература и искусство конца XIII - XV в.: 90000 слов
История, литература и искусство тюдоровского периода: 15000 слов
Семнадцатый век: 50000 слов/Восемнадцатый век: 60000 слов 
<Вывод>: 15000 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: Поэзия и проза Древнего Востока: 5000 слов
Махабхарата: 900000 слов
Гомер: 17000 слов 
<Вывод>: 5000 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: Глава 1: 5000 слов/Глава 2: 5000 слов/Глава 3: 5000 слов
Глава 4: 50200 слов
Глава 5: 507872500 слов/Глава 6: 10 слова 
<Вывод>: 10 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: Г1: 1700 слов
Г2: 1700 слов
Г3: 1700 слов 
<Вывод>: 1700.0 
<Решение студента>: ch1 = input()
ch2 = input()
ch3 = input()

res = f'{ch1}/{ch2}/{ch3}'.split('/')

counter = 10000000

for item in res:
    item = int(item.split(': ')[2].split()[1])

    if item < counter:
        counter = item
    
print(counter) 
<Идеальное решение>: ch1 = input()
ch2 = input()
ch3 = input()

res = f'{ch1}/{ch2}/{ch3}'.split('/')

counter = 10000000

for item in res:
    item = int(item.split(': ')[1].split()[0])

    if item < counter:
        counter = item
    
print(counter) 


<Комментарий эксперта>:"
229,512,32,"Мария хочет проверить, какое минимальное количество слов встречается в трех разделах книги. Напишите программу, которая поможет девушке. 

ФОРМАТ ВВОДА 
Вводятся три строки (за каждый раздел книги) в формате '<название главы>: <количество слов> слов'.  Между собой информация о главах разделена прямым слэшем (""/""). 
Гарантируется, что каждая строка состоит из информации минимум об одной главе.
ФОРМАТ ВЫВОДА 
Целое число — минимальное число слов, встречающееся в трех разделах книги. 
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Считайте строки в три разных переменных. Затем объедините эти строки в одну, в качестве разделителя используйте прямой слэш. Сохраните результат в новую переменную.
Создайте переменную-счетчик для определения минимального количества слов.
Разбейте созданную в п.1 переменную по разделителю и обратитесь к каждому элементу полученного списка — из каждой строки вытащите количество слов (не забудьте преобразовать в целое число). Если данное значение числа слов меньше переменной-счетчика, то обновите переменную-счетчик.
Напечатайте значение переменной-счетчика.","['История, литература и искусство древнего периода: 50000 слов/История и искусство XI - XIII вв.: 30000 слов/История, литература и искусство конца XIII - XV в.: 90000 слов\nИстория, литература и искусство тюдоровского периода: 15000 слов\nСемнадцатый век: 50000 слов/Восемнадцатый век: 60000 слов', 'Поэзия и проза Древнего Востока: 5000 слов\nМахабхарата: 900000 слов\nГомер: 17000 слов', 'Глава 1: 5000 слов/Глава 2: 5000 слов/Глава 3: 5000 слов\nГлава 4: 50200 слов\nГлава 5: 507872500 слов/Глава 6: 10 слова', 'Г1: 1700 слов\nГ2: 1700 слов\nГ3: 1700 слов']","['15000', '5000', '10', '1700.0']","ch1 = input()
ch2 = input()
ch3 = input()

res = f'{ch1}/{ch2}/{ch3}'.split('/')

counter = 10000000

for item in res:
    item = int(item.split(': ')[1])

    if item < counter:
        counter = item
    
print(counter)","ch1 = input()
ch2 = input()
ch3 = input()

res = f'{ch1}/{ch2}/{ch3}'.split('/')

counter = 10000000

for item in res:
    item = int(item.split(': ')[1].split()[0])

    if item < counter:
        counter = item
    
print(counter)","Ошибка при использовании int(). Вы пытаетесь преобразовать данные, содержащие нечисловые значения.","['open', 'open', 'closed', 'closed']","<Task description>: Мария хочет проверить, какое минимальное количество слов встречается в трех разделах книги. Напишите программу, которая поможет девушке. 

ФОРМАТ ВВОДА 
Вводятся три строки (за каждый раздел книги) в формате '<название главы>: <количество слов> слов'.  Между собой информация о главах разделена прямым слэшем (""/""). 
Гарантируется, что каждая строка состоит из информации минимум об одной главе.
ФОРМАТ ВЫВОДА 
Целое число — минимальное число слов, встречающееся в трех разделах книги. 
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Считайте строки в три разных переменных. Затем объедините эти строки в одну, в качестве разделителя используйте прямой слэш. Сохраните результат в новую переменную.
Создайте переменную-счетчик для определения минимального количества слов.
Разбейте созданную в п.1 переменную по разделителю и обратитесь к каждому элементу полученного списка — из каждой строки вытащите количество слов (не забудьте преобразовать в целое число). Если данное значение числа слов меньше переменной-счетчика, то обновите переменную-счетчик.
Напечатайте значение переменной-счетчика. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: История, литература и искусство древнего периода: 50000 слов/История и искусство XI - XIII вв.: 30000 слов/История, литература и искусство конца XIII - XV в.: 90000 слов
История, литература и искусство тюдоровского периода: 15000 слов
Семнадцатый век: 50000 слов/Восемнадцатый век: 60000 слов 
<Вывод>: 15000 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: Поэзия и проза Древнего Востока: 5000 слов
Махабхарата: 900000 слов
Гомер: 17000 слов 
<Вывод>: 5000 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: Глава 1: 5000 слов/Глава 2: 5000 слов/Глава 3: 5000 слов
Глава 4: 50200 слов
Глава 5: 507872500 слов/Глава 6: 10 слова 
<Вывод>: 10 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: Г1: 1700 слов
Г2: 1700 слов
Г3: 1700 слов 
<Вывод>: 1700.0 
<Решение студента>: ch1 = input()
ch2 = input()
ch3 = input()

res = f'{ch1}/{ch2}/{ch3}'.split('/')

counter = 10000000

for item in res:
    item = int(item.split(': ')[1])

    if item < counter:
        counter = item
    
print(counter) 
<Идеальное решение>: ch1 = input()
ch2 = input()
ch3 = input()

res = f'{ch1}/{ch2}/{ch3}'.split('/')

counter = 10000000

for item in res:
    item = int(item.split(': ')[1].split()[0])

    if item < counter:
        counter = item
    
print(counter) 


<Комментарий эксперта>:"
230,513,32,"Мария хочет проверить, какое минимальное количество слов встречается в трех разделах книги. Напишите программу, которая поможет девушке. 

ФОРМАТ ВВОДА 
Вводятся три строки (за каждый раздел книги) в формате '<название главы>: <количество слов> слов'.  Между собой информация о главах разделена прямым слэшем (""/""). 
Гарантируется, что каждая строка состоит из информации минимум об одной главе.
ФОРМАТ ВЫВОДА 
Целое число — минимальное число слов, встречающееся в трех разделах книги. 
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Считайте строки в три разных переменных. Затем объедините эти строки в одну, в качестве разделителя используйте прямой слэш. Сохраните результат в новую переменную.
Создайте переменную-счетчик для определения минимального количества слов.
Разбейте созданную в п.1 переменную по разделителю и обратитесь к каждому элементу полученного списка — из каждой строки вытащите количество слов (не забудьте преобразовать в целое число). Если данное значение числа слов меньше переменной-счетчика, то обновите переменную-счетчик.
Напечатайте значение переменной-счетчика.","['История, литература и искусство древнего периода: 50000 слов/История и искусство XI - XIII вв.: 30000 слов/История, литература и искусство конца XIII - XV в.: 90000 слов\nИстория, литература и искусство тюдоровского периода: 15000 слов\nСемнадцатый век: 50000 слов/Восемнадцатый век: 60000 слов', 'Поэзия и проза Древнего Востока: 5000 слов\nМахабхарата: 900000 слов\nГомер: 17000 слов', 'Глава 1: 5000 слов/Глава 2: 5000 слов/Глава 3: 5000 слов\nГлава 4: 50200 слов\nГлава 5: 507872500 слов/Глава 6: 10 слова', 'Г1: 1700 слов\nГ2: 1700 слов\nГ3: 1700 слов']","['15000', '5000', '10', '1700.0']","ch1 = input()
ch2 = input()
ch3 = input()

res = f'{ch1}/{ch2}/{ch3}'.split('/')

counter = 10000000

for item in res:
    item = int(item.split(': ')[1].split()[0])

    if item <= counter:
        counter = item
    
print(counter)","ch1 = input()
ch2 = input()
ch3 = input()

res = f'{ch1}/{ch2}/{ch3}'.split('/')

counter = 10000000

for item in res:
    item = int(item.split(': ')[1].split()[0])

    if item < counter:
        counter = item
    
print(counter)","Ошибка в открытых и скрытых тестах. 

Ваш код некорректно выполняет условия задания. Например, он некорректно выполняет условие ""выводится целое число — минимальное число слов, встречающееся в трех разделах книги."". Попробуйте изменить условие if, чтобы скорректировать ошибку.","['open', 'open', 'closed', 'closed']","<Task description>: Мария хочет проверить, какое минимальное количество слов встречается в трех разделах книги. Напишите программу, которая поможет девушке. 

ФОРМАТ ВВОДА 
Вводятся три строки (за каждый раздел книги) в формате '<название главы>: <количество слов> слов'.  Между собой информация о главах разделена прямым слэшем (""/""). 
Гарантируется, что каждая строка состоит из информации минимум об одной главе.
ФОРМАТ ВЫВОДА 
Целое число — минимальное число слов, встречающееся в трех разделах книги. 
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Считайте строки в три разных переменных. Затем объедините эти строки в одну, в качестве разделителя используйте прямой слэш. Сохраните результат в новую переменную.
Создайте переменную-счетчик для определения минимального количества слов.
Разбейте созданную в п.1 переменную по разделителю и обратитесь к каждому элементу полученного списка — из каждой строки вытащите количество слов (не забудьте преобразовать в целое число). Если данное значение числа слов меньше переменной-счетчика, то обновите переменную-счетчик.
Напечатайте значение переменной-счетчика. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: История, литература и искусство древнего периода: 50000 слов/История и искусство XI - XIII вв.: 30000 слов/История, литература и искусство конца XIII - XV в.: 90000 слов
История, литература и искусство тюдоровского периода: 15000 слов
Семнадцатый век: 50000 слов/Восемнадцатый век: 60000 слов 
<Вывод>: 15000 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: Поэзия и проза Древнего Востока: 5000 слов
Махабхарата: 900000 слов
Гомер: 17000 слов 
<Вывод>: 5000 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: Глава 1: 5000 слов/Глава 2: 5000 слов/Глава 3: 5000 слов
Глава 4: 50200 слов
Глава 5: 507872500 слов/Глава 6: 10 слова 
<Вывод>: 10 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: Г1: 1700 слов
Г2: 1700 слов
Г3: 1700 слов 
<Вывод>: 1700.0 
<Решение студента>: ch1 = input()
ch2 = input()
ch3 = input()

res = f'{ch1}/{ch2}/{ch3}'.split('/')

counter = 10000000

for item in res:
    item = int(item.split(': ')[1].split()[0])

    if item <= counter:
        counter = item
    
print(counter) 
<Идеальное решение>: ch1 = input()
ch2 = input()
ch3 = input()

res = f'{ch1}/{ch2}/{ch3}'.split('/')

counter = 10000000

for item in res:
    item = int(item.split(': ')[1].split()[0])

    if item < counter:
        counter = item
    
print(counter) 


<Комментарий эксперта>:"
231,514,32,"Мария хочет проверить, какое минимальное количество слов встречается в трех разделах книги. Напишите программу, которая поможет девушке. 

ФОРМАТ ВВОДА 
Вводятся три строки (за каждый раздел книги) в формате '<название главы>: <количество слов> слов'.  Между собой информация о главах разделена прямым слэшем (""/""). 
Гарантируется, что каждая строка состоит из информации минимум об одной главе.
ФОРМАТ ВЫВОДА 
Целое число — минимальное число слов, встречающееся в трех разделах книги. 
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Считайте строки в три разных переменных. Затем объедините эти строки в одну, в качестве разделителя используйте прямой слэш. Сохраните результат в новую переменную.
Создайте переменную-счетчик для определения минимального количества слов.
Разбейте созданную в п.1 переменную по разделителю и обратитесь к каждому элементу полученного списка — из каждой строки вытащите количество слов (не забудьте преобразовать в целое число). Если данное значение числа слов меньше переменной-счетчика, то обновите переменную-счетчик.
Напечатайте значение переменной-счетчика.","['История, литература и искусство древнего периода: 50000 слов/История и искусство XI - XIII вв.: 30000 слов/История, литература и искусство конца XIII - XV в.: 90000 слов\nИстория, литература и искусство тюдоровского периода: 15000 слов\nСемнадцатый век: 50000 слов/Восемнадцатый век: 60000 слов', 'Поэзия и проза Древнего Востока: 5000 слов\nМахабхарата: 900000 слов\nГомер: 17000 слов', 'Глава 1: 5000 слов/Глава 2: 5000 слов/Глава 3: 5000 слов\nГлава 4: 50200 слов\nГлава 5: 507872500 слов/Глава 6: 10 слова', 'Г1: 1700 слов\nГ2: 1700 слов\nГ3: 1700 слов']","['15000', '5000', '10', '1700.0']","ch1 = input()
ch2 = input()
ch3 = input()

res = f'{ch1}/{ch2}/{ch3}'.split('/')

counter = 10000000

for item in res:
    item = int(item.split(': ')[1].split()[0])

    if item > counter:
        counter = item
    
print(counter)","ch1 = input()
ch2 = input()
ch3 = input()

res = f'{ch1}/{ch2}/{ch3}'.split('/')

counter = 10000000

for item in res:
    item = int(item.split(': ')[1].split()[0])

    if item < counter:
        counter = item
    
print(counter)","Ошибка в открытых и скрытых тестах. 

Ваш код некорректно выполняет условия задания. Например, он некорректно выполняет условие ""выводится целое число — минимальное число слов, встречающееся в трех разделах книги."". Попробуйте изменить условие if, чтобы скорректировать ошибку.","['open', 'open', 'closed', 'closed']","<Task description>: Мария хочет проверить, какое минимальное количество слов встречается в трех разделах книги. Напишите программу, которая поможет девушке. 

ФОРМАТ ВВОДА 
Вводятся три строки (за каждый раздел книги) в формате '<название главы>: <количество слов> слов'.  Между собой информация о главах разделена прямым слэшем (""/""). 
Гарантируется, что каждая строка состоит из информации минимум об одной главе.
ФОРМАТ ВЫВОДА 
Целое число — минимальное число слов, встречающееся в трех разделах книги. 
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Считайте строки в три разных переменных. Затем объедините эти строки в одну, в качестве разделителя используйте прямой слэш. Сохраните результат в новую переменную.
Создайте переменную-счетчик для определения минимального количества слов.
Разбейте созданную в п.1 переменную по разделителю и обратитесь к каждому элементу полученного списка — из каждой строки вытащите количество слов (не забудьте преобразовать в целое число). Если данное значение числа слов меньше переменной-счетчика, то обновите переменную-счетчик.
Напечатайте значение переменной-счетчика. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: История, литература и искусство древнего периода: 50000 слов/История и искусство XI - XIII вв.: 30000 слов/История, литература и искусство конца XIII - XV в.: 90000 слов
История, литература и искусство тюдоровского периода: 15000 слов
Семнадцатый век: 50000 слов/Восемнадцатый век: 60000 слов 
<Вывод>: 15000 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: Поэзия и проза Древнего Востока: 5000 слов
Махабхарата: 900000 слов
Гомер: 17000 слов 
<Вывод>: 5000 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: Глава 1: 5000 слов/Глава 2: 5000 слов/Глава 3: 5000 слов
Глава 4: 50200 слов
Глава 5: 507872500 слов/Глава 6: 10 слова 
<Вывод>: 10 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: Г1: 1700 слов
Г2: 1700 слов
Г3: 1700 слов 
<Вывод>: 1700.0 
<Решение студента>: ch1 = input()
ch2 = input()
ch3 = input()

res = f'{ch1}/{ch2}/{ch3}'.split('/')

counter = 10000000

for item in res:
    item = int(item.split(': ')[1].split()[0])

    if item > counter:
        counter = item
    
print(counter) 
<Идеальное решение>: ch1 = input()
ch2 = input()
ch3 = input()

res = f'{ch1}/{ch2}/{ch3}'.split('/')

counter = 10000000

for item in res:
    item = int(item.split(': ')[1].split()[0])

    if item < counter:
        counter = item
    
print(counter) 


<Комментарий эксперта>:"
232,515,32,"Мария хочет проверить, какое минимальное количество слов встречается в трех разделах книги. Напишите программу, которая поможет девушке. 

ФОРМАТ ВВОДА 
Вводятся три строки (за каждый раздел книги) в формате '<название главы>: <количество слов> слов'.  Между собой информация о главах разделена прямым слэшем (""/""). 
Гарантируется, что каждая строка состоит из информации минимум об одной главе.
ФОРМАТ ВЫВОДА 
Целое число — минимальное число слов, встречающееся в трех разделах книги. 
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Считайте строки в три разных переменных. Затем объедините эти строки в одну, в качестве разделителя используйте прямой слэш. Сохраните результат в новую переменную.
Создайте переменную-счетчик для определения минимального количества слов.
Разбейте созданную в п.1 переменную по разделителю и обратитесь к каждому элементу полученного списка — из каждой строки вытащите количество слов (не забудьте преобразовать в целое число). Если данное значение числа слов меньше переменной-счетчика, то обновите переменную-счетчик.
Напечатайте значение переменной-счетчика.","['История, литература и искусство древнего периода: 50000 слов/История и искусство XI - XIII вв.: 30000 слов/История, литература и искусство конца XIII - XV в.: 90000 слов\nИстория, литература и искусство тюдоровского периода: 15000 слов\nСемнадцатый век: 50000 слов/Восемнадцатый век: 60000 слов', 'Поэзия и проза Древнего Востока: 5000 слов\nМахабхарата: 900000 слов\nГомер: 17000 слов', 'Глава 1: 5000 слов/Глава 2: 5000 слов/Глава 3: 5000 слов\nГлава 4: 50200 слов\nГлава 5: 507872500 слов/Глава 6: 10 слова', 'Г1: 1700 слов\nГ2: 1700 слов\nГ3: 1700 слов']","['15000', '5000', '10', '1700.0']","ch1 = input()
ch2 = input()
ch3 = input()

res = f'{ch1}/{ch2}/{ch3}'.split('/')

counter = 10000000

for item in res:
    item = int(item.split(': ')[1].split()[0])

    if item < counter:
        counter == item
    
print(counter)","ch1 = input()
ch2 = input()
ch3 = input()

res = f'{ch1}/{ch2}/{ch3}'.split('/')

counter = 10000000

for item in res:
    item = int(item.split(': ')[1].split()[0])

    if item < counter:
        counter = item
    
print(counter)",Синтаксическая ошибка. При перезаписывании значения переменной используйте знак одинарного равенства.,"['open', 'open', 'closed', 'closed']","<Task description>: Мария хочет проверить, какое минимальное количество слов встречается в трех разделах книги. Напишите программу, которая поможет девушке. 

ФОРМАТ ВВОДА 
Вводятся три строки (за каждый раздел книги) в формате '<название главы>: <количество слов> слов'.  Между собой информация о главах разделена прямым слэшем (""/""). 
Гарантируется, что каждая строка состоит из информации минимум об одной главе.
ФОРМАТ ВЫВОДА 
Целое число — минимальное число слов, встречающееся в трех разделах книги. 
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Считайте строки в три разных переменных. Затем объедините эти строки в одну, в качестве разделителя используйте прямой слэш. Сохраните результат в новую переменную.
Создайте переменную-счетчик для определения минимального количества слов.
Разбейте созданную в п.1 переменную по разделителю и обратитесь к каждому элементу полученного списка — из каждой строки вытащите количество слов (не забудьте преобразовать в целое число). Если данное значение числа слов меньше переменной-счетчика, то обновите переменную-счетчик.
Напечатайте значение переменной-счетчика. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: История, литература и искусство древнего периода: 50000 слов/История и искусство XI - XIII вв.: 30000 слов/История, литература и искусство конца XIII - XV в.: 90000 слов
История, литература и искусство тюдоровского периода: 15000 слов
Семнадцатый век: 50000 слов/Восемнадцатый век: 60000 слов 
<Вывод>: 15000 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: Поэзия и проза Древнего Востока: 5000 слов
Махабхарата: 900000 слов
Гомер: 17000 слов 
<Вывод>: 5000 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: Глава 1: 5000 слов/Глава 2: 5000 слов/Глава 3: 5000 слов
Глава 4: 50200 слов
Глава 5: 507872500 слов/Глава 6: 10 слова 
<Вывод>: 10 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: Г1: 1700 слов
Г2: 1700 слов
Г3: 1700 слов 
<Вывод>: 1700.0 
<Решение студента>: ch1 = input()
ch2 = input()
ch3 = input()

res = f'{ch1}/{ch2}/{ch3}'.split('/')

counter = 10000000

for item in res:
    item = int(item.split(': ')[1].split()[0])

    if item < counter:
        counter == item
    
print(counter) 
<Идеальное решение>: ch1 = input()
ch2 = input()
ch3 = input()

res = f'{ch1}/{ch2}/{ch3}'.split('/')

counter = 10000000

for item in res:
    item = int(item.split(': ')[1].split()[0])

    if item < counter:
        counter = item
    
print(counter) 


<Комментарий эксперта>:"
233,516,32,"Мария хочет проверить, какое минимальное количество слов встречается в трех разделах книги. Напишите программу, которая поможет девушке. 

ФОРМАТ ВВОДА 
Вводятся три строки (за каждый раздел книги) в формате '<название главы>: <количество слов> слов'.  Между собой информация о главах разделена прямым слэшем (""/""). 
Гарантируется, что каждая строка состоит из информации минимум об одной главе.
ФОРМАТ ВЫВОДА 
Целое число — минимальное число слов, встречающееся в трех разделах книги. 
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Считайте строки в три разных переменных. Затем объедините эти строки в одну, в качестве разделителя используйте прямой слэш. Сохраните результат в новую переменную.
Создайте переменную-счетчик для определения минимального количества слов.
Разбейте созданную в п.1 переменную по разделителю и обратитесь к каждому элементу полученного списка — из каждой строки вытащите количество слов (не забудьте преобразовать в целое число). Если данное значение числа слов меньше переменной-счетчика, то обновите переменную-счетчик.
Напечатайте значение переменной-счетчика.","['История, литература и искусство древнего периода: 50000 слов/История и искусство XI - XIII вв.: 30000 слов/История, литература и искусство конца XIII - XV в.: 90000 слов\nИстория, литература и искусство тюдоровского периода: 15000 слов\nСемнадцатый век: 50000 слов/Восемнадцатый век: 60000 слов', 'Поэзия и проза Древнего Востока: 5000 слов\nМахабхарата: 900000 слов\nГомер: 17000 слов', 'Глава 1: 5000 слов/Глава 2: 5000 слов/Глава 3: 5000 слов\nГлава 4: 50200 слов\nГлава 5: 507872500 слов/Глава 6: 10 слова', 'Г1: 1700 слов\nГ2: 1700 слов\nГ3: 1700 слов']","['15000', '5000', '10', '1700.0']","ch1 = input()
ch2 = input()
ch3 = input()

res = f'{ch1}/{ch2}/{ch3}'.split('/')

counter = 10000000

for item in res:
    item = int(item.split(': ')[1].split()[0])

    if item < counter:
        counter = item
    
print(item)","ch1 = input()
ch2 = input()
ch3 = input()

res = f'{ch1}/{ch2}/{ch3}'.split('/')

counter = 10000000

for item in res:
    item = int(item.split(': ')[1].split()[0])

    if item < counter:
        counter = item
    
print(counter)","Ошибка в открытых и скрытых тестах. 

Ваш код возвращает некорректную переменную.","['open', 'open', 'closed', 'closed']","<Task description>: Мария хочет проверить, какое минимальное количество слов встречается в трех разделах книги. Напишите программу, которая поможет девушке. 

ФОРМАТ ВВОДА 
Вводятся три строки (за каждый раздел книги) в формате '<название главы>: <количество слов> слов'.  Между собой информация о главах разделена прямым слэшем (""/""). 
Гарантируется, что каждая строка состоит из информации минимум об одной главе.
ФОРМАТ ВЫВОДА 
Целое число — минимальное число слов, встречающееся в трех разделах книги. 
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Считайте строки в три разных переменных. Затем объедините эти строки в одну, в качестве разделителя используйте прямой слэш. Сохраните результат в новую переменную.
Создайте переменную-счетчик для определения минимального количества слов.
Разбейте созданную в п.1 переменную по разделителю и обратитесь к каждому элементу полученного списка — из каждой строки вытащите количество слов (не забудьте преобразовать в целое число). Если данное значение числа слов меньше переменной-счетчика, то обновите переменную-счетчик.
Напечатайте значение переменной-счетчика. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: История, литература и искусство древнего периода: 50000 слов/История и искусство XI - XIII вв.: 30000 слов/История, литература и искусство конца XIII - XV в.: 90000 слов
История, литература и искусство тюдоровского периода: 15000 слов
Семнадцатый век: 50000 слов/Восемнадцатый век: 60000 слов 
<Вывод>: 15000 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: Поэзия и проза Древнего Востока: 5000 слов
Махабхарата: 900000 слов
Гомер: 17000 слов 
<Вывод>: 5000 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: Глава 1: 5000 слов/Глава 2: 5000 слов/Глава 3: 5000 слов
Глава 4: 50200 слов
Глава 5: 507872500 слов/Глава 6: 10 слова 
<Вывод>: 10 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: Г1: 1700 слов
Г2: 1700 слов
Г3: 1700 слов 
<Вывод>: 1700.0 
<Решение студента>: ch1 = input()
ch2 = input()
ch3 = input()

res = f'{ch1}/{ch2}/{ch3}'.split('/')

counter = 10000000

for item in res:
    item = int(item.split(': ')[1].split()[0])

    if item < counter:
        counter = item
    
print(item) 
<Идеальное решение>: ch1 = input()
ch2 = input()
ch3 = input()

res = f'{ch1}/{ch2}/{ch3}'.split('/')

counter = 10000000

for item in res:
    item = int(item.split(': ')[1].split()[0])

    if item < counter:
        counter = item
    
print(counter) 


<Комментарий эксперта>:"
234,517,32,"Мария хочет проверить, какое минимальное количество слов встречается в трех разделах книги. Напишите программу, которая поможет девушке. 

ФОРМАТ ВВОДА 
Вводятся три строки (за каждый раздел книги) в формате '<название главы>: <количество слов> слов'.  Между собой информация о главах разделена прямым слэшем (""/""). 
Гарантируется, что каждая строка состоит из информации минимум об одной главе.
ФОРМАТ ВЫВОДА 
Целое число — минимальное число слов, встречающееся в трех разделах книги. 
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Считайте строки в три разных переменных. Затем объедините эти строки в одну, в качестве разделителя используйте прямой слэш. Сохраните результат в новую переменную.
Создайте переменную-счетчик для определения минимального количества слов.
Разбейте созданную в п.1 переменную по разделителю и обратитесь к каждому элементу полученного списка — из каждой строки вытащите количество слов (не забудьте преобразовать в целое число). Если данное значение числа слов меньше переменной-счетчика, то обновите переменную-счетчик.
Напечатайте значение переменной-счетчика.","['История, литература и искусство древнего периода: 50000 слов/История и искусство XI - XIII вв.: 30000 слов/История, литература и искусство конца XIII - XV в.: 90000 слов\nИстория, литература и искусство тюдоровского периода: 15000 слов\nСемнадцатый век: 50000 слов/Восемнадцатый век: 60000 слов', 'Поэзия и проза Древнего Востока: 5000 слов\nМахабхарата: 900000 слов\nГомер: 17000 слов', 'Глава 1: 5000 слов/Глава 2: 5000 слов/Глава 3: 5000 слов\nГлава 4: 50200 слов\nГлава 5: 507872500 слов/Глава 6: 10 слова', 'Г1: 1700 слов\nГ2: 1700 слов\nГ3: 1700 слов']","['15000', '5000', '10', '1700.0']","ch1 = input()
ch2 = input()
ch3 = input()

res = f'{ch1}/{ch2}/{ch3}'.split('/')

counter = 10000000

for item in res:
    item = int(item.split(': ')[1].split()[0])

    if item < counter:
        counter = item
    
    print(counter)","ch1 = input()
ch2 = input()
ch3 = input()

res = f'{ch1}/{ch2}/{ch3}'.split('/')

counter = 10000000

for item in res:
    item = int(item.split(': ')[1].split()[0])

    if item < counter:
        counter = item
    
print(counter)",Некорректная табуляция функции print().,"['open', 'open', 'closed', 'closed']","<Task description>: Мария хочет проверить, какое минимальное количество слов встречается в трех разделах книги. Напишите программу, которая поможет девушке. 

ФОРМАТ ВВОДА 
Вводятся три строки (за каждый раздел книги) в формате '<название главы>: <количество слов> слов'.  Между собой информация о главах разделена прямым слэшем (""/""). 
Гарантируется, что каждая строка состоит из информации минимум об одной главе.
ФОРМАТ ВЫВОДА 
Целое число — минимальное число слов, встречающееся в трех разделах книги. 
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Считайте строки в три разных переменных. Затем объедините эти строки в одну, в качестве разделителя используйте прямой слэш. Сохраните результат в новую переменную.
Создайте переменную-счетчик для определения минимального количества слов.
Разбейте созданную в п.1 переменную по разделителю и обратитесь к каждому элементу полученного списка — из каждой строки вытащите количество слов (не забудьте преобразовать в целое число). Если данное значение числа слов меньше переменной-счетчика, то обновите переменную-счетчик.
Напечатайте значение переменной-счетчика. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: История, литература и искусство древнего периода: 50000 слов/История и искусство XI - XIII вв.: 30000 слов/История, литература и искусство конца XIII - XV в.: 90000 слов
История, литература и искусство тюдоровского периода: 15000 слов
Семнадцатый век: 50000 слов/Восемнадцатый век: 60000 слов 
<Вывод>: 15000 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: Поэзия и проза Древнего Востока: 5000 слов
Махабхарата: 900000 слов
Гомер: 17000 слов 
<Вывод>: 5000 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: Глава 1: 5000 слов/Глава 2: 5000 слов/Глава 3: 5000 слов
Глава 4: 50200 слов
Глава 5: 507872500 слов/Глава 6: 10 слова 
<Вывод>: 10 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: Г1: 1700 слов
Г2: 1700 слов
Г3: 1700 слов 
<Вывод>: 1700.0 
<Решение студента>: ch1 = input()
ch2 = input()
ch3 = input()

res = f'{ch1}/{ch2}/{ch3}'.split('/')

counter = 10000000

for item in res:
    item = int(item.split(': ')[1].split()[0])

    if item < counter:
        counter = item
    
    print(counter) 
<Идеальное решение>: ch1 = input()
ch2 = input()
ch3 = input()

res = f'{ch1}/{ch2}/{ch3}'.split('/')

counter = 10000000

for item in res:
    item = int(item.split(': ')[1].split()[0])

    if item < counter:
        counter = item
    
print(counter) 


<Комментарий эксперта>:"
235,518,32,"Мария хочет проверить, какое минимальное количество слов встречается в трех разделах книги. Напишите программу, которая поможет девушке. 

ФОРМАТ ВВОДА 
Вводятся три строки (за каждый раздел книги) в формате '<название главы>: <количество слов> слов'.  Между собой информация о главах разделена прямым слэшем (""/""). 
Гарантируется, что каждая строка состоит из информации минимум об одной главе.
ФОРМАТ ВЫВОДА 
Целое число — минимальное число слов, встречающееся в трех разделах книги. 
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Считайте строки в три разных переменных. Затем объедините эти строки в одну, в качестве разделителя используйте прямой слэш. Сохраните результат в новую переменную.
Создайте переменную-счетчик для определения минимального количества слов.
Разбейте созданную в п.1 переменную по разделителю и обратитесь к каждому элементу полученного списка — из каждой строки вытащите количество слов (не забудьте преобразовать в целое число). Если данное значение числа слов меньше переменной-счетчика, то обновите переменную-счетчик.
Напечатайте значение переменной-счетчика.","['История, литература и искусство древнего периода: 50000 слов/История и искусство XI - XIII вв.: 30000 слов/История, литература и искусство конца XIII - XV в.: 90000 слов\nИстория, литература и искусство тюдоровского периода: 15000 слов\nСемнадцатый век: 50000 слов/Восемнадцатый век: 60000 слов', 'Поэзия и проза Древнего Востока: 5000 слов\nМахабхарата: 900000 слов\nГомер: 17000 слов', 'Глава 1: 5000 слов/Глава 2: 5000 слов/Глава 3: 5000 слов\nГлава 4: 50200 слов\nГлава 5: 507872500 слов/Глава 6: 10 слова', 'Г1: 1700 слов\nГ2: 1700 слов\nГ3: 1700 слов']","['15000', '5000', '10', '1700.0']","ch1 = input()
ch2 = input()
ch3 = input()

res = f'{ch1}/{ch2}/{ch3}'.split('/')

counter = 10000000

for item in res:
    item = int(item.split(': ')[1].split()[0])

if item < counter:
    counter = item
    
print(counter)","ch1 = input()
ch2 = input()
ch3 = input()

res = f'{ch1}/{ch2}/{ch3}'.split('/')

counter = 10000000

for item in res:
    item = int(item.split(': ')[1].split()[0])

    if item < counter:
        counter = item
    
print(counter)",Некорректная табуляция условной конструкции if.,"['open', 'open', 'closed', 'closed']","<Task description>: Мария хочет проверить, какое минимальное количество слов встречается в трех разделах книги. Напишите программу, которая поможет девушке. 

ФОРМАТ ВВОДА 
Вводятся три строки (за каждый раздел книги) в формате '<название главы>: <количество слов> слов'.  Между собой информация о главах разделена прямым слэшем (""/""). 
Гарантируется, что каждая строка состоит из информации минимум об одной главе.
ФОРМАТ ВЫВОДА 
Целое число — минимальное число слов, встречающееся в трех разделах книги. 
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Считайте строки в три разных переменных. Затем объедините эти строки в одну, в качестве разделителя используйте прямой слэш. Сохраните результат в новую переменную.
Создайте переменную-счетчик для определения минимального количества слов.
Разбейте созданную в п.1 переменную по разделителю и обратитесь к каждому элементу полученного списка — из каждой строки вытащите количество слов (не забудьте преобразовать в целое число). Если данное значение числа слов меньше переменной-счетчика, то обновите переменную-счетчик.
Напечатайте значение переменной-счетчика. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: История, литература и искусство древнего периода: 50000 слов/История и искусство XI - XIII вв.: 30000 слов/История, литература и искусство конца XIII - XV в.: 90000 слов
История, литература и искусство тюдоровского периода: 15000 слов
Семнадцатый век: 50000 слов/Восемнадцатый век: 60000 слов 
<Вывод>: 15000 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: Поэзия и проза Древнего Востока: 5000 слов
Махабхарата: 900000 слов
Гомер: 17000 слов 
<Вывод>: 5000 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: Глава 1: 5000 слов/Глава 2: 5000 слов/Глава 3: 5000 слов
Глава 4: 50200 слов
Глава 5: 507872500 слов/Глава 6: 10 слова 
<Вывод>: 10 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: Г1: 1700 слов
Г2: 1700 слов
Г3: 1700 слов 
<Вывод>: 1700.0 
<Решение студента>: ch1 = input()
ch2 = input()
ch3 = input()

res = f'{ch1}/{ch2}/{ch3}'.split('/')

counter = 10000000

for item in res:
    item = int(item.split(': ')[1].split()[0])

if item < counter:
    counter = item
    
print(counter) 
<Идеальное решение>: ch1 = input()
ch2 = input()
ch3 = input()

res = f'{ch1}/{ch2}/{ch3}'.split('/')

counter = 10000000

for item in res:
    item = int(item.split(': ')[1].split()[0])

    if item < counter:
        counter = item
    
print(counter) 


<Комментарий эксперта>:"
236,537,34,"Напишите функцию, определяющую можно считать книгу переведенной или нет. 

ТРЕБУЕМАЯ ФУНКЦИЯ 
Функция text_check, принимающая на вход словарь, ключи в котором — названия глав (строки), а значения — кортежи с двумя элементами (целым числом — количеством слов в главе; и строкой ""переведена"" или ""не переведена""). Гарантируется, что словарь содержит информацию минимум об одной главе.
Если хотя бы одна глава была переведена, то функция должна возвращать список из двух значений: логической константы True и целого числа — количества слов в главах, которые были переведены.
Если все главы не были переведены, то функция возвращает логическую константу False.
ВАЖНО! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Определите функцию и аргумент, с которым она работает.
Задайте две переменные-счетчика — одну для подсчета количества слов, другую для подсчета количества строк ""переведена"".
Обратитесь к парам ключ-значение в переданном функции словаре. Если первый по индексу элемент значения (кортежа) принимает значение ""переведена"", то прибавьте 1 к первой переменной-счетчику и прибавьте нулевой по индексу элемент значения (кортежа) ко второй переменной-счетчику.
Проверьте, что первая переменная-счетчик не равна нулю, и если да, то пусть функция вернет список из двух значений: логической константы True и значения второй-переменной счетчика; иначе пусть функция вернет логическую константу False.","[""{\n    'Глава 1': (3000, 'не переведена'), \n    'Глава 2': (2000, 'не переведена'), \n    'Глава 3': (10000, 'не переведена'), \n    'Глава 4': (6000, 'не переведена'),\n    'Глава 5': (6500, 'не переведена')\n}"", ""{\n    'Героический эпос народов СССР. № 1': (100000, 'переведена'),\n    'Героический эпос народов СССР. № 2': (1005, 'не переведена')\n}"", ""{\n    'Арабская поэзия средних веков': (1092, 'не переведена'),\n    'Ирано-таджикская поэзия': (10090, 'переведена'),\n    'Средневековый роман и повесть': (2198, 'переведена')\n}"", ""{\n    'г1': (90, 'не переведена'), \n    'г2': (29, 'не переведена'), \n    'г3': (10, 'не переведена'), \n    'г4': (80, 'не переведена'),\n    'г5': (8, 'не переведена')\n}"", ""{\n    'повесть': (32, 'переведена'), \n    'поэма': (212, 'переведена'), \n    'роман': (809, 'переведена'),\n    'рассказы': (80, 'переведена')\n}"", ""{\n    'ода': (312, 'не переведена'), \n    'новелла': (2112, 'переведена'), \n    'юмореска': (809, 'переведена'),\n    'сатира': (89280, 'не переведена')\n}""]","['False', '[True, 100000]', '[True, 12288]', 'False', '[True, 1133]', '[True, 2921]']","def text_check(data)
    counter = 0
    summa = 0
    for k, v in data.items():
        if v[1] == 'переведена':
            counter += 1
            summa += v[0]
            
    if counter != 0:
        return ([True, summa])
        
    return False","def text_check(data):
    counter = 0
    summa = 0
    for k, v in data.items():
        if v[1] == 'переведена':
            counter += 1
            summa += v[0]
            
    if counter != 0:
        return ([True, summa])
        
    return False",Вы забыли поставить двоеточие после определения функции.,"['open', 'open', 'open', 'closed', 'closed', 'closed']","<Task description>: Напишите функцию, определяющую можно считать книгу переведенной или нет. 

ТРЕБУЕМАЯ ФУНКЦИЯ 
Функция text_check, принимающая на вход словарь, ключи в котором — названия глав (строки), а значения — кортежи с двумя элементами (целым числом — количеством слов в главе; и строкой ""переведена"" или ""не переведена""). Гарантируется, что словарь содержит информацию минимум об одной главе.
Если хотя бы одна глава была переведена, то функция должна возвращать список из двух значений: логической константы True и целого числа — количества слов в главах, которые были переведены.
Если все главы не были переведены, то функция возвращает логическую константу False.
ВАЖНО! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Определите функцию и аргумент, с которым она работает.
Задайте две переменные-счетчика — одну для подсчета количества слов, другую для подсчета количества строк ""переведена"".
Обратитесь к парам ключ-значение в переданном функции словаре. Если первый по индексу элемент значения (кортежа) принимает значение ""переведена"", то прибавьте 1 к первой переменной-счетчику и прибавьте нулевой по индексу элемент значения (кортежа) ко второй переменной-счетчику.
Проверьте, что первая переменная-счетчик не равна нулю, и если да, то пусть функция вернет список из двух значений: логической константы True и значения второй-переменной счетчика; иначе пусть функция вернет логическую константу False. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: {
    'Глава 1': (3000, 'не переведена'), 
    'Глава 2': (2000, 'не переведена'), 
    'Глава 3': (10000, 'не переведена'), 
    'Глава 4': (6000, 'не переведена'),
    'Глава 5': (6500, 'не переведена')
} 
<Вывод>: False 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: {
    'Героический эпос народов СССР. № 1': (100000, 'переведена'),
    'Героический эпос народов СССР. № 2': (1005, 'не переведена')
} 
<Вывод>: [True, 100000] 
<Example 3>: 
<Тип теста 3>: open 
<Ввод>: {
    'Арабская поэзия средних веков': (1092, 'не переведена'),
    'Ирано-таджикская поэзия': (10090, 'переведена'),
    'Средневековый роман и повесть': (2198, 'переведена')
} 
<Вывод>: [True, 12288] 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: {
    'г1': (90, 'не переведена'), 
    'г2': (29, 'не переведена'), 
    'г3': (10, 'не переведена'), 
    'г4': (80, 'не переведена'),
    'г5': (8, 'не переведена')
} 
<Вывод>: False 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: {
    'повесть': (32, 'переведена'), 
    'поэма': (212, 'переведена'), 
    'роман': (809, 'переведена'),
    'рассказы': (80, 'переведена')
} 
<Вывод>: [True, 1133] 
<Example 6>: 
<Тип теста 6>: closed 
<Ввод>: {
    'ода': (312, 'не переведена'), 
    'новелла': (2112, 'переведена'), 
    'юмореска': (809, 'переведена'),
    'сатира': (89280, 'не переведена')
} 
<Вывод>: [True, 2921] 
<Решение студента>: def text_check(data)
    counter = 0
    summa = 0
    for k, v in data.items():
        if v[1] == 'переведена':
            counter += 1
            summa += v[0]
            
    if counter != 0:
        return ([True, summa])
        
    return False 
<Идеальное решение>: def text_check(data):
    counter = 0
    summa = 0
    for k, v in data.items():
        if v[1] == 'переведена':
            counter += 1
            summa += v[0]
            
    if counter != 0:
        return ([True, summa])
        
    return False 


<Комментарий эксперта>:"
237,538,34,"Напишите функцию, определяющую можно считать книгу переведенной или нет. 

ТРЕБУЕМАЯ ФУНКЦИЯ 
Функция text_check, принимающая на вход словарь, ключи в котором — названия глав (строки), а значения — кортежи с двумя элементами (целым числом — количеством слов в главе; и строкой ""переведена"" или ""не переведена""). Гарантируется, что словарь содержит информацию минимум об одной главе.
Если хотя бы одна глава была переведена, то функция должна возвращать список из двух значений: логической константы True и целого числа — количества слов в главах, которые были переведены.
Если все главы не были переведены, то функция возвращает логическую константу False.
ВАЖНО! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Определите функцию и аргумент, с которым она работает.
Задайте две переменные-счетчика — одну для подсчета количества слов, другую для подсчета количества строк ""переведена"".
Обратитесь к парам ключ-значение в переданном функции словаре. Если первый по индексу элемент значения (кортежа) принимает значение ""переведена"", то прибавьте 1 к первой переменной-счетчику и прибавьте нулевой по индексу элемент значения (кортежа) ко второй переменной-счетчику.
Проверьте, что первая переменная-счетчик не равна нулю, и если да, то пусть функция вернет список из двух значений: логической константы True и значения второй-переменной счетчика; иначе пусть функция вернет логическую константу False.","[""{\n    'Глава 1': (3000, 'не переведена'), \n    'Глава 2': (2000, 'не переведена'), \n    'Глава 3': (10000, 'не переведена'), \n    'Глава 4': (6000, 'не переведена'),\n    'Глава 5': (6500, 'не переведена')\n}"", ""{\n    'Героический эпос народов СССР. № 1': (100000, 'переведена'),\n    'Героический эпос народов СССР. № 2': (1005, 'не переведена')\n}"", ""{\n    'Арабская поэзия средних веков': (1092, 'не переведена'),\n    'Ирано-таджикская поэзия': (10090, 'переведена'),\n    'Средневековый роман и повесть': (2198, 'переведена')\n}"", ""{\n    'г1': (90, 'не переведена'), \n    'г2': (29, 'не переведена'), \n    'г3': (10, 'не переведена'), \n    'г4': (80, 'не переведена'),\n    'г5': (8, 'не переведена')\n}"", ""{\n    'повесть': (32, 'переведена'), \n    'поэма': (212, 'переведена'), \n    'роман': (809, 'переведена'),\n    'рассказы': (80, 'переведена')\n}"", ""{\n    'ода': (312, 'не переведена'), \n    'новелла': (2112, 'переведена'), \n    'юмореска': (809, 'переведена'),\n    'сатира': (89280, 'не переведена')\n}""]","['False', '[True, 100000]', '[True, 12288]', 'False', '[True, 1133]', '[True, 2921]']","def text_check():
    counter = 0
    summa = 0
    for k, v in data.items():
        if v[1] == 'переведена':
            counter += 1
            summa += v[0]
            
    if counter != 0:
        return ([True, summa])
        
    return False","def text_check(data):
    counter = 0
    summa = 0
    for k, v in data.items():
        if v[1] == 'переведена':
            counter += 1
            summa += v[0]
            
    if counter != 0:
        return ([True, summa])
        
    return False","Вы не добавили переменные, которые функция будет принимать как аргументы.","['open', 'open', 'open', 'closed', 'closed', 'closed']","<Task description>: Напишите функцию, определяющую можно считать книгу переведенной или нет. 

ТРЕБУЕМАЯ ФУНКЦИЯ 
Функция text_check, принимающая на вход словарь, ключи в котором — названия глав (строки), а значения — кортежи с двумя элементами (целым числом — количеством слов в главе; и строкой ""переведена"" или ""не переведена""). Гарантируется, что словарь содержит информацию минимум об одной главе.
Если хотя бы одна глава была переведена, то функция должна возвращать список из двух значений: логической константы True и целого числа — количества слов в главах, которые были переведены.
Если все главы не были переведены, то функция возвращает логическую константу False.
ВАЖНО! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Определите функцию и аргумент, с которым она работает.
Задайте две переменные-счетчика — одну для подсчета количества слов, другую для подсчета количества строк ""переведена"".
Обратитесь к парам ключ-значение в переданном функции словаре. Если первый по индексу элемент значения (кортежа) принимает значение ""переведена"", то прибавьте 1 к первой переменной-счетчику и прибавьте нулевой по индексу элемент значения (кортежа) ко второй переменной-счетчику.
Проверьте, что первая переменная-счетчик не равна нулю, и если да, то пусть функция вернет список из двух значений: логической константы True и значения второй-переменной счетчика; иначе пусть функция вернет логическую константу False. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: {
    'Глава 1': (3000, 'не переведена'), 
    'Глава 2': (2000, 'не переведена'), 
    'Глава 3': (10000, 'не переведена'), 
    'Глава 4': (6000, 'не переведена'),
    'Глава 5': (6500, 'не переведена')
} 
<Вывод>: False 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: {
    'Героический эпос народов СССР. № 1': (100000, 'переведена'),
    'Героический эпос народов СССР. № 2': (1005, 'не переведена')
} 
<Вывод>: [True, 100000] 
<Example 3>: 
<Тип теста 3>: open 
<Ввод>: {
    'Арабская поэзия средних веков': (1092, 'не переведена'),
    'Ирано-таджикская поэзия': (10090, 'переведена'),
    'Средневековый роман и повесть': (2198, 'переведена')
} 
<Вывод>: [True, 12288] 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: {
    'г1': (90, 'не переведена'), 
    'г2': (29, 'не переведена'), 
    'г3': (10, 'не переведена'), 
    'г4': (80, 'не переведена'),
    'г5': (8, 'не переведена')
} 
<Вывод>: False 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: {
    'повесть': (32, 'переведена'), 
    'поэма': (212, 'переведена'), 
    'роман': (809, 'переведена'),
    'рассказы': (80, 'переведена')
} 
<Вывод>: [True, 1133] 
<Example 6>: 
<Тип теста 6>: closed 
<Ввод>: {
    'ода': (312, 'не переведена'), 
    'новелла': (2112, 'переведена'), 
    'юмореска': (809, 'переведена'),
    'сатира': (89280, 'не переведена')
} 
<Вывод>: [True, 2921] 
<Решение студента>: def text_check():
    counter = 0
    summa = 0
    for k, v in data.items():
        if v[1] == 'переведена':
            counter += 1
            summa += v[0]
            
    if counter != 0:
        return ([True, summa])
        
    return False 
<Идеальное решение>: def text_check(data):
    counter = 0
    summa = 0
    for k, v in data.items():
        if v[1] == 'переведена':
            counter += 1
            summa += v[0]
            
    if counter != 0:
        return ([True, summa])
        
    return False 


<Комментарий эксперта>:"
238,539,34,"Напишите функцию, определяющую можно считать книгу переведенной или нет. 

ТРЕБУЕМАЯ ФУНКЦИЯ 
Функция text_check, принимающая на вход словарь, ключи в котором — названия глав (строки), а значения — кортежи с двумя элементами (целым числом — количеством слов в главе; и строкой ""переведена"" или ""не переведена""). Гарантируется, что словарь содержит информацию минимум об одной главе.
Если хотя бы одна глава была переведена, то функция должна возвращать список из двух значений: логической константы True и целого числа — количества слов в главах, которые были переведены.
Если все главы не были переведены, то функция возвращает логическую константу False.
ВАЖНО! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Определите функцию и аргумент, с которым она работает.
Задайте две переменные-счетчика — одну для подсчета количества слов, другую для подсчета количества строк ""переведена"".
Обратитесь к парам ключ-значение в переданном функции словаре. Если первый по индексу элемент значения (кортежа) принимает значение ""переведена"", то прибавьте 1 к первой переменной-счетчику и прибавьте нулевой по индексу элемент значения (кортежа) ко второй переменной-счетчику.
Проверьте, что первая переменная-счетчик не равна нулю, и если да, то пусть функция вернет список из двух значений: логической константы True и значения второй-переменной счетчика; иначе пусть функция вернет логическую константу False.","[""{\n    'Глава 1': (3000, 'не переведена'), \n    'Глава 2': (2000, 'не переведена'), \n    'Глава 3': (10000, 'не переведена'), \n    'Глава 4': (6000, 'не переведена'),\n    'Глава 5': (6500, 'не переведена')\n}"", ""{\n    'Героический эпос народов СССР. № 1': (100000, 'переведена'),\n    'Героический эпос народов СССР. № 2': (1005, 'не переведена')\n}"", ""{\n    'Арабская поэзия средних веков': (1092, 'не переведена'),\n    'Ирано-таджикская поэзия': (10090, 'переведена'),\n    'Средневековый роман и повесть': (2198, 'переведена')\n}"", ""{\n    'г1': (90, 'не переведена'), \n    'г2': (29, 'не переведена'), \n    'г3': (10, 'не переведена'), \n    'г4': (80, 'не переведена'),\n    'г5': (8, 'не переведена')\n}"", ""{\n    'повесть': (32, 'переведена'), \n    'поэма': (212, 'переведена'), \n    'роман': (809, 'переведена'),\n    'рассказы': (80, 'переведена')\n}"", ""{\n    'ода': (312, 'не переведена'), \n    'новелла': (2112, 'переведена'), \n    'юмореска': (809, 'переведена'),\n    'сатира': (89280, 'не переведена')\n}""]","['False', '[True, 100000]', '[True, 12288]', 'False', '[True, 1133]', '[True, 2921]']","def text_check(data):
    counter = 0
    summ = 0
    for k, v in data.items():
        if v[1] == 'переведена':
            counter += 1
            summa += v[0]
            
    if counter != 0:
        return ([True, summa])
        
    return False","def text_check(data):
    counter = 0
    summa = 0
    for k, v in data.items():
        if v[1] == 'переведена':
            counter += 1
            summa += v[0]
            
    if counter != 0:
        return ([True, summa])
        
    return False","Вы использовали переменную, которая не была задана ранее. Проверьте, что все переменные, которые вы используете, были заданы.","['open', 'open', 'open', 'closed', 'closed', 'closed']","<Task description>: Напишите функцию, определяющую можно считать книгу переведенной или нет. 

ТРЕБУЕМАЯ ФУНКЦИЯ 
Функция text_check, принимающая на вход словарь, ключи в котором — названия глав (строки), а значения — кортежи с двумя элементами (целым числом — количеством слов в главе; и строкой ""переведена"" или ""не переведена""). Гарантируется, что словарь содержит информацию минимум об одной главе.
Если хотя бы одна глава была переведена, то функция должна возвращать список из двух значений: логической константы True и целого числа — количества слов в главах, которые были переведены.
Если все главы не были переведены, то функция возвращает логическую константу False.
ВАЖНО! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Определите функцию и аргумент, с которым она работает.
Задайте две переменные-счетчика — одну для подсчета количества слов, другую для подсчета количества строк ""переведена"".
Обратитесь к парам ключ-значение в переданном функции словаре. Если первый по индексу элемент значения (кортежа) принимает значение ""переведена"", то прибавьте 1 к первой переменной-счетчику и прибавьте нулевой по индексу элемент значения (кортежа) ко второй переменной-счетчику.
Проверьте, что первая переменная-счетчик не равна нулю, и если да, то пусть функция вернет список из двух значений: логической константы True и значения второй-переменной счетчика; иначе пусть функция вернет логическую константу False. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: {
    'Глава 1': (3000, 'не переведена'), 
    'Глава 2': (2000, 'не переведена'), 
    'Глава 3': (10000, 'не переведена'), 
    'Глава 4': (6000, 'не переведена'),
    'Глава 5': (6500, 'не переведена')
} 
<Вывод>: False 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: {
    'Героический эпос народов СССР. № 1': (100000, 'переведена'),
    'Героический эпос народов СССР. № 2': (1005, 'не переведена')
} 
<Вывод>: [True, 100000] 
<Example 3>: 
<Тип теста 3>: open 
<Ввод>: {
    'Арабская поэзия средних веков': (1092, 'не переведена'),
    'Ирано-таджикская поэзия': (10090, 'переведена'),
    'Средневековый роман и повесть': (2198, 'переведена')
} 
<Вывод>: [True, 12288] 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: {
    'г1': (90, 'не переведена'), 
    'г2': (29, 'не переведена'), 
    'г3': (10, 'не переведена'), 
    'г4': (80, 'не переведена'),
    'г5': (8, 'не переведена')
} 
<Вывод>: False 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: {
    'повесть': (32, 'переведена'), 
    'поэма': (212, 'переведена'), 
    'роман': (809, 'переведена'),
    'рассказы': (80, 'переведена')
} 
<Вывод>: [True, 1133] 
<Example 6>: 
<Тип теста 6>: closed 
<Ввод>: {
    'ода': (312, 'не переведена'), 
    'новелла': (2112, 'переведена'), 
    'юмореска': (809, 'переведена'),
    'сатира': (89280, 'не переведена')
} 
<Вывод>: [True, 2921] 
<Решение студента>: def text_check(data):
    counter = 0
    summ = 0
    for k, v in data.items():
        if v[1] == 'переведена':
            counter += 1
            summa += v[0]
            
    if counter != 0:
        return ([True, summa])
        
    return False 
<Идеальное решение>: def text_check(data):
    counter = 0
    summa = 0
    for k, v in data.items():
        if v[1] == 'переведена':
            counter += 1
            summa += v[0]
            
    if counter != 0:
        return ([True, summa])
        
    return False 


<Комментарий эксперта>:"
239,540,34,"Напишите функцию, определяющую можно считать книгу переведенной или нет. 

ТРЕБУЕМАЯ ФУНКЦИЯ 
Функция text_check, принимающая на вход словарь, ключи в котором — названия глав (строки), а значения — кортежи с двумя элементами (целым числом — количеством слов в главе; и строкой ""переведена"" или ""не переведена""). Гарантируется, что словарь содержит информацию минимум об одной главе.
Если хотя бы одна глава была переведена, то функция должна возвращать список из двух значений: логической константы True и целого числа — количества слов в главах, которые были переведены.
Если все главы не были переведены, то функция возвращает логическую константу False.
ВАЖНО! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Определите функцию и аргумент, с которым она работает.
Задайте две переменные-счетчика — одну для подсчета количества слов, другую для подсчета количества строк ""переведена"".
Обратитесь к парам ключ-значение в переданном функции словаре. Если первый по индексу элемент значения (кортежа) принимает значение ""переведена"", то прибавьте 1 к первой переменной-счетчику и прибавьте нулевой по индексу элемент значения (кортежа) ко второй переменной-счетчику.
Проверьте, что первая переменная-счетчик не равна нулю, и если да, то пусть функция вернет список из двух значений: логической константы True и значения второй-переменной счетчика; иначе пусть функция вернет логическую константу False.","[""{\n    'Глава 1': (3000, 'не переведена'), \n    'Глава 2': (2000, 'не переведена'), \n    'Глава 3': (10000, 'не переведена'), \n    'Глава 4': (6000, 'не переведена'),\n    'Глава 5': (6500, 'не переведена')\n}"", ""{\n    'Героический эпос народов СССР. № 1': (100000, 'переведена'),\n    'Героический эпос народов СССР. № 2': (1005, 'не переведена')\n}"", ""{\n    'Арабская поэзия средних веков': (1092, 'не переведена'),\n    'Ирано-таджикская поэзия': (10090, 'переведена'),\n    'Средневековый роман и повесть': (2198, 'переведена')\n}"", ""{\n    'г1': (90, 'не переведена'), \n    'г2': (29, 'не переведена'), \n    'г3': (10, 'не переведена'), \n    'г4': (80, 'не переведена'),\n    'г5': (8, 'не переведена')\n}"", ""{\n    'повесть': (32, 'переведена'), \n    'поэма': (212, 'переведена'), \n    'роман': (809, 'переведена'),\n    'рассказы': (80, 'переведена')\n}"", ""{\n    'ода': (312, 'не переведена'), \n    'новелла': (2112, 'переведена'), \n    'юмореска': (809, 'переведена'),\n    'сатира': (89280, 'не переведена')\n}""]","['False', '[True, 100000]', '[True, 12288]', 'False', '[True, 1133]', '[True, 2921]']","def text_check(data):
    counter = 0
    summa = 0
    for k, v in data:
        if v[1] == 'переведена':
            counter += 1
            summa += v[0]
            
    if counter != 0:
        return ([True, summa])
        
    return False","def text_check(data):
    counter = 0
    summa = 0
    for k, v in data.items():
        if v[1] == 'переведена':
            counter += 1
            summa += v[0]
            
    if counter != 0:
        return ([True, summa])
        
    return False","Ошибка при обращении к элементам словаря data. Попытка обратиться к двум значениям, вместо одного. Используйте опреатор .items().","['open', 'open', 'open', 'closed', 'closed', 'closed']","<Task description>: Напишите функцию, определяющую можно считать книгу переведенной или нет. 

ТРЕБУЕМАЯ ФУНКЦИЯ 
Функция text_check, принимающая на вход словарь, ключи в котором — названия глав (строки), а значения — кортежи с двумя элементами (целым числом — количеством слов в главе; и строкой ""переведена"" или ""не переведена""). Гарантируется, что словарь содержит информацию минимум об одной главе.
Если хотя бы одна глава была переведена, то функция должна возвращать список из двух значений: логической константы True и целого числа — количества слов в главах, которые были переведены.
Если все главы не были переведены, то функция возвращает логическую константу False.
ВАЖНО! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Определите функцию и аргумент, с которым она работает.
Задайте две переменные-счетчика — одну для подсчета количества слов, другую для подсчета количества строк ""переведена"".
Обратитесь к парам ключ-значение в переданном функции словаре. Если первый по индексу элемент значения (кортежа) принимает значение ""переведена"", то прибавьте 1 к первой переменной-счетчику и прибавьте нулевой по индексу элемент значения (кортежа) ко второй переменной-счетчику.
Проверьте, что первая переменная-счетчик не равна нулю, и если да, то пусть функция вернет список из двух значений: логической константы True и значения второй-переменной счетчика; иначе пусть функция вернет логическую константу False. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: {
    'Глава 1': (3000, 'не переведена'), 
    'Глава 2': (2000, 'не переведена'), 
    'Глава 3': (10000, 'не переведена'), 
    'Глава 4': (6000, 'не переведена'),
    'Глава 5': (6500, 'не переведена')
} 
<Вывод>: False 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: {
    'Героический эпос народов СССР. № 1': (100000, 'переведена'),
    'Героический эпос народов СССР. № 2': (1005, 'не переведена')
} 
<Вывод>: [True, 100000] 
<Example 3>: 
<Тип теста 3>: open 
<Ввод>: {
    'Арабская поэзия средних веков': (1092, 'не переведена'),
    'Ирано-таджикская поэзия': (10090, 'переведена'),
    'Средневековый роман и повесть': (2198, 'переведена')
} 
<Вывод>: [True, 12288] 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: {
    'г1': (90, 'не переведена'), 
    'г2': (29, 'не переведена'), 
    'г3': (10, 'не переведена'), 
    'г4': (80, 'не переведена'),
    'г5': (8, 'не переведена')
} 
<Вывод>: False 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: {
    'повесть': (32, 'переведена'), 
    'поэма': (212, 'переведена'), 
    'роман': (809, 'переведена'),
    'рассказы': (80, 'переведена')
} 
<Вывод>: [True, 1133] 
<Example 6>: 
<Тип теста 6>: closed 
<Ввод>: {
    'ода': (312, 'не переведена'), 
    'новелла': (2112, 'переведена'), 
    'юмореска': (809, 'переведена'),
    'сатира': (89280, 'не переведена')
} 
<Вывод>: [True, 2921] 
<Решение студента>: def text_check(data):
    counter = 0
    summa = 0
    for k, v in data:
        if v[1] == 'переведена':
            counter += 1
            summa += v[0]
            
    if counter != 0:
        return ([True, summa])
        
    return False 
<Идеальное решение>: def text_check(data):
    counter = 0
    summa = 0
    for k, v in data.items():
        if v[1] == 'переведена':
            counter += 1
            summa += v[0]
            
    if counter != 0:
        return ([True, summa])
        
    return False 


<Комментарий эксперта>:"
240,541,34,"Напишите функцию, определяющую можно считать книгу переведенной или нет. 

ТРЕБУЕМАЯ ФУНКЦИЯ 
Функция text_check, принимающая на вход словарь, ключи в котором — названия глав (строки), а значения — кортежи с двумя элементами (целым числом — количеством слов в главе; и строкой ""переведена"" или ""не переведена""). Гарантируется, что словарь содержит информацию минимум об одной главе.
Если хотя бы одна глава была переведена, то функция должна возвращать список из двух значений: логической константы True и целого числа — количества слов в главах, которые были переведены.
Если все главы не были переведены, то функция возвращает логическую константу False.
ВАЖНО! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Определите функцию и аргумент, с которым она работает.
Задайте две переменные-счетчика — одну для подсчета количества слов, другую для подсчета количества строк ""переведена"".
Обратитесь к парам ключ-значение в переданном функции словаре. Если первый по индексу элемент значения (кортежа) принимает значение ""переведена"", то прибавьте 1 к первой переменной-счетчику и прибавьте нулевой по индексу элемент значения (кортежа) ко второй переменной-счетчику.
Проверьте, что первая переменная-счетчик не равна нулю, и если да, то пусть функция вернет список из двух значений: логической константы True и значения второй-переменной счетчика; иначе пусть функция вернет логическую константу False.","[""{\n    'Глава 1': (3000, 'не переведена'), \n    'Глава 2': (2000, 'не переведена'), \n    'Глава 3': (10000, 'не переведена'), \n    'Глава 4': (6000, 'не переведена'),\n    'Глава 5': (6500, 'не переведена')\n}"", ""{\n    'Героический эпос народов СССР. № 1': (100000, 'переведена'),\n    'Героический эпос народов СССР. № 2': (1005, 'не переведена')\n}"", ""{\n    'Арабская поэзия средних веков': (1092, 'не переведена'),\n    'Ирано-таджикская поэзия': (10090, 'переведена'),\n    'Средневековый роман и повесть': (2198, 'переведена')\n}"", ""{\n    'г1': (90, 'не переведена'), \n    'г2': (29, 'не переведена'), \n    'г3': (10, 'не переведена'), \n    'г4': (80, 'не переведена'),\n    'г5': (8, 'не переведена')\n}"", ""{\n    'повесть': (32, 'переведена'), \n    'поэма': (212, 'переведена'), \n    'роман': (809, 'переведена'),\n    'рассказы': (80, 'переведена')\n}"", ""{\n    'ода': (312, 'не переведена'), \n    'новелла': (2112, 'переведена'), \n    'юмореска': (809, 'переведена'),\n    'сатира': (89280, 'не переведена')\n}""]","['False', '[True, 100000]', '[True, 12288]', 'False', '[True, 1133]', '[True, 2921]']","def text_check(data):
    counter = 0
    summa = 0
    for k, v in data.items():
        if k[1] == 'переведена':
            counter += 1
            summa += k[0]
            
    if counter != 0:
        return ([True, summa])
        
    return False","def text_check(data):
    counter = 0
    summa = 0
    for k, v in data.items():
        if v[1] == 'переведена':
            counter += 1
            summa += v[0]
            
    if counter != 0:
        return ([True, summa])
        
    return False","Ошибка в открытых и скрытых тестах. 

Вы обращаетесь к неверной переменной пары ключ-значение.","['open', 'open', 'open', 'closed', 'closed', 'closed']","<Task description>: Напишите функцию, определяющую можно считать книгу переведенной или нет. 

ТРЕБУЕМАЯ ФУНКЦИЯ 
Функция text_check, принимающая на вход словарь, ключи в котором — названия глав (строки), а значения — кортежи с двумя элементами (целым числом — количеством слов в главе; и строкой ""переведена"" или ""не переведена""). Гарантируется, что словарь содержит информацию минимум об одной главе.
Если хотя бы одна глава была переведена, то функция должна возвращать список из двух значений: логической константы True и целого числа — количества слов в главах, которые были переведены.
Если все главы не были переведены, то функция возвращает логическую константу False.
ВАЖНО! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Определите функцию и аргумент, с которым она работает.
Задайте две переменные-счетчика — одну для подсчета количества слов, другую для подсчета количества строк ""переведена"".
Обратитесь к парам ключ-значение в переданном функции словаре. Если первый по индексу элемент значения (кортежа) принимает значение ""переведена"", то прибавьте 1 к первой переменной-счетчику и прибавьте нулевой по индексу элемент значения (кортежа) ко второй переменной-счетчику.
Проверьте, что первая переменная-счетчик не равна нулю, и если да, то пусть функция вернет список из двух значений: логической константы True и значения второй-переменной счетчика; иначе пусть функция вернет логическую константу False. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: {
    'Глава 1': (3000, 'не переведена'), 
    'Глава 2': (2000, 'не переведена'), 
    'Глава 3': (10000, 'не переведена'), 
    'Глава 4': (6000, 'не переведена'),
    'Глава 5': (6500, 'не переведена')
} 
<Вывод>: False 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: {
    'Героический эпос народов СССР. № 1': (100000, 'переведена'),
    'Героический эпос народов СССР. № 2': (1005, 'не переведена')
} 
<Вывод>: [True, 100000] 
<Example 3>: 
<Тип теста 3>: open 
<Ввод>: {
    'Арабская поэзия средних веков': (1092, 'не переведена'),
    'Ирано-таджикская поэзия': (10090, 'переведена'),
    'Средневековый роман и повесть': (2198, 'переведена')
} 
<Вывод>: [True, 12288] 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: {
    'г1': (90, 'не переведена'), 
    'г2': (29, 'не переведена'), 
    'г3': (10, 'не переведена'), 
    'г4': (80, 'не переведена'),
    'г5': (8, 'не переведена')
} 
<Вывод>: False 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: {
    'повесть': (32, 'переведена'), 
    'поэма': (212, 'переведена'), 
    'роман': (809, 'переведена'),
    'рассказы': (80, 'переведена')
} 
<Вывод>: [True, 1133] 
<Example 6>: 
<Тип теста 6>: closed 
<Ввод>: {
    'ода': (312, 'не переведена'), 
    'новелла': (2112, 'переведена'), 
    'юмореска': (809, 'переведена'),
    'сатира': (89280, 'не переведена')
} 
<Вывод>: [True, 2921] 
<Решение студента>: def text_check(data):
    counter = 0
    summa = 0
    for k, v in data.items():
        if k[1] == 'переведена':
            counter += 1
            summa += k[0]
            
    if counter != 0:
        return ([True, summa])
        
    return False 
<Идеальное решение>: def text_check(data):
    counter = 0
    summa = 0
    for k, v in data.items():
        if v[1] == 'переведена':
            counter += 1
            summa += v[0]
            
    if counter != 0:
        return ([True, summa])
        
    return False 


<Комментарий эксперта>:"
241,542,34,"Напишите функцию, определяющую можно считать книгу переведенной или нет. 

ТРЕБУЕМАЯ ФУНКЦИЯ 
Функция text_check, принимающая на вход словарь, ключи в котором — названия глав (строки), а значения — кортежи с двумя элементами (целым числом — количеством слов в главе; и строкой ""переведена"" или ""не переведена""). Гарантируется, что словарь содержит информацию минимум об одной главе.
Если хотя бы одна глава была переведена, то функция должна возвращать список из двух значений: логической константы True и целого числа — количества слов в главах, которые были переведены.
Если все главы не были переведены, то функция возвращает логическую константу False.
ВАЖНО! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Определите функцию и аргумент, с которым она работает.
Задайте две переменные-счетчика — одну для подсчета количества слов, другую для подсчета количества строк ""переведена"".
Обратитесь к парам ключ-значение в переданном функции словаре. Если первый по индексу элемент значения (кортежа) принимает значение ""переведена"", то прибавьте 1 к первой переменной-счетчику и прибавьте нулевой по индексу элемент значения (кортежа) ко второй переменной-счетчику.
Проверьте, что первая переменная-счетчик не равна нулю, и если да, то пусть функция вернет список из двух значений: логической константы True и значения второй-переменной счетчика; иначе пусть функция вернет логическую константу False.","[""{\n    'Глава 1': (3000, 'не переведена'), \n    'Глава 2': (2000, 'не переведена'), \n    'Глава 3': (10000, 'не переведена'), \n    'Глава 4': (6000, 'не переведена'),\n    'Глава 5': (6500, 'не переведена')\n}"", ""{\n    'Героический эпос народов СССР. № 1': (100000, 'переведена'),\n    'Героический эпос народов СССР. № 2': (1005, 'не переведена')\n}"", ""{\n    'Арабская поэзия средних веков': (1092, 'не переведена'),\n    'Ирано-таджикская поэзия': (10090, 'переведена'),\n    'Средневековый роман и повесть': (2198, 'переведена')\n}"", ""{\n    'г1': (90, 'не переведена'), \n    'г2': (29, 'не переведена'), \n    'г3': (10, 'не переведена'), \n    'г4': (80, 'не переведена'),\n    'г5': (8, 'не переведена')\n}"", ""{\n    'повесть': (32, 'переведена'), \n    'поэма': (212, 'переведена'), \n    'роман': (809, 'переведена'),\n    'рассказы': (80, 'переведена')\n}"", ""{\n    'ода': (312, 'не переведена'), \n    'новелла': (2112, 'переведена'), \n    'юмореска': (809, 'переведена'),\n    'сатира': (89280, 'не переведена')\n}""]","['False', '[True, 100000]', '[True, 12288]', 'False', '[True, 1133]', '[True, 2921]']","def text_check(data):
    counter = 0
    summa = 0
    for k, v in data.items():
        if v[2] == 'переведена':
            counter += 1
            summa += v[1]
            
    if counter != 0:
        return ([True, summa])
        
    return False","def text_check(data):
    counter = 0
    summa = 0
    for k, v in data.items():
        if v[1] == 'переведена':
            counter += 1
            summa += v[0]
            
    if counter != 0:
        return ([True, summa])
        
    return False","Ваш код обращается к неверному индексу разделенной переменной item. Помните, что отсчет индексов начинается с 0.","['open', 'open', 'open', 'closed', 'closed', 'closed']","<Task description>: Напишите функцию, определяющую можно считать книгу переведенной или нет. 

ТРЕБУЕМАЯ ФУНКЦИЯ 
Функция text_check, принимающая на вход словарь, ключи в котором — названия глав (строки), а значения — кортежи с двумя элементами (целым числом — количеством слов в главе; и строкой ""переведена"" или ""не переведена""). Гарантируется, что словарь содержит информацию минимум об одной главе.
Если хотя бы одна глава была переведена, то функция должна возвращать список из двух значений: логической константы True и целого числа — количества слов в главах, которые были переведены.
Если все главы не были переведены, то функция возвращает логическую константу False.
ВАЖНО! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Определите функцию и аргумент, с которым она работает.
Задайте две переменные-счетчика — одну для подсчета количества слов, другую для подсчета количества строк ""переведена"".
Обратитесь к парам ключ-значение в переданном функции словаре. Если первый по индексу элемент значения (кортежа) принимает значение ""переведена"", то прибавьте 1 к первой переменной-счетчику и прибавьте нулевой по индексу элемент значения (кортежа) ко второй переменной-счетчику.
Проверьте, что первая переменная-счетчик не равна нулю, и если да, то пусть функция вернет список из двух значений: логической константы True и значения второй-переменной счетчика; иначе пусть функция вернет логическую константу False. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: {
    'Глава 1': (3000, 'не переведена'), 
    'Глава 2': (2000, 'не переведена'), 
    'Глава 3': (10000, 'не переведена'), 
    'Глава 4': (6000, 'не переведена'),
    'Глава 5': (6500, 'не переведена')
} 
<Вывод>: False 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: {
    'Героический эпос народов СССР. № 1': (100000, 'переведена'),
    'Героический эпос народов СССР. № 2': (1005, 'не переведена')
} 
<Вывод>: [True, 100000] 
<Example 3>: 
<Тип теста 3>: open 
<Ввод>: {
    'Арабская поэзия средних веков': (1092, 'не переведена'),
    'Ирано-таджикская поэзия': (10090, 'переведена'),
    'Средневековый роман и повесть': (2198, 'переведена')
} 
<Вывод>: [True, 12288] 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: {
    'г1': (90, 'не переведена'), 
    'г2': (29, 'не переведена'), 
    'г3': (10, 'не переведена'), 
    'г4': (80, 'не переведена'),
    'г5': (8, 'не переведена')
} 
<Вывод>: False 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: {
    'повесть': (32, 'переведена'), 
    'поэма': (212, 'переведена'), 
    'роман': (809, 'переведена'),
    'рассказы': (80, 'переведена')
} 
<Вывод>: [True, 1133] 
<Example 6>: 
<Тип теста 6>: closed 
<Ввод>: {
    'ода': (312, 'не переведена'), 
    'новелла': (2112, 'переведена'), 
    'юмореска': (809, 'переведена'),
    'сатира': (89280, 'не переведена')
} 
<Вывод>: [True, 2921] 
<Решение студента>: def text_check(data):
    counter = 0
    summa = 0
    for k, v in data.items():
        if v[2] == 'переведена':
            counter += 1
            summa += v[1]
            
    if counter != 0:
        return ([True, summa])
        
    return False 
<Идеальное решение>: def text_check(data):
    counter = 0
    summa = 0
    for k, v in data.items():
        if v[1] == 'переведена':
            counter += 1
            summa += v[0]
            
    if counter != 0:
        return ([True, summa])
        
    return False 


<Комментарий эксперта>:"
242,543,34,"Напишите функцию, определяющую можно считать книгу переведенной или нет. 

ТРЕБУЕМАЯ ФУНКЦИЯ 
Функция text_check, принимающая на вход словарь, ключи в котором — названия глав (строки), а значения — кортежи с двумя элементами (целым числом — количеством слов в главе; и строкой ""переведена"" или ""не переведена""). Гарантируется, что словарь содержит информацию минимум об одной главе.
Если хотя бы одна глава была переведена, то функция должна возвращать список из двух значений: логической константы True и целого числа — количества слов в главах, которые были переведены.
Если все главы не были переведены, то функция возвращает логическую константу False.
ВАЖНО! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Определите функцию и аргумент, с которым она работает.
Задайте две переменные-счетчика — одну для подсчета количества слов, другую для подсчета количества строк ""переведена"".
Обратитесь к парам ключ-значение в переданном функции словаре. Если первый по индексу элемент значения (кортежа) принимает значение ""переведена"", то прибавьте 1 к первой переменной-счетчику и прибавьте нулевой по индексу элемент значения (кортежа) ко второй переменной-счетчику.
Проверьте, что первая переменная-счетчик не равна нулю, и если да, то пусть функция вернет список из двух значений: логической константы True и значения второй-переменной счетчика; иначе пусть функция вернет логическую константу False.","[""{\n    'Глава 1': (3000, 'не переведена'), \n    'Глава 2': (2000, 'не переведена'), \n    'Глава 3': (10000, 'не переведена'), \n    'Глава 4': (6000, 'не переведена'),\n    'Глава 5': (6500, 'не переведена')\n}"", ""{\n    'Героический эпос народов СССР. № 1': (100000, 'переведена'),\n    'Героический эпос народов СССР. № 2': (1005, 'не переведена')\n}"", ""{\n    'Арабская поэзия средних веков': (1092, 'не переведена'),\n    'Ирано-таджикская поэзия': (10090, 'переведена'),\n    'Средневековый роман и повесть': (2198, 'переведена')\n}"", ""{\n    'г1': (90, 'не переведена'), \n    'г2': (29, 'не переведена'), \n    'г3': (10, 'не переведена'), \n    'г4': (80, 'не переведена'),\n    'г5': (8, 'не переведена')\n}"", ""{\n    'повесть': (32, 'переведена'), \n    'поэма': (212, 'переведена'), \n    'роман': (809, 'переведена'),\n    'рассказы': (80, 'переведена')\n}"", ""{\n    'ода': (312, 'не переведена'), \n    'новелла': (2112, 'переведена'), \n    'юмореска': (809, 'переведена'),\n    'сатира': (89280, 'не переведена')\n}""]","['False', '[True, 100000]', '[True, 12288]', 'False', '[True, 1133]', '[True, 2921]']","def text_check(data):
    counter = 0
    summa = 0
    for k, v in data.items():
        if v[1] = 'переведена':
            counter += 1
            summa += v[0]
            
    if counter != 0:
        return ([True, summa])
        
    return False","def text_check(data):
    counter = 0
    summa = 0
    for k, v in data.items():
        if v[1] == 'переведена':
            counter += 1
            summa += v[0]
            
    if counter != 0:
        return ([True, summa])
        
    return False",Синтаксическая ошибка. При сравнении двух значений следует использовать знако двойного равенства.,"['open', 'open', 'open', 'closed', 'closed', 'closed']","<Task description>: Напишите функцию, определяющую можно считать книгу переведенной или нет. 

ТРЕБУЕМАЯ ФУНКЦИЯ 
Функция text_check, принимающая на вход словарь, ключи в котором — названия глав (строки), а значения — кортежи с двумя элементами (целым числом — количеством слов в главе; и строкой ""переведена"" или ""не переведена""). Гарантируется, что словарь содержит информацию минимум об одной главе.
Если хотя бы одна глава была переведена, то функция должна возвращать список из двух значений: логической константы True и целого числа — количества слов в главах, которые были переведены.
Если все главы не были переведены, то функция возвращает логическую константу False.
ВАЖНО! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Определите функцию и аргумент, с которым она работает.
Задайте две переменные-счетчика — одну для подсчета количества слов, другую для подсчета количества строк ""переведена"".
Обратитесь к парам ключ-значение в переданном функции словаре. Если первый по индексу элемент значения (кортежа) принимает значение ""переведена"", то прибавьте 1 к первой переменной-счетчику и прибавьте нулевой по индексу элемент значения (кортежа) ко второй переменной-счетчику.
Проверьте, что первая переменная-счетчик не равна нулю, и если да, то пусть функция вернет список из двух значений: логической константы True и значения второй-переменной счетчика; иначе пусть функция вернет логическую константу False. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: {
    'Глава 1': (3000, 'не переведена'), 
    'Глава 2': (2000, 'не переведена'), 
    'Глава 3': (10000, 'не переведена'), 
    'Глава 4': (6000, 'не переведена'),
    'Глава 5': (6500, 'не переведена')
} 
<Вывод>: False 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: {
    'Героический эпос народов СССР. № 1': (100000, 'переведена'),
    'Героический эпос народов СССР. № 2': (1005, 'не переведена')
} 
<Вывод>: [True, 100000] 
<Example 3>: 
<Тип теста 3>: open 
<Ввод>: {
    'Арабская поэзия средних веков': (1092, 'не переведена'),
    'Ирано-таджикская поэзия': (10090, 'переведена'),
    'Средневековый роман и повесть': (2198, 'переведена')
} 
<Вывод>: [True, 12288] 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: {
    'г1': (90, 'не переведена'), 
    'г2': (29, 'не переведена'), 
    'г3': (10, 'не переведена'), 
    'г4': (80, 'не переведена'),
    'г5': (8, 'не переведена')
} 
<Вывод>: False 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: {
    'повесть': (32, 'переведена'), 
    'поэма': (212, 'переведена'), 
    'роман': (809, 'переведена'),
    'рассказы': (80, 'переведена')
} 
<Вывод>: [True, 1133] 
<Example 6>: 
<Тип теста 6>: closed 
<Ввод>: {
    'ода': (312, 'не переведена'), 
    'новелла': (2112, 'переведена'), 
    'юмореска': (809, 'переведена'),
    'сатира': (89280, 'не переведена')
} 
<Вывод>: [True, 2921] 
<Решение студента>: def text_check(data):
    counter = 0
    summa = 0
    for k, v in data.items():
        if v[1] = 'переведена':
            counter += 1
            summa += v[0]
            
    if counter != 0:
        return ([True, summa])
        
    return False 
<Идеальное решение>: def text_check(data):
    counter = 0
    summa = 0
    for k, v in data.items():
        if v[1] == 'переведена':
            counter += 1
            summa += v[0]
            
    if counter != 0:
        return ([True, summa])
        
    return False 


<Комментарий эксперта>:"
243,544,34,"Напишите функцию, определяющую можно считать книгу переведенной или нет. 

ТРЕБУЕМАЯ ФУНКЦИЯ 
Функция text_check, принимающая на вход словарь, ключи в котором — названия глав (строки), а значения — кортежи с двумя элементами (целым числом — количеством слов в главе; и строкой ""переведена"" или ""не переведена""). Гарантируется, что словарь содержит информацию минимум об одной главе.
Если хотя бы одна глава была переведена, то функция должна возвращать список из двух значений: логической константы True и целого числа — количества слов в главах, которые были переведены.
Если все главы не были переведены, то функция возвращает логическую константу False.
ВАЖНО! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Определите функцию и аргумент, с которым она работает.
Задайте две переменные-счетчика — одну для подсчета количества слов, другую для подсчета количества строк ""переведена"".
Обратитесь к парам ключ-значение в переданном функции словаре. Если первый по индексу элемент значения (кортежа) принимает значение ""переведена"", то прибавьте 1 к первой переменной-счетчику и прибавьте нулевой по индексу элемент значения (кортежа) ко второй переменной-счетчику.
Проверьте, что первая переменная-счетчик не равна нулю, и если да, то пусть функция вернет список из двух значений: логической константы True и значения второй-переменной счетчика; иначе пусть функция вернет логическую константу False.","[""{\n    'Глава 1': (3000, 'не переведена'), \n    'Глава 2': (2000, 'не переведена'), \n    'Глава 3': (10000, 'не переведена'), \n    'Глава 4': (6000, 'не переведена'),\n    'Глава 5': (6500, 'не переведена')\n}"", ""{\n    'Героический эпос народов СССР. № 1': (100000, 'переведена'),\n    'Героический эпос народов СССР. № 2': (1005, 'не переведена')\n}"", ""{\n    'Арабская поэзия средних веков': (1092, 'не переведена'),\n    'Ирано-таджикская поэзия': (10090, 'переведена'),\n    'Средневековый роман и повесть': (2198, 'переведена')\n}"", ""{\n    'г1': (90, 'не переведена'), \n    'г2': (29, 'не переведена'), \n    'г3': (10, 'не переведена'), \n    'г4': (80, 'не переведена'),\n    'г5': (8, 'не переведена')\n}"", ""{\n    'повесть': (32, 'переведена'), \n    'поэма': (212, 'переведена'), \n    'роман': (809, 'переведена'),\n    'рассказы': (80, 'переведена')\n}"", ""{\n    'ода': (312, 'не переведена'), \n    'новелла': (2112, 'переведена'), \n    'юмореска': (809, 'переведена'),\n    'сатира': (89280, 'не переведена')\n}""]","['False', '[True, 100000]', '[True, 12288]', 'False', '[True, 1133]', '[True, 2921]']","def text_check(data):
    counter = 0
    summa = 0
    for k, v in data.items():
        if v[1] == переведена:
            counter += 1
            summa += v[0]
            
    if counter != 0:
        return ([True, summa])
        
    return False","def text_check(data):
    counter = 0
    summa = 0
    for k, v in data.items():
        if v[1] == 'переведена':
            counter += 1
            summa += v[0]
            
    if counter != 0:
        return ([True, summa])
        
    return False","Синтаксическая ошибка. Значение ""переведена"" следует заключать в кавычки.","['open', 'open', 'open', 'closed', 'closed', 'closed']","<Task description>: Напишите функцию, определяющую можно считать книгу переведенной или нет. 

ТРЕБУЕМАЯ ФУНКЦИЯ 
Функция text_check, принимающая на вход словарь, ключи в котором — названия глав (строки), а значения — кортежи с двумя элементами (целым числом — количеством слов в главе; и строкой ""переведена"" или ""не переведена""). Гарантируется, что словарь содержит информацию минимум об одной главе.
Если хотя бы одна глава была переведена, то функция должна возвращать список из двух значений: логической константы True и целого числа — количества слов в главах, которые были переведены.
Если все главы не были переведены, то функция возвращает логическую константу False.
ВАЖНО! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Определите функцию и аргумент, с которым она работает.
Задайте две переменные-счетчика — одну для подсчета количества слов, другую для подсчета количества строк ""переведена"".
Обратитесь к парам ключ-значение в переданном функции словаре. Если первый по индексу элемент значения (кортежа) принимает значение ""переведена"", то прибавьте 1 к первой переменной-счетчику и прибавьте нулевой по индексу элемент значения (кортежа) ко второй переменной-счетчику.
Проверьте, что первая переменная-счетчик не равна нулю, и если да, то пусть функция вернет список из двух значений: логической константы True и значения второй-переменной счетчика; иначе пусть функция вернет логическую константу False. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: {
    'Глава 1': (3000, 'не переведена'), 
    'Глава 2': (2000, 'не переведена'), 
    'Глава 3': (10000, 'не переведена'), 
    'Глава 4': (6000, 'не переведена'),
    'Глава 5': (6500, 'не переведена')
} 
<Вывод>: False 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: {
    'Героический эпос народов СССР. № 1': (100000, 'переведена'),
    'Героический эпос народов СССР. № 2': (1005, 'не переведена')
} 
<Вывод>: [True, 100000] 
<Example 3>: 
<Тип теста 3>: open 
<Ввод>: {
    'Арабская поэзия средних веков': (1092, 'не переведена'),
    'Ирано-таджикская поэзия': (10090, 'переведена'),
    'Средневековый роман и повесть': (2198, 'переведена')
} 
<Вывод>: [True, 12288] 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: {
    'г1': (90, 'не переведена'), 
    'г2': (29, 'не переведена'), 
    'г3': (10, 'не переведена'), 
    'г4': (80, 'не переведена'),
    'г5': (8, 'не переведена')
} 
<Вывод>: False 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: {
    'повесть': (32, 'переведена'), 
    'поэма': (212, 'переведена'), 
    'роман': (809, 'переведена'),
    'рассказы': (80, 'переведена')
} 
<Вывод>: [True, 1133] 
<Example 6>: 
<Тип теста 6>: closed 
<Ввод>: {
    'ода': (312, 'не переведена'), 
    'новелла': (2112, 'переведена'), 
    'юмореска': (809, 'переведена'),
    'сатира': (89280, 'не переведена')
} 
<Вывод>: [True, 2921] 
<Решение студента>: def text_check(data):
    counter = 0
    summa = 0
    for k, v in data.items():
        if v[1] == переведена:
            counter += 1
            summa += v[0]
            
    if counter != 0:
        return ([True, summa])
        
    return False 
<Идеальное решение>: def text_check(data):
    counter = 0
    summa = 0
    for k, v in data.items():
        if v[1] == 'переведена':
            counter += 1
            summa += v[0]
            
    if counter != 0:
        return ([True, summa])
        
    return False 


<Комментарий эксперта>:"
244,545,34,"Напишите функцию, определяющую можно считать книгу переведенной или нет. 

ТРЕБУЕМАЯ ФУНКЦИЯ 
Функция text_check, принимающая на вход словарь, ключи в котором — названия глав (строки), а значения — кортежи с двумя элементами (целым числом — количеством слов в главе; и строкой ""переведена"" или ""не переведена""). Гарантируется, что словарь содержит информацию минимум об одной главе.
Если хотя бы одна глава была переведена, то функция должна возвращать список из двух значений: логической константы True и целого числа — количества слов в главах, которые были переведены.
Если все главы не были переведены, то функция возвращает логическую константу False.
ВАЖНО! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Определите функцию и аргумент, с которым она работает.
Задайте две переменные-счетчика — одну для подсчета количества слов, другую для подсчета количества строк ""переведена"".
Обратитесь к парам ключ-значение в переданном функции словаре. Если первый по индексу элемент значения (кортежа) принимает значение ""переведена"", то прибавьте 1 к первой переменной-счетчику и прибавьте нулевой по индексу элемент значения (кортежа) ко второй переменной-счетчику.
Проверьте, что первая переменная-счетчик не равна нулю, и если да, то пусть функция вернет список из двух значений: логической константы True и значения второй-переменной счетчика; иначе пусть функция вернет логическую константу False.","[""{\n    'Глава 1': (3000, 'не переведена'), \n    'Глава 2': (2000, 'не переведена'), \n    'Глава 3': (10000, 'не переведена'), \n    'Глава 4': (6000, 'не переведена'),\n    'Глава 5': (6500, 'не переведена')\n}"", ""{\n    'Героический эпос народов СССР. № 1': (100000, 'переведена'),\n    'Героический эпос народов СССР. № 2': (1005, 'не переведена')\n}"", ""{\n    'Арабская поэзия средних веков': (1092, 'не переведена'),\n    'Ирано-таджикская поэзия': (10090, 'переведена'),\n    'Средневековый роман и повесть': (2198, 'переведена')\n}"", ""{\n    'г1': (90, 'не переведена'), \n    'г2': (29, 'не переведена'), \n    'г3': (10, 'не переведена'), \n    'г4': (80, 'не переведена'),\n    'г5': (8, 'не переведена')\n}"", ""{\n    'повесть': (32, 'переведена'), \n    'поэма': (212, 'переведена'), \n    'роман': (809, 'переведена'),\n    'рассказы': (80, 'переведена')\n}"", ""{\n    'ода': (312, 'не переведена'), \n    'новелла': (2112, 'переведена'), \n    'юмореска': (809, 'переведена'),\n    'сатира': (89280, 'не переведена')\n}""]","['False', '[True, 100000]', '[True, 12288]', 'False', '[True, 1133]', '[True, 2921]']","def text_check(data):
    counter = 0
    summa = 0
    for k, v in data.items():
        if v[1] != 'переведена':
            counter += 1
            summa += v[0]
            
    if counter != 0:
        return ([True, summa])
        
    return False","def text_check(data):
    counter = 0
    summa = 0
    for k, v in data.items():
        if v[1] == 'переведена':
            counter += 1
            summa += v[0]
            
    if counter != 0:
        return ([True, summa])
        
    return False","Ошибка в открытых и скрытых тестах. 

Ваш код некорректно выполняет условия задания. Так, он некорректно выполянет условия ""Если хотя бы одна глава была переведена, то функция должна возвращать список из двух значений: логической константы True и целого числа — количества слов в главах, которые были переведены. Если все главы не были переведены, то функция возвращает логическую константу False"". Попробуйте изменить условие if для исправления ошибки.","['open', 'open', 'open', 'closed', 'closed', 'closed']","<Task description>: Напишите функцию, определяющую можно считать книгу переведенной или нет. 

ТРЕБУЕМАЯ ФУНКЦИЯ 
Функция text_check, принимающая на вход словарь, ключи в котором — названия глав (строки), а значения — кортежи с двумя элементами (целым числом — количеством слов в главе; и строкой ""переведена"" или ""не переведена""). Гарантируется, что словарь содержит информацию минимум об одной главе.
Если хотя бы одна глава была переведена, то функция должна возвращать список из двух значений: логической константы True и целого числа — количества слов в главах, которые были переведены.
Если все главы не были переведены, то функция возвращает логическую константу False.
ВАЖНО! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Определите функцию и аргумент, с которым она работает.
Задайте две переменные-счетчика — одну для подсчета количества слов, другую для подсчета количества строк ""переведена"".
Обратитесь к парам ключ-значение в переданном функции словаре. Если первый по индексу элемент значения (кортежа) принимает значение ""переведена"", то прибавьте 1 к первой переменной-счетчику и прибавьте нулевой по индексу элемент значения (кортежа) ко второй переменной-счетчику.
Проверьте, что первая переменная-счетчик не равна нулю, и если да, то пусть функция вернет список из двух значений: логической константы True и значения второй-переменной счетчика; иначе пусть функция вернет логическую константу False. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: {
    'Глава 1': (3000, 'не переведена'), 
    'Глава 2': (2000, 'не переведена'), 
    'Глава 3': (10000, 'не переведена'), 
    'Глава 4': (6000, 'не переведена'),
    'Глава 5': (6500, 'не переведена')
} 
<Вывод>: False 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: {
    'Героический эпос народов СССР. № 1': (100000, 'переведена'),
    'Героический эпос народов СССР. № 2': (1005, 'не переведена')
} 
<Вывод>: [True, 100000] 
<Example 3>: 
<Тип теста 3>: open 
<Ввод>: {
    'Арабская поэзия средних веков': (1092, 'не переведена'),
    'Ирано-таджикская поэзия': (10090, 'переведена'),
    'Средневековый роман и повесть': (2198, 'переведена')
} 
<Вывод>: [True, 12288] 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: {
    'г1': (90, 'не переведена'), 
    'г2': (29, 'не переведена'), 
    'г3': (10, 'не переведена'), 
    'г4': (80, 'не переведена'),
    'г5': (8, 'не переведена')
} 
<Вывод>: False 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: {
    'повесть': (32, 'переведена'), 
    'поэма': (212, 'переведена'), 
    'роман': (809, 'переведена'),
    'рассказы': (80, 'переведена')
} 
<Вывод>: [True, 1133] 
<Example 6>: 
<Тип теста 6>: closed 
<Ввод>: {
    'ода': (312, 'не переведена'), 
    'новелла': (2112, 'переведена'), 
    'юмореска': (809, 'переведена'),
    'сатира': (89280, 'не переведена')
} 
<Вывод>: [True, 2921] 
<Решение студента>: def text_check(data):
    counter = 0
    summa = 0
    for k, v in data.items():
        if v[1] != 'переведена':
            counter += 1
            summa += v[0]
            
    if counter != 0:
        return ([True, summa])
        
    return False 
<Идеальное решение>: def text_check(data):
    counter = 0
    summa = 0
    for k, v in data.items():
        if v[1] == 'переведена':
            counter += 1
            summa += v[0]
            
    if counter != 0:
        return ([True, summa])
        
    return False 


<Комментарий эксперта>:"
245,546,34,"Напишите функцию, определяющую можно считать книгу переведенной или нет. 

ТРЕБУЕМАЯ ФУНКЦИЯ 
Функция text_check, принимающая на вход словарь, ключи в котором — названия глав (строки), а значения — кортежи с двумя элементами (целым числом — количеством слов в главе; и строкой ""переведена"" или ""не переведена""). Гарантируется, что словарь содержит информацию минимум об одной главе.
Если хотя бы одна глава была переведена, то функция должна возвращать список из двух значений: логической константы True и целого числа — количества слов в главах, которые были переведены.
Если все главы не были переведены, то функция возвращает логическую константу False.
ВАЖНО! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Определите функцию и аргумент, с которым она работает.
Задайте две переменные-счетчика — одну для подсчета количества слов, другую для подсчета количества строк ""переведена"".
Обратитесь к парам ключ-значение в переданном функции словаре. Если первый по индексу элемент значения (кортежа) принимает значение ""переведена"", то прибавьте 1 к первой переменной-счетчику и прибавьте нулевой по индексу элемент значения (кортежа) ко второй переменной-счетчику.
Проверьте, что первая переменная-счетчик не равна нулю, и если да, то пусть функция вернет список из двух значений: логической константы True и значения второй-переменной счетчика; иначе пусть функция вернет логическую константу False.","[""{\n    'Глава 1': (3000, 'не переведена'), \n    'Глава 2': (2000, 'не переведена'), \n    'Глава 3': (10000, 'не переведена'), \n    'Глава 4': (6000, 'не переведена'),\n    'Глава 5': (6500, 'не переведена')\n}"", ""{\n    'Героический эпос народов СССР. № 1': (100000, 'переведена'),\n    'Героический эпос народов СССР. № 2': (1005, 'не переведена')\n}"", ""{\n    'Арабская поэзия средних веков': (1092, 'не переведена'),\n    'Ирано-таджикская поэзия': (10090, 'переведена'),\n    'Средневековый роман и повесть': (2198, 'переведена')\n}"", ""{\n    'г1': (90, 'не переведена'), \n    'г2': (29, 'не переведена'), \n    'г3': (10, 'не переведена'), \n    'г4': (80, 'не переведена'),\n    'г5': (8, 'не переведена')\n}"", ""{\n    'повесть': (32, 'переведена'), \n    'поэма': (212, 'переведена'), \n    'роман': (809, 'переведена'),\n    'рассказы': (80, 'переведена')\n}"", ""{\n    'ода': (312, 'не переведена'), \n    'новелла': (2112, 'переведена'), \n    'юмореска': (809, 'переведена'),\n    'сатира': (89280, 'не переведена')\n}""]","['False', '[True, 100000]', '[True, 12288]', 'False', '[True, 1133]', '[True, 2921]']","def text_check(data):
    counter = 0
    summa = 0
    for k, v in data.items():
        if v[1] == 'переведена':
            counter += 1
            summa += v[0]
            
    if counter != 0:
        return ([False, summa])
        
    return True","def text_check(data):
    counter = 0
    summa = 0
    for k, v in data.items():
        if v[1] == 'переведена':
            counter += 1
            summa += v[0]
            
    if counter != 0:
        return ([True, summa])
        
    return False","Ошибка в открытых и скрытых тестах. 

Ваш код некорректно выполняет условия задания. Так, он некорректно выполянет условия ""Если хотя бы одна глава была переведена, то функция должна возвращать список из двух значений: логической константы True и целого числа — количества слов в главах, которые были переведены. Если все главы не были переведены, то функция возвращает логическую константу False"". Попробуйте изменить условие if для исправления ошибки.","['open', 'open', 'open', 'closed', 'closed', 'closed']","<Task description>: Напишите функцию, определяющую можно считать книгу переведенной или нет. 

ТРЕБУЕМАЯ ФУНКЦИЯ 
Функция text_check, принимающая на вход словарь, ключи в котором — названия глав (строки), а значения — кортежи с двумя элементами (целым числом — количеством слов в главе; и строкой ""переведена"" или ""не переведена""). Гарантируется, что словарь содержит информацию минимум об одной главе.
Если хотя бы одна глава была переведена, то функция должна возвращать список из двух значений: логической константы True и целого числа — количества слов в главах, которые были переведены.
Если все главы не были переведены, то функция возвращает логическую константу False.
ВАЖНО! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Определите функцию и аргумент, с которым она работает.
Задайте две переменные-счетчика — одну для подсчета количества слов, другую для подсчета количества строк ""переведена"".
Обратитесь к парам ключ-значение в переданном функции словаре. Если первый по индексу элемент значения (кортежа) принимает значение ""переведена"", то прибавьте 1 к первой переменной-счетчику и прибавьте нулевой по индексу элемент значения (кортежа) ко второй переменной-счетчику.
Проверьте, что первая переменная-счетчик не равна нулю, и если да, то пусть функция вернет список из двух значений: логической константы True и значения второй-переменной счетчика; иначе пусть функция вернет логическую константу False. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: {
    'Глава 1': (3000, 'не переведена'), 
    'Глава 2': (2000, 'не переведена'), 
    'Глава 3': (10000, 'не переведена'), 
    'Глава 4': (6000, 'не переведена'),
    'Глава 5': (6500, 'не переведена')
} 
<Вывод>: False 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: {
    'Героический эпос народов СССР. № 1': (100000, 'переведена'),
    'Героический эпос народов СССР. № 2': (1005, 'не переведена')
} 
<Вывод>: [True, 100000] 
<Example 3>: 
<Тип теста 3>: open 
<Ввод>: {
    'Арабская поэзия средних веков': (1092, 'не переведена'),
    'Ирано-таджикская поэзия': (10090, 'переведена'),
    'Средневековый роман и повесть': (2198, 'переведена')
} 
<Вывод>: [True, 12288] 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: {
    'г1': (90, 'не переведена'), 
    'г2': (29, 'не переведена'), 
    'г3': (10, 'не переведена'), 
    'г4': (80, 'не переведена'),
    'г5': (8, 'не переведена')
} 
<Вывод>: False 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: {
    'повесть': (32, 'переведена'), 
    'поэма': (212, 'переведена'), 
    'роман': (809, 'переведена'),
    'рассказы': (80, 'переведена')
} 
<Вывод>: [True, 1133] 
<Example 6>: 
<Тип теста 6>: closed 
<Ввод>: {
    'ода': (312, 'не переведена'), 
    'новелла': (2112, 'переведена'), 
    'юмореска': (809, 'переведена'),
    'сатира': (89280, 'не переведена')
} 
<Вывод>: [True, 2921] 
<Решение студента>: def text_check(data):
    counter = 0
    summa = 0
    for k, v in data.items():
        if v[1] == 'переведена':
            counter += 1
            summa += v[0]
            
    if counter != 0:
        return ([False, summa])
        
    return True 
<Идеальное решение>: def text_check(data):
    counter = 0
    summa = 0
    for k, v in data.items():
        if v[1] == 'переведена':
            counter += 1
            summa += v[0]
            
    if counter != 0:
        return ([True, summa])
        
    return False 


<Комментарий эксперта>:"
246,547,34,"Напишите функцию, определяющую можно считать книгу переведенной или нет. 

ТРЕБУЕМАЯ ФУНКЦИЯ 
Функция text_check, принимающая на вход словарь, ключи в котором — названия глав (строки), а значения — кортежи с двумя элементами (целым числом — количеством слов в главе; и строкой ""переведена"" или ""не переведена""). Гарантируется, что словарь содержит информацию минимум об одной главе.
Если хотя бы одна глава была переведена, то функция должна возвращать список из двух значений: логической константы True и целого числа — количества слов в главах, которые были переведены.
Если все главы не были переведены, то функция возвращает логическую константу False.
ВАЖНО! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Определите функцию и аргумент, с которым она работает.
Задайте две переменные-счетчика — одну для подсчета количества слов, другую для подсчета количества строк ""переведена"".
Обратитесь к парам ключ-значение в переданном функции словаре. Если первый по индексу элемент значения (кортежа) принимает значение ""переведена"", то прибавьте 1 к первой переменной-счетчику и прибавьте нулевой по индексу элемент значения (кортежа) ко второй переменной-счетчику.
Проверьте, что первая переменная-счетчик не равна нулю, и если да, то пусть функция вернет список из двух значений: логической константы True и значения второй-переменной счетчика; иначе пусть функция вернет логическую константу False.","[""{\n    'Глава 1': (3000, 'не переведена'), \n    'Глава 2': (2000, 'не переведена'), \n    'Глава 3': (10000, 'не переведена'), \n    'Глава 4': (6000, 'не переведена'),\n    'Глава 5': (6500, 'не переведена')\n}"", ""{\n    'Героический эпос народов СССР. № 1': (100000, 'переведена'),\n    'Героический эпос народов СССР. № 2': (1005, 'не переведена')\n}"", ""{\n    'Арабская поэзия средних веков': (1092, 'не переведена'),\n    'Ирано-таджикская поэзия': (10090, 'переведена'),\n    'Средневековый роман и повесть': (2198, 'переведена')\n}"", ""{\n    'г1': (90, 'не переведена'), \n    'г2': (29, 'не переведена'), \n    'г3': (10, 'не переведена'), \n    'г4': (80, 'не переведена'),\n    'г5': (8, 'не переведена')\n}"", ""{\n    'повесть': (32, 'переведена'), \n    'поэма': (212, 'переведена'), \n    'роман': (809, 'переведена'),\n    'рассказы': (80, 'переведена')\n}"", ""{\n    'ода': (312, 'не переведена'), \n    'новелла': (2112, 'переведена'), \n    'юмореска': (809, 'переведена'),\n    'сатира': (89280, 'не переведена')\n}""]","['False', '[True, 100000]', '[True, 12288]', 'False', '[True, 1133]', '[True, 2921]']","def text_check(data):
    counter = 0
    summa = 0
    for k, v in data.items():
        if v[1] == 'переведена':
            counter += 1
            summa += v[0]
            
    if counter != 0:
        return ([summa, True])
        
    return False","def text_check(data):
    counter = 0
    summa = 0
    for k, v in data.items():
        if v[1] == 'переведена':
            counter += 1
            summa += v[0]
            
    if counter != 0:
        return ([True, summa])
        
    return False","Ошибка в открытых и скрытых тестах. 

Ваш код некорректно выполняет условия задания. Так, он некорректно выполянет условия ""Если хотя бы одна глава была переведена, то функция должна возвращать список из двух значений: логической константы True и целого числа — количества слов в главах, которые были переведены. Если все главы не были переведены, то функция возвращает логическую константу False"". Попробуйте изменить условие if для исправления ошибки.","['open', 'open', 'open', 'closed', 'closed', 'closed']","<Task description>: Напишите функцию, определяющую можно считать книгу переведенной или нет. 

ТРЕБУЕМАЯ ФУНКЦИЯ 
Функция text_check, принимающая на вход словарь, ключи в котором — названия глав (строки), а значения — кортежи с двумя элементами (целым числом — количеством слов в главе; и строкой ""переведена"" или ""не переведена""). Гарантируется, что словарь содержит информацию минимум об одной главе.
Если хотя бы одна глава была переведена, то функция должна возвращать список из двух значений: логической константы True и целого числа — количества слов в главах, которые были переведены.
Если все главы не были переведены, то функция возвращает логическую константу False.
ВАЖНО! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Определите функцию и аргумент, с которым она работает.
Задайте две переменные-счетчика — одну для подсчета количества слов, другую для подсчета количества строк ""переведена"".
Обратитесь к парам ключ-значение в переданном функции словаре. Если первый по индексу элемент значения (кортежа) принимает значение ""переведена"", то прибавьте 1 к первой переменной-счетчику и прибавьте нулевой по индексу элемент значения (кортежа) ко второй переменной-счетчику.
Проверьте, что первая переменная-счетчик не равна нулю, и если да, то пусть функция вернет список из двух значений: логической константы True и значения второй-переменной счетчика; иначе пусть функция вернет логическую константу False. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: {
    'Глава 1': (3000, 'не переведена'), 
    'Глава 2': (2000, 'не переведена'), 
    'Глава 3': (10000, 'не переведена'), 
    'Глава 4': (6000, 'не переведена'),
    'Глава 5': (6500, 'не переведена')
} 
<Вывод>: False 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: {
    'Героический эпос народов СССР. № 1': (100000, 'переведена'),
    'Героический эпос народов СССР. № 2': (1005, 'не переведена')
} 
<Вывод>: [True, 100000] 
<Example 3>: 
<Тип теста 3>: open 
<Ввод>: {
    'Арабская поэзия средних веков': (1092, 'не переведена'),
    'Ирано-таджикская поэзия': (10090, 'переведена'),
    'Средневековый роман и повесть': (2198, 'переведена')
} 
<Вывод>: [True, 12288] 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: {
    'г1': (90, 'не переведена'), 
    'г2': (29, 'не переведена'), 
    'г3': (10, 'не переведена'), 
    'г4': (80, 'не переведена'),
    'г5': (8, 'не переведена')
} 
<Вывод>: False 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: {
    'повесть': (32, 'переведена'), 
    'поэма': (212, 'переведена'), 
    'роман': (809, 'переведена'),
    'рассказы': (80, 'переведена')
} 
<Вывод>: [True, 1133] 
<Example 6>: 
<Тип теста 6>: closed 
<Ввод>: {
    'ода': (312, 'не переведена'), 
    'новелла': (2112, 'переведена'), 
    'юмореска': (809, 'переведена'),
    'сатира': (89280, 'не переведена')
} 
<Вывод>: [True, 2921] 
<Решение студента>: def text_check(data):
    counter = 0
    summa = 0
    for k, v in data.items():
        if v[1] == 'переведена':
            counter += 1
            summa += v[0]
            
    if counter != 0:
        return ([summa, True])
        
    return False 
<Идеальное решение>: def text_check(data):
    counter = 0
    summa = 0
    for k, v in data.items():
        if v[1] == 'переведена':
            counter += 1
            summa += v[0]
            
    if counter != 0:
        return ([True, summa])
        
    return False 


<Комментарий эксперта>:"
247,548,34,"Напишите функцию, определяющую можно считать книгу переведенной или нет. 

ТРЕБУЕМАЯ ФУНКЦИЯ 
Функция text_check, принимающая на вход словарь, ключи в котором — названия глав (строки), а значения — кортежи с двумя элементами (целым числом — количеством слов в главе; и строкой ""переведена"" или ""не переведена""). Гарантируется, что словарь содержит информацию минимум об одной главе.
Если хотя бы одна глава была переведена, то функция должна возвращать список из двух значений: логической константы True и целого числа — количества слов в главах, которые были переведены.
Если все главы не были переведены, то функция возвращает логическую константу False.
ВАЖНО! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Определите функцию и аргумент, с которым она работает.
Задайте две переменные-счетчика — одну для подсчета количества слов, другую для подсчета количества строк ""переведена"".
Обратитесь к парам ключ-значение в переданном функции словаре. Если первый по индексу элемент значения (кортежа) принимает значение ""переведена"", то прибавьте 1 к первой переменной-счетчику и прибавьте нулевой по индексу элемент значения (кортежа) ко второй переменной-счетчику.
Проверьте, что первая переменная-счетчик не равна нулю, и если да, то пусть функция вернет список из двух значений: логической константы True и значения второй-переменной счетчика; иначе пусть функция вернет логическую константу False.","[""{\n    'Глава 1': (3000, 'не переведена'), \n    'Глава 2': (2000, 'не переведена'), \n    'Глава 3': (10000, 'не переведена'), \n    'Глава 4': (6000, 'не переведена'),\n    'Глава 5': (6500, 'не переведена')\n}"", ""{\n    'Героический эпос народов СССР. № 1': (100000, 'переведена'),\n    'Героический эпос народов СССР. № 2': (1005, 'не переведена')\n}"", ""{\n    'Арабская поэзия средних веков': (1092, 'не переведена'),\n    'Ирано-таджикская поэзия': (10090, 'переведена'),\n    'Средневековый роман и повесть': (2198, 'переведена')\n}"", ""{\n    'г1': (90, 'не переведена'), \n    'г2': (29, 'не переведена'), \n    'г3': (10, 'не переведена'), \n    'г4': (80, 'не переведена'),\n    'г5': (8, 'не переведена')\n}"", ""{\n    'повесть': (32, 'переведена'), \n    'поэма': (212, 'переведена'), \n    'роман': (809, 'переведена'),\n    'рассказы': (80, 'переведена')\n}"", ""{\n    'ода': (312, 'не переведена'), \n    'новелла': (2112, 'переведена'), \n    'юмореска': (809, 'переведена'),\n    'сатира': (89280, 'не переведена')\n}""]","['False', '[True, 100000]', '[True, 12288]', 'False', '[True, 1133]', '[True, 2921]']","def text_check(data):
    counter = 0
    summa = 0
    for k, v in data.items():
        if v[1] == 'переведена':
            counter += 1
            summa == v[0]
            
    if counter != 0:
        return ([True, summa])
        
    return False","def text_check(data):
    counter = 0
    summa = 0
    for k, v in data.items():
        if v[1] == 'переведена':
            counter += 1
            summa += v[0]
            
    if counter != 0:
        return ([True, summa])
        
    return False","Ошибка в открытых и скрытых тестах. 

Ваш код некорректно выполняет условия задания. Так, он некорректно выполянет условия ""Если хотя бы одна глава была переведена, то функция должна возвращать список из двух значений: логической константы True и целого числа — количества слов в главах, которые были переведены. Если все главы не были переведены, то функция возвращает логическую константу False"". Попробуйте изменить условие if для исправления ошибки.","['open', 'open', 'open', 'closed', 'closed', 'closed']","<Task description>: Напишите функцию, определяющую можно считать книгу переведенной или нет. 

ТРЕБУЕМАЯ ФУНКЦИЯ 
Функция text_check, принимающая на вход словарь, ключи в котором — названия глав (строки), а значения — кортежи с двумя элементами (целым числом — количеством слов в главе; и строкой ""переведена"" или ""не переведена""). Гарантируется, что словарь содержит информацию минимум об одной главе.
Если хотя бы одна глава была переведена, то функция должна возвращать список из двух значений: логической константы True и целого числа — количества слов в главах, которые были переведены.
Если все главы не были переведены, то функция возвращает логическую константу False.
ВАЖНО! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Определите функцию и аргумент, с которым она работает.
Задайте две переменные-счетчика — одну для подсчета количества слов, другую для подсчета количества строк ""переведена"".
Обратитесь к парам ключ-значение в переданном функции словаре. Если первый по индексу элемент значения (кортежа) принимает значение ""переведена"", то прибавьте 1 к первой переменной-счетчику и прибавьте нулевой по индексу элемент значения (кортежа) ко второй переменной-счетчику.
Проверьте, что первая переменная-счетчик не равна нулю, и если да, то пусть функция вернет список из двух значений: логической константы True и значения второй-переменной счетчика; иначе пусть функция вернет логическую константу False. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: {
    'Глава 1': (3000, 'не переведена'), 
    'Глава 2': (2000, 'не переведена'), 
    'Глава 3': (10000, 'не переведена'), 
    'Глава 4': (6000, 'не переведена'),
    'Глава 5': (6500, 'не переведена')
} 
<Вывод>: False 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: {
    'Героический эпос народов СССР. № 1': (100000, 'переведена'),
    'Героический эпос народов СССР. № 2': (1005, 'не переведена')
} 
<Вывод>: [True, 100000] 
<Example 3>: 
<Тип теста 3>: open 
<Ввод>: {
    'Арабская поэзия средних веков': (1092, 'не переведена'),
    'Ирано-таджикская поэзия': (10090, 'переведена'),
    'Средневековый роман и повесть': (2198, 'переведена')
} 
<Вывод>: [True, 12288] 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: {
    'г1': (90, 'не переведена'), 
    'г2': (29, 'не переведена'), 
    'г3': (10, 'не переведена'), 
    'г4': (80, 'не переведена'),
    'г5': (8, 'не переведена')
} 
<Вывод>: False 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: {
    'повесть': (32, 'переведена'), 
    'поэма': (212, 'переведена'), 
    'роман': (809, 'переведена'),
    'рассказы': (80, 'переведена')
} 
<Вывод>: [True, 1133] 
<Example 6>: 
<Тип теста 6>: closed 
<Ввод>: {
    'ода': (312, 'не переведена'), 
    'новелла': (2112, 'переведена'), 
    'юмореска': (809, 'переведена'),
    'сатира': (89280, 'не переведена')
} 
<Вывод>: [True, 2921] 
<Решение студента>: def text_check(data):
    counter = 0
    summa = 0
    for k, v in data.items():
        if v[1] == 'переведена':
            counter += 1
            summa == v[0]
            
    if counter != 0:
        return ([True, summa])
        
    return False 
<Идеальное решение>: def text_check(data):
    counter = 0
    summa = 0
    for k, v in data.items():
        if v[1] == 'переведена':
            counter += 1
            summa += v[0]
            
    if counter != 0:
        return ([True, summa])
        
    return False 


<Комментарий эксперта>:"
248,549,34,"Напишите функцию, определяющую можно считать книгу переведенной или нет. 

ТРЕБУЕМАЯ ФУНКЦИЯ 
Функция text_check, принимающая на вход словарь, ключи в котором — названия глав (строки), а значения — кортежи с двумя элементами (целым числом — количеством слов в главе; и строкой ""переведена"" или ""не переведена""). Гарантируется, что словарь содержит информацию минимум об одной главе.
Если хотя бы одна глава была переведена, то функция должна возвращать список из двух значений: логической константы True и целого числа — количества слов в главах, которые были переведены.
Если все главы не были переведены, то функция возвращает логическую константу False.
ВАЖНО! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Определите функцию и аргумент, с которым она работает.
Задайте две переменные-счетчика — одну для подсчета количества слов, другую для подсчета количества строк ""переведена"".
Обратитесь к парам ключ-значение в переданном функции словаре. Если первый по индексу элемент значения (кортежа) принимает значение ""переведена"", то прибавьте 1 к первой переменной-счетчику и прибавьте нулевой по индексу элемент значения (кортежа) ко второй переменной-счетчику.
Проверьте, что первая переменная-счетчик не равна нулю, и если да, то пусть функция вернет список из двух значений: логической константы True и значения второй-переменной счетчика; иначе пусть функция вернет логическую константу False.","[""{\n    'Глава 1': (3000, 'не переведена'), \n    'Глава 2': (2000, 'не переведена'), \n    'Глава 3': (10000, 'не переведена'), \n    'Глава 4': (6000, 'не переведена'),\n    'Глава 5': (6500, 'не переведена')\n}"", ""{\n    'Героический эпос народов СССР. № 1': (100000, 'переведена'),\n    'Героический эпос народов СССР. № 2': (1005, 'не переведена')\n}"", ""{\n    'Арабская поэзия средних веков': (1092, 'не переведена'),\n    'Ирано-таджикская поэзия': (10090, 'переведена'),\n    'Средневековый роман и повесть': (2198, 'переведена')\n}"", ""{\n    'г1': (90, 'не переведена'), \n    'г2': (29, 'не переведена'), \n    'г3': (10, 'не переведена'), \n    'г4': (80, 'не переведена'),\n    'г5': (8, 'не переведена')\n}"", ""{\n    'повесть': (32, 'переведена'), \n    'поэма': (212, 'переведена'), \n    'роман': (809, 'переведена'),\n    'рассказы': (80, 'переведена')\n}"", ""{\n    'ода': (312, 'не переведена'), \n    'новелла': (2112, 'переведена'), \n    'юмореска': (809, 'переведена'),\n    'сатира': (89280, 'не переведена')\n}""]","['False', '[True, 100000]', '[True, 12288]', 'False', '[True, 1133]', '[True, 2921]']","def text_check(data):
    counter = 0
    summa = 0
    for k, v in data.items():
        if v[1] == 'переведена':
            counter += 1
            summa += v[0]
            
    if counter != 0:
        print([True, summa])
        
    print(False)","def text_check(data):
    counter = 0
    summa = 0
    for k, v in data.items():
        if v[1] == 'переведена':
            counter += 1
            summa += v[0]
            
    if counter != 0:
        return ([True, summa])
        
    return False",Ошибка при выборе метода для возвращения данных. В данном задании ненльзя использовать print().,"['open', 'open', 'open', 'closed', 'closed', 'closed']","<Task description>: Напишите функцию, определяющую можно считать книгу переведенной или нет. 

ТРЕБУЕМАЯ ФУНКЦИЯ 
Функция text_check, принимающая на вход словарь, ключи в котором — названия глав (строки), а значения — кортежи с двумя элементами (целым числом — количеством слов в главе; и строкой ""переведена"" или ""не переведена""). Гарантируется, что словарь содержит информацию минимум об одной главе.
Если хотя бы одна глава была переведена, то функция должна возвращать список из двух значений: логической константы True и целого числа — количества слов в главах, которые были переведены.
Если все главы не были переведены, то функция возвращает логическую константу False.
ВАЖНО! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Определите функцию и аргумент, с которым она работает.
Задайте две переменные-счетчика — одну для подсчета количества слов, другую для подсчета количества строк ""переведена"".
Обратитесь к парам ключ-значение в переданном функции словаре. Если первый по индексу элемент значения (кортежа) принимает значение ""переведена"", то прибавьте 1 к первой переменной-счетчику и прибавьте нулевой по индексу элемент значения (кортежа) ко второй переменной-счетчику.
Проверьте, что первая переменная-счетчик не равна нулю, и если да, то пусть функция вернет список из двух значений: логической константы True и значения второй-переменной счетчика; иначе пусть функция вернет логическую константу False. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: {
    'Глава 1': (3000, 'не переведена'), 
    'Глава 2': (2000, 'не переведена'), 
    'Глава 3': (10000, 'не переведена'), 
    'Глава 4': (6000, 'не переведена'),
    'Глава 5': (6500, 'не переведена')
} 
<Вывод>: False 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: {
    'Героический эпос народов СССР. № 1': (100000, 'переведена'),
    'Героический эпос народов СССР. № 2': (1005, 'не переведена')
} 
<Вывод>: [True, 100000] 
<Example 3>: 
<Тип теста 3>: open 
<Ввод>: {
    'Арабская поэзия средних веков': (1092, 'не переведена'),
    'Ирано-таджикская поэзия': (10090, 'переведена'),
    'Средневековый роман и повесть': (2198, 'переведена')
} 
<Вывод>: [True, 12288] 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: {
    'г1': (90, 'не переведена'), 
    'г2': (29, 'не переведена'), 
    'г3': (10, 'не переведена'), 
    'г4': (80, 'не переведена'),
    'г5': (8, 'не переведена')
} 
<Вывод>: False 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: {
    'повесть': (32, 'переведена'), 
    'поэма': (212, 'переведена'), 
    'роман': (809, 'переведена'),
    'рассказы': (80, 'переведена')
} 
<Вывод>: [True, 1133] 
<Example 6>: 
<Тип теста 6>: closed 
<Ввод>: {
    'ода': (312, 'не переведена'), 
    'новелла': (2112, 'переведена'), 
    'юмореска': (809, 'переведена'),
    'сатира': (89280, 'не переведена')
} 
<Вывод>: [True, 2921] 
<Решение студента>: def text_check(data):
    counter = 0
    summa = 0
    for k, v in data.items():
        if v[1] == 'переведена':
            counter += 1
            summa += v[0]
            
    if counter != 0:
        print([True, summa])
        
    print(False) 
<Идеальное решение>: def text_check(data):
    counter = 0
    summa = 0
    for k, v in data.items():
        if v[1] == 'переведена':
            counter += 1
            summa += v[0]
            
    if counter != 0:
        return ([True, summa])
        
    return False 


<Комментарий эксперта>:"
249,550,34,"Напишите функцию, определяющую можно считать книгу переведенной или нет. 

ТРЕБУЕМАЯ ФУНКЦИЯ 
Функция text_check, принимающая на вход словарь, ключи в котором — названия глав (строки), а значения — кортежи с двумя элементами (целым числом — количеством слов в главе; и строкой ""переведена"" или ""не переведена""). Гарантируется, что словарь содержит информацию минимум об одной главе.
Если хотя бы одна глава была переведена, то функция должна возвращать список из двух значений: логической константы True и целого числа — количества слов в главах, которые были переведены.
Если все главы не были переведены, то функция возвращает логическую константу False.
ВАЖНО! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Определите функцию и аргумент, с которым она работает.
Задайте две переменные-счетчика — одну для подсчета количества слов, другую для подсчета количества строк ""переведена"".
Обратитесь к парам ключ-значение в переданном функции словаре. Если первый по индексу элемент значения (кортежа) принимает значение ""переведена"", то прибавьте 1 к первой переменной-счетчику и прибавьте нулевой по индексу элемент значения (кортежа) ко второй переменной-счетчику.
Проверьте, что первая переменная-счетчик не равна нулю, и если да, то пусть функция вернет список из двух значений: логической константы True и значения второй-переменной счетчика; иначе пусть функция вернет логическую константу False.","[""{\n    'Глава 1': (3000, 'не переведена'), \n    'Глава 2': (2000, 'не переведена'), \n    'Глава 3': (10000, 'не переведена'), \n    'Глава 4': (6000, 'не переведена'),\n    'Глава 5': (6500, 'не переведена')\n}"", ""{\n    'Героический эпос народов СССР. № 1': (100000, 'переведена'),\n    'Героический эпос народов СССР. № 2': (1005, 'не переведена')\n}"", ""{\n    'Арабская поэзия средних веков': (1092, 'не переведена'),\n    'Ирано-таджикская поэзия': (10090, 'переведена'),\n    'Средневековый роман и повесть': (2198, 'переведена')\n}"", ""{\n    'г1': (90, 'не переведена'), \n    'г2': (29, 'не переведена'), \n    'г3': (10, 'не переведена'), \n    'г4': (80, 'не переведена'),\n    'г5': (8, 'не переведена')\n}"", ""{\n    'повесть': (32, 'переведена'), \n    'поэма': (212, 'переведена'), \n    'роман': (809, 'переведена'),\n    'рассказы': (80, 'переведена')\n}"", ""{\n    'ода': (312, 'не переведена'), \n    'новелла': (2112, 'переведена'), \n    'юмореска': (809, 'переведена'),\n    'сатира': (89280, 'не переведена')\n}""]","['False', '[True, 100000]', '[True, 12288]', 'False', '[True, 1133]', '[True, 2921]']","def text_check(data):
    counter = 0
    summa = 0
    for k, v in data.items():
        if v[1] == 'переведена':
            counter += 1
            summa += v[0]
            
    if counter != 0:
        return ([true, summa])
        
    return false","def text_check(data):
    counter = 0
    summa = 0
    for k, v in data.items():
        if v[1] == 'переведена':
            counter += 1
            summa += v[0]
            
    if counter != 0:
        return ([True, summa])
        
    return False",Синтаксическая ошибка. Обратите внимание на синтаксис булевых значений.,"['open', 'open', 'open', 'closed', 'closed', 'closed']","<Task description>: Напишите функцию, определяющую можно считать книгу переведенной или нет. 

ТРЕБУЕМАЯ ФУНКЦИЯ 
Функция text_check, принимающая на вход словарь, ключи в котором — названия глав (строки), а значения — кортежи с двумя элементами (целым числом — количеством слов в главе; и строкой ""переведена"" или ""не переведена""). Гарантируется, что словарь содержит информацию минимум об одной главе.
Если хотя бы одна глава была переведена, то функция должна возвращать список из двух значений: логической константы True и целого числа — количества слов в главах, которые были переведены.
Если все главы не были переведены, то функция возвращает логическую константу False.
ВАЖНО! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Определите функцию и аргумент, с которым она работает.
Задайте две переменные-счетчика — одну для подсчета количества слов, другую для подсчета количества строк ""переведена"".
Обратитесь к парам ключ-значение в переданном функции словаре. Если первый по индексу элемент значения (кортежа) принимает значение ""переведена"", то прибавьте 1 к первой переменной-счетчику и прибавьте нулевой по индексу элемент значения (кортежа) ко второй переменной-счетчику.
Проверьте, что первая переменная-счетчик не равна нулю, и если да, то пусть функция вернет список из двух значений: логической константы True и значения второй-переменной счетчика; иначе пусть функция вернет логическую константу False. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: {
    'Глава 1': (3000, 'не переведена'), 
    'Глава 2': (2000, 'не переведена'), 
    'Глава 3': (10000, 'не переведена'), 
    'Глава 4': (6000, 'не переведена'),
    'Глава 5': (6500, 'не переведена')
} 
<Вывод>: False 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: {
    'Героический эпос народов СССР. № 1': (100000, 'переведена'),
    'Героический эпос народов СССР. № 2': (1005, 'не переведена')
} 
<Вывод>: [True, 100000] 
<Example 3>: 
<Тип теста 3>: open 
<Ввод>: {
    'Арабская поэзия средних веков': (1092, 'не переведена'),
    'Ирано-таджикская поэзия': (10090, 'переведена'),
    'Средневековый роман и повесть': (2198, 'переведена')
} 
<Вывод>: [True, 12288] 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: {
    'г1': (90, 'не переведена'), 
    'г2': (29, 'не переведена'), 
    'г3': (10, 'не переведена'), 
    'г4': (80, 'не переведена'),
    'г5': (8, 'не переведена')
} 
<Вывод>: False 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: {
    'повесть': (32, 'переведена'), 
    'поэма': (212, 'переведена'), 
    'роман': (809, 'переведена'),
    'рассказы': (80, 'переведена')
} 
<Вывод>: [True, 1133] 
<Example 6>: 
<Тип теста 6>: closed 
<Ввод>: {
    'ода': (312, 'не переведена'), 
    'новелла': (2112, 'переведена'), 
    'юмореска': (809, 'переведена'),
    'сатира': (89280, 'не переведена')
} 
<Вывод>: [True, 2921] 
<Решение студента>: def text_check(data):
    counter = 0
    summa = 0
    for k, v in data.items():
        if v[1] == 'переведена':
            counter += 1
            summa += v[0]
            
    if counter != 0:
        return ([true, summa])
        
    return false 
<Идеальное решение>: def text_check(data):
    counter = 0
    summa = 0
    for k, v in data.items():
        if v[1] == 'переведена':
            counter += 1
            summa += v[0]
            
    if counter != 0:
        return ([True, summa])
        
    return False 


<Комментарий эксперта>:"
250,551,34,"Напишите функцию, определяющую можно считать книгу переведенной или нет. 

ТРЕБУЕМАЯ ФУНКЦИЯ 
Функция text_check, принимающая на вход словарь, ключи в котором — названия глав (строки), а значения — кортежи с двумя элементами (целым числом — количеством слов в главе; и строкой ""переведена"" или ""не переведена""). Гарантируется, что словарь содержит информацию минимум об одной главе.
Если хотя бы одна глава была переведена, то функция должна возвращать список из двух значений: логической константы True и целого числа — количества слов в главах, которые были переведены.
Если все главы не были переведены, то функция возвращает логическую константу False.
ВАЖНО! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Определите функцию и аргумент, с которым она работает.
Задайте две переменные-счетчика — одну для подсчета количества слов, другую для подсчета количества строк ""переведена"".
Обратитесь к парам ключ-значение в переданном функции словаре. Если первый по индексу элемент значения (кортежа) принимает значение ""переведена"", то прибавьте 1 к первой переменной-счетчику и прибавьте нулевой по индексу элемент значения (кортежа) ко второй переменной-счетчику.
Проверьте, что первая переменная-счетчик не равна нулю, и если да, то пусть функция вернет список из двух значений: логической константы True и значения второй-переменной счетчика; иначе пусть функция вернет логическую константу False.","[""{\n    'Глава 1': (3000, 'не переведена'), \n    'Глава 2': (2000, 'не переведена'), \n    'Глава 3': (10000, 'не переведена'), \n    'Глава 4': (6000, 'не переведена'),\n    'Глава 5': (6500, 'не переведена')\n}"", ""{\n    'Героический эпос народов СССР. № 1': (100000, 'переведена'),\n    'Героический эпос народов СССР. № 2': (1005, 'не переведена')\n}"", ""{\n    'Арабская поэзия средних веков': (1092, 'не переведена'),\n    'Ирано-таджикская поэзия': (10090, 'переведена'),\n    'Средневековый роман и повесть': (2198, 'переведена')\n}"", ""{\n    'г1': (90, 'не переведена'), \n    'г2': (29, 'не переведена'), \n    'г3': (10, 'не переведена'), \n    'г4': (80, 'не переведена'),\n    'г5': (8, 'не переведена')\n}"", ""{\n    'повесть': (32, 'переведена'), \n    'поэма': (212, 'переведена'), \n    'роман': (809, 'переведена'),\n    'рассказы': (80, 'переведена')\n}"", ""{\n    'ода': (312, 'не переведена'), \n    'новелла': (2112, 'переведена'), \n    'юмореска': (809, 'переведена'),\n    'сатира': (89280, 'не переведена')\n}""]","['False', '[True, 100000]', '[True, 12288]', 'False', '[True, 1133]', '[True, 2921]']","def text_check(data):
    counter = 0
    summa = 0
    for k, v in data.items():
        if v[1] == 'переведена':
            counter += 1
            summa += v[0]
            
        if counter != 0:
            return ([True, summa])
        
    return False","def text_check(data):
    counter = 0
    summa = 0
    for k, v in data.items():
        if v[1] == 'переведена':
            counter += 1
            summa += v[0]
            
    if counter != 0:
        return ([True, summa])
        
    return False",Ошибка в табуляции. Проверьте табуляцию второй условной конструкции if-else.,"['open', 'open', 'open', 'closed', 'closed', 'closed']","<Task description>: Напишите функцию, определяющую можно считать книгу переведенной или нет. 

ТРЕБУЕМАЯ ФУНКЦИЯ 
Функция text_check, принимающая на вход словарь, ключи в котором — названия глав (строки), а значения — кортежи с двумя элементами (целым числом — количеством слов в главе; и строкой ""переведена"" или ""не переведена""). Гарантируется, что словарь содержит информацию минимум об одной главе.
Если хотя бы одна глава была переведена, то функция должна возвращать список из двух значений: логической константы True и целого числа — количества слов в главах, которые были переведены.
Если все главы не были переведены, то функция возвращает логическую константу False.
ВАЖНО! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Определите функцию и аргумент, с которым она работает.
Задайте две переменные-счетчика — одну для подсчета количества слов, другую для подсчета количества строк ""переведена"".
Обратитесь к парам ключ-значение в переданном функции словаре. Если первый по индексу элемент значения (кортежа) принимает значение ""переведена"", то прибавьте 1 к первой переменной-счетчику и прибавьте нулевой по индексу элемент значения (кортежа) ко второй переменной-счетчику.
Проверьте, что первая переменная-счетчик не равна нулю, и если да, то пусть функция вернет список из двух значений: логической константы True и значения второй-переменной счетчика; иначе пусть функция вернет логическую константу False. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: {
    'Глава 1': (3000, 'не переведена'), 
    'Глава 2': (2000, 'не переведена'), 
    'Глава 3': (10000, 'не переведена'), 
    'Глава 4': (6000, 'не переведена'),
    'Глава 5': (6500, 'не переведена')
} 
<Вывод>: False 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: {
    'Героический эпос народов СССР. № 1': (100000, 'переведена'),
    'Героический эпос народов СССР. № 2': (1005, 'не переведена')
} 
<Вывод>: [True, 100000] 
<Example 3>: 
<Тип теста 3>: open 
<Ввод>: {
    'Арабская поэзия средних веков': (1092, 'не переведена'),
    'Ирано-таджикская поэзия': (10090, 'переведена'),
    'Средневековый роман и повесть': (2198, 'переведена')
} 
<Вывод>: [True, 12288] 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: {
    'г1': (90, 'не переведена'), 
    'г2': (29, 'не переведена'), 
    'г3': (10, 'не переведена'), 
    'г4': (80, 'не переведена'),
    'г5': (8, 'не переведена')
} 
<Вывод>: False 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: {
    'повесть': (32, 'переведена'), 
    'поэма': (212, 'переведена'), 
    'роман': (809, 'переведена'),
    'рассказы': (80, 'переведена')
} 
<Вывод>: [True, 1133] 
<Example 6>: 
<Тип теста 6>: closed 
<Ввод>: {
    'ода': (312, 'не переведена'), 
    'новелла': (2112, 'переведена'), 
    'юмореска': (809, 'переведена'),
    'сатира': (89280, 'не переведена')
} 
<Вывод>: [True, 2921] 
<Решение студента>: def text_check(data):
    counter = 0
    summa = 0
    for k, v in data.items():
        if v[1] == 'переведена':
            counter += 1
            summa += v[0]
            
        if counter != 0:
            return ([True, summa])
        
    return False 
<Идеальное решение>: def text_check(data):
    counter = 0
    summa = 0
    for k, v in data.items():
        if v[1] == 'переведена':
            counter += 1
            summa += v[0]
            
    if counter != 0:
        return ([True, summa])
        
    return False 


<Комментарий эксперта>:"
251,552,34,"Напишите функцию, определяющую можно считать книгу переведенной или нет. 

ТРЕБУЕМАЯ ФУНКЦИЯ 
Функция text_check, принимающая на вход словарь, ключи в котором — названия глав (строки), а значения — кортежи с двумя элементами (целым числом — количеством слов в главе; и строкой ""переведена"" или ""не переведена""). Гарантируется, что словарь содержит информацию минимум об одной главе.
Если хотя бы одна глава была переведена, то функция должна возвращать список из двух значений: логической константы True и целого числа — количества слов в главах, которые были переведены.
Если все главы не были переведены, то функция возвращает логическую константу False.
ВАЖНО! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Определите функцию и аргумент, с которым она работает.
Задайте две переменные-счетчика — одну для подсчета количества слов, другую для подсчета количества строк ""переведена"".
Обратитесь к парам ключ-значение в переданном функции словаре. Если первый по индексу элемент значения (кортежа) принимает значение ""переведена"", то прибавьте 1 к первой переменной-счетчику и прибавьте нулевой по индексу элемент значения (кортежа) ко второй переменной-счетчику.
Проверьте, что первая переменная-счетчик не равна нулю, и если да, то пусть функция вернет список из двух значений: логической константы True и значения второй-переменной счетчика; иначе пусть функция вернет логическую константу False.","[""{\n    'Глава 1': (3000, 'не переведена'), \n    'Глава 2': (2000, 'не переведена'), \n    'Глава 3': (10000, 'не переведена'), \n    'Глава 4': (6000, 'не переведена'),\n    'Глава 5': (6500, 'не переведена')\n}"", ""{\n    'Героический эпос народов СССР. № 1': (100000, 'переведена'),\n    'Героический эпос народов СССР. № 2': (1005, 'не переведена')\n}"", ""{\n    'Арабская поэзия средних веков': (1092, 'не переведена'),\n    'Ирано-таджикская поэзия': (10090, 'переведена'),\n    'Средневековый роман и повесть': (2198, 'переведена')\n}"", ""{\n    'г1': (90, 'не переведена'), \n    'г2': (29, 'не переведена'), \n    'г3': (10, 'не переведена'), \n    'г4': (80, 'не переведена'),\n    'г5': (8, 'не переведена')\n}"", ""{\n    'повесть': (32, 'переведена'), \n    'поэма': (212, 'переведена'), \n    'роман': (809, 'переведена'),\n    'рассказы': (80, 'переведена')\n}"", ""{\n    'ода': (312, 'не переведена'), \n    'новелла': (2112, 'переведена'), \n    'юмореска': (809, 'переведена'),\n    'сатира': (89280, 'не переведена')\n}""]","['False', '[True, 100000]', '[True, 12288]', 'False', '[True, 1133]', '[True, 2921]']","def text_check(data):
    counter = 0
    summa = 0
    for k, v in data.items():
        if v[1] == 'переведена':
            counter += 1
            summa += v[0]
            
    if counter != 0:
        return (True, summa)
        
    return False","def text_check(data):
    counter = 0
    summa = 0
    for k, v in data.items():
        if v[1] == 'переведена':
            counter += 1
            summa += v[0]
            
    if counter != 0:
        return ([True, summa])
        
    return False","Ошибка в открытых и скрытых тестах. 

Ваш код имеет некорректный формат вывода ответов. Помните, что если хотя бы одна глава была переведена, то функция должна возвращать список из двух значений: логической константы True и целого числа — количества слов в главах, которые были переведены.","['open', 'open', 'open', 'closed', 'closed', 'closed']","<Task description>: Напишите функцию, определяющую можно считать книгу переведенной или нет. 

ТРЕБУЕМАЯ ФУНКЦИЯ 
Функция text_check, принимающая на вход словарь, ключи в котором — названия глав (строки), а значения — кортежи с двумя элементами (целым числом — количеством слов в главе; и строкой ""переведена"" или ""не переведена""). Гарантируется, что словарь содержит информацию минимум об одной главе.
Если хотя бы одна глава была переведена, то функция должна возвращать список из двух значений: логической константы True и целого числа — количества слов в главах, которые были переведены.
Если все главы не были переведены, то функция возвращает логическую константу False.
ВАЖНО! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Определите функцию и аргумент, с которым она работает.
Задайте две переменные-счетчика — одну для подсчета количества слов, другую для подсчета количества строк ""переведена"".
Обратитесь к парам ключ-значение в переданном функции словаре. Если первый по индексу элемент значения (кортежа) принимает значение ""переведена"", то прибавьте 1 к первой переменной-счетчику и прибавьте нулевой по индексу элемент значения (кортежа) ко второй переменной-счетчику.
Проверьте, что первая переменная-счетчик не равна нулю, и если да, то пусть функция вернет список из двух значений: логической константы True и значения второй-переменной счетчика; иначе пусть функция вернет логическую константу False. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: {
    'Глава 1': (3000, 'не переведена'), 
    'Глава 2': (2000, 'не переведена'), 
    'Глава 3': (10000, 'не переведена'), 
    'Глава 4': (6000, 'не переведена'),
    'Глава 5': (6500, 'не переведена')
} 
<Вывод>: False 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: {
    'Героический эпос народов СССР. № 1': (100000, 'переведена'),
    'Героический эпос народов СССР. № 2': (1005, 'не переведена')
} 
<Вывод>: [True, 100000] 
<Example 3>: 
<Тип теста 3>: open 
<Ввод>: {
    'Арабская поэзия средних веков': (1092, 'не переведена'),
    'Ирано-таджикская поэзия': (10090, 'переведена'),
    'Средневековый роман и повесть': (2198, 'переведена')
} 
<Вывод>: [True, 12288] 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: {
    'г1': (90, 'не переведена'), 
    'г2': (29, 'не переведена'), 
    'г3': (10, 'не переведена'), 
    'г4': (80, 'не переведена'),
    'г5': (8, 'не переведена')
} 
<Вывод>: False 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: {
    'повесть': (32, 'переведена'), 
    'поэма': (212, 'переведена'), 
    'роман': (809, 'переведена'),
    'рассказы': (80, 'переведена')
} 
<Вывод>: [True, 1133] 
<Example 6>: 
<Тип теста 6>: closed 
<Ввод>: {
    'ода': (312, 'не переведена'), 
    'новелла': (2112, 'переведена'), 
    'юмореска': (809, 'переведена'),
    'сатира': (89280, 'не переведена')
} 
<Вывод>: [True, 2921] 
<Решение студента>: def text_check(data):
    counter = 0
    summa = 0
    for k, v in data.items():
        if v[1] == 'переведена':
            counter += 1
            summa += v[0]
            
    if counter != 0:
        return (True, summa)
        
    return False 
<Идеальное решение>: def text_check(data):
    counter = 0
    summa = 0
    for k, v in data.items():
        if v[1] == 'переведена':
            counter += 1
            summa += v[0]
            
    if counter != 0:
        return ([True, summa])
        
    return False 


<Комментарий эксперта>:"
252,553,35,"Роман изучает свой отчет по итогам поездки в Англию, где он описывал различные диалекты. Помогите определить диалекты английского языка, которые упоминаются ровно 2 раза.

ФОРМАТ ВВОДА
Текстовый файл dialects.txt, в котором записан отчет. Гарантируется, что в отчете только названия диалектов всегда записаны с большой буквы. При этом сами диалекты должны учитываться вне зависимости от регистра (например, ""Кардифф"" и ""КАРДиф"" должны считаться, как один диалект)
Гарантируется, что пустых строк в файле нет.
Гарантируется, что в файле будет упоминание хотя бы одного диалекта.
Также дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.
ФОРМАТ ВЫВОДА
Названия диалектов, которые упоминаются в отчете ровно два раза. 
Названия должны быть записаны в нижнем регистре в обратном алфавитном порядке через точку с запятой и пробел.
ДОПОЛНИТЕЛЬНО
В открытом тесте используется файл dialects.txt. Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Создайте пустой словарь, в который будете записывать диалекты и число их упоминаний.
Откройте файл в режиме чтения в кодировке utf-8.
Обратитесь к каждой строке в файле и выполните следующие действия:
уберите невидимые символы в конце строки (символ перехода на новую строку);
обратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;
разбейте строку по разделителю, в результате получите список;
обратитесь к каждому элементу в получившемся списке: если первая его буква — заглавная, тогда этот диалект и нужно проверить (не забудьте привести все буквы в диалекте к одному регистру):
если этого диалекта еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.
если такой диалект уже есть в словаре из п.1, то нужно увеличить его значение на 1.
После цикла создайте пустой список — в него нужно будет добавить названия тех диалектов, значение которых в словаре ровно 2.
Обратитесь к парам ключ-значение в словаре: если значение равно 2, то добавьте ключ в список из п.4.
Отсортируйте список в обратном алфавиту порядке и напечатайте его элементы через точку с запятой и пробел.","[nan, nan, nan]","['саффолк; кокни', 'манчестер; кардифф', 'эссекс; сассекс; ольстер; ливерпуль; дублин']","punctuation = '!#$%&()*+,-–./:;<=>?@^_'

data = {}

open('dialects.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].isupper():
                if w.lower() not in data:
                    data[w.lower()] = 1
                else:
                    data[w.lower()] += 1

                 
res = []

for k, v in data.items():
    if v == 2:
        res.append(k)
        
print(*sorted(res, reverse=True), sep='; ')","punctuation = '!#$%&()*+,-–./:;<=>?@^_'

data = {}

with open('dialects.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].isupper():
                if w.lower() not in data:
                    data[w.lower()] = 1
                else:
                    data[w.lower()] += 1

                 
res = []

for k, v in data.items():
    if v == 2:
        res.append(k)
        
print(*sorted(res, reverse=True), sep='; ')",Некорректный синтаксис при использовании функции open.,"['open', 'closed', 'closed']","<Task description>: Роман изучает свой отчет по итогам поездки в Англию, где он описывал различные диалекты. Помогите определить диалекты английского языка, которые упоминаются ровно 2 раза.

ФОРМАТ ВВОДА
Текстовый файл dialects.txt, в котором записан отчет. Гарантируется, что в отчете только названия диалектов всегда записаны с большой буквы. При этом сами диалекты должны учитываться вне зависимости от регистра (например, ""Кардифф"" и ""КАРДиф"" должны считаться, как один диалект)
Гарантируется, что пустых строк в файле нет.
Гарантируется, что в файле будет упоминание хотя бы одного диалекта.
Также дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.
ФОРМАТ ВЫВОДА
Названия диалектов, которые упоминаются в отчете ровно два раза. 
Названия должны быть записаны в нижнем регистре в обратном алфавитном порядке через точку с запятой и пробел.
ДОПОЛНИТЕЛЬНО
В открытом тесте используется файл dialects.txt. Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Создайте пустой словарь, в который будете записывать диалекты и число их упоминаний.
Откройте файл в режиме чтения в кодировке utf-8.
Обратитесь к каждой строке в файле и выполните следующие действия:
уберите невидимые символы в конце строки (символ перехода на новую строку);
обратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;
разбейте строку по разделителю, в результате получите список;
обратитесь к каждому элементу в получившемся списке: если первая его буква — заглавная, тогда этот диалект и нужно проверить (не забудьте привести все буквы в диалекте к одному регистру):
если этого диалекта еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.
если такой диалект уже есть в словаре из п.1, то нужно увеличить его значение на 1.
После цикла создайте пустой список — в него нужно будет добавить названия тех диалектов, значение которых в словаре ровно 2.
Обратитесь к парам ключ-значение в словаре: если значение равно 2, то добавьте ключ в список из п.4.
Отсортируйте список в обратном алфавиту порядке и напечатайте его элементы через точку с запятой и пробел. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: nan 
<Вывод>: саффолк; кокни 
<Example 2>: 
<Тип теста 2>: closed 
<Ввод>: nan 
<Вывод>: манчестер; кардифф 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: nan 
<Вывод>: эссекс; сассекс; ольстер; ливерпуль; дублин 
<Решение студента>: punctuation = '!#$%&()*+,-–./:;<=>?@^_'

data = {}

open('dialects.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].isupper():
                if w.lower() not in data:
                    data[w.lower()] = 1
                else:
                    data[w.lower()] += 1

                 
res = []

for k, v in data.items():
    if v == 2:
        res.append(k)
        
print(*sorted(res, reverse=True), sep='; ') 
<Идеальное решение>: punctuation = '!#$%&()*+,-–./:;<=>?@^_'

data = {}

with open('dialects.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].isupper():
                if w.lower() not in data:
                    data[w.lower()] = 1
                else:
                    data[w.lower()] += 1

                 
res = []

for k, v in data.items():
    if v == 2:
        res.append(k)
        
print(*sorted(res, reverse=True), sep='; ') 


<Комментарий эксперта>:"
253,554,35,"Роман изучает свой отчет по итогам поездки в Англию, где он описывал различные диалекты. Помогите определить диалекты английского языка, которые упоминаются ровно 2 раза.

ФОРМАТ ВВОДА
Текстовый файл dialects.txt, в котором записан отчет. Гарантируется, что в отчете только названия диалектов всегда записаны с большой буквы. При этом сами диалекты должны учитываться вне зависимости от регистра (например, ""Кардифф"" и ""КАРДиф"" должны считаться, как один диалект)
Гарантируется, что пустых строк в файле нет.
Гарантируется, что в файле будет упоминание хотя бы одного диалекта.
Также дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.
ФОРМАТ ВЫВОДА
Названия диалектов, которые упоминаются в отчете ровно два раза. 
Названия должны быть записаны в нижнем регистре в обратном алфавитном порядке через точку с запятой и пробел.
ДОПОЛНИТЕЛЬНО
В открытом тесте используется файл dialects.txt. Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Создайте пустой словарь, в который будете записывать диалекты и число их упоминаний.
Откройте файл в режиме чтения в кодировке utf-8.
Обратитесь к каждой строке в файле и выполните следующие действия:
уберите невидимые символы в конце строки (символ перехода на новую строку);
обратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;
разбейте строку по разделителю, в результате получите список;
обратитесь к каждому элементу в получившемся списке: если первая его буква — заглавная, тогда этот диалект и нужно проверить (не забудьте привести все буквы в диалекте к одному регистру):
если этого диалекта еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.
если такой диалект уже есть в словаре из п.1, то нужно увеличить его значение на 1.
После цикла создайте пустой список — в него нужно будет добавить названия тех диалектов, значение которых в словаре ровно 2.
Обратитесь к парам ключ-значение в словаре: если значение равно 2, то добавьте ключ в список из п.4.
Отсортируйте список в обратном алфавиту порядке и напечатайте его элементы через точку с запятой и пробел.","[nan, nan, nan]","['саффолк; кокни', 'манчестер; кардифф', 'эссекс; сассекс; ольстер; ливерпуль; дублин']","punctuation = '!#$%&()*+,-–./:;<=>?@^_'

data = {}

with open('dialects.csv', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].isupper():
                if w.lower() not in data:
                    data[w.lower()] = 1
                else:
                    data[w.lower()] += 1

                 
res = []

for k, v in data.items():
    if v == 2:
        res.append(k)
        
print(*sorted(res, reverse=True), sep='; ')","punctuation = '!#$%&()*+,-–./:;<=>?@^_'

data = {}

with open('dialects.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].isupper():
                if w.lower() not in data:
                    data[w.lower()] = 1
                else:
                    data[w.lower()] += 1

                 
res = []

for k, v in data.items():
    if v == 2:
        res.append(k)
        
print(*sorted(res, reverse=True), sep='; ')",Ошибка при открытии файла. Обращение к файлу некорректного формата.,"['open', 'closed', 'closed']","<Task description>: Роман изучает свой отчет по итогам поездки в Англию, где он описывал различные диалекты. Помогите определить диалекты английского языка, которые упоминаются ровно 2 раза.

ФОРМАТ ВВОДА
Текстовый файл dialects.txt, в котором записан отчет. Гарантируется, что в отчете только названия диалектов всегда записаны с большой буквы. При этом сами диалекты должны учитываться вне зависимости от регистра (например, ""Кардифф"" и ""КАРДиф"" должны считаться, как один диалект)
Гарантируется, что пустых строк в файле нет.
Гарантируется, что в файле будет упоминание хотя бы одного диалекта.
Также дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.
ФОРМАТ ВЫВОДА
Названия диалектов, которые упоминаются в отчете ровно два раза. 
Названия должны быть записаны в нижнем регистре в обратном алфавитном порядке через точку с запятой и пробел.
ДОПОЛНИТЕЛЬНО
В открытом тесте используется файл dialects.txt. Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Создайте пустой словарь, в который будете записывать диалекты и число их упоминаний.
Откройте файл в режиме чтения в кодировке utf-8.
Обратитесь к каждой строке в файле и выполните следующие действия:
уберите невидимые символы в конце строки (символ перехода на новую строку);
обратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;
разбейте строку по разделителю, в результате получите список;
обратитесь к каждому элементу в получившемся списке: если первая его буква — заглавная, тогда этот диалект и нужно проверить (не забудьте привести все буквы в диалекте к одному регистру):
если этого диалекта еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.
если такой диалект уже есть в словаре из п.1, то нужно увеличить его значение на 1.
После цикла создайте пустой список — в него нужно будет добавить названия тех диалектов, значение которых в словаре ровно 2.
Обратитесь к парам ключ-значение в словаре: если значение равно 2, то добавьте ключ в список из п.4.
Отсортируйте список в обратном алфавиту порядке и напечатайте его элементы через точку с запятой и пробел. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: nan 
<Вывод>: саффолк; кокни 
<Example 2>: 
<Тип теста 2>: closed 
<Ввод>: nan 
<Вывод>: манчестер; кардифф 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: nan 
<Вывод>: эссекс; сассекс; ольстер; ливерпуль; дублин 
<Решение студента>: punctuation = '!#$%&()*+,-–./:;<=>?@^_'

data = {}

with open('dialects.csv', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].isupper():
                if w.lower() not in data:
                    data[w.lower()] = 1
                else:
                    data[w.lower()] += 1

                 
res = []

for k, v in data.items():
    if v == 2:
        res.append(k)
        
print(*sorted(res, reverse=True), sep='; ') 
<Идеальное решение>: punctuation = '!#$%&()*+,-–./:;<=>?@^_'

data = {}

with open('dialects.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].isupper():
                if w.lower() not in data:
                    data[w.lower()] = 1
                else:
                    data[w.lower()] += 1

                 
res = []

for k, v in data.items():
    if v == 2:
        res.append(k)
        
print(*sorted(res, reverse=True), sep='; ') 


<Комментарий эксперта>:"
254,555,35,"Роман изучает свой отчет по итогам поездки в Англию, где он описывал различные диалекты. Помогите определить диалекты английского языка, которые упоминаются ровно 2 раза.

ФОРМАТ ВВОДА
Текстовый файл dialects.txt, в котором записан отчет. Гарантируется, что в отчете только названия диалектов всегда записаны с большой буквы. При этом сами диалекты должны учитываться вне зависимости от регистра (например, ""Кардифф"" и ""КАРДиф"" должны считаться, как один диалект)
Гарантируется, что пустых строк в файле нет.
Гарантируется, что в файле будет упоминание хотя бы одного диалекта.
Также дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.
ФОРМАТ ВЫВОДА
Названия диалектов, которые упоминаются в отчете ровно два раза. 
Названия должны быть записаны в нижнем регистре в обратном алфавитном порядке через точку с запятой и пробел.
ДОПОЛНИТЕЛЬНО
В открытом тесте используется файл dialects.txt. Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Создайте пустой словарь, в который будете записывать диалекты и число их упоминаний.
Откройте файл в режиме чтения в кодировке utf-8.
Обратитесь к каждой строке в файле и выполните следующие действия:
уберите невидимые символы в конце строки (символ перехода на новую строку);
обратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;
разбейте строку по разделителю, в результате получите список;
обратитесь к каждому элементу в получившемся списке: если первая его буква — заглавная, тогда этот диалект и нужно проверить (не забудьте привести все буквы в диалекте к одному регистру):
если этого диалекта еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.
если такой диалект уже есть в словаре из п.1, то нужно увеличить его значение на 1.
После цикла создайте пустой список — в него нужно будет добавить названия тех диалектов, значение которых в словаре ровно 2.
Обратитесь к парам ключ-значение в словаре: если значение равно 2, то добавьте ключ в список из п.4.
Отсортируйте список в обратном алфавиту порядке и напечатайте его элементы через точку с запятой и пробел.","[nan, nan, nan]","['саффолк; кокни', 'манчестер; кардифф', 'эссекс; сассекс; ольстер; ливерпуль; дублин']","punctuation = '!#$%&()*+,-–./:;<=>?@^_'

with open('dialects.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].isupper():
                if w.lower() not in data:
                    data[w.lower()] = 1
                else:
                    data[w.lower()] += 1

                 
res = []

for k, v in data.items():
    if v == 2:
        res.append(k)
        
print(*sorted(res, reverse=True), sep='; ')","punctuation = '!#$%&()*+,-–./:;<=>?@^_'

data = {}

with open('dialects.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].isupper():
                if w.lower() not in data:
                    data[w.lower()] = 1
                else:
                    data[w.lower()] += 1

                 
res = []

for k, v in data.items():
    if v == 2:
        res.append(k)
        
print(*sorted(res, reverse=True), sep='; ')","Ошибка при обращении к незаданной переменной. Проверьте, что все Ваши переменные корректно заданы.","['open', 'closed', 'closed']","<Task description>: Роман изучает свой отчет по итогам поездки в Англию, где он описывал различные диалекты. Помогите определить диалекты английского языка, которые упоминаются ровно 2 раза.

ФОРМАТ ВВОДА
Текстовый файл dialects.txt, в котором записан отчет. Гарантируется, что в отчете только названия диалектов всегда записаны с большой буквы. При этом сами диалекты должны учитываться вне зависимости от регистра (например, ""Кардифф"" и ""КАРДиф"" должны считаться, как один диалект)
Гарантируется, что пустых строк в файле нет.
Гарантируется, что в файле будет упоминание хотя бы одного диалекта.
Также дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.
ФОРМАТ ВЫВОДА
Названия диалектов, которые упоминаются в отчете ровно два раза. 
Названия должны быть записаны в нижнем регистре в обратном алфавитном порядке через точку с запятой и пробел.
ДОПОЛНИТЕЛЬНО
В открытом тесте используется файл dialects.txt. Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Создайте пустой словарь, в который будете записывать диалекты и число их упоминаний.
Откройте файл в режиме чтения в кодировке utf-8.
Обратитесь к каждой строке в файле и выполните следующие действия:
уберите невидимые символы в конце строки (символ перехода на новую строку);
обратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;
разбейте строку по разделителю, в результате получите список;
обратитесь к каждому элементу в получившемся списке: если первая его буква — заглавная, тогда этот диалект и нужно проверить (не забудьте привести все буквы в диалекте к одному регистру):
если этого диалекта еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.
если такой диалект уже есть в словаре из п.1, то нужно увеличить его значение на 1.
После цикла создайте пустой список — в него нужно будет добавить названия тех диалектов, значение которых в словаре ровно 2.
Обратитесь к парам ключ-значение в словаре: если значение равно 2, то добавьте ключ в список из п.4.
Отсортируйте список в обратном алфавиту порядке и напечатайте его элементы через точку с запятой и пробел. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: nan 
<Вывод>: саффолк; кокни 
<Example 2>: 
<Тип теста 2>: closed 
<Ввод>: nan 
<Вывод>: манчестер; кардифф 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: nan 
<Вывод>: эссекс; сассекс; ольстер; ливерпуль; дублин 
<Решение студента>: punctuation = '!#$%&()*+,-–./:;<=>?@^_'

with open('dialects.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].isupper():
                if w.lower() not in data:
                    data[w.lower()] = 1
                else:
                    data[w.lower()] += 1

                 
res = []

for k, v in data.items():
    if v == 2:
        res.append(k)
        
print(*sorted(res, reverse=True), sep='; ') 
<Идеальное решение>: punctuation = '!#$%&()*+,-–./:;<=>?@^_'

data = {}

with open('dialects.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].isupper():
                if w.lower() not in data:
                    data[w.lower()] = 1
                else:
                    data[w.lower()] += 1

                 
res = []

for k, v in data.items():
    if v == 2:
        res.append(k)
        
print(*sorted(res, reverse=True), sep='; ') 


<Комментарий эксперта>:"
255,556,35,"Роман изучает свой отчет по итогам поездки в Англию, где он описывал различные диалекты. Помогите определить диалекты английского языка, которые упоминаются ровно 2 раза.

ФОРМАТ ВВОДА
Текстовый файл dialects.txt, в котором записан отчет. Гарантируется, что в отчете только названия диалектов всегда записаны с большой буквы. При этом сами диалекты должны учитываться вне зависимости от регистра (например, ""Кардифф"" и ""КАРДиф"" должны считаться, как один диалект)
Гарантируется, что пустых строк в файле нет.
Гарантируется, что в файле будет упоминание хотя бы одного диалекта.
Также дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.
ФОРМАТ ВЫВОДА
Названия диалектов, которые упоминаются в отчете ровно два раза. 
Названия должны быть записаны в нижнем регистре в обратном алфавитном порядке через точку с запятой и пробел.
ДОПОЛНИТЕЛЬНО
В открытом тесте используется файл dialects.txt. Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Создайте пустой словарь, в который будете записывать диалекты и число их упоминаний.
Откройте файл в режиме чтения в кодировке utf-8.
Обратитесь к каждой строке в файле и выполните следующие действия:
уберите невидимые символы в конце строки (символ перехода на новую строку);
обратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;
разбейте строку по разделителю, в результате получите список;
обратитесь к каждому элементу в получившемся списке: если первая его буква — заглавная, тогда этот диалект и нужно проверить (не забудьте привести все буквы в диалекте к одному регистру):
если этого диалекта еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.
если такой диалект уже есть в словаре из п.1, то нужно увеличить его значение на 1.
После цикла создайте пустой список — в него нужно будет добавить названия тех диалектов, значение которых в словаре ровно 2.
Обратитесь к парам ключ-значение в словаре: если значение равно 2, то добавьте ключ в список из п.4.
Отсортируйте список в обратном алфавиту порядке и напечатайте его элементы через точку с запятой и пробел.","[nan, nan, nan]","['саффолк; кокни', 'манчестер; кардифф', 'эссекс; сассекс; ольстер; ливерпуль; дублин']","punctuation = '!#$%&()*+,-–./:;<=>?@^_'

data = {}

with open('dialects.txt', 'r', encoding='utf-8') as my_file:
    for line in file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].isupper():
                if w.lower() not in data:
                    data[w.lower()] = 1
                else:
                    data[w.lower()] += 1

                 
res = []

for k, v in data.items():
    if v == 2:
        res.append(k)
        
print(*sorted(res, reverse=True), sep='; ')","punctuation = '!#$%&()*+,-–./:;<=>?@^_'

data = {}

with open('dialects.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].isupper():
                if w.lower() not in data:
                    data[w.lower()] = 1
                else:
                    data[w.lower()] += 1

                 
res = []

for k, v in data.items():
    if v == 2:
        res.append(k)
        
print(*sorted(res, reverse=True), sep='; ')","Ошибка при обращении к незаданной переменной. Проверьте, что все Ваши переменные корректно заданы.","['open', 'closed', 'closed']","<Task description>: Роман изучает свой отчет по итогам поездки в Англию, где он описывал различные диалекты. Помогите определить диалекты английского языка, которые упоминаются ровно 2 раза.

ФОРМАТ ВВОДА
Текстовый файл dialects.txt, в котором записан отчет. Гарантируется, что в отчете только названия диалектов всегда записаны с большой буквы. При этом сами диалекты должны учитываться вне зависимости от регистра (например, ""Кардифф"" и ""КАРДиф"" должны считаться, как один диалект)
Гарантируется, что пустых строк в файле нет.
Гарантируется, что в файле будет упоминание хотя бы одного диалекта.
Также дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.
ФОРМАТ ВЫВОДА
Названия диалектов, которые упоминаются в отчете ровно два раза. 
Названия должны быть записаны в нижнем регистре в обратном алфавитном порядке через точку с запятой и пробел.
ДОПОЛНИТЕЛЬНО
В открытом тесте используется файл dialects.txt. Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Создайте пустой словарь, в который будете записывать диалекты и число их упоминаний.
Откройте файл в режиме чтения в кодировке utf-8.
Обратитесь к каждой строке в файле и выполните следующие действия:
уберите невидимые символы в конце строки (символ перехода на новую строку);
обратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;
разбейте строку по разделителю, в результате получите список;
обратитесь к каждому элементу в получившемся списке: если первая его буква — заглавная, тогда этот диалект и нужно проверить (не забудьте привести все буквы в диалекте к одному регистру):
если этого диалекта еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.
если такой диалект уже есть в словаре из п.1, то нужно увеличить его значение на 1.
После цикла создайте пустой список — в него нужно будет добавить названия тех диалектов, значение которых в словаре ровно 2.
Обратитесь к парам ключ-значение в словаре: если значение равно 2, то добавьте ключ в список из п.4.
Отсортируйте список в обратном алфавиту порядке и напечатайте его элементы через точку с запятой и пробел. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: nan 
<Вывод>: саффолк; кокни 
<Example 2>: 
<Тип теста 2>: closed 
<Ввод>: nan 
<Вывод>: манчестер; кардифф 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: nan 
<Вывод>: эссекс; сассекс; ольстер; ливерпуль; дублин 
<Решение студента>: punctuation = '!#$%&()*+,-–./:;<=>?@^_'

data = {}

with open('dialects.txt', 'r', encoding='utf-8') as my_file:
    for line in file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].isupper():
                if w.lower() not in data:
                    data[w.lower()] = 1
                else:
                    data[w.lower()] += 1

                 
res = []

for k, v in data.items():
    if v == 2:
        res.append(k)
        
print(*sorted(res, reverse=True), sep='; ') 
<Идеальное решение>: punctuation = '!#$%&()*+,-–./:;<=>?@^_'

data = {}

with open('dialects.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].isupper():
                if w.lower() not in data:
                    data[w.lower()] = 1
                else:
                    data[w.lower()] += 1

                 
res = []

for k, v in data.items():
    if v == 2:
        res.append(k)
        
print(*sorted(res, reverse=True), sep='; ') 


<Комментарий эксперта>:"
256,557,35,"Роман изучает свой отчет по итогам поездки в Англию, где он описывал различные диалекты. Помогите определить диалекты английского языка, которые упоминаются ровно 2 раза.

ФОРМАТ ВВОДА
Текстовый файл dialects.txt, в котором записан отчет. Гарантируется, что в отчете только названия диалектов всегда записаны с большой буквы. При этом сами диалекты должны учитываться вне зависимости от регистра (например, ""Кардифф"" и ""КАРДиф"" должны считаться, как один диалект)
Гарантируется, что пустых строк в файле нет.
Гарантируется, что в файле будет упоминание хотя бы одного диалекта.
Также дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.
ФОРМАТ ВЫВОДА
Названия диалектов, которые упоминаются в отчете ровно два раза. 
Названия должны быть записаны в нижнем регистре в обратном алфавитном порядке через точку с запятой и пробел.
ДОПОЛНИТЕЛЬНО
В открытом тесте используется файл dialects.txt. Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Создайте пустой словарь, в который будете записывать диалекты и число их упоминаний.
Откройте файл в режиме чтения в кодировке utf-8.
Обратитесь к каждой строке в файле и выполните следующие действия:
уберите невидимые символы в конце строки (символ перехода на новую строку);
обратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;
разбейте строку по разделителю, в результате получите список;
обратитесь к каждому элементу в получившемся списке: если первая его буква — заглавная, тогда этот диалект и нужно проверить (не забудьте привести все буквы в диалекте к одному регистру):
если этого диалекта еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.
если такой диалект уже есть в словаре из п.1, то нужно увеличить его значение на 1.
После цикла создайте пустой список — в него нужно будет добавить названия тех диалектов, значение которых в словаре ровно 2.
Обратитесь к парам ключ-значение в словаре: если значение равно 2, то добавьте ключ в список из п.4.
Отсортируйте список в обратном алфавиту порядке и напечатайте его элементы через точку с запятой и пробел.","[nan, nan, nan]","['саффолк; кокни', 'манчестер; кардифф', 'эссекс; сассекс; ольстер; ливерпуль; дублин']","punctuation = '!#$%&()*+,-–./:;<=>?@^_'

data = {}

with open('dialects.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
                
        line = line.split()
        for w in line:
            if w[0].isupper():
                if w.lower() not in data:
                    data[w.lower()] = 1
                else:
                    data[w.lower()] += 1

                 
res = []

for k, v in data.items():
    if v == 2:
        res.append(k)
        
print(*sorted(res, reverse=True), sep='; ')","punctuation = '!#$%&()*+,-–./:;<=>?@^_'

data = {}

with open('dialects.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].isupper():
                if w.lower() not in data:
                    data[w.lower()] = 1
                else:
                    data[w.lower()] += 1

                 
res = []

for k, v in data.items():
    if v == 2:
        res.append(k)
        
print(*sorted(res, reverse=True), sep='; ')","Ошибка в открытых и скрытых тестах. 

Ваш код некорректно обрабатывает данные. Ваш код не выполняет условие ""необходимо будет очистить от символов, сохраненных в переменную punctuation"" Попробуйте изменить код, чтобы скорректировать ошибку.","['open', 'closed', 'closed']","<Task description>: Роман изучает свой отчет по итогам поездки в Англию, где он описывал различные диалекты. Помогите определить диалекты английского языка, которые упоминаются ровно 2 раза.

ФОРМАТ ВВОДА
Текстовый файл dialects.txt, в котором записан отчет. Гарантируется, что в отчете только названия диалектов всегда записаны с большой буквы. При этом сами диалекты должны учитываться вне зависимости от регистра (например, ""Кардифф"" и ""КАРДиф"" должны считаться, как один диалект)
Гарантируется, что пустых строк в файле нет.
Гарантируется, что в файле будет упоминание хотя бы одного диалекта.
Также дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.
ФОРМАТ ВЫВОДА
Названия диалектов, которые упоминаются в отчете ровно два раза. 
Названия должны быть записаны в нижнем регистре в обратном алфавитном порядке через точку с запятой и пробел.
ДОПОЛНИТЕЛЬНО
В открытом тесте используется файл dialects.txt. Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Создайте пустой словарь, в который будете записывать диалекты и число их упоминаний.
Откройте файл в режиме чтения в кодировке utf-8.
Обратитесь к каждой строке в файле и выполните следующие действия:
уберите невидимые символы в конце строки (символ перехода на новую строку);
обратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;
разбейте строку по разделителю, в результате получите список;
обратитесь к каждому элементу в получившемся списке: если первая его буква — заглавная, тогда этот диалект и нужно проверить (не забудьте привести все буквы в диалекте к одному регистру):
если этого диалекта еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.
если такой диалект уже есть в словаре из п.1, то нужно увеличить его значение на 1.
После цикла создайте пустой список — в него нужно будет добавить названия тех диалектов, значение которых в словаре ровно 2.
Обратитесь к парам ключ-значение в словаре: если значение равно 2, то добавьте ключ в список из п.4.
Отсортируйте список в обратном алфавиту порядке и напечатайте его элементы через точку с запятой и пробел. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: nan 
<Вывод>: саффолк; кокни 
<Example 2>: 
<Тип теста 2>: closed 
<Ввод>: nan 
<Вывод>: манчестер; кардифф 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: nan 
<Вывод>: эссекс; сассекс; ольстер; ливерпуль; дублин 
<Решение студента>: punctuation = '!#$%&()*+,-–./:;<=>?@^_'

data = {}

with open('dialects.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
                
        line = line.split()
        for w in line:
            if w[0].isupper():
                if w.lower() not in data:
                    data[w.lower()] = 1
                else:
                    data[w.lower()] += 1

                 
res = []

for k, v in data.items():
    if v == 2:
        res.append(k)
        
print(*sorted(res, reverse=True), sep='; ') 
<Идеальное решение>: punctuation = '!#$%&()*+,-–./:;<=>?@^_'

data = {}

with open('dialects.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].isupper():
                if w.lower() not in data:
                    data[w.lower()] = 1
                else:
                    data[w.lower()] += 1

                 
res = []

for k, v in data.items():
    if v == 2:
        res.append(k)
        
print(*sorted(res, reverse=True), sep='; ') 


<Комментарий эксперта>:"
257,558,35,"Роман изучает свой отчет по итогам поездки в Англию, где он описывал различные диалекты. Помогите определить диалекты английского языка, которые упоминаются ровно 2 раза.

ФОРМАТ ВВОДА
Текстовый файл dialects.txt, в котором записан отчет. Гарантируется, что в отчете только названия диалектов всегда записаны с большой буквы. При этом сами диалекты должны учитываться вне зависимости от регистра (например, ""Кардифф"" и ""КАРДиф"" должны считаться, как один диалект)
Гарантируется, что пустых строк в файле нет.
Гарантируется, что в файле будет упоминание хотя бы одного диалекта.
Также дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.
ФОРМАТ ВЫВОДА
Названия диалектов, которые упоминаются в отчете ровно два раза. 
Названия должны быть записаны в нижнем регистре в обратном алфавитном порядке через точку с запятой и пробел.
ДОПОЛНИТЕЛЬНО
В открытом тесте используется файл dialects.txt. Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Создайте пустой словарь, в который будете записывать диалекты и число их упоминаний.
Откройте файл в режиме чтения в кодировке utf-8.
Обратитесь к каждой строке в файле и выполните следующие действия:
уберите невидимые символы в конце строки (символ перехода на новую строку);
обратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;
разбейте строку по разделителю, в результате получите список;
обратитесь к каждому элементу в получившемся списке: если первая его буква — заглавная, тогда этот диалект и нужно проверить (не забудьте привести все буквы в диалекте к одному регистру):
если этого диалекта еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.
если такой диалект уже есть в словаре из п.1, то нужно увеличить его значение на 1.
После цикла создайте пустой список — в него нужно будет добавить названия тех диалектов, значение которых в словаре ровно 2.
Обратитесь к парам ключ-значение в словаре: если значение равно 2, то добавьте ключ в список из п.4.
Отсортируйте список в обратном алфавиту порядке и напечатайте его элементы через точку с запятой и пробел.","[nan, nan, nan]","['саффолк; кокни', 'манчестер; кардифф', 'эссекс; сассекс; ольстер; ливерпуль; дублин']","punctuation = '!#$%&()*+,-–./:;<=>?@^_'

data = {}

with open('dialects.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].isupper():
                if w.lower() not in data:
                    data[w.lower()] = 1
                else:
                    data[w.lower()] += 1

                 
res = []

for k, v in data.items():
    if v == 2:
        res.append(k)
        
print(*sorted(res, reverse=True), sep='; ')","punctuation = '!#$%&()*+,-–./:;<=>?@^_'

data = {}

with open('dialects.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].isupper():
                if w.lower() not in data:
                    data[w.lower()] = 1
                else:
                    data[w.lower()] += 1

                 
res = []

for k, v in data.items():
    if v == 2:
        res.append(k)
        
print(*sorted(res, reverse=True), sep='; ')",Синтаксическая ошибка при использовании метода strip(). Не забывайте использовать скобки после каждого метода.,"['open', 'closed', 'closed']","<Task description>: Роман изучает свой отчет по итогам поездки в Англию, где он описывал различные диалекты. Помогите определить диалекты английского языка, которые упоминаются ровно 2 раза.

ФОРМАТ ВВОДА
Текстовый файл dialects.txt, в котором записан отчет. Гарантируется, что в отчете только названия диалектов всегда записаны с большой буквы. При этом сами диалекты должны учитываться вне зависимости от регистра (например, ""Кардифф"" и ""КАРДиф"" должны считаться, как один диалект)
Гарантируется, что пустых строк в файле нет.
Гарантируется, что в файле будет упоминание хотя бы одного диалекта.
Также дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.
ФОРМАТ ВЫВОДА
Названия диалектов, которые упоминаются в отчете ровно два раза. 
Названия должны быть записаны в нижнем регистре в обратном алфавитном порядке через точку с запятой и пробел.
ДОПОЛНИТЕЛЬНО
В открытом тесте используется файл dialects.txt. Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Создайте пустой словарь, в который будете записывать диалекты и число их упоминаний.
Откройте файл в режиме чтения в кодировке utf-8.
Обратитесь к каждой строке в файле и выполните следующие действия:
уберите невидимые символы в конце строки (символ перехода на новую строку);
обратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;
разбейте строку по разделителю, в результате получите список;
обратитесь к каждому элементу в получившемся списке: если первая его буква — заглавная, тогда этот диалект и нужно проверить (не забудьте привести все буквы в диалекте к одному регистру):
если этого диалекта еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.
если такой диалект уже есть в словаре из п.1, то нужно увеличить его значение на 1.
После цикла создайте пустой список — в него нужно будет добавить названия тех диалектов, значение которых в словаре ровно 2.
Обратитесь к парам ключ-значение в словаре: если значение равно 2, то добавьте ключ в список из п.4.
Отсортируйте список в обратном алфавиту порядке и напечатайте его элементы через точку с запятой и пробел. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: nan 
<Вывод>: саффолк; кокни 
<Example 2>: 
<Тип теста 2>: closed 
<Ввод>: nan 
<Вывод>: манчестер; кардифф 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: nan 
<Вывод>: эссекс; сассекс; ольстер; ливерпуль; дублин 
<Решение студента>: punctuation = '!#$%&()*+,-–./:;<=>?@^_'

data = {}

with open('dialects.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].isupper():
                if w.lower() not in data:
                    data[w.lower()] = 1
                else:
                    data[w.lower()] += 1

                 
res = []

for k, v in data.items():
    if v == 2:
        res.append(k)
        
print(*sorted(res, reverse=True), sep='; ') 
<Идеальное решение>: punctuation = '!#$%&()*+,-–./:;<=>?@^_'

data = {}

with open('dialects.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].isupper():
                if w.lower() not in data:
                    data[w.lower()] = 1
                else:
                    data[w.lower()] += 1

                 
res = []

for k, v in data.items():
    if v == 2:
        res.append(k)
        
print(*sorted(res, reverse=True), sep='; ') 


<Комментарий эксперта>:"
258,559,35,"Роман изучает свой отчет по итогам поездки в Англию, где он описывал различные диалекты. Помогите определить диалекты английского языка, которые упоминаются ровно 2 раза.

ФОРМАТ ВВОДА
Текстовый файл dialects.txt, в котором записан отчет. Гарантируется, что в отчете только названия диалектов всегда записаны с большой буквы. При этом сами диалекты должны учитываться вне зависимости от регистра (например, ""Кардифф"" и ""КАРДиф"" должны считаться, как один диалект)
Гарантируется, что пустых строк в файле нет.
Гарантируется, что в файле будет упоминание хотя бы одного диалекта.
Также дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.
ФОРМАТ ВЫВОДА
Названия диалектов, которые упоминаются в отчете ровно два раза. 
Названия должны быть записаны в нижнем регистре в обратном алфавитном порядке через точку с запятой и пробел.
ДОПОЛНИТЕЛЬНО
В открытом тесте используется файл dialects.txt. Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Создайте пустой словарь, в который будете записывать диалекты и число их упоминаний.
Откройте файл в режиме чтения в кодировке utf-8.
Обратитесь к каждой строке в файле и выполните следующие действия:
уберите невидимые символы в конце строки (символ перехода на новую строку);
обратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;
разбейте строку по разделителю, в результате получите список;
обратитесь к каждому элементу в получившемся списке: если первая его буква — заглавная, тогда этот диалект и нужно проверить (не забудьте привести все буквы в диалекте к одному регистру):
если этого диалекта еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.
если такой диалект уже есть в словаре из п.1, то нужно увеличить его значение на 1.
После цикла создайте пустой список — в него нужно будет добавить названия тех диалектов, значение которых в словаре ровно 2.
Обратитесь к парам ключ-значение в словаре: если значение равно 2, то добавьте ключ в список из п.4.
Отсортируйте список в обратном алфавиту порядке и напечатайте его элементы через точку с запятой и пробел.","[nan, nan, nan]","['саффолк; кокни', 'манчестер; кардифф', 'эссекс; сассекс; ольстер; ливерпуль; дублин']","punctuation = '!#$%&()*+,-–./:;<=>?@^_'

data = {}

with open('dialects.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for word in line:
            if w[0].isupper():
                if w.lower() not in data:
                    data[w.lower()] = 1
                else:
                    data[w.lower()] += 1

                 
res = []

for k, v in data.items():
    if v == 2:
        res.append(k)
        
print(*sorted(res, reverse=True), sep='; ')","punctuation = '!#$%&()*+,-–./:;<=>?@^_'

data = {}

with open('dialects.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].isupper():
                if w.lower() not in data:
                    data[w.lower()] = 1
                else:
                    data[w.lower()] += 1

                 
res = []

for k, v in data.items():
    if v == 2:
        res.append(k)
        
print(*sorted(res, reverse=True), sep='; ')","Ошибка при обращении к ранее не заданным переменным. Проверьте, что все Ваши переменные написаны корректно.","['open', 'closed', 'closed']","<Task description>: Роман изучает свой отчет по итогам поездки в Англию, где он описывал различные диалекты. Помогите определить диалекты английского языка, которые упоминаются ровно 2 раза.

ФОРМАТ ВВОДА
Текстовый файл dialects.txt, в котором записан отчет. Гарантируется, что в отчете только названия диалектов всегда записаны с большой буквы. При этом сами диалекты должны учитываться вне зависимости от регистра (например, ""Кардифф"" и ""КАРДиф"" должны считаться, как один диалект)
Гарантируется, что пустых строк в файле нет.
Гарантируется, что в файле будет упоминание хотя бы одного диалекта.
Также дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.
ФОРМАТ ВЫВОДА
Названия диалектов, которые упоминаются в отчете ровно два раза. 
Названия должны быть записаны в нижнем регистре в обратном алфавитном порядке через точку с запятой и пробел.
ДОПОЛНИТЕЛЬНО
В открытом тесте используется файл dialects.txt. Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Создайте пустой словарь, в который будете записывать диалекты и число их упоминаний.
Откройте файл в режиме чтения в кодировке utf-8.
Обратитесь к каждой строке в файле и выполните следующие действия:
уберите невидимые символы в конце строки (символ перехода на новую строку);
обратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;
разбейте строку по разделителю, в результате получите список;
обратитесь к каждому элементу в получившемся списке: если первая его буква — заглавная, тогда этот диалект и нужно проверить (не забудьте привести все буквы в диалекте к одному регистру):
если этого диалекта еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.
если такой диалект уже есть в словаре из п.1, то нужно увеличить его значение на 1.
После цикла создайте пустой список — в него нужно будет добавить названия тех диалектов, значение которых в словаре ровно 2.
Обратитесь к парам ключ-значение в словаре: если значение равно 2, то добавьте ключ в список из п.4.
Отсортируйте список в обратном алфавиту порядке и напечатайте его элементы через точку с запятой и пробел. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: nan 
<Вывод>: саффолк; кокни 
<Example 2>: 
<Тип теста 2>: closed 
<Ввод>: nan 
<Вывод>: манчестер; кардифф 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: nan 
<Вывод>: эссекс; сассекс; ольстер; ливерпуль; дублин 
<Решение студента>: punctuation = '!#$%&()*+,-–./:;<=>?@^_'

data = {}

with open('dialects.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for word in line:
            if w[0].isupper():
                if w.lower() not in data:
                    data[w.lower()] = 1
                else:
                    data[w.lower()] += 1

                 
res = []

for k, v in data.items():
    if v == 2:
        res.append(k)
        
print(*sorted(res, reverse=True), sep='; ') 
<Идеальное решение>: punctuation = '!#$%&()*+,-–./:;<=>?@^_'

data = {}

with open('dialects.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].isupper():
                if w.lower() not in data:
                    data[w.lower()] = 1
                else:
                    data[w.lower()] += 1

                 
res = []

for k, v in data.items():
    if v == 2:
        res.append(k)
        
print(*sorted(res, reverse=True), sep='; ') 


<Комментарий эксперта>:"
259,560,35,"Роман изучает свой отчет по итогам поездки в Англию, где он описывал различные диалекты. Помогите определить диалекты английского языка, которые упоминаются ровно 2 раза.

ФОРМАТ ВВОДА
Текстовый файл dialects.txt, в котором записан отчет. Гарантируется, что в отчете только названия диалектов всегда записаны с большой буквы. При этом сами диалекты должны учитываться вне зависимости от регистра (например, ""Кардифф"" и ""КАРДиф"" должны считаться, как один диалект)
Гарантируется, что пустых строк в файле нет.
Гарантируется, что в файле будет упоминание хотя бы одного диалекта.
Также дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.
ФОРМАТ ВЫВОДА
Названия диалектов, которые упоминаются в отчете ровно два раза. 
Названия должны быть записаны в нижнем регистре в обратном алфавитном порядке через точку с запятой и пробел.
ДОПОЛНИТЕЛЬНО
В открытом тесте используется файл dialects.txt. Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Создайте пустой словарь, в который будете записывать диалекты и число их упоминаний.
Откройте файл в режиме чтения в кодировке utf-8.
Обратитесь к каждой строке в файле и выполните следующие действия:
уберите невидимые символы в конце строки (символ перехода на новую строку);
обратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;
разбейте строку по разделителю, в результате получите список;
обратитесь к каждому элементу в получившемся списке: если первая его буква — заглавная, тогда этот диалект и нужно проверить (не забудьте привести все буквы в диалекте к одному регистру):
если этого диалекта еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.
если такой диалект уже есть в словаре из п.1, то нужно увеличить его значение на 1.
После цикла создайте пустой список — в него нужно будет добавить названия тех диалектов, значение которых в словаре ровно 2.
Обратитесь к парам ключ-значение в словаре: если значение равно 2, то добавьте ключ в список из п.4.
Отсортируйте список в обратном алфавиту порядке и напечатайте его элементы через точку с запятой и пробел.","[nan, nan, nan]","['саффолк; кокни', 'манчестер; кардифф', 'эссекс; сассекс; ольстер; ливерпуль; дублин']","punctuation = '!#$%&()*+,-–./:;<=>?@^_'

data = {}

with open('dialects.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line
            if w[0].isupper():
                if w.lower() not in data:
                    data[w.lower()] = 1
                else:
                    data[w.lower()] += 1

                 
res = []

for k, v in data.items():
    if v == 2:
        res.append(k)
        
print(*sorted(res, reverse=True), sep='; ')","punctuation = '!#$%&()*+,-–./:;<=>?@^_'

data = {}

with open('dialects.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].isupper():
                if w.lower() not in data:
                    data[w.lower()] = 1
                else:
                    data[w.lower()] += 1

                 
res = []

for k, v in data.items():
    if v == 2:
        res.append(k)
        
print(*sorted(res, reverse=True), sep='; ')",Вы забыли поставить двоеточие после условия цикла for.,"['open', 'closed', 'closed']","<Task description>: Роман изучает свой отчет по итогам поездки в Англию, где он описывал различные диалекты. Помогите определить диалекты английского языка, которые упоминаются ровно 2 раза.

ФОРМАТ ВВОДА
Текстовый файл dialects.txt, в котором записан отчет. Гарантируется, что в отчете только названия диалектов всегда записаны с большой буквы. При этом сами диалекты должны учитываться вне зависимости от регистра (например, ""Кардифф"" и ""КАРДиф"" должны считаться, как один диалект)
Гарантируется, что пустых строк в файле нет.
Гарантируется, что в файле будет упоминание хотя бы одного диалекта.
Также дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.
ФОРМАТ ВЫВОДА
Названия диалектов, которые упоминаются в отчете ровно два раза. 
Названия должны быть записаны в нижнем регистре в обратном алфавитном порядке через точку с запятой и пробел.
ДОПОЛНИТЕЛЬНО
В открытом тесте используется файл dialects.txt. Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Создайте пустой словарь, в который будете записывать диалекты и число их упоминаний.
Откройте файл в режиме чтения в кодировке utf-8.
Обратитесь к каждой строке в файле и выполните следующие действия:
уберите невидимые символы в конце строки (символ перехода на новую строку);
обратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;
разбейте строку по разделителю, в результате получите список;
обратитесь к каждому элементу в получившемся списке: если первая его буква — заглавная, тогда этот диалект и нужно проверить (не забудьте привести все буквы в диалекте к одному регистру):
если этого диалекта еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.
если такой диалект уже есть в словаре из п.1, то нужно увеличить его значение на 1.
После цикла создайте пустой список — в него нужно будет добавить названия тех диалектов, значение которых в словаре ровно 2.
Обратитесь к парам ключ-значение в словаре: если значение равно 2, то добавьте ключ в список из п.4.
Отсортируйте список в обратном алфавиту порядке и напечатайте его элементы через точку с запятой и пробел. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: nan 
<Вывод>: саффолк; кокни 
<Example 2>: 
<Тип теста 2>: closed 
<Ввод>: nan 
<Вывод>: манчестер; кардифф 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: nan 
<Вывод>: эссекс; сассекс; ольстер; ливерпуль; дублин 
<Решение студента>: punctuation = '!#$%&()*+,-–./:;<=>?@^_'

data = {}

with open('dialects.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line
            if w[0].isupper():
                if w.lower() not in data:
                    data[w.lower()] = 1
                else:
                    data[w.lower()] += 1

                 
res = []

for k, v in data.items():
    if v == 2:
        res.append(k)
        
print(*sorted(res, reverse=True), sep='; ') 
<Идеальное решение>: punctuation = '!#$%&()*+,-–./:;<=>?@^_'

data = {}

with open('dialects.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].isupper():
                if w.lower() not in data:
                    data[w.lower()] = 1
                else:
                    data[w.lower()] += 1

                 
res = []

for k, v in data.items():
    if v == 2:
        res.append(k)
        
print(*sorted(res, reverse=True), sep='; ') 


<Комментарий эксперта>:"
260,561,35,"Роман изучает свой отчет по итогам поездки в Англию, где он описывал различные диалекты. Помогите определить диалекты английского языка, которые упоминаются ровно 2 раза.

ФОРМАТ ВВОДА
Текстовый файл dialects.txt, в котором записан отчет. Гарантируется, что в отчете только названия диалектов всегда записаны с большой буквы. При этом сами диалекты должны учитываться вне зависимости от регистра (например, ""Кардифф"" и ""КАРДиф"" должны считаться, как один диалект)
Гарантируется, что пустых строк в файле нет.
Гарантируется, что в файле будет упоминание хотя бы одного диалекта.
Также дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.
ФОРМАТ ВЫВОДА
Названия диалектов, которые упоминаются в отчете ровно два раза. 
Названия должны быть записаны в нижнем регистре в обратном алфавитном порядке через точку с запятой и пробел.
ДОПОЛНИТЕЛЬНО
В открытом тесте используется файл dialects.txt. Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Создайте пустой словарь, в который будете записывать диалекты и число их упоминаний.
Откройте файл в режиме чтения в кодировке utf-8.
Обратитесь к каждой строке в файле и выполните следующие действия:
уберите невидимые символы в конце строки (символ перехода на новую строку);
обратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;
разбейте строку по разделителю, в результате получите список;
обратитесь к каждому элементу в получившемся списке: если первая его буква — заглавная, тогда этот диалект и нужно проверить (не забудьте привести все буквы в диалекте к одному регистру):
если этого диалекта еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.
если такой диалект уже есть в словаре из п.1, то нужно увеличить его значение на 1.
После цикла создайте пустой список — в него нужно будет добавить названия тех диалектов, значение которых в словаре ровно 2.
Обратитесь к парам ключ-значение в словаре: если значение равно 2, то добавьте ключ в список из п.4.
Отсортируйте список в обратном алфавиту порядке и напечатайте его элементы через точку с запятой и пробел.","[nan, nan, nan]","['саффолк; кокни', 'манчестер; кардифф', 'эссекс; сассекс; ольстер; ливерпуль; дублин']","punctuation = '!#$%&()*+,-–./:;<=>?@^_'

data = {}

with open('dialects.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[1].isupper():
                if w.lower() not in data:
                    data[w.lower()] = 1
                else:
                    data[w.lower()] += 1

                 
res = []

for k, v in data.items():
    if v == 2:
        res.append(k)
        
print(*sorted(res, reverse=True), sep='; ')","punctuation = '!#$%&()*+,-–./:;<=>?@^_'

data = {}

with open('dialects.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].isupper():
                if w.lower() not in data:
                    data[w.lower()] = 1
                else:
                    data[w.lower()] += 1

                 
res = []

for k, v in data.items():
    if v == 2:
        res.append(k)
        
print(*sorted(res, reverse=True), sep='; ')","Ошибка при итерации по символам каждого слова. Помните, что в Python нумерация элементов начинается с 0.","['open', 'closed', 'closed']","<Task description>: Роман изучает свой отчет по итогам поездки в Англию, где он описывал различные диалекты. Помогите определить диалекты английского языка, которые упоминаются ровно 2 раза.

ФОРМАТ ВВОДА
Текстовый файл dialects.txt, в котором записан отчет. Гарантируется, что в отчете только названия диалектов всегда записаны с большой буквы. При этом сами диалекты должны учитываться вне зависимости от регистра (например, ""Кардифф"" и ""КАРДиф"" должны считаться, как один диалект)
Гарантируется, что пустых строк в файле нет.
Гарантируется, что в файле будет упоминание хотя бы одного диалекта.
Также дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.
ФОРМАТ ВЫВОДА
Названия диалектов, которые упоминаются в отчете ровно два раза. 
Названия должны быть записаны в нижнем регистре в обратном алфавитном порядке через точку с запятой и пробел.
ДОПОЛНИТЕЛЬНО
В открытом тесте используется файл dialects.txt. Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Создайте пустой словарь, в который будете записывать диалекты и число их упоминаний.
Откройте файл в режиме чтения в кодировке utf-8.
Обратитесь к каждой строке в файле и выполните следующие действия:
уберите невидимые символы в конце строки (символ перехода на новую строку);
обратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;
разбейте строку по разделителю, в результате получите список;
обратитесь к каждому элементу в получившемся списке: если первая его буква — заглавная, тогда этот диалект и нужно проверить (не забудьте привести все буквы в диалекте к одному регистру):
если этого диалекта еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.
если такой диалект уже есть в словаре из п.1, то нужно увеличить его значение на 1.
После цикла создайте пустой список — в него нужно будет добавить названия тех диалектов, значение которых в словаре ровно 2.
Обратитесь к парам ключ-значение в словаре: если значение равно 2, то добавьте ключ в список из п.4.
Отсортируйте список в обратном алфавиту порядке и напечатайте его элементы через точку с запятой и пробел. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: nan 
<Вывод>: саффолк; кокни 
<Example 2>: 
<Тип теста 2>: closed 
<Ввод>: nan 
<Вывод>: манчестер; кардифф 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: nan 
<Вывод>: эссекс; сассекс; ольстер; ливерпуль; дублин 
<Решение студента>: punctuation = '!#$%&()*+,-–./:;<=>?@^_'

data = {}

with open('dialects.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[1].isupper():
                if w.lower() not in data:
                    data[w.lower()] = 1
                else:
                    data[w.lower()] += 1

                 
res = []

for k, v in data.items():
    if v == 2:
        res.append(k)
        
print(*sorted(res, reverse=True), sep='; ') 
<Идеальное решение>: punctuation = '!#$%&()*+,-–./:;<=>?@^_'

data = {}

with open('dialects.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].isupper():
                if w.lower() not in data:
                    data[w.lower()] = 1
                else:
                    data[w.lower()] += 1

                 
res = []

for k, v in data.items():
    if v == 2:
        res.append(k)
        
print(*sorted(res, reverse=True), sep='; ') 


<Комментарий эксперта>:"
261,562,35,"Роман изучает свой отчет по итогам поездки в Англию, где он описывал различные диалекты. Помогите определить диалекты английского языка, которые упоминаются ровно 2 раза.

ФОРМАТ ВВОДА
Текстовый файл dialects.txt, в котором записан отчет. Гарантируется, что в отчете только названия диалектов всегда записаны с большой буквы. При этом сами диалекты должны учитываться вне зависимости от регистра (например, ""Кардифф"" и ""КАРДиф"" должны считаться, как один диалект)
Гарантируется, что пустых строк в файле нет.
Гарантируется, что в файле будет упоминание хотя бы одного диалекта.
Также дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.
ФОРМАТ ВЫВОДА
Названия диалектов, которые упоминаются в отчете ровно два раза. 
Названия должны быть записаны в нижнем регистре в обратном алфавитном порядке через точку с запятой и пробел.
ДОПОЛНИТЕЛЬНО
В открытом тесте используется файл dialects.txt. Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Создайте пустой словарь, в который будете записывать диалекты и число их упоминаний.
Откройте файл в режиме чтения в кодировке utf-8.
Обратитесь к каждой строке в файле и выполните следующие действия:
уберите невидимые символы в конце строки (символ перехода на новую строку);
обратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;
разбейте строку по разделителю, в результате получите список;
обратитесь к каждому элементу в получившемся списке: если первая его буква — заглавная, тогда этот диалект и нужно проверить (не забудьте привести все буквы в диалекте к одному регистру):
если этого диалекта еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.
если такой диалект уже есть в словаре из п.1, то нужно увеличить его значение на 1.
После цикла создайте пустой список — в него нужно будет добавить названия тех диалектов, значение которых в словаре ровно 2.
Обратитесь к парам ключ-значение в словаре: если значение равно 2, то добавьте ключ в список из п.4.
Отсортируйте список в обратном алфавиту порядке и напечатайте его элементы через точку с запятой и пробел.","[nan, nan, nan]","['саффолк; кокни', 'манчестер; кардифф', 'эссекс; сассекс; ольстер; ливерпуль; дублин']","punctuation = '!#$%&()*+,-–./:;<=>?@^_'

data = {}

with open('dialects.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line.strip()
        
        for p in punctuation:
            line.replace(p, '')
        
        line.split()
        for w in line:
            if w[0].isupper():
                if w.lower() not in data:
                    data[w.lower()] = 1
                else:
                    data[w.lower()] += 1

                 
res = []

for k, v in data.items():
    if v == 2:
        res.append(k)
        
print(*sorted(res, reverse=True), sep='; ')","punctuation = '!#$%&()*+,-–./:;<=>?@^_'

data = {}

with open('dialects.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].isupper():
                if w.lower() not in data:
                    data[w.lower()] = 1
                else:
                    data[w.lower()] += 1

                 
res = []

for k, v in data.items():
    if v == 2:
        res.append(k)
        
print(*sorted(res, reverse=True), sep='; ')","Для перезаписи переменной должны соблюдаться нормы синтаксиса формата ""x = ...""","['open', 'closed', 'closed']","<Task description>: Роман изучает свой отчет по итогам поездки в Англию, где он описывал различные диалекты. Помогите определить диалекты английского языка, которые упоминаются ровно 2 раза.

ФОРМАТ ВВОДА
Текстовый файл dialects.txt, в котором записан отчет. Гарантируется, что в отчете только названия диалектов всегда записаны с большой буквы. При этом сами диалекты должны учитываться вне зависимости от регистра (например, ""Кардифф"" и ""КАРДиф"" должны считаться, как один диалект)
Гарантируется, что пустых строк в файле нет.
Гарантируется, что в файле будет упоминание хотя бы одного диалекта.
Также дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.
ФОРМАТ ВЫВОДА
Названия диалектов, которые упоминаются в отчете ровно два раза. 
Названия должны быть записаны в нижнем регистре в обратном алфавитном порядке через точку с запятой и пробел.
ДОПОЛНИТЕЛЬНО
В открытом тесте используется файл dialects.txt. Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Создайте пустой словарь, в который будете записывать диалекты и число их упоминаний.
Откройте файл в режиме чтения в кодировке utf-8.
Обратитесь к каждой строке в файле и выполните следующие действия:
уберите невидимые символы в конце строки (символ перехода на новую строку);
обратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;
разбейте строку по разделителю, в результате получите список;
обратитесь к каждому элементу в получившемся списке: если первая его буква — заглавная, тогда этот диалект и нужно проверить (не забудьте привести все буквы в диалекте к одному регистру):
если этого диалекта еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.
если такой диалект уже есть в словаре из п.1, то нужно увеличить его значение на 1.
После цикла создайте пустой список — в него нужно будет добавить названия тех диалектов, значение которых в словаре ровно 2.
Обратитесь к парам ключ-значение в словаре: если значение равно 2, то добавьте ключ в список из п.4.
Отсортируйте список в обратном алфавиту порядке и напечатайте его элементы через точку с запятой и пробел. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: nan 
<Вывод>: саффолк; кокни 
<Example 2>: 
<Тип теста 2>: closed 
<Ввод>: nan 
<Вывод>: манчестер; кардифф 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: nan 
<Вывод>: эссекс; сассекс; ольстер; ливерпуль; дублин 
<Решение студента>: punctuation = '!#$%&()*+,-–./:;<=>?@^_'

data = {}

with open('dialects.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line.strip()
        
        for p in punctuation:
            line.replace(p, '')
        
        line.split()
        for w in line:
            if w[0].isupper():
                if w.lower() not in data:
                    data[w.lower()] = 1
                else:
                    data[w.lower()] += 1

                 
res = []

for k, v in data.items():
    if v == 2:
        res.append(k)
        
print(*sorted(res, reverse=True), sep='; ') 
<Идеальное решение>: punctuation = '!#$%&()*+,-–./:;<=>?@^_'

data = {}

with open('dialects.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].isupper():
                if w.lower() not in data:
                    data[w.lower()] = 1
                else:
                    data[w.lower()] += 1

                 
res = []

for k, v in data.items():
    if v == 2:
        res.append(k)
        
print(*sorted(res, reverse=True), sep='; ') 


<Комментарий эксперта>:"
262,563,35,"Роман изучает свой отчет по итогам поездки в Англию, где он описывал различные диалекты. Помогите определить диалекты английского языка, которые упоминаются ровно 2 раза.

ФОРМАТ ВВОДА
Текстовый файл dialects.txt, в котором записан отчет. Гарантируется, что в отчете только названия диалектов всегда записаны с большой буквы. При этом сами диалекты должны учитываться вне зависимости от регистра (например, ""Кардифф"" и ""КАРДиф"" должны считаться, как один диалект)
Гарантируется, что пустых строк в файле нет.
Гарантируется, что в файле будет упоминание хотя бы одного диалекта.
Также дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.
ФОРМАТ ВЫВОДА
Названия диалектов, которые упоминаются в отчете ровно два раза. 
Названия должны быть записаны в нижнем регистре в обратном алфавитном порядке через точку с запятой и пробел.
ДОПОЛНИТЕЛЬНО
В открытом тесте используется файл dialects.txt. Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Создайте пустой словарь, в который будете записывать диалекты и число их упоминаний.
Откройте файл в режиме чтения в кодировке utf-8.
Обратитесь к каждой строке в файле и выполните следующие действия:
уберите невидимые символы в конце строки (символ перехода на новую строку);
обратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;
разбейте строку по разделителю, в результате получите список;
обратитесь к каждому элементу в получившемся списке: если первая его буква — заглавная, тогда этот диалект и нужно проверить (не забудьте привести все буквы в диалекте к одному регистру):
если этого диалекта еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.
если такой диалект уже есть в словаре из п.1, то нужно увеличить его значение на 1.
После цикла создайте пустой список — в него нужно будет добавить названия тех диалектов, значение которых в словаре ровно 2.
Обратитесь к парам ключ-значение в словаре: если значение равно 2, то добавьте ключ в список из п.4.
Отсортируйте список в обратном алфавиту порядке и напечатайте его элементы через точку с запятой и пробел.","[nan, nan, nan]","['саффолк; кокни', 'манчестер; кардифф', 'эссекс; сассекс; ольстер; ливерпуль; дублин']","punctuation = '!#$%&()*+,-–./:;<=>?@^_'

data = {}

with open('dialects.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].upper():
                if w.lower() not in data:
                    data[w.lower()] = 1
                else:
                    data[w.lower()] += 1

                 
res = []

for k, v in data.items():
    if v == 2:
        res.append(k)
        
print(*sorted(res, reverse=True), sep='; ')","punctuation = '!#$%&()*+,-–./:;<=>?@^_'

data = {}

with open('dialects.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].isupper():
                if w.lower() not in data:
                    data[w.lower()] = 1
                else:
                    data[w.lower()] += 1

                 
res = []

for k, v in data.items():
    if v == 2:
        res.append(k)
        
print(*sorted(res, reverse=True), sep='; ')",Ошибка в использовании метода проверки заглавных букв. Метод .upper() конвертирует все символы строки в заглавные.,"['open', 'closed', 'closed']","<Task description>: Роман изучает свой отчет по итогам поездки в Англию, где он описывал различные диалекты. Помогите определить диалекты английского языка, которые упоминаются ровно 2 раза.

ФОРМАТ ВВОДА
Текстовый файл dialects.txt, в котором записан отчет. Гарантируется, что в отчете только названия диалектов всегда записаны с большой буквы. При этом сами диалекты должны учитываться вне зависимости от регистра (например, ""Кардифф"" и ""КАРДиф"" должны считаться, как один диалект)
Гарантируется, что пустых строк в файле нет.
Гарантируется, что в файле будет упоминание хотя бы одного диалекта.
Также дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.
ФОРМАТ ВЫВОДА
Названия диалектов, которые упоминаются в отчете ровно два раза. 
Названия должны быть записаны в нижнем регистре в обратном алфавитном порядке через точку с запятой и пробел.
ДОПОЛНИТЕЛЬНО
В открытом тесте используется файл dialects.txt. Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Создайте пустой словарь, в который будете записывать диалекты и число их упоминаний.
Откройте файл в режиме чтения в кодировке utf-8.
Обратитесь к каждой строке в файле и выполните следующие действия:
уберите невидимые символы в конце строки (символ перехода на новую строку);
обратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;
разбейте строку по разделителю, в результате получите список;
обратитесь к каждому элементу в получившемся списке: если первая его буква — заглавная, тогда этот диалект и нужно проверить (не забудьте привести все буквы в диалекте к одному регистру):
если этого диалекта еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.
если такой диалект уже есть в словаре из п.1, то нужно увеличить его значение на 1.
После цикла создайте пустой список — в него нужно будет добавить названия тех диалектов, значение которых в словаре ровно 2.
Обратитесь к парам ключ-значение в словаре: если значение равно 2, то добавьте ключ в список из п.4.
Отсортируйте список в обратном алфавиту порядке и напечатайте его элементы через точку с запятой и пробел. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: nan 
<Вывод>: саффолк; кокни 
<Example 2>: 
<Тип теста 2>: closed 
<Ввод>: nan 
<Вывод>: манчестер; кардифф 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: nan 
<Вывод>: эссекс; сассекс; ольстер; ливерпуль; дублин 
<Решение студента>: punctuation = '!#$%&()*+,-–./:;<=>?@^_'

data = {}

with open('dialects.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].upper():
                if w.lower() not in data:
                    data[w.lower()] = 1
                else:
                    data[w.lower()] += 1

                 
res = []

for k, v in data.items():
    if v == 2:
        res.append(k)
        
print(*sorted(res, reverse=True), sep='; ') 
<Идеальное решение>: punctuation = '!#$%&()*+,-–./:;<=>?@^_'

data = {}

with open('dialects.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].isupper():
                if w.lower() not in data:
                    data[w.lower()] = 1
                else:
                    data[w.lower()] += 1

                 
res = []

for k, v in data.items():
    if v == 2:
        res.append(k)
        
print(*sorted(res, reverse=True), sep='; ') 


<Комментарий эксперта>:"
263,564,35,"Роман изучает свой отчет по итогам поездки в Англию, где он описывал различные диалекты. Помогите определить диалекты английского языка, которые упоминаются ровно 2 раза.

ФОРМАТ ВВОДА
Текстовый файл dialects.txt, в котором записан отчет. Гарантируется, что в отчете только названия диалектов всегда записаны с большой буквы. При этом сами диалекты должны учитываться вне зависимости от регистра (например, ""Кардифф"" и ""КАРДиф"" должны считаться, как один диалект)
Гарантируется, что пустых строк в файле нет.
Гарантируется, что в файле будет упоминание хотя бы одного диалекта.
Также дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.
ФОРМАТ ВЫВОДА
Названия диалектов, которые упоминаются в отчете ровно два раза. 
Названия должны быть записаны в нижнем регистре в обратном алфавитном порядке через точку с запятой и пробел.
ДОПОЛНИТЕЛЬНО
В открытом тесте используется файл dialects.txt. Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Создайте пустой словарь, в который будете записывать диалекты и число их упоминаний.
Откройте файл в режиме чтения в кодировке utf-8.
Обратитесь к каждой строке в файле и выполните следующие действия:
уберите невидимые символы в конце строки (символ перехода на новую строку);
обратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;
разбейте строку по разделителю, в результате получите список;
обратитесь к каждому элементу в получившемся списке: если первая его буква — заглавная, тогда этот диалект и нужно проверить (не забудьте привести все буквы в диалекте к одному регистру):
если этого диалекта еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.
если такой диалект уже есть в словаре из п.1, то нужно увеличить его значение на 1.
После цикла создайте пустой список — в него нужно будет добавить названия тех диалектов, значение которых в словаре ровно 2.
Обратитесь к парам ключ-значение в словаре: если значение равно 2, то добавьте ключ в список из п.4.
Отсортируйте список в обратном алфавиту порядке и напечатайте его элементы через точку с запятой и пробел.","[nan, nan, nan]","['саффолк; кокни', 'манчестер; кардифф', 'эссекс; сассекс; ольстер; ливерпуль; дублин']","punctuation = '!#$%&()*+,-–./:;<=>?@^_'

data = {}

with open(dialects.txt, 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].isupper():
                if w.lower() not in data:
                    data[w.lower()] = 1
                else:
                    data[w.lower()] += 1

                 
res = []

for k, v in data.items():
    if v == 2:
        res.append(k)
        
print(*sorted(res, reverse=True), sep='; ')","punctuation = '!#$%&()*+,-–./:;<=>?@^_'

data = {}

with open('dialects.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].isupper():
                if w.lower() not in data:
                    data[w.lower()] = 1
                else:
                    data[w.lower()] += 1

                 
res = []

for k, v in data.items():
    if v == 2:
        res.append(k)
        
print(*sorted(res, reverse=True), sep='; ')",Ошибка при открытии файла. При обращении к файлу необходимо заключать его название в кавычки.,"['open', 'closed', 'closed']","<Task description>: Роман изучает свой отчет по итогам поездки в Англию, где он описывал различные диалекты. Помогите определить диалекты английского языка, которые упоминаются ровно 2 раза.

ФОРМАТ ВВОДА
Текстовый файл dialects.txt, в котором записан отчет. Гарантируется, что в отчете только названия диалектов всегда записаны с большой буквы. При этом сами диалекты должны учитываться вне зависимости от регистра (например, ""Кардифф"" и ""КАРДиф"" должны считаться, как один диалект)
Гарантируется, что пустых строк в файле нет.
Гарантируется, что в файле будет упоминание хотя бы одного диалекта.
Также дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.
ФОРМАТ ВЫВОДА
Названия диалектов, которые упоминаются в отчете ровно два раза. 
Названия должны быть записаны в нижнем регистре в обратном алфавитном порядке через точку с запятой и пробел.
ДОПОЛНИТЕЛЬНО
В открытом тесте используется файл dialects.txt. Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Создайте пустой словарь, в который будете записывать диалекты и число их упоминаний.
Откройте файл в режиме чтения в кодировке utf-8.
Обратитесь к каждой строке в файле и выполните следующие действия:
уберите невидимые символы в конце строки (символ перехода на новую строку);
обратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;
разбейте строку по разделителю, в результате получите список;
обратитесь к каждому элементу в получившемся списке: если первая его буква — заглавная, тогда этот диалект и нужно проверить (не забудьте привести все буквы в диалекте к одному регистру):
если этого диалекта еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.
если такой диалект уже есть в словаре из п.1, то нужно увеличить его значение на 1.
После цикла создайте пустой список — в него нужно будет добавить названия тех диалектов, значение которых в словаре ровно 2.
Обратитесь к парам ключ-значение в словаре: если значение равно 2, то добавьте ключ в список из п.4.
Отсортируйте список в обратном алфавиту порядке и напечатайте его элементы через точку с запятой и пробел. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: nan 
<Вывод>: саффолк; кокни 
<Example 2>: 
<Тип теста 2>: closed 
<Ввод>: nan 
<Вывод>: манчестер; кардифф 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: nan 
<Вывод>: эссекс; сассекс; ольстер; ливерпуль; дублин 
<Решение студента>: punctuation = '!#$%&()*+,-–./:;<=>?@^_'

data = {}

with open(dialects.txt, 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].isupper():
                if w.lower() not in data:
                    data[w.lower()] = 1
                else:
                    data[w.lower()] += 1

                 
res = []

for k, v in data.items():
    if v == 2:
        res.append(k)
        
print(*sorted(res, reverse=True), sep='; ') 
<Идеальное решение>: punctuation = '!#$%&()*+,-–./:;<=>?@^_'

data = {}

with open('dialects.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].isupper():
                if w.lower() not in data:
                    data[w.lower()] = 1
                else:
                    data[w.lower()] += 1

                 
res = []

for k, v in data.items():
    if v == 2:
        res.append(k)
        
print(*sorted(res, reverse=True), sep='; ') 


<Комментарий эксперта>:"
264,565,35,"Роман изучает свой отчет по итогам поездки в Англию, где он описывал различные диалекты. Помогите определить диалекты английского языка, которые упоминаются ровно 2 раза.

ФОРМАТ ВВОДА
Текстовый файл dialects.txt, в котором записан отчет. Гарантируется, что в отчете только названия диалектов всегда записаны с большой буквы. При этом сами диалекты должны учитываться вне зависимости от регистра (например, ""Кардифф"" и ""КАРДиф"" должны считаться, как один диалект)
Гарантируется, что пустых строк в файле нет.
Гарантируется, что в файле будет упоминание хотя бы одного диалекта.
Также дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.
ФОРМАТ ВЫВОДА
Названия диалектов, которые упоминаются в отчете ровно два раза. 
Названия должны быть записаны в нижнем регистре в обратном алфавитном порядке через точку с запятой и пробел.
ДОПОЛНИТЕЛЬНО
В открытом тесте используется файл dialects.txt. Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Создайте пустой словарь, в который будете записывать диалекты и число их упоминаний.
Откройте файл в режиме чтения в кодировке utf-8.
Обратитесь к каждой строке в файле и выполните следующие действия:
уберите невидимые символы в конце строки (символ перехода на новую строку);
обратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;
разбейте строку по разделителю, в результате получите список;
обратитесь к каждому элементу в получившемся списке: если первая его буква — заглавная, тогда этот диалект и нужно проверить (не забудьте привести все буквы в диалекте к одному регистру):
если этого диалекта еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.
если такой диалект уже есть в словаре из п.1, то нужно увеличить его значение на 1.
После цикла создайте пустой список — в него нужно будет добавить названия тех диалектов, значение которых в словаре ровно 2.
Обратитесь к парам ключ-значение в словаре: если значение равно 2, то добавьте ключ в список из п.4.
Отсортируйте список в обратном алфавиту порядке и напечатайте его элементы через точку с запятой и пробел.","[nan, nan, nan]","['саффолк; кокни', 'манчестер; кардифф', 'эссекс; сассекс; ольстер; ливерпуль; дублин']","punctuation = '!#$%&()*+,-–./:;<=>?@^_'

data = {}

with open('dialects.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].isupper():
                if w not in data:
                    data[w.lower()] = 1
                else:
                    data[w.lower()] += 1

                 
res = []

for k, v in data.items():
    if v == 2:
        res.append(k)
        
print(*sorted(res, reverse=True), sep='; ')","punctuation = '!#$%&()*+,-–./:;<=>?@^_'

data = {}

with open('dialects.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].isupper():
                if w.lower() not in data:
                    data[w.lower()] = 1
                else:
                    data[w.lower()] += 1

                 
res = []

for k, v in data.items():
    if v == 2:
        res.append(k)
        
print(*sorted(res, reverse=True), sep='; ')","Ошибка в открытых и скрытых тестах. 

Ваш код некорректно обрабатывает данные. При добавлении слова в словарь необходимо учитывать, что первый элемент слова начинается с заглавной буквы.","['open', 'closed', 'closed']","<Task description>: Роман изучает свой отчет по итогам поездки в Англию, где он описывал различные диалекты. Помогите определить диалекты английского языка, которые упоминаются ровно 2 раза.

ФОРМАТ ВВОДА
Текстовый файл dialects.txt, в котором записан отчет. Гарантируется, что в отчете только названия диалектов всегда записаны с большой буквы. При этом сами диалекты должны учитываться вне зависимости от регистра (например, ""Кардифф"" и ""КАРДиф"" должны считаться, как один диалект)
Гарантируется, что пустых строк в файле нет.
Гарантируется, что в файле будет упоминание хотя бы одного диалекта.
Также дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.
ФОРМАТ ВЫВОДА
Названия диалектов, которые упоминаются в отчете ровно два раза. 
Названия должны быть записаны в нижнем регистре в обратном алфавитном порядке через точку с запятой и пробел.
ДОПОЛНИТЕЛЬНО
В открытом тесте используется файл dialects.txt. Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Создайте пустой словарь, в который будете записывать диалекты и число их упоминаний.
Откройте файл в режиме чтения в кодировке utf-8.
Обратитесь к каждой строке в файле и выполните следующие действия:
уберите невидимые символы в конце строки (символ перехода на новую строку);
обратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;
разбейте строку по разделителю, в результате получите список;
обратитесь к каждому элементу в получившемся списке: если первая его буква — заглавная, тогда этот диалект и нужно проверить (не забудьте привести все буквы в диалекте к одному регистру):
если этого диалекта еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.
если такой диалект уже есть в словаре из п.1, то нужно увеличить его значение на 1.
После цикла создайте пустой список — в него нужно будет добавить названия тех диалектов, значение которых в словаре ровно 2.
Обратитесь к парам ключ-значение в словаре: если значение равно 2, то добавьте ключ в список из п.4.
Отсортируйте список в обратном алфавиту порядке и напечатайте его элементы через точку с запятой и пробел. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: nan 
<Вывод>: саффолк; кокни 
<Example 2>: 
<Тип теста 2>: closed 
<Ввод>: nan 
<Вывод>: манчестер; кардифф 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: nan 
<Вывод>: эссекс; сассекс; ольстер; ливерпуль; дублин 
<Решение студента>: punctuation = '!#$%&()*+,-–./:;<=>?@^_'

data = {}

with open('dialects.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].isupper():
                if w not in data:
                    data[w.lower()] = 1
                else:
                    data[w.lower()] += 1

                 
res = []

for k, v in data.items():
    if v == 2:
        res.append(k)
        
print(*sorted(res, reverse=True), sep='; ') 
<Идеальное решение>: punctuation = '!#$%&()*+,-–./:;<=>?@^_'

data = {}

with open('dialects.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].isupper():
                if w.lower() not in data:
                    data[w.lower()] = 1
                else:
                    data[w.lower()] += 1

                 
res = []

for k, v in data.items():
    if v == 2:
        res.append(k)
        
print(*sorted(res, reverse=True), sep='; ') 


<Комментарий эксперта>:"
265,566,35,"Роман изучает свой отчет по итогам поездки в Англию, где он описывал различные диалекты. Помогите определить диалекты английского языка, которые упоминаются ровно 2 раза.

ФОРМАТ ВВОДА
Текстовый файл dialects.txt, в котором записан отчет. Гарантируется, что в отчете только названия диалектов всегда записаны с большой буквы. При этом сами диалекты должны учитываться вне зависимости от регистра (например, ""Кардифф"" и ""КАРДиф"" должны считаться, как один диалект)
Гарантируется, что пустых строк в файле нет.
Гарантируется, что в файле будет упоминание хотя бы одного диалекта.
Также дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.
ФОРМАТ ВЫВОДА
Названия диалектов, которые упоминаются в отчете ровно два раза. 
Названия должны быть записаны в нижнем регистре в обратном алфавитном порядке через точку с запятой и пробел.
ДОПОЛНИТЕЛЬНО
В открытом тесте используется файл dialects.txt. Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Создайте пустой словарь, в который будете записывать диалекты и число их упоминаний.
Откройте файл в режиме чтения в кодировке utf-8.
Обратитесь к каждой строке в файле и выполните следующие действия:
уберите невидимые символы в конце строки (символ перехода на новую строку);
обратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;
разбейте строку по разделителю, в результате получите список;
обратитесь к каждому элементу в получившемся списке: если первая его буква — заглавная, тогда этот диалект и нужно проверить (не забудьте привести все буквы в диалекте к одному регистру):
если этого диалекта еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.
если такой диалект уже есть в словаре из п.1, то нужно увеличить его значение на 1.
После цикла создайте пустой список — в него нужно будет добавить названия тех диалектов, значение которых в словаре ровно 2.
Обратитесь к парам ключ-значение в словаре: если значение равно 2, то добавьте ключ в список из п.4.
Отсортируйте список в обратном алфавиту порядке и напечатайте его элементы через точку с запятой и пробел.","[nan, nan, nan]","['саффолк; кокни', 'манчестер; кардифф', 'эссекс; сассекс; ольстер; ливерпуль; дублин']","punctuation = '!#$%&()*+,-–./:;<=>?@^_'

data = {}

with open('dialects.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].isupper():
                if w.lower() in data:
                    data[w.lower()] = 1
                else:
                    data[w.lower()] += 1

                 
res = []

for k, v in data.items():
    if v == 2:
        res.append(k)
        
print(*sorted(res, reverse=True), sep='; ')","punctuation = '!#$%&()*+,-–./:;<=>?@^_'

data = {}

with open('dialects.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].isupper():
                if w.lower() not in data:
                    data[w.lower()] = 1
                else:
                    data[w.lower()] += 1

                 
res = []

for k, v in data.items():
    if v == 2:
        res.append(k)
        
print(*sorted(res, reverse=True), sep='; ')","Ошибка при добавлении данных в словарь. Скорректируйте код таким образом, чтобы в словарь добавлялись только те ключи, которые ранее добавлены не были.","['open', 'closed', 'closed']","<Task description>: Роман изучает свой отчет по итогам поездки в Англию, где он описывал различные диалекты. Помогите определить диалекты английского языка, которые упоминаются ровно 2 раза.

ФОРМАТ ВВОДА
Текстовый файл dialects.txt, в котором записан отчет. Гарантируется, что в отчете только названия диалектов всегда записаны с большой буквы. При этом сами диалекты должны учитываться вне зависимости от регистра (например, ""Кардифф"" и ""КАРДиф"" должны считаться, как один диалект)
Гарантируется, что пустых строк в файле нет.
Гарантируется, что в файле будет упоминание хотя бы одного диалекта.
Также дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.
ФОРМАТ ВЫВОДА
Названия диалектов, которые упоминаются в отчете ровно два раза. 
Названия должны быть записаны в нижнем регистре в обратном алфавитном порядке через точку с запятой и пробел.
ДОПОЛНИТЕЛЬНО
В открытом тесте используется файл dialects.txt. Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Создайте пустой словарь, в который будете записывать диалекты и число их упоминаний.
Откройте файл в режиме чтения в кодировке utf-8.
Обратитесь к каждой строке в файле и выполните следующие действия:
уберите невидимые символы в конце строки (символ перехода на новую строку);
обратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;
разбейте строку по разделителю, в результате получите список;
обратитесь к каждому элементу в получившемся списке: если первая его буква — заглавная, тогда этот диалект и нужно проверить (не забудьте привести все буквы в диалекте к одному регистру):
если этого диалекта еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.
если такой диалект уже есть в словаре из п.1, то нужно увеличить его значение на 1.
После цикла создайте пустой список — в него нужно будет добавить названия тех диалектов, значение которых в словаре ровно 2.
Обратитесь к парам ключ-значение в словаре: если значение равно 2, то добавьте ключ в список из п.4.
Отсортируйте список в обратном алфавиту порядке и напечатайте его элементы через точку с запятой и пробел. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: nan 
<Вывод>: саффолк; кокни 
<Example 2>: 
<Тип теста 2>: closed 
<Ввод>: nan 
<Вывод>: манчестер; кардифф 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: nan 
<Вывод>: эссекс; сассекс; ольстер; ливерпуль; дублин 
<Решение студента>: punctuation = '!#$%&()*+,-–./:;<=>?@^_'

data = {}

with open('dialects.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].isupper():
                if w.lower() in data:
                    data[w.lower()] = 1
                else:
                    data[w.lower()] += 1

                 
res = []

for k, v in data.items():
    if v == 2:
        res.append(k)
        
print(*sorted(res, reverse=True), sep='; ') 
<Идеальное решение>: punctuation = '!#$%&()*+,-–./:;<=>?@^_'

data = {}

with open('dialects.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].isupper():
                if w.lower() not in data:
                    data[w.lower()] = 1
                else:
                    data[w.lower()] += 1

                 
res = []

for k, v in data.items():
    if v == 2:
        res.append(k)
        
print(*sorted(res, reverse=True), sep='; ') 


<Комментарий эксперта>:"
266,567,35,"Роман изучает свой отчет по итогам поездки в Англию, где он описывал различные диалекты. Помогите определить диалекты английского языка, которые упоминаются ровно 2 раза.

ФОРМАТ ВВОДА
Текстовый файл dialects.txt, в котором записан отчет. Гарантируется, что в отчете только названия диалектов всегда записаны с большой буквы. При этом сами диалекты должны учитываться вне зависимости от регистра (например, ""Кардифф"" и ""КАРДиф"" должны считаться, как один диалект)
Гарантируется, что пустых строк в файле нет.
Гарантируется, что в файле будет упоминание хотя бы одного диалекта.
Также дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.
ФОРМАТ ВЫВОДА
Названия диалектов, которые упоминаются в отчете ровно два раза. 
Названия должны быть записаны в нижнем регистре в обратном алфавитном порядке через точку с запятой и пробел.
ДОПОЛНИТЕЛЬНО
В открытом тесте используется файл dialects.txt. Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Создайте пустой словарь, в который будете записывать диалекты и число их упоминаний.
Откройте файл в режиме чтения в кодировке utf-8.
Обратитесь к каждой строке в файле и выполните следующие действия:
уберите невидимые символы в конце строки (символ перехода на новую строку);
обратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;
разбейте строку по разделителю, в результате получите список;
обратитесь к каждому элементу в получившемся списке: если первая его буква — заглавная, тогда этот диалект и нужно проверить (не забудьте привести все буквы в диалекте к одному регистру):
если этого диалекта еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.
если такой диалект уже есть в словаре из п.1, то нужно увеличить его значение на 1.
После цикла создайте пустой список — в него нужно будет добавить названия тех диалектов, значение которых в словаре ровно 2.
Обратитесь к парам ключ-значение в словаре: если значение равно 2, то добавьте ключ в список из п.4.
Отсортируйте список в обратном алфавиту порядке и напечатайте его элементы через точку с запятой и пробел.","[nan, nan, nan]","['саффолк; кокни', 'манчестер; кардифф', 'эссекс; сассекс; ольстер; ливерпуль; дублин']","punctuation = '!#$%&()*+,-–./:;<=>?@^_'

data = {}

with open('dialects.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].isupper():
                if w.lower() not in data:
                    data[w.lower()] = 1
                else:
                    data[w.lower()] += 1

                 

for k, v in data.items():
    if v == 2:
        res.append(k)
        
print(*sorted(res, reverse=True), sep='; ')","punctuation = '!#$%&()*+,-–./:;<=>?@^_'

data = {}

with open('dialects.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].isupper():
                if w.lower() not in data:
                    data[w.lower()] = 1
                else:
                    data[w.lower()] += 1

                 
res = []

for k, v in data.items():
    if v == 2:
        res.append(k)
        
print(*sorted(res, reverse=True), sep='; ')","Ошибка при обращении к незаданной переменной. Проверьте, что все Ваши переменные корректно заданы.","['open', 'closed', 'closed']","<Task description>: Роман изучает свой отчет по итогам поездки в Англию, где он описывал различные диалекты. Помогите определить диалекты английского языка, которые упоминаются ровно 2 раза.

ФОРМАТ ВВОДА
Текстовый файл dialects.txt, в котором записан отчет. Гарантируется, что в отчете только названия диалектов всегда записаны с большой буквы. При этом сами диалекты должны учитываться вне зависимости от регистра (например, ""Кардифф"" и ""КАРДиф"" должны считаться, как один диалект)
Гарантируется, что пустых строк в файле нет.
Гарантируется, что в файле будет упоминание хотя бы одного диалекта.
Также дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.
ФОРМАТ ВЫВОДА
Названия диалектов, которые упоминаются в отчете ровно два раза. 
Названия должны быть записаны в нижнем регистре в обратном алфавитном порядке через точку с запятой и пробел.
ДОПОЛНИТЕЛЬНО
В открытом тесте используется файл dialects.txt. Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Создайте пустой словарь, в который будете записывать диалекты и число их упоминаний.
Откройте файл в режиме чтения в кодировке utf-8.
Обратитесь к каждой строке в файле и выполните следующие действия:
уберите невидимые символы в конце строки (символ перехода на новую строку);
обратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;
разбейте строку по разделителю, в результате получите список;
обратитесь к каждому элементу в получившемся списке: если первая его буква — заглавная, тогда этот диалект и нужно проверить (не забудьте привести все буквы в диалекте к одному регистру):
если этого диалекта еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.
если такой диалект уже есть в словаре из п.1, то нужно увеличить его значение на 1.
После цикла создайте пустой список — в него нужно будет добавить названия тех диалектов, значение которых в словаре ровно 2.
Обратитесь к парам ключ-значение в словаре: если значение равно 2, то добавьте ключ в список из п.4.
Отсортируйте список в обратном алфавиту порядке и напечатайте его элементы через точку с запятой и пробел. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: nan 
<Вывод>: саффолк; кокни 
<Example 2>: 
<Тип теста 2>: closed 
<Ввод>: nan 
<Вывод>: манчестер; кардифф 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: nan 
<Вывод>: эссекс; сассекс; ольстер; ливерпуль; дублин 
<Решение студента>: punctuation = '!#$%&()*+,-–./:;<=>?@^_'

data = {}

with open('dialects.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].isupper():
                if w.lower() not in data:
                    data[w.lower()] = 1
                else:
                    data[w.lower()] += 1

                 

for k, v in data.items():
    if v == 2:
        res.append(k)
        
print(*sorted(res, reverse=True), sep='; ') 
<Идеальное решение>: punctuation = '!#$%&()*+,-–./:;<=>?@^_'

data = {}

with open('dialects.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].isupper():
                if w.lower() not in data:
                    data[w.lower()] = 1
                else:
                    data[w.lower()] += 1

                 
res = []

for k, v in data.items():
    if v == 2:
        res.append(k)
        
print(*sorted(res, reverse=True), sep='; ') 


<Комментарий эксперта>:"
267,568,35,"Роман изучает свой отчет по итогам поездки в Англию, где он описывал различные диалекты. Помогите определить диалекты английского языка, которые упоминаются ровно 2 раза.

ФОРМАТ ВВОДА
Текстовый файл dialects.txt, в котором записан отчет. Гарантируется, что в отчете только названия диалектов всегда записаны с большой буквы. При этом сами диалекты должны учитываться вне зависимости от регистра (например, ""Кардифф"" и ""КАРДиф"" должны считаться, как один диалект)
Гарантируется, что пустых строк в файле нет.
Гарантируется, что в файле будет упоминание хотя бы одного диалекта.
Также дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.
ФОРМАТ ВЫВОДА
Названия диалектов, которые упоминаются в отчете ровно два раза. 
Названия должны быть записаны в нижнем регистре в обратном алфавитном порядке через точку с запятой и пробел.
ДОПОЛНИТЕЛЬНО
В открытом тесте используется файл dialects.txt. Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Создайте пустой словарь, в который будете записывать диалекты и число их упоминаний.
Откройте файл в режиме чтения в кодировке utf-8.
Обратитесь к каждой строке в файле и выполните следующие действия:
уберите невидимые символы в конце строки (символ перехода на новую строку);
обратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;
разбейте строку по разделителю, в результате получите список;
обратитесь к каждому элементу в получившемся списке: если первая его буква — заглавная, тогда этот диалект и нужно проверить (не забудьте привести все буквы в диалекте к одному регистру):
если этого диалекта еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.
если такой диалект уже есть в словаре из п.1, то нужно увеличить его значение на 1.
После цикла создайте пустой список — в него нужно будет добавить названия тех диалектов, значение которых в словаре ровно 2.
Обратитесь к парам ключ-значение в словаре: если значение равно 2, то добавьте ключ в список из п.4.
Отсортируйте список в обратном алфавиту порядке и напечатайте его элементы через точку с запятой и пробел.","[nan, nan, nan]","['саффолк; кокни', 'манчестер; кардифф', 'эссекс; сассекс; ольстер; ливерпуль; дублин']","punctuation = '!#$%&()*+,-–./:;<=>?@^_'

data = {}

with open('dialects.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].isupper():
                if w.lower() not in data:
                    data[w.lower()] = 1
                else:
                    data[w.lower()] += 1

                 
res = []

for k, v in data:
    if v == 2:
        res.append(k)
        
print(*sorted(res, reverse=True), sep='; ')","punctuation = '!#$%&()*+,-–./:;<=>?@^_'

data = {}

with open('dialects.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].isupper():
                if w.lower() not in data:
                    data[w.lower()] = 1
                else:
                    data[w.lower()] += 1

                 
res = []

for k, v in data.items():
    if v == 2:
        res.append(k)
        
print(*sorted(res, reverse=True), sep='; ')","Ошибка при обращении к элементам словаря data. Попытка обратиться к двум значениям, вместо одного. Используйте опреатор .items().","['open', 'closed', 'closed']","<Task description>: Роман изучает свой отчет по итогам поездки в Англию, где он описывал различные диалекты. Помогите определить диалекты английского языка, которые упоминаются ровно 2 раза.

ФОРМАТ ВВОДА
Текстовый файл dialects.txt, в котором записан отчет. Гарантируется, что в отчете только названия диалектов всегда записаны с большой буквы. При этом сами диалекты должны учитываться вне зависимости от регистра (например, ""Кардифф"" и ""КАРДиф"" должны считаться, как один диалект)
Гарантируется, что пустых строк в файле нет.
Гарантируется, что в файле будет упоминание хотя бы одного диалекта.
Также дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.
ФОРМАТ ВЫВОДА
Названия диалектов, которые упоминаются в отчете ровно два раза. 
Названия должны быть записаны в нижнем регистре в обратном алфавитном порядке через точку с запятой и пробел.
ДОПОЛНИТЕЛЬНО
В открытом тесте используется файл dialects.txt. Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Создайте пустой словарь, в который будете записывать диалекты и число их упоминаний.
Откройте файл в режиме чтения в кодировке utf-8.
Обратитесь к каждой строке в файле и выполните следующие действия:
уберите невидимые символы в конце строки (символ перехода на новую строку);
обратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;
разбейте строку по разделителю, в результате получите список;
обратитесь к каждому элементу в получившемся списке: если первая его буква — заглавная, тогда этот диалект и нужно проверить (не забудьте привести все буквы в диалекте к одному регистру):
если этого диалекта еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.
если такой диалект уже есть в словаре из п.1, то нужно увеличить его значение на 1.
После цикла создайте пустой список — в него нужно будет добавить названия тех диалектов, значение которых в словаре ровно 2.
Обратитесь к парам ключ-значение в словаре: если значение равно 2, то добавьте ключ в список из п.4.
Отсортируйте список в обратном алфавиту порядке и напечатайте его элементы через точку с запятой и пробел. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: nan 
<Вывод>: саффолк; кокни 
<Example 2>: 
<Тип теста 2>: closed 
<Ввод>: nan 
<Вывод>: манчестер; кардифф 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: nan 
<Вывод>: эссекс; сассекс; ольстер; ливерпуль; дублин 
<Решение студента>: punctuation = '!#$%&()*+,-–./:;<=>?@^_'

data = {}

with open('dialects.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].isupper():
                if w.lower() not in data:
                    data[w.lower()] = 1
                else:
                    data[w.lower()] += 1

                 
res = []

for k, v in data:
    if v == 2:
        res.append(k)
        
print(*sorted(res, reverse=True), sep='; ') 
<Идеальное решение>: punctuation = '!#$%&()*+,-–./:;<=>?@^_'

data = {}

with open('dialects.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].isupper():
                if w.lower() not in data:
                    data[w.lower()] = 1
                else:
                    data[w.lower()] += 1

                 
res = []

for k, v in data.items():
    if v == 2:
        res.append(k)
        
print(*sorted(res, reverse=True), sep='; ') 


<Комментарий эксперта>:"
268,569,35,"Роман изучает свой отчет по итогам поездки в Англию, где он описывал различные диалекты. Помогите определить диалекты английского языка, которые упоминаются ровно 2 раза.

ФОРМАТ ВВОДА
Текстовый файл dialects.txt, в котором записан отчет. Гарантируется, что в отчете только названия диалектов всегда записаны с большой буквы. При этом сами диалекты должны учитываться вне зависимости от регистра (например, ""Кардифф"" и ""КАРДиф"" должны считаться, как один диалект)
Гарантируется, что пустых строк в файле нет.
Гарантируется, что в файле будет упоминание хотя бы одного диалекта.
Также дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.
ФОРМАТ ВЫВОДА
Названия диалектов, которые упоминаются в отчете ровно два раза. 
Названия должны быть записаны в нижнем регистре в обратном алфавитном порядке через точку с запятой и пробел.
ДОПОЛНИТЕЛЬНО
В открытом тесте используется файл dialects.txt. Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Создайте пустой словарь, в который будете записывать диалекты и число их упоминаний.
Откройте файл в режиме чтения в кодировке utf-8.
Обратитесь к каждой строке в файле и выполните следующие действия:
уберите невидимые символы в конце строки (символ перехода на новую строку);
обратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;
разбейте строку по разделителю, в результате получите список;
обратитесь к каждому элементу в получившемся списке: если первая его буква — заглавная, тогда этот диалект и нужно проверить (не забудьте привести все буквы в диалекте к одному регистру):
если этого диалекта еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.
если такой диалект уже есть в словаре из п.1, то нужно увеличить его значение на 1.
После цикла создайте пустой список — в него нужно будет добавить названия тех диалектов, значение которых в словаре ровно 2.
Обратитесь к парам ключ-значение в словаре: если значение равно 2, то добавьте ключ в список из п.4.
Отсортируйте список в обратном алфавиту порядке и напечатайте его элементы через точку с запятой и пробел.","[nan, nan, nan]","['саффолк; кокни', 'манчестер; кардифф', 'эссекс; сассекс; ольстер; ливерпуль; дублин']","punctuation = '!#$%&()*+,-–./:;<=>?@^_'

data = {}

with open('dialects.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].isupper():
                if w.lower() not in data:
                    data[w.lower()] = 1
                else:
                    data[w.lower()] += 1

                 
res = []

for k, v in data.items():
    if v = 2:
        res.append(k)
        
print(*sorted(res, reverse=True), sep='; ')","punctuation = '!#$%&()*+,-–./:;<=>?@^_'

data = {}

with open('dialects.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].isupper():
                if w.lower() not in data:
                    data[w.lower()] = 1
                else:
                    data[w.lower()] += 1

                 
res = []

for k, v in data.items():
    if v == 2:
        res.append(k)
        
print(*sorted(res, reverse=True), sep='; ')",Синтаксическая ошибка. При сравнении двух значений следует использовать знако двойного равенства.,"['open', 'closed', 'closed']","<Task description>: Роман изучает свой отчет по итогам поездки в Англию, где он описывал различные диалекты. Помогите определить диалекты английского языка, которые упоминаются ровно 2 раза.

ФОРМАТ ВВОДА
Текстовый файл dialects.txt, в котором записан отчет. Гарантируется, что в отчете только названия диалектов всегда записаны с большой буквы. При этом сами диалекты должны учитываться вне зависимости от регистра (например, ""Кардифф"" и ""КАРДиф"" должны считаться, как один диалект)
Гарантируется, что пустых строк в файле нет.
Гарантируется, что в файле будет упоминание хотя бы одного диалекта.
Также дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.
ФОРМАТ ВЫВОДА
Названия диалектов, которые упоминаются в отчете ровно два раза. 
Названия должны быть записаны в нижнем регистре в обратном алфавитном порядке через точку с запятой и пробел.
ДОПОЛНИТЕЛЬНО
В открытом тесте используется файл dialects.txt. Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Создайте пустой словарь, в который будете записывать диалекты и число их упоминаний.
Откройте файл в режиме чтения в кодировке utf-8.
Обратитесь к каждой строке в файле и выполните следующие действия:
уберите невидимые символы в конце строки (символ перехода на новую строку);
обратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;
разбейте строку по разделителю, в результате получите список;
обратитесь к каждому элементу в получившемся списке: если первая его буква — заглавная, тогда этот диалект и нужно проверить (не забудьте привести все буквы в диалекте к одному регистру):
если этого диалекта еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.
если такой диалект уже есть в словаре из п.1, то нужно увеличить его значение на 1.
После цикла создайте пустой список — в него нужно будет добавить названия тех диалектов, значение которых в словаре ровно 2.
Обратитесь к парам ключ-значение в словаре: если значение равно 2, то добавьте ключ в список из п.4.
Отсортируйте список в обратном алфавиту порядке и напечатайте его элементы через точку с запятой и пробел. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: nan 
<Вывод>: саффолк; кокни 
<Example 2>: 
<Тип теста 2>: closed 
<Ввод>: nan 
<Вывод>: манчестер; кардифф 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: nan 
<Вывод>: эссекс; сассекс; ольстер; ливерпуль; дублин 
<Решение студента>: punctuation = '!#$%&()*+,-–./:;<=>?@^_'

data = {}

with open('dialects.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].isupper():
                if w.lower() not in data:
                    data[w.lower()] = 1
                else:
                    data[w.lower()] += 1

                 
res = []

for k, v in data.items():
    if v = 2:
        res.append(k)
        
print(*sorted(res, reverse=True), sep='; ') 
<Идеальное решение>: punctuation = '!#$%&()*+,-–./:;<=>?@^_'

data = {}

with open('dialects.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].isupper():
                if w.lower() not in data:
                    data[w.lower()] = 1
                else:
                    data[w.lower()] += 1

                 
res = []

for k, v in data.items():
    if v == 2:
        res.append(k)
        
print(*sorted(res, reverse=True), sep='; ') 


<Комментарий эксперта>:"
269,570,35,"Роман изучает свой отчет по итогам поездки в Англию, где он описывал различные диалекты. Помогите определить диалекты английского языка, которые упоминаются ровно 2 раза.

ФОРМАТ ВВОДА
Текстовый файл dialects.txt, в котором записан отчет. Гарантируется, что в отчете только названия диалектов всегда записаны с большой буквы. При этом сами диалекты должны учитываться вне зависимости от регистра (например, ""Кардифф"" и ""КАРДиф"" должны считаться, как один диалект)
Гарантируется, что пустых строк в файле нет.
Гарантируется, что в файле будет упоминание хотя бы одного диалекта.
Также дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.
ФОРМАТ ВЫВОДА
Названия диалектов, которые упоминаются в отчете ровно два раза. 
Названия должны быть записаны в нижнем регистре в обратном алфавитном порядке через точку с запятой и пробел.
ДОПОЛНИТЕЛЬНО
В открытом тесте используется файл dialects.txt. Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Создайте пустой словарь, в который будете записывать диалекты и число их упоминаний.
Откройте файл в режиме чтения в кодировке utf-8.
Обратитесь к каждой строке в файле и выполните следующие действия:
уберите невидимые символы в конце строки (символ перехода на новую строку);
обратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;
разбейте строку по разделителю, в результате получите список;
обратитесь к каждому элементу в получившемся списке: если первая его буква — заглавная, тогда этот диалект и нужно проверить (не забудьте привести все буквы в диалекте к одному регистру):
если этого диалекта еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.
если такой диалект уже есть в словаре из п.1, то нужно увеличить его значение на 1.
После цикла создайте пустой список — в него нужно будет добавить названия тех диалектов, значение которых в словаре ровно 2.
Обратитесь к парам ключ-значение в словаре: если значение равно 2, то добавьте ключ в список из п.4.
Отсортируйте список в обратном алфавиту порядке и напечатайте его элементы через точку с запятой и пробел.","[nan, nan, nan]","['саффолк; кокни', 'манчестер; кардифф', 'эссекс; сассекс; ольстер; ливерпуль; дублин']","punctuation = '!#$%&()*+,-–./:;<=>?@^_'

data = {}

with open('dialects.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].isupper():
                if w.lower() not in data:
                    data[w.lower()] = 1
                else:
                    data[w.lower()] += 1

                 
res = []

for k, v in data.items():
    if k == 2:
        res.append(v)
        
print(*sorted(res, reverse=True), sep='; ')","punctuation = '!#$%&()*+,-–./:;<=>?@^_'

data = {}

with open('dialects.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].isupper():
                if w.lower() not in data:
                    data[w.lower()] = 1
                else:
                    data[w.lower()] += 1

                 
res = []

for k, v in data.items():
    if v == 2:
        res.append(k)
        
print(*sorted(res, reverse=True), sep='; ')","Ошибка в открытых и скрытых тестах. 

Ваш код некорректно работает с парами ключ-значение словаря data.","['open', 'closed', 'closed']","<Task description>: Роман изучает свой отчет по итогам поездки в Англию, где он описывал различные диалекты. Помогите определить диалекты английского языка, которые упоминаются ровно 2 раза.

ФОРМАТ ВВОДА
Текстовый файл dialects.txt, в котором записан отчет. Гарантируется, что в отчете только названия диалектов всегда записаны с большой буквы. При этом сами диалекты должны учитываться вне зависимости от регистра (например, ""Кардифф"" и ""КАРДиф"" должны считаться, как один диалект)
Гарантируется, что пустых строк в файле нет.
Гарантируется, что в файле будет упоминание хотя бы одного диалекта.
Также дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.
ФОРМАТ ВЫВОДА
Названия диалектов, которые упоминаются в отчете ровно два раза. 
Названия должны быть записаны в нижнем регистре в обратном алфавитном порядке через точку с запятой и пробел.
ДОПОЛНИТЕЛЬНО
В открытом тесте используется файл dialects.txt. Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Создайте пустой словарь, в который будете записывать диалекты и число их упоминаний.
Откройте файл в режиме чтения в кодировке utf-8.
Обратитесь к каждой строке в файле и выполните следующие действия:
уберите невидимые символы в конце строки (символ перехода на новую строку);
обратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;
разбейте строку по разделителю, в результате получите список;
обратитесь к каждому элементу в получившемся списке: если первая его буква — заглавная, тогда этот диалект и нужно проверить (не забудьте привести все буквы в диалекте к одному регистру):
если этого диалекта еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.
если такой диалект уже есть в словаре из п.1, то нужно увеличить его значение на 1.
После цикла создайте пустой список — в него нужно будет добавить названия тех диалектов, значение которых в словаре ровно 2.
Обратитесь к парам ключ-значение в словаре: если значение равно 2, то добавьте ключ в список из п.4.
Отсортируйте список в обратном алфавиту порядке и напечатайте его элементы через точку с запятой и пробел. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: nan 
<Вывод>: саффолк; кокни 
<Example 2>: 
<Тип теста 2>: closed 
<Ввод>: nan 
<Вывод>: манчестер; кардифф 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: nan 
<Вывод>: эссекс; сассекс; ольстер; ливерпуль; дублин 
<Решение студента>: punctuation = '!#$%&()*+,-–./:;<=>?@^_'

data = {}

with open('dialects.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].isupper():
                if w.lower() not in data:
                    data[w.lower()] = 1
                else:
                    data[w.lower()] += 1

                 
res = []

for k, v in data.items():
    if k == 2:
        res.append(v)
        
print(*sorted(res, reverse=True), sep='; ') 
<Идеальное решение>: punctuation = '!#$%&()*+,-–./:;<=>?@^_'

data = {}

with open('dialects.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].isupper():
                if w.lower() not in data:
                    data[w.lower()] = 1
                else:
                    data[w.lower()] += 1

                 
res = []

for k, v in data.items():
    if v == 2:
        res.append(k)
        
print(*sorted(res, reverse=True), sep='; ') 


<Комментарий эксперта>:"
270,571,35,"Роман изучает свой отчет по итогам поездки в Англию, где он описывал различные диалекты. Помогите определить диалекты английского языка, которые упоминаются ровно 2 раза.

ФОРМАТ ВВОДА
Текстовый файл dialects.txt, в котором записан отчет. Гарантируется, что в отчете только названия диалектов всегда записаны с большой буквы. При этом сами диалекты должны учитываться вне зависимости от регистра (например, ""Кардифф"" и ""КАРДиф"" должны считаться, как один диалект)
Гарантируется, что пустых строк в файле нет.
Гарантируется, что в файле будет упоминание хотя бы одного диалекта.
Также дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.
ФОРМАТ ВЫВОДА
Названия диалектов, которые упоминаются в отчете ровно два раза. 
Названия должны быть записаны в нижнем регистре в обратном алфавитном порядке через точку с запятой и пробел.
ДОПОЛНИТЕЛЬНО
В открытом тесте используется файл dialects.txt. Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Создайте пустой словарь, в который будете записывать диалекты и число их упоминаний.
Откройте файл в режиме чтения в кодировке utf-8.
Обратитесь к каждой строке в файле и выполните следующие действия:
уберите невидимые символы в конце строки (символ перехода на новую строку);
обратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;
разбейте строку по разделителю, в результате получите список;
обратитесь к каждому элементу в получившемся списке: если первая его буква — заглавная, тогда этот диалект и нужно проверить (не забудьте привести все буквы в диалекте к одному регистру):
если этого диалекта еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.
если такой диалект уже есть в словаре из п.1, то нужно увеличить его значение на 1.
После цикла создайте пустой список — в него нужно будет добавить названия тех диалектов, значение которых в словаре ровно 2.
Обратитесь к парам ключ-значение в словаре: если значение равно 2, то добавьте ключ в список из п.4.
Отсортируйте список в обратном алфавиту порядке и напечатайте его элементы через точку с запятой и пробел.","[nan, nan, nan]","['саффолк; кокни', 'манчестер; кардифф', 'эссекс; сассекс; ольстер; ливерпуль; дублин']","punctuation = '!#$%&()*+,-–./:;<=>?@^_'

data = {}

with open('dialects.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].isupper():
                if w.lower() not in data:
                    data[w.lower()] = 1
                else:
                    data[w.lower()] += 1

                 
res = []

for k, v in data.items():
    if v >= 2:
        res.append(k)
        
print(*sorted(res, reverse=True), sep='; ')","punctuation = '!#$%&()*+,-–./:;<=>?@^_'

data = {}

with open('dialects.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].isupper():
                if w.lower() not in data:
                    data[w.lower()] = 1
                else:
                    data[w.lower()] += 1

                 
res = []

for k, v in data.items():
    if v == 2:
        res.append(k)
        
print(*sorted(res, reverse=True), sep='; ')","Ошибка в открытых и скрытых тестах. 

Ваш код некорректно выполняет условия задания. Например, он некорректно выполняет условие ""выведите названия диалектов, которые упоминаются в отчете ровно два раза"". Попробуйте изменить print(), чтобы скорректировать ошибку.","['open', 'closed', 'closed']","<Task description>: Роман изучает свой отчет по итогам поездки в Англию, где он описывал различные диалекты. Помогите определить диалекты английского языка, которые упоминаются ровно 2 раза.

ФОРМАТ ВВОДА
Текстовый файл dialects.txt, в котором записан отчет. Гарантируется, что в отчете только названия диалектов всегда записаны с большой буквы. При этом сами диалекты должны учитываться вне зависимости от регистра (например, ""Кардифф"" и ""КАРДиф"" должны считаться, как один диалект)
Гарантируется, что пустых строк в файле нет.
Гарантируется, что в файле будет упоминание хотя бы одного диалекта.
Также дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.
ФОРМАТ ВЫВОДА
Названия диалектов, которые упоминаются в отчете ровно два раза. 
Названия должны быть записаны в нижнем регистре в обратном алфавитном порядке через точку с запятой и пробел.
ДОПОЛНИТЕЛЬНО
В открытом тесте используется файл dialects.txt. Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Создайте пустой словарь, в который будете записывать диалекты и число их упоминаний.
Откройте файл в режиме чтения в кодировке utf-8.
Обратитесь к каждой строке в файле и выполните следующие действия:
уберите невидимые символы в конце строки (символ перехода на новую строку);
обратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;
разбейте строку по разделителю, в результате получите список;
обратитесь к каждому элементу в получившемся списке: если первая его буква — заглавная, тогда этот диалект и нужно проверить (не забудьте привести все буквы в диалекте к одному регистру):
если этого диалекта еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.
если такой диалект уже есть в словаре из п.1, то нужно увеличить его значение на 1.
После цикла создайте пустой список — в него нужно будет добавить названия тех диалектов, значение которых в словаре ровно 2.
Обратитесь к парам ключ-значение в словаре: если значение равно 2, то добавьте ключ в список из п.4.
Отсортируйте список в обратном алфавиту порядке и напечатайте его элементы через точку с запятой и пробел. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: nan 
<Вывод>: саффолк; кокни 
<Example 2>: 
<Тип теста 2>: closed 
<Ввод>: nan 
<Вывод>: манчестер; кардифф 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: nan 
<Вывод>: эссекс; сассекс; ольстер; ливерпуль; дублин 
<Решение студента>: punctuation = '!#$%&()*+,-–./:;<=>?@^_'

data = {}

with open('dialects.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].isupper():
                if w.lower() not in data:
                    data[w.lower()] = 1
                else:
                    data[w.lower()] += 1

                 
res = []

for k, v in data.items():
    if v >= 2:
        res.append(k)
        
print(*sorted(res, reverse=True), sep='; ') 
<Идеальное решение>: punctuation = '!#$%&()*+,-–./:;<=>?@^_'

data = {}

with open('dialects.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].isupper():
                if w.lower() not in data:
                    data[w.lower()] = 1
                else:
                    data[w.lower()] += 1

                 
res = []

for k, v in data.items():
    if v == 2:
        res.append(k)
        
print(*sorted(res, reverse=True), sep='; ') 


<Комментарий эксперта>:"
271,572,35,"Роман изучает свой отчет по итогам поездки в Англию, где он описывал различные диалекты. Помогите определить диалекты английского языка, которые упоминаются ровно 2 раза.

ФОРМАТ ВВОДА
Текстовый файл dialects.txt, в котором записан отчет. Гарантируется, что в отчете только названия диалектов всегда записаны с большой буквы. При этом сами диалекты должны учитываться вне зависимости от регистра (например, ""Кардифф"" и ""КАРДиф"" должны считаться, как один диалект)
Гарантируется, что пустых строк в файле нет.
Гарантируется, что в файле будет упоминание хотя бы одного диалекта.
Также дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.
ФОРМАТ ВЫВОДА
Названия диалектов, которые упоминаются в отчете ровно два раза. 
Названия должны быть записаны в нижнем регистре в обратном алфавитном порядке через точку с запятой и пробел.
ДОПОЛНИТЕЛЬНО
В открытом тесте используется файл dialects.txt. Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Создайте пустой словарь, в который будете записывать диалекты и число их упоминаний.
Откройте файл в режиме чтения в кодировке utf-8.
Обратитесь к каждой строке в файле и выполните следующие действия:
уберите невидимые символы в конце строки (символ перехода на новую строку);
обратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;
разбейте строку по разделителю, в результате получите список;
обратитесь к каждому элементу в получившемся списке: если первая его буква — заглавная, тогда этот диалект и нужно проверить (не забудьте привести все буквы в диалекте к одному регистру):
если этого диалекта еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.
если такой диалект уже есть в словаре из п.1, то нужно увеличить его значение на 1.
После цикла создайте пустой список — в него нужно будет добавить названия тех диалектов, значение которых в словаре ровно 2.
Обратитесь к парам ключ-значение в словаре: если значение равно 2, то добавьте ключ в список из п.4.
Отсортируйте список в обратном алфавиту порядке и напечатайте его элементы через точку с запятой и пробел.","[nan, nan, nan]","['саффолк; кокни', 'манчестер; кардифф', 'эссекс; сассекс; ольстер; ливерпуль; дублин']","punctuation = '!#$%&()*+,-–./:;<=>?@^_'

data = {}

with open('dialects.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].isupper():
                if w.lower() not in data:
                    data[w.lower()] = 1
                else:
                    data[w.lower()] += 1

                 
res = []

for k, v in data.items():
    if v == 2:
        res.append(k)
        
print(*res)","punctuation = '!#$%&()*+,-–./:;<=>?@^_'

data = {}

with open('dialects.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].isupper():
                if w.lower() not in data:
                    data[w.lower()] = 1
                else:
                    data[w.lower()] += 1

                 
res = []

for k, v in data.items():
    if v == 2:
        res.append(k)
        
print(*sorted(res, reverse=True), sep='; ')","Ошибка в открытых и скрытых тестах. 

Ваш код некорректно выполняет условия задания. Например, он некорректно выполняет условие ""названия должны быть записаны в нижнем регистре в обратном алфавитном порядке через точку с запятой и пробел"". Попробуйте изменить print(), чтобы скорректировать ошибку.","['open', 'closed', 'closed']","<Task description>: Роман изучает свой отчет по итогам поездки в Англию, где он описывал различные диалекты. Помогите определить диалекты английского языка, которые упоминаются ровно 2 раза.

ФОРМАТ ВВОДА
Текстовый файл dialects.txt, в котором записан отчет. Гарантируется, что в отчете только названия диалектов всегда записаны с большой буквы. При этом сами диалекты должны учитываться вне зависимости от регистра (например, ""Кардифф"" и ""КАРДиф"" должны считаться, как один диалект)
Гарантируется, что пустых строк в файле нет.
Гарантируется, что в файле будет упоминание хотя бы одного диалекта.
Также дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.
ФОРМАТ ВЫВОДА
Названия диалектов, которые упоминаются в отчете ровно два раза. 
Названия должны быть записаны в нижнем регистре в обратном алфавитном порядке через точку с запятой и пробел.
ДОПОЛНИТЕЛЬНО
В открытом тесте используется файл dialects.txt. Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Создайте пустой словарь, в который будете записывать диалекты и число их упоминаний.
Откройте файл в режиме чтения в кодировке utf-8.
Обратитесь к каждой строке в файле и выполните следующие действия:
уберите невидимые символы в конце строки (символ перехода на новую строку);
обратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;
разбейте строку по разделителю, в результате получите список;
обратитесь к каждому элементу в получившемся списке: если первая его буква — заглавная, тогда этот диалект и нужно проверить (не забудьте привести все буквы в диалекте к одному регистру):
если этого диалекта еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.
если такой диалект уже есть в словаре из п.1, то нужно увеличить его значение на 1.
После цикла создайте пустой список — в него нужно будет добавить названия тех диалектов, значение которых в словаре ровно 2.
Обратитесь к парам ключ-значение в словаре: если значение равно 2, то добавьте ключ в список из п.4.
Отсортируйте список в обратном алфавиту порядке и напечатайте его элементы через точку с запятой и пробел. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: nan 
<Вывод>: саффолк; кокни 
<Example 2>: 
<Тип теста 2>: closed 
<Ввод>: nan 
<Вывод>: манчестер; кардифф 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: nan 
<Вывод>: эссекс; сассекс; ольстер; ливерпуль; дублин 
<Решение студента>: punctuation = '!#$%&()*+,-–./:;<=>?@^_'

data = {}

with open('dialects.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].isupper():
                if w.lower() not in data:
                    data[w.lower()] = 1
                else:
                    data[w.lower()] += 1

                 
res = []

for k, v in data.items():
    if v == 2:
        res.append(k)
        
print(*res) 
<Идеальное решение>: punctuation = '!#$%&()*+,-–./:;<=>?@^_'

data = {}

with open('dialects.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].isupper():
                if w.lower() not in data:
                    data[w.lower()] = 1
                else:
                    data[w.lower()] += 1

                 
res = []

for k, v in data.items():
    if v == 2:
        res.append(k)
        
print(*sorted(res, reverse=True), sep='; ') 


<Комментарий эксперта>:"
272,573,35,"Роман изучает свой отчет по итогам поездки в Англию, где он описывал различные диалекты. Помогите определить диалекты английского языка, которые упоминаются ровно 2 раза.

ФОРМАТ ВВОДА
Текстовый файл dialects.txt, в котором записан отчет. Гарантируется, что в отчете только названия диалектов всегда записаны с большой буквы. При этом сами диалекты должны учитываться вне зависимости от регистра (например, ""Кардифф"" и ""КАРДиф"" должны считаться, как один диалект)
Гарантируется, что пустых строк в файле нет.
Гарантируется, что в файле будет упоминание хотя бы одного диалекта.
Также дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.
ФОРМАТ ВЫВОДА
Названия диалектов, которые упоминаются в отчете ровно два раза. 
Названия должны быть записаны в нижнем регистре в обратном алфавитном порядке через точку с запятой и пробел.
ДОПОЛНИТЕЛЬНО
В открытом тесте используется файл dialects.txt. Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Создайте пустой словарь, в который будете записывать диалекты и число их упоминаний.
Откройте файл в режиме чтения в кодировке utf-8.
Обратитесь к каждой строке в файле и выполните следующие действия:
уберите невидимые символы в конце строки (символ перехода на новую строку);
обратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;
разбейте строку по разделителю, в результате получите список;
обратитесь к каждому элементу в получившемся списке: если первая его буква — заглавная, тогда этот диалект и нужно проверить (не забудьте привести все буквы в диалекте к одному регистру):
если этого диалекта еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.
если такой диалект уже есть в словаре из п.1, то нужно увеличить его значение на 1.
После цикла создайте пустой список — в него нужно будет добавить названия тех диалектов, значение которых в словаре ровно 2.
Обратитесь к парам ключ-значение в словаре: если значение равно 2, то добавьте ключ в список из п.4.
Отсортируйте список в обратном алфавиту порядке и напечатайте его элементы через точку с запятой и пробел.","[nan, nan, nan]","['саффолк; кокни', 'манчестер; кардифф', 'эссекс; сассекс; ольстер; ливерпуль; дублин']","punctuation = '!#$%&()*+,-–./:;<=>?@^_'

data = {}

with open('dialects.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].isupper():
                if w.lower() not in data:
                    data[w.lower()] = 1
                else:
                    data[w.lower()] += 1

                 
res = []

for k, v in data.items():
    if v == 2:
        res.append(k)
        
print(*sorted(res)","punctuation = '!#$%&()*+,-–./:;<=>?@^_'

data = {}

with open('dialects.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].isupper():
                if w.lower() not in data:
                    data[w.lower()] = 1
                else:
                    data[w.lower()] += 1

                 
res = []

for k, v in data.items():
    if v == 2:
        res.append(k)
        
print(*sorted(res, reverse=True), sep='; ')","Ошибка в открытых и скрытых тестах. 

Ваш код некорректно выполняет условия задания. Например, он некорректно выполняет условие ""названия должны быть записаны в нижнем регистре в обратном алфавитном порядке через точку с запятой и пробел"". Попробуйте изменить print(), чтобы скорректировать ошибку.","['open', 'closed', 'closed']","<Task description>: Роман изучает свой отчет по итогам поездки в Англию, где он описывал различные диалекты. Помогите определить диалекты английского языка, которые упоминаются ровно 2 раза.

ФОРМАТ ВВОДА
Текстовый файл dialects.txt, в котором записан отчет. Гарантируется, что в отчете только названия диалектов всегда записаны с большой буквы. При этом сами диалекты должны учитываться вне зависимости от регистра (например, ""Кардифф"" и ""КАРДиф"" должны считаться, как один диалект)
Гарантируется, что пустых строк в файле нет.
Гарантируется, что в файле будет упоминание хотя бы одного диалекта.
Также дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.
ФОРМАТ ВЫВОДА
Названия диалектов, которые упоминаются в отчете ровно два раза. 
Названия должны быть записаны в нижнем регистре в обратном алфавитном порядке через точку с запятой и пробел.
ДОПОЛНИТЕЛЬНО
В открытом тесте используется файл dialects.txt. Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Создайте пустой словарь, в который будете записывать диалекты и число их упоминаний.
Откройте файл в режиме чтения в кодировке utf-8.
Обратитесь к каждой строке в файле и выполните следующие действия:
уберите невидимые символы в конце строки (символ перехода на новую строку);
обратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;
разбейте строку по разделителю, в результате получите список;
обратитесь к каждому элементу в получившемся списке: если первая его буква — заглавная, тогда этот диалект и нужно проверить (не забудьте привести все буквы в диалекте к одному регистру):
если этого диалекта еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.
если такой диалект уже есть в словаре из п.1, то нужно увеличить его значение на 1.
После цикла создайте пустой список — в него нужно будет добавить названия тех диалектов, значение которых в словаре ровно 2.
Обратитесь к парам ключ-значение в словаре: если значение равно 2, то добавьте ключ в список из п.4.
Отсортируйте список в обратном алфавиту порядке и напечатайте его элементы через точку с запятой и пробел. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: nan 
<Вывод>: саффолк; кокни 
<Example 2>: 
<Тип теста 2>: closed 
<Ввод>: nan 
<Вывод>: манчестер; кардифф 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: nan 
<Вывод>: эссекс; сассекс; ольстер; ливерпуль; дублин 
<Решение студента>: punctuation = '!#$%&()*+,-–./:;<=>?@^_'

data = {}

with open('dialects.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].isupper():
                if w.lower() not in data:
                    data[w.lower()] = 1
                else:
                    data[w.lower()] += 1

                 
res = []

for k, v in data.items():
    if v == 2:
        res.append(k)
        
print(*sorted(res) 
<Идеальное решение>: punctuation = '!#$%&()*+,-–./:;<=>?@^_'

data = {}

with open('dialects.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].isupper():
                if w.lower() not in data:
                    data[w.lower()] = 1
                else:
                    data[w.lower()] += 1

                 
res = []

for k, v in data.items():
    if v == 2:
        res.append(k)
        
print(*sorted(res, reverse=True), sep='; ') 


<Комментарий эксперта>:"
273,574,35,"Роман изучает свой отчет по итогам поездки в Англию, где он описывал различные диалекты. Помогите определить диалекты английского языка, которые упоминаются ровно 2 раза.

ФОРМАТ ВВОДА
Текстовый файл dialects.txt, в котором записан отчет. Гарантируется, что в отчете только названия диалектов всегда записаны с большой буквы. При этом сами диалекты должны учитываться вне зависимости от регистра (например, ""Кардифф"" и ""КАРДиф"" должны считаться, как один диалект)
Гарантируется, что пустых строк в файле нет.
Гарантируется, что в файле будет упоминание хотя бы одного диалекта.
Также дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.
ФОРМАТ ВЫВОДА
Названия диалектов, которые упоминаются в отчете ровно два раза. 
Названия должны быть записаны в нижнем регистре в обратном алфавитном порядке через точку с запятой и пробел.
ДОПОЛНИТЕЛЬНО
В открытом тесте используется файл dialects.txt. Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Создайте пустой словарь, в который будете записывать диалекты и число их упоминаний.
Откройте файл в режиме чтения в кодировке utf-8.
Обратитесь к каждой строке в файле и выполните следующие действия:
уберите невидимые символы в конце строки (символ перехода на новую строку);
обратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;
разбейте строку по разделителю, в результате получите список;
обратитесь к каждому элементу в получившемся списке: если первая его буква — заглавная, тогда этот диалект и нужно проверить (не забудьте привести все буквы в диалекте к одному регистру):
если этого диалекта еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.
если такой диалект уже есть в словаре из п.1, то нужно увеличить его значение на 1.
После цикла создайте пустой список — в него нужно будет добавить названия тех диалектов, значение которых в словаре ровно 2.
Обратитесь к парам ключ-значение в словаре: если значение равно 2, то добавьте ключ в список из п.4.
Отсортируйте список в обратном алфавиту порядке и напечатайте его элементы через точку с запятой и пробел.","[nan, nan, nan]","['саффолк; кокни', 'манчестер; кардифф', 'эссекс; сассекс; ольстер; ливерпуль; дублин']","punctuation = '!#$%&()*+,-–./:;<=>?@^_'

data = {}

with open('dialects.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].isupper():
                if w.lower() not in data:
                    data[w.lower()] = 1
                else:
                    data[w.lower()] += 1

                 
res = []

for k, v in data.items():
    if v == 2:
        res.append(k)
        
print(*sorted(res), sep='; ')","punctuation = '!#$%&()*+,-–./:;<=>?@^_'

data = {}

with open('dialects.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].isupper():
                if w.lower() not in data:
                    data[w.lower()] = 1
                else:
                    data[w.lower()] += 1

                 
res = []

for k, v in data.items():
    if v == 2:
        res.append(k)
        
print(*sorted(res, reverse=True), sep='; ')","Ошибка в открытых и скрытых тестах. 

Ваш код некорректно выполняет условия задания. Например, он некорректно выполняет условие ""названия должны быть записаны в нижнем регистре в обратном алфавитном порядке через точку с запятой и пробел"". Попробуйте изменить print(), чтобы скорректировать ошибку.","['open', 'closed', 'closed']","<Task description>: Роман изучает свой отчет по итогам поездки в Англию, где он описывал различные диалекты. Помогите определить диалекты английского языка, которые упоминаются ровно 2 раза.

ФОРМАТ ВВОДА
Текстовый файл dialects.txt, в котором записан отчет. Гарантируется, что в отчете только названия диалектов всегда записаны с большой буквы. При этом сами диалекты должны учитываться вне зависимости от регистра (например, ""Кардифф"" и ""КАРДиф"" должны считаться, как один диалект)
Гарантируется, что пустых строк в файле нет.
Гарантируется, что в файле будет упоминание хотя бы одного диалекта.
Также дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.
ФОРМАТ ВЫВОДА
Названия диалектов, которые упоминаются в отчете ровно два раза. 
Названия должны быть записаны в нижнем регистре в обратном алфавитном порядке через точку с запятой и пробел.
ДОПОЛНИТЕЛЬНО
В открытом тесте используется файл dialects.txt. Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Создайте пустой словарь, в который будете записывать диалекты и число их упоминаний.
Откройте файл в режиме чтения в кодировке utf-8.
Обратитесь к каждой строке в файле и выполните следующие действия:
уберите невидимые символы в конце строки (символ перехода на новую строку);
обратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;
разбейте строку по разделителю, в результате получите список;
обратитесь к каждому элементу в получившемся списке: если первая его буква — заглавная, тогда этот диалект и нужно проверить (не забудьте привести все буквы в диалекте к одному регистру):
если этого диалекта еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.
если такой диалект уже есть в словаре из п.1, то нужно увеличить его значение на 1.
После цикла создайте пустой список — в него нужно будет добавить названия тех диалектов, значение которых в словаре ровно 2.
Обратитесь к парам ключ-значение в словаре: если значение равно 2, то добавьте ключ в список из п.4.
Отсортируйте список в обратном алфавиту порядке и напечатайте его элементы через точку с запятой и пробел. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: nan 
<Вывод>: саффолк; кокни 
<Example 2>: 
<Тип теста 2>: closed 
<Ввод>: nan 
<Вывод>: манчестер; кардифф 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: nan 
<Вывод>: эссекс; сассекс; ольстер; ливерпуль; дублин 
<Решение студента>: punctuation = '!#$%&()*+,-–./:;<=>?@^_'

data = {}

with open('dialects.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].isupper():
                if w.lower() not in data:
                    data[w.lower()] = 1
                else:
                    data[w.lower()] += 1

                 
res = []

for k, v in data.items():
    if v == 2:
        res.append(k)
        
print(*sorted(res), sep='; ') 
<Идеальное решение>: punctuation = '!#$%&()*+,-–./:;<=>?@^_'

data = {}

with open('dialects.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].isupper():
                if w.lower() not in data:
                    data[w.lower()] = 1
                else:
                    data[w.lower()] += 1

                 
res = []

for k, v in data.items():
    if v == 2:
        res.append(k)
        
print(*sorted(res, reverse=True), sep='; ') 


<Комментарий эксперта>:"
274,575,35,"Роман изучает свой отчет по итогам поездки в Англию, где он описывал различные диалекты. Помогите определить диалекты английского языка, которые упоминаются ровно 2 раза.

ФОРМАТ ВВОДА
Текстовый файл dialects.txt, в котором записан отчет. Гарантируется, что в отчете только названия диалектов всегда записаны с большой буквы. При этом сами диалекты должны учитываться вне зависимости от регистра (например, ""Кардифф"" и ""КАРДиф"" должны считаться, как один диалект)
Гарантируется, что пустых строк в файле нет.
Гарантируется, что в файле будет упоминание хотя бы одного диалекта.
Также дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.
ФОРМАТ ВЫВОДА
Названия диалектов, которые упоминаются в отчете ровно два раза. 
Названия должны быть записаны в нижнем регистре в обратном алфавитном порядке через точку с запятой и пробел.
ДОПОЛНИТЕЛЬНО
В открытом тесте используется файл dialects.txt. Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Создайте пустой словарь, в который будете записывать диалекты и число их упоминаний.
Откройте файл в режиме чтения в кодировке utf-8.
Обратитесь к каждой строке в файле и выполните следующие действия:
уберите невидимые символы в конце строки (символ перехода на новую строку);
обратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;
разбейте строку по разделителю, в результате получите список;
обратитесь к каждому элементу в получившемся списке: если первая его буква — заглавная, тогда этот диалект и нужно проверить (не забудьте привести все буквы в диалекте к одному регистру):
если этого диалекта еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.
если такой диалект уже есть в словаре из п.1, то нужно увеличить его значение на 1.
После цикла создайте пустой список — в него нужно будет добавить названия тех диалектов, значение которых в словаре ровно 2.
Обратитесь к парам ключ-значение в словаре: если значение равно 2, то добавьте ключ в список из п.4.
Отсортируйте список в обратном алфавиту порядке и напечатайте его элементы через точку с запятой и пробел.","[nan, nan, nan]","['саффолк; кокни', 'манчестер; кардифф', 'эссекс; сассекс; ольстер; ливерпуль; дублин']","punctuation = '!#$%&()*+,-–./:;<=>?@^_'

data = {}

with open('dialects.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].isupper():
                if w.lower() not in data:
                    data[w.lower()] = 1
                else:
                    data[w.lower()] += 1

                 
res = []

for k, v in data.items():
    if v == 2:
        res.append(k)
        
print(*sorted(res, reverse=True))","punctuation = '!#$%&()*+,-–./:;<=>?@^_'

data = {}

with open('dialects.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].isupper():
                if w.lower() not in data:
                    data[w.lower()] = 1
                else:
                    data[w.lower()] += 1

                 
res = []

for k, v in data.items():
    if v == 2:
        res.append(k)
        
print(*sorted(res, reverse=True), sep='; ')","Ошибка в открытых и скрытых тестах. 

Ваш код некорректно выполняет условия задания. Например, он некорректно выполняет условие ""названия должны быть записаны в нижнем регистре в обратном алфавитном порядке через точку с запятой и пробел"". Попробуйте изменить print(), чтобы скорректировать ошибку.","['open', 'closed', 'closed']","<Task description>: Роман изучает свой отчет по итогам поездки в Англию, где он описывал различные диалекты. Помогите определить диалекты английского языка, которые упоминаются ровно 2 раза.

ФОРМАТ ВВОДА
Текстовый файл dialects.txt, в котором записан отчет. Гарантируется, что в отчете только названия диалектов всегда записаны с большой буквы. При этом сами диалекты должны учитываться вне зависимости от регистра (например, ""Кардифф"" и ""КАРДиф"" должны считаться, как один диалект)
Гарантируется, что пустых строк в файле нет.
Гарантируется, что в файле будет упоминание хотя бы одного диалекта.
Также дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.
ФОРМАТ ВЫВОДА
Названия диалектов, которые упоминаются в отчете ровно два раза. 
Названия должны быть записаны в нижнем регистре в обратном алфавитном порядке через точку с запятой и пробел.
ДОПОЛНИТЕЛЬНО
В открытом тесте используется файл dialects.txt. Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Создайте пустой словарь, в который будете записывать диалекты и число их упоминаний.
Откройте файл в режиме чтения в кодировке utf-8.
Обратитесь к каждой строке в файле и выполните следующие действия:
уберите невидимые символы в конце строки (символ перехода на новую строку);
обратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;
разбейте строку по разделителю, в результате получите список;
обратитесь к каждому элементу в получившемся списке: если первая его буква — заглавная, тогда этот диалект и нужно проверить (не забудьте привести все буквы в диалекте к одному регистру):
если этого диалекта еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.
если такой диалект уже есть в словаре из п.1, то нужно увеличить его значение на 1.
После цикла создайте пустой список — в него нужно будет добавить названия тех диалектов, значение которых в словаре ровно 2.
Обратитесь к парам ключ-значение в словаре: если значение равно 2, то добавьте ключ в список из п.4.
Отсортируйте список в обратном алфавиту порядке и напечатайте его элементы через точку с запятой и пробел. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: nan 
<Вывод>: саффолк; кокни 
<Example 2>: 
<Тип теста 2>: closed 
<Ввод>: nan 
<Вывод>: манчестер; кардифф 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: nan 
<Вывод>: эссекс; сассекс; ольстер; ливерпуль; дублин 
<Решение студента>: punctuation = '!#$%&()*+,-–./:;<=>?@^_'

data = {}

with open('dialects.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].isupper():
                if w.lower() not in data:
                    data[w.lower()] = 1
                else:
                    data[w.lower()] += 1

                 
res = []

for k, v in data.items():
    if v == 2:
        res.append(k)
        
print(*sorted(res, reverse=True)) 
<Идеальное решение>: punctuation = '!#$%&()*+,-–./:;<=>?@^_'

data = {}

with open('dialects.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].isupper():
                if w.lower() not in data:
                    data[w.lower()] = 1
                else:
                    data[w.lower()] += 1

                 
res = []

for k, v in data.items():
    if v == 2:
        res.append(k)
        
print(*sorted(res, reverse=True), sep='; ') 


<Комментарий эксперта>:"
275,576,35,"Роман изучает свой отчет по итогам поездки в Англию, где он описывал различные диалекты. Помогите определить диалекты английского языка, которые упоминаются ровно 2 раза.

ФОРМАТ ВВОДА
Текстовый файл dialects.txt, в котором записан отчет. Гарантируется, что в отчете только названия диалектов всегда записаны с большой буквы. При этом сами диалекты должны учитываться вне зависимости от регистра (например, ""Кардифф"" и ""КАРДиф"" должны считаться, как один диалект)
Гарантируется, что пустых строк в файле нет.
Гарантируется, что в файле будет упоминание хотя бы одного диалекта.
Также дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.
ФОРМАТ ВЫВОДА
Названия диалектов, которые упоминаются в отчете ровно два раза. 
Названия должны быть записаны в нижнем регистре в обратном алфавитном порядке через точку с запятой и пробел.
ДОПОЛНИТЕЛЬНО
В открытом тесте используется файл dialects.txt. Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Создайте пустой словарь, в который будете записывать диалекты и число их упоминаний.
Откройте файл в режиме чтения в кодировке utf-8.
Обратитесь к каждой строке в файле и выполните следующие действия:
уберите невидимые символы в конце строки (символ перехода на новую строку);
обратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;
разбейте строку по разделителю, в результате получите список;
обратитесь к каждому элементу в получившемся списке: если первая его буква — заглавная, тогда этот диалект и нужно проверить (не забудьте привести все буквы в диалекте к одному регистру):
если этого диалекта еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.
если такой диалект уже есть в словаре из п.1, то нужно увеличить его значение на 1.
После цикла создайте пустой список — в него нужно будет добавить названия тех диалектов, значение которых в словаре ровно 2.
Обратитесь к парам ключ-значение в словаре: если значение равно 2, то добавьте ключ в список из п.4.
Отсортируйте список в обратном алфавиту порядке и напечатайте его элементы через точку с запятой и пробел.","[nan, nan, nan]","['саффолк; кокни', 'манчестер; кардифф', 'эссекс; сассекс; ольстер; ливерпуль; дублин']","punctuation = '!#$%&()*+,-–./:;<=>?@^_'

data = {}

with open('dialects.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].isupper():
                if w.lower() not in data:
                    data[w.lower()] = 1
                else:
                    data[w.lower()] += 1

                 
res = []

for k, v in data.items():
    if v == 2:
        res.append(k)
        
print(*sorted(res, reverse=true), sep='; ')","punctuation = '!#$%&()*+,-–./:;<=>?@^_'

data = {}

with open('dialects.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].isupper():
                if w.lower() not in data:
                    data[w.lower()] = 1
                else:
                    data[w.lower()] += 1

                 
res = []

for k, v in data.items():
    if v == 2:
        res.append(k)
        
print(*sorted(res, reverse=True), sep='; ')",Синтаксическая ошибка. Обратите внимание на синтаксис булевых значений.,"['open', 'closed', 'closed']","<Task description>: Роман изучает свой отчет по итогам поездки в Англию, где он описывал различные диалекты. Помогите определить диалекты английского языка, которые упоминаются ровно 2 раза.

ФОРМАТ ВВОДА
Текстовый файл dialects.txt, в котором записан отчет. Гарантируется, что в отчете только названия диалектов всегда записаны с большой буквы. При этом сами диалекты должны учитываться вне зависимости от регистра (например, ""Кардифф"" и ""КАРДиф"" должны считаться, как один диалект)
Гарантируется, что пустых строк в файле нет.
Гарантируется, что в файле будет упоминание хотя бы одного диалекта.
Также дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.
ФОРМАТ ВЫВОДА
Названия диалектов, которые упоминаются в отчете ровно два раза. 
Названия должны быть записаны в нижнем регистре в обратном алфавитном порядке через точку с запятой и пробел.
ДОПОЛНИТЕЛЬНО
В открытом тесте используется файл dialects.txt. Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Создайте пустой словарь, в который будете записывать диалекты и число их упоминаний.
Откройте файл в режиме чтения в кодировке utf-8.
Обратитесь к каждой строке в файле и выполните следующие действия:
уберите невидимые символы в конце строки (символ перехода на новую строку);
обратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;
разбейте строку по разделителю, в результате получите список;
обратитесь к каждому элементу в получившемся списке: если первая его буква — заглавная, тогда этот диалект и нужно проверить (не забудьте привести все буквы в диалекте к одному регистру):
если этого диалекта еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.
если такой диалект уже есть в словаре из п.1, то нужно увеличить его значение на 1.
После цикла создайте пустой список — в него нужно будет добавить названия тех диалектов, значение которых в словаре ровно 2.
Обратитесь к парам ключ-значение в словаре: если значение равно 2, то добавьте ключ в список из п.4.
Отсортируйте список в обратном алфавиту порядке и напечатайте его элементы через точку с запятой и пробел. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: nan 
<Вывод>: саффолк; кокни 
<Example 2>: 
<Тип теста 2>: closed 
<Ввод>: nan 
<Вывод>: манчестер; кардифф 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: nan 
<Вывод>: эссекс; сассекс; ольстер; ливерпуль; дублин 
<Решение студента>: punctuation = '!#$%&()*+,-–./:;<=>?@^_'

data = {}

with open('dialects.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].isupper():
                if w.lower() not in data:
                    data[w.lower()] = 1
                else:
                    data[w.lower()] += 1

                 
res = []

for k, v in data.items():
    if v == 2:
        res.append(k)
        
print(*sorted(res, reverse=true), sep='; ') 
<Идеальное решение>: punctuation = '!#$%&()*+,-–./:;<=>?@^_'

data = {}

with open('dialects.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0].isupper():
                if w.lower() not in data:
                    data[w.lower()] = 1
                else:
                    data[w.lower()] += 1

                 
res = []

for k, v in data.items():
    if v == 2:
        res.append(k)
        
print(*sorted(res, reverse=True), sep='; ') 


<Комментарий эксперта>:"
276,601,38,"Реализуйте следующую программу:

Задан пустой список winners. Этот код уже написан.
В цикле while считываются строки до тех пор, пока не введена строка ""СТОП"".
Для каждой вводимой строки сделайте проверку — если она не начинается со строки ""3 место"" и в ней есть слово ""айдентика"", добавьте ее в список winners.
Гарантируется, что до слова ""СТОП"" будет введена как минимум одна строка.
Напечатайте список winners. Строки в нем должны идти в том же порядке, что и при вводе.","['2 место – Nightmares (саунд)\n1 место – Антиборщевик (айдентика)\n1 место – Исследователи (иллюстрация и комикс)\n2 место – Ripped Beauty (айдентика)\n1 место – Tropic Mayhem (игровая графика)\nСТОП', '1 место – питон (айдентика)\n2 место – анализ данных (саунд)\nСТОП', '2 место – Fireworks Massacre (игровая графика)\n2 место – Tress//passing (айдентика)\n1 место – Стеллаж TWIST (предметный дизайн)\n2 место – Minerals (саунд)\n3 место – Dark F (айдентика)\nСТОП', '3 место – Tress//passing (айдентика)\n3 место – colab. (айдентика)\nСТОП']","[""['1 место – Антиборщевик (айдентика)', '2 место – Ripped Beauty (айдентика)']"", ""['1 место – питон (айдентика)']"", ""['2 место – Tress//passing (айдентика)']"", '[]']","winners = []

# ваш код

while True
    info = input()
    
    if info == 'СТОП':
        break
    
    if 'айдентика' in info and not(info.startswith('3 место')):
        winners.append(info)
print(winners)","winners = []

# ваш код

while True:
    info = input()
    
    if info == 'СТОП':
        break
    
    if 'айдентика' in info and not(info.startswith('3 место')):
        winners.append(info)
print(winners)",Вы забыли поставить двоеточие после условия цикла while.,"['open', 'open', 'closed', 'closed']","<Task description>: Реализуйте следующую программу:

Задан пустой список winners. Этот код уже написан.
В цикле while считываются строки до тех пор, пока не введена строка ""СТОП"".
Для каждой вводимой строки сделайте проверку — если она не начинается со строки ""3 место"" и в ней есть слово ""айдентика"", добавьте ее в список winners.
Гарантируется, что до слова ""СТОП"" будет введена как минимум одна строка.
Напечатайте список winners. Строки в нем должны идти в том же порядке, что и при вводе. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: 2 место – Nightmares (саунд)
1 место – Антиборщевик (айдентика)
1 место – Исследователи (иллюстрация и комикс)
2 место – Ripped Beauty (айдентика)
1 место – Tropic Mayhem (игровая графика)
СТОП 
<Вывод>: ['1 место – Антиборщевик (айдентика)', '2 место – Ripped Beauty (айдентика)'] 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: 1 место – питон (айдентика)
2 место – анализ данных (саунд)
СТОП 
<Вывод>: ['1 место – питон (айдентика)'] 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: 2 место – Fireworks Massacre (игровая графика)
2 место – Tress//passing (айдентика)
1 место – Стеллаж TWIST (предметный дизайн)
2 место – Minerals (саунд)
3 место – Dark F (айдентика)
СТОП 
<Вывод>: ['2 место – Tress//passing (айдентика)'] 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: 3 место – Tress//passing (айдентика)
3 место – colab. (айдентика)
СТОП 
<Вывод>: [] 
<Решение студента>: winners = []

# ваш код

while True
    info = input()
    
    if info == 'СТОП':
        break
    
    if 'айдентика' in info and not(info.startswith('3 место')):
        winners.append(info)
print(winners) 
<Идеальное решение>: winners = []

# ваш код

while True:
    info = input()
    
    if info == 'СТОП':
        break
    
    if 'айдентика' in info and not(info.startswith('3 место')):
        winners.append(info)
print(winners) 


<Комментарий эксперта>:"
277,602,38,"Реализуйте следующую программу:

Задан пустой список winners. Этот код уже написан.
В цикле while считываются строки до тех пор, пока не введена строка ""СТОП"".
Для каждой вводимой строки сделайте проверку — если она не начинается со строки ""3 место"" и в ней есть слово ""айдентика"", добавьте ее в список winners.
Гарантируется, что до слова ""СТОП"" будет введена как минимум одна строка.
Напечатайте список winners. Строки в нем должны идти в том же порядке, что и при вводе.","['2 место – Nightmares (саунд)\n1 место – Антиборщевик (айдентика)\n1 место – Исследователи (иллюстрация и комикс)\n2 место – Ripped Beauty (айдентика)\n1 место – Tropic Mayhem (игровая графика)\nСТОП', '1 место – питон (айдентика)\n2 место – анализ данных (саунд)\nСТОП', '2 место – Fireworks Massacre (игровая графика)\n2 место – Tress//passing (айдентика)\n1 место – Стеллаж TWIST (предметный дизайн)\n2 место – Minerals (саунд)\n3 место – Dark F (айдентика)\nСТОП', '3 место – Tress//passing (айдентика)\n3 место – colab. (айдентика)\nСТОП']","[""['1 место – Антиборщевик (айдентика)', '2 место – Ripped Beauty (айдентика)']"", ""['1 место – питон (айдентика)']"", ""['2 место – Tress//passing (айдентика)']"", '[]']","winners = []

# ваш код

while True:
    info = input()
    
    if info == 'END':
        break
    
    if 'айдентика' in info and not(info.startswith('3 место')):
        winners.append(info)
print(winners)","winners = []

# ваш код

while True:
    info = input()
    
    if info == 'СТОП':
        break
    
    if 'айдентика' in info and not(info.startswith('3 место')):
        winners.append(info)
print(winners)",Ошибка при считывании переменной в первой условной конструкции if. Сравнение производится с некорректной переменной.,"['open', 'open', 'closed', 'closed']","<Task description>: Реализуйте следующую программу:

Задан пустой список winners. Этот код уже написан.
В цикле while считываются строки до тех пор, пока не введена строка ""СТОП"".
Для каждой вводимой строки сделайте проверку — если она не начинается со строки ""3 место"" и в ней есть слово ""айдентика"", добавьте ее в список winners.
Гарантируется, что до слова ""СТОП"" будет введена как минимум одна строка.
Напечатайте список winners. Строки в нем должны идти в том же порядке, что и при вводе. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: 2 место – Nightmares (саунд)
1 место – Антиборщевик (айдентика)
1 место – Исследователи (иллюстрация и комикс)
2 место – Ripped Beauty (айдентика)
1 место – Tropic Mayhem (игровая графика)
СТОП 
<Вывод>: ['1 место – Антиборщевик (айдентика)', '2 место – Ripped Beauty (айдентика)'] 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: 1 место – питон (айдентика)
2 место – анализ данных (саунд)
СТОП 
<Вывод>: ['1 место – питон (айдентика)'] 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: 2 место – Fireworks Massacre (игровая графика)
2 место – Tress//passing (айдентика)
1 место – Стеллаж TWIST (предметный дизайн)
2 место – Minerals (саунд)
3 место – Dark F (айдентика)
СТОП 
<Вывод>: ['2 место – Tress//passing (айдентика)'] 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: 3 место – Tress//passing (айдентика)
3 место – colab. (айдентика)
СТОП 
<Вывод>: [] 
<Решение студента>: winners = []

# ваш код

while True:
    info = input()
    
    if info == 'END':
        break
    
    if 'айдентика' in info and not(info.startswith('3 место')):
        winners.append(info)
print(winners) 
<Идеальное решение>: winners = []

# ваш код

while True:
    info = input()
    
    if info == 'СТОП':
        break
    
    if 'айдентика' in info and not(info.startswith('3 место')):
        winners.append(info)
print(winners) 


<Комментарий эксперта>:"
278,603,38,"Реализуйте следующую программу:

Задан пустой список winners. Этот код уже написан.
В цикле while считываются строки до тех пор, пока не введена строка ""СТОП"".
Для каждой вводимой строки сделайте проверку — если она не начинается со строки ""3 место"" и в ней есть слово ""айдентика"", добавьте ее в список winners.
Гарантируется, что до слова ""СТОП"" будет введена как минимум одна строка.
Напечатайте список winners. Строки в нем должны идти в том же порядке, что и при вводе.","['2 место – Nightmares (саунд)\n1 место – Антиборщевик (айдентика)\n1 место – Исследователи (иллюстрация и комикс)\n2 место – Ripped Beauty (айдентика)\n1 место – Tropic Mayhem (игровая графика)\nСТОП', '1 место – питон (айдентика)\n2 место – анализ данных (саунд)\nСТОП', '2 место – Fireworks Massacre (игровая графика)\n2 место – Tress//passing (айдентика)\n1 место – Стеллаж TWIST (предметный дизайн)\n2 место – Minerals (саунд)\n3 место – Dark F (айдентика)\nСТОП', '3 место – Tress//passing (айдентика)\n3 место – colab. (айдентика)\nСТОП']","[""['1 место – Антиборщевик (айдентика)', '2 место – Ripped Beauty (айдентика)']"", ""['1 место – питон (айдентика)']"", ""['2 место – Tress//passing (айдентика)']"", '[]']","winners = []

# ваш код

while True:
    info = input()
    
    if info = 'СТОП':
        break
    
    if 'айдентика' in info and not(info.startswith('3 место')):
        winners.append(info)
print(winners)","winners = []

# ваш код

while True:
    info = input()
    
    if info == 'СТОП':
        break
    
    if 'айдентика' in info and not(info.startswith('3 место')):
        winners.append(info)
print(winners)",Синтаксическая ошибка. При сравнении двух переменных используйте знак двойного равенства.,"['open', 'open', 'closed', 'closed']","<Task description>: Реализуйте следующую программу:

Задан пустой список winners. Этот код уже написан.
В цикле while считываются строки до тех пор, пока не введена строка ""СТОП"".
Для каждой вводимой строки сделайте проверку — если она не начинается со строки ""3 место"" и в ней есть слово ""айдентика"", добавьте ее в список winners.
Гарантируется, что до слова ""СТОП"" будет введена как минимум одна строка.
Напечатайте список winners. Строки в нем должны идти в том же порядке, что и при вводе. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: 2 место – Nightmares (саунд)
1 место – Антиборщевик (айдентика)
1 место – Исследователи (иллюстрация и комикс)
2 место – Ripped Beauty (айдентика)
1 место – Tropic Mayhem (игровая графика)
СТОП 
<Вывод>: ['1 место – Антиборщевик (айдентика)', '2 место – Ripped Beauty (айдентика)'] 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: 1 место – питон (айдентика)
2 место – анализ данных (саунд)
СТОП 
<Вывод>: ['1 место – питон (айдентика)'] 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: 2 место – Fireworks Massacre (игровая графика)
2 место – Tress//passing (айдентика)
1 место – Стеллаж TWIST (предметный дизайн)
2 место – Minerals (саунд)
3 место – Dark F (айдентика)
СТОП 
<Вывод>: ['2 место – Tress//passing (айдентика)'] 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: 3 место – Tress//passing (айдентика)
3 место – colab. (айдентика)
СТОП 
<Вывод>: [] 
<Решение студента>: winners = []

# ваш код

while True:
    info = input()
    
    if info = 'СТОП':
        break
    
    if 'айдентика' in info and not(info.startswith('3 место')):
        winners.append(info)
print(winners) 
<Идеальное решение>: winners = []

# ваш код

while True:
    info = input()
    
    if info == 'СТОП':
        break
    
    if 'айдентика' in info and not(info.startswith('3 место')):
        winners.append(info)
print(winners) 


<Комментарий эксперта>:"
279,604,38,"Реализуйте следующую программу:

Задан пустой список winners. Этот код уже написан.
В цикле while считываются строки до тех пор, пока не введена строка ""СТОП"".
Для каждой вводимой строки сделайте проверку — если она не начинается со строки ""3 место"" и в ней есть слово ""айдентика"", добавьте ее в список winners.
Гарантируется, что до слова ""СТОП"" будет введена как минимум одна строка.
Напечатайте список winners. Строки в нем должны идти в том же порядке, что и при вводе.","['2 место – Nightmares (саунд)\n1 место – Антиборщевик (айдентика)\n1 место – Исследователи (иллюстрация и комикс)\n2 место – Ripped Beauty (айдентика)\n1 место – Tropic Mayhem (игровая графика)\nСТОП', '1 место – питон (айдентика)\n2 место – анализ данных (саунд)\nСТОП', '2 место – Fireworks Massacre (игровая графика)\n2 место – Tress//passing (айдентика)\n1 место – Стеллаж TWIST (предметный дизайн)\n2 место – Minerals (саунд)\n3 место – Dark F (айдентика)\nСТОП', '3 место – Tress//passing (айдентика)\n3 место – colab. (айдентика)\nСТОП']","[""['1 место – Антиборщевик (айдентика)', '2 место – Ripped Beauty (айдентика)']"", ""['1 место – питон (айдентика)']"", ""['2 место – Tress//passing (айдентика)']"", '[]']","winners = []

# ваш код

while True:
    info = input()
    
    if info == 'СТОП':
        break
    
    if айдентика in info and not(info.startswith('3 место')):
        winners.append(info)
print(winners)","winners = []

# ваш код

while True:
    info = input()
    
    if info == 'СТОП':
        break
    
    if 'айдентика' in info and not(info.startswith('3 место')):
        winners.append(info)
print(winners)","Вы забыли заключить ""айдентика"" в каквычки.","['open', 'open', 'closed', 'closed']","<Task description>: Реализуйте следующую программу:

Задан пустой список winners. Этот код уже написан.
В цикле while считываются строки до тех пор, пока не введена строка ""СТОП"".
Для каждой вводимой строки сделайте проверку — если она не начинается со строки ""3 место"" и в ней есть слово ""айдентика"", добавьте ее в список winners.
Гарантируется, что до слова ""СТОП"" будет введена как минимум одна строка.
Напечатайте список winners. Строки в нем должны идти в том же порядке, что и при вводе. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: 2 место – Nightmares (саунд)
1 место – Антиборщевик (айдентика)
1 место – Исследователи (иллюстрация и комикс)
2 место – Ripped Beauty (айдентика)
1 место – Tropic Mayhem (игровая графика)
СТОП 
<Вывод>: ['1 место – Антиборщевик (айдентика)', '2 место – Ripped Beauty (айдентика)'] 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: 1 место – питон (айдентика)
2 место – анализ данных (саунд)
СТОП 
<Вывод>: ['1 место – питон (айдентика)'] 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: 2 место – Fireworks Massacre (игровая графика)
2 место – Tress//passing (айдентика)
1 место – Стеллаж TWIST (предметный дизайн)
2 место – Minerals (саунд)
3 место – Dark F (айдентика)
СТОП 
<Вывод>: ['2 место – Tress//passing (айдентика)'] 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: 3 место – Tress//passing (айдентика)
3 место – colab. (айдентика)
СТОП 
<Вывод>: [] 
<Решение студента>: winners = []

# ваш код

while True:
    info = input()
    
    if info == 'СТОП':
        break
    
    if айдентика in info and not(info.startswith('3 место')):
        winners.append(info)
print(winners) 
<Идеальное решение>: winners = []

# ваш код

while True:
    info = input()
    
    if info == 'СТОП':
        break
    
    if 'айдентика' in info and not(info.startswith('3 место')):
        winners.append(info)
print(winners) 


<Комментарий эксперта>:"
280,605,38,"Реализуйте следующую программу:

Задан пустой список winners. Этот код уже написан.
В цикле while считываются строки до тех пор, пока не введена строка ""СТОП"".
Для каждой вводимой строки сделайте проверку — если она не начинается со строки ""3 место"" и в ней есть слово ""айдентика"", добавьте ее в список winners.
Гарантируется, что до слова ""СТОП"" будет введена как минимум одна строка.
Напечатайте список winners. Строки в нем должны идти в том же порядке, что и при вводе.","['2 место – Nightmares (саунд)\n1 место – Антиборщевик (айдентика)\n1 место – Исследователи (иллюстрация и комикс)\n2 место – Ripped Beauty (айдентика)\n1 место – Tropic Mayhem (игровая графика)\nСТОП', '1 место – питон (айдентика)\n2 место – анализ данных (саунд)\nСТОП', '2 место – Fireworks Massacre (игровая графика)\n2 место – Tress//passing (айдентика)\n1 место – Стеллаж TWIST (предметный дизайн)\n2 место – Minerals (саунд)\n3 место – Dark F (айдентика)\nСТОП', '3 место – Tress//passing (айдентика)\n3 место – colab. (айдентика)\nСТОП']","[""['1 место – Антиборщевик (айдентика)', '2 место – Ripped Beauty (айдентика)']"", ""['1 место – питон (айдентика)']"", ""['2 место – Tress//passing (айдентика)']"", '[]']","winners = []

# ваш код

while True:
    info = input()
    
    if info == 'СТОП':
        break
    
    if 'айдентика' in info or not(info.startswith('3 место')):
        winners.append(info)
print(winners)","winners = []

# ваш код

while True:
    info = input()
    
    if info == 'СТОП':
        break
    
    if 'айдентика' in info and not(info.startswith('3 место')):
        winners.append(info)
print(winners)","Ошибка в открытых и скрытых тестах. 

Ваш код охватывает не все возможные случаи. Так, условия ""если строка не начинается со строки ""3 место"" и в ней есть слово ""айдентика"", добавьте ее в список winners."" должны выполняться одновременно. Попробуйте дополнить условие if, чтобы охватить все возможные случаи.","['open', 'open', 'closed', 'closed']","<Task description>: Реализуйте следующую программу:

Задан пустой список winners. Этот код уже написан.
В цикле while считываются строки до тех пор, пока не введена строка ""СТОП"".
Для каждой вводимой строки сделайте проверку — если она не начинается со строки ""3 место"" и в ней есть слово ""айдентика"", добавьте ее в список winners.
Гарантируется, что до слова ""СТОП"" будет введена как минимум одна строка.
Напечатайте список winners. Строки в нем должны идти в том же порядке, что и при вводе. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: 2 место – Nightmares (саунд)
1 место – Антиборщевик (айдентика)
1 место – Исследователи (иллюстрация и комикс)
2 место – Ripped Beauty (айдентика)
1 место – Tropic Mayhem (игровая графика)
СТОП 
<Вывод>: ['1 место – Антиборщевик (айдентика)', '2 место – Ripped Beauty (айдентика)'] 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: 1 место – питон (айдентика)
2 место – анализ данных (саунд)
СТОП 
<Вывод>: ['1 место – питон (айдентика)'] 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: 2 место – Fireworks Massacre (игровая графика)
2 место – Tress//passing (айдентика)
1 место – Стеллаж TWIST (предметный дизайн)
2 место – Minerals (саунд)
3 место – Dark F (айдентика)
СТОП 
<Вывод>: ['2 место – Tress//passing (айдентика)'] 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: 3 место – Tress//passing (айдентика)
3 место – colab. (айдентика)
СТОП 
<Вывод>: [] 
<Решение студента>: winners = []

# ваш код

while True:
    info = input()
    
    if info == 'СТОП':
        break
    
    if 'айдентика' in info or not(info.startswith('3 место')):
        winners.append(info)
print(winners) 
<Идеальное решение>: winners = []

# ваш код

while True:
    info = input()
    
    if info == 'СТОП':
        break
    
    if 'айдентика' in info and not(info.startswith('3 место')):
        winners.append(info)
print(winners) 


<Комментарий эксперта>:"
281,606,38,"Реализуйте следующую программу:

Задан пустой список winners. Этот код уже написан.
В цикле while считываются строки до тех пор, пока не введена строка ""СТОП"".
Для каждой вводимой строки сделайте проверку — если она не начинается со строки ""3 место"" и в ней есть слово ""айдентика"", добавьте ее в список winners.
Гарантируется, что до слова ""СТОП"" будет введена как минимум одна строка.
Напечатайте список winners. Строки в нем должны идти в том же порядке, что и при вводе.","['2 место – Nightmares (саунд)\n1 место – Антиборщевик (айдентика)\n1 место – Исследователи (иллюстрация и комикс)\n2 место – Ripped Beauty (айдентика)\n1 место – Tropic Mayhem (игровая графика)\nСТОП', '1 место – питон (айдентика)\n2 место – анализ данных (саунд)\nСТОП', '2 место – Fireworks Massacre (игровая графика)\n2 место – Tress//passing (айдентика)\n1 место – Стеллаж TWIST (предметный дизайн)\n2 место – Minerals (саунд)\n3 место – Dark F (айдентика)\nСТОП', '3 место – Tress//passing (айдентика)\n3 место – colab. (айдентика)\nСТОП']","[""['1 место – Антиборщевик (айдентика)', '2 место – Ripped Beauty (айдентика)']"", ""['1 место – питон (айдентика)']"", ""['2 место – Tress//passing (айдентика)']"", '[]']","winners = []

# ваш код

while True:
    info = input()
    
    if info == 'СТОП':
        break
    
    if 'айдентика' in info: 
        winners.append(info)
    if not(info.startswith('3 место')):
        winners.append(info)
print(winners)","winners = []

# ваш код

while True:
    info = input()
    
    if info == 'СТОП':
        break
    
    if 'айдентика' in info and not(info.startswith('3 место')):
        winners.append(info)
print(winners)","Ошибка в открытых и скрытых тестах. 

Ваш код охватывает не все возможные случаи. Так, условия ""если строка не начинается со строки ""3 место"" и в ней есть слово ""айдентика"", добавьте ее в список winners."" должны выполняться одновременно. Попробуйте дополнить условие if, чтобы охватить все возможные случаи.","['open', 'open', 'closed', 'closed']","<Task description>: Реализуйте следующую программу:

Задан пустой список winners. Этот код уже написан.
В цикле while считываются строки до тех пор, пока не введена строка ""СТОП"".
Для каждой вводимой строки сделайте проверку — если она не начинается со строки ""3 место"" и в ней есть слово ""айдентика"", добавьте ее в список winners.
Гарантируется, что до слова ""СТОП"" будет введена как минимум одна строка.
Напечатайте список winners. Строки в нем должны идти в том же порядке, что и при вводе. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: 2 место – Nightmares (саунд)
1 место – Антиборщевик (айдентика)
1 место – Исследователи (иллюстрация и комикс)
2 место – Ripped Beauty (айдентика)
1 место – Tropic Mayhem (игровая графика)
СТОП 
<Вывод>: ['1 место – Антиборщевик (айдентика)', '2 место – Ripped Beauty (айдентика)'] 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: 1 место – питон (айдентика)
2 место – анализ данных (саунд)
СТОП 
<Вывод>: ['1 место – питон (айдентика)'] 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: 2 место – Fireworks Massacre (игровая графика)
2 место – Tress//passing (айдентика)
1 место – Стеллаж TWIST (предметный дизайн)
2 место – Minerals (саунд)
3 место – Dark F (айдентика)
СТОП 
<Вывод>: ['2 место – Tress//passing (айдентика)'] 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: 3 место – Tress//passing (айдентика)
3 место – colab. (айдентика)
СТОП 
<Вывод>: [] 
<Решение студента>: winners = []

# ваш код

while True:
    info = input()
    
    if info == 'СТОП':
        break
    
    if 'айдентика' in info: 
        winners.append(info)
    if not(info.startswith('3 место')):
        winners.append(info)
print(winners) 
<Идеальное решение>: winners = []

# ваш код

while True:
    info = input()
    
    if info == 'СТОП':
        break
    
    if 'айдентика' in info and not(info.startswith('3 место')):
        winners.append(info)
print(winners) 


<Комментарий эксперта>:"
282,607,38,"Реализуйте следующую программу:

Задан пустой список winners. Этот код уже написан.
В цикле while считываются строки до тех пор, пока не введена строка ""СТОП"".
Для каждой вводимой строки сделайте проверку — если она не начинается со строки ""3 место"" и в ней есть слово ""айдентика"", добавьте ее в список winners.
Гарантируется, что до слова ""СТОП"" будет введена как минимум одна строка.
Напечатайте список winners. Строки в нем должны идти в том же порядке, что и при вводе.","['2 место – Nightmares (саунд)\n1 место – Антиборщевик (айдентика)\n1 место – Исследователи (иллюстрация и комикс)\n2 место – Ripped Beauty (айдентика)\n1 место – Tropic Mayhem (игровая графика)\nСТОП', '1 место – питон (айдентика)\n2 место – анализ данных (саунд)\nСТОП', '2 место – Fireworks Massacre (игровая графика)\n2 место – Tress//passing (айдентика)\n1 место – Стеллаж TWIST (предметный дизайн)\n2 место – Minerals (саунд)\n3 место – Dark F (айдентика)\nСТОП', '3 место – Tress//passing (айдентика)\n3 место – colab. (айдентика)\nСТОП']","[""['1 место – Антиборщевик (айдентика)', '2 место – Ripped Beauty (айдентика)']"", ""['1 место – питон (айдентика)']"", ""['2 место – Tress//passing (айдентика)']"", '[]']","winners = []

# ваш код

while True:
    info = input()
    
    if info == 'СТОП':
        break
    
    if 'айдентика' not in info and not(info.startswith('3 место')):
        winners.append(info)
print(winners)","winners = []

# ваш код

while True:
    info = input()
    
    if info == 'СТОП':
        break
    
    if 'айдентика' in info and not(info.startswith('3 место')):
        winners.append(info)
print(winners)","Ошибка в открытых и скрытых тестах. 

Ваш код охватывает не все возможные случаи. Так, не выполняется условие ""в строке есть слово ""айдентика"". Попробуйте дополнить условие if, чтобы охватить все возможные случаи.","['open', 'open', 'closed', 'closed']","<Task description>: Реализуйте следующую программу:

Задан пустой список winners. Этот код уже написан.
В цикле while считываются строки до тех пор, пока не введена строка ""СТОП"".
Для каждой вводимой строки сделайте проверку — если она не начинается со строки ""3 место"" и в ней есть слово ""айдентика"", добавьте ее в список winners.
Гарантируется, что до слова ""СТОП"" будет введена как минимум одна строка.
Напечатайте список winners. Строки в нем должны идти в том же порядке, что и при вводе. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: 2 место – Nightmares (саунд)
1 место – Антиборщевик (айдентика)
1 место – Исследователи (иллюстрация и комикс)
2 место – Ripped Beauty (айдентика)
1 место – Tropic Mayhem (игровая графика)
СТОП 
<Вывод>: ['1 место – Антиборщевик (айдентика)', '2 место – Ripped Beauty (айдентика)'] 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: 1 место – питон (айдентика)
2 место – анализ данных (саунд)
СТОП 
<Вывод>: ['1 место – питон (айдентика)'] 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: 2 место – Fireworks Massacre (игровая графика)
2 место – Tress//passing (айдентика)
1 место – Стеллаж TWIST (предметный дизайн)
2 место – Minerals (саунд)
3 место – Dark F (айдентика)
СТОП 
<Вывод>: ['2 место – Tress//passing (айдентика)'] 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: 3 место – Tress//passing (айдентика)
3 место – colab. (айдентика)
СТОП 
<Вывод>: [] 
<Решение студента>: winners = []

# ваш код

while True:
    info = input()
    
    if info == 'СТОП':
        break
    
    if 'айдентика' not in info and not(info.startswith('3 место')):
        winners.append(info)
print(winners) 
<Идеальное решение>: winners = []

# ваш код

while True:
    info = input()
    
    if info == 'СТОП':
        break
    
    if 'айдентика' in info and not(info.startswith('3 место')):
        winners.append(info)
print(winners) 


<Комментарий эксперта>:"
283,608,38,"Реализуйте следующую программу:

Задан пустой список winners. Этот код уже написан.
В цикле while считываются строки до тех пор, пока не введена строка ""СТОП"".
Для каждой вводимой строки сделайте проверку — если она не начинается со строки ""3 место"" и в ней есть слово ""айдентика"", добавьте ее в список winners.
Гарантируется, что до слова ""СТОП"" будет введена как минимум одна строка.
Напечатайте список winners. Строки в нем должны идти в том же порядке, что и при вводе.","['2 место – Nightmares (саунд)\n1 место – Антиборщевик (айдентика)\n1 место – Исследователи (иллюстрация и комикс)\n2 место – Ripped Beauty (айдентика)\n1 место – Tropic Mayhem (игровая графика)\nСТОП', '1 место – питон (айдентика)\n2 место – анализ данных (саунд)\nСТОП', '2 место – Fireworks Massacre (игровая графика)\n2 место – Tress//passing (айдентика)\n1 место – Стеллаж TWIST (предметный дизайн)\n2 место – Minerals (саунд)\n3 место – Dark F (айдентика)\nСТОП', '3 место – Tress//passing (айдентика)\n3 место – colab. (айдентика)\nСТОП']","[""['1 место – Антиборщевик (айдентика)', '2 место – Ripped Beauty (айдентика)']"", ""['1 место – питон (айдентика)']"", ""['2 место – Tress//passing (айдентика)']"", '[]']","winners = []

# ваш код

while True:
    info = input()
    
    if info == 'СТОП':
        break
    
    if 'айдентика' in info and info.startswith('3 место'):
        winners.append(info)
print(winners)","winners = []

# ваш код

while True:
    info = input()
    
    if info == 'СТОП':
        break
    
    if 'айдентика' in info and not(info.startswith('3 место')):
        winners.append(info)
print(winners)","Ошибка в открытых и скрытых тестах. 

Ваш код охватывает не все возможные случаи. Так, не выполянется условие ""если строка не начинается со строки ""3 место"". Попробуйте дополнить условие if, чтобы охватить все возможные случаи.","['open', 'open', 'closed', 'closed']","<Task description>: Реализуйте следующую программу:

Задан пустой список winners. Этот код уже написан.
В цикле while считываются строки до тех пор, пока не введена строка ""СТОП"".
Для каждой вводимой строки сделайте проверку — если она не начинается со строки ""3 место"" и в ней есть слово ""айдентика"", добавьте ее в список winners.
Гарантируется, что до слова ""СТОП"" будет введена как минимум одна строка.
Напечатайте список winners. Строки в нем должны идти в том же порядке, что и при вводе. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: 2 место – Nightmares (саунд)
1 место – Антиборщевик (айдентика)
1 место – Исследователи (иллюстрация и комикс)
2 место – Ripped Beauty (айдентика)
1 место – Tropic Mayhem (игровая графика)
СТОП 
<Вывод>: ['1 место – Антиборщевик (айдентика)', '2 место – Ripped Beauty (айдентика)'] 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: 1 место – питон (айдентика)
2 место – анализ данных (саунд)
СТОП 
<Вывод>: ['1 место – питон (айдентика)'] 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: 2 место – Fireworks Massacre (игровая графика)
2 место – Tress//passing (айдентика)
1 место – Стеллаж TWIST (предметный дизайн)
2 место – Minerals (саунд)
3 место – Dark F (айдентика)
СТОП 
<Вывод>: ['2 место – Tress//passing (айдентика)'] 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: 3 место – Tress//passing (айдентика)
3 место – colab. (айдентика)
СТОП 
<Вывод>: [] 
<Решение студента>: winners = []

# ваш код

while True:
    info = input()
    
    if info == 'СТОП':
        break
    
    if 'айдентика' in info and info.startswith('3 место'):
        winners.append(info)
print(winners) 
<Идеальное решение>: winners = []

# ваш код

while True:
    info = input()
    
    if info == 'СТОП':
        break
    
    if 'айдентика' in info and not(info.startswith('3 место')):
        winners.append(info)
print(winners) 


<Комментарий эксперта>:"
284,609,38,"Реализуйте следующую программу:

Задан пустой список winners. Этот код уже написан.
В цикле while считываются строки до тех пор, пока не введена строка ""СТОП"".
Для каждой вводимой строки сделайте проверку — если она не начинается со строки ""3 место"" и в ней есть слово ""айдентика"", добавьте ее в список winners.
Гарантируется, что до слова ""СТОП"" будет введена как минимум одна строка.
Напечатайте список winners. Строки в нем должны идти в том же порядке, что и при вводе.","['2 место – Nightmares (саунд)\n1 место – Антиборщевик (айдентика)\n1 место – Исследователи (иллюстрация и комикс)\n2 место – Ripped Beauty (айдентика)\n1 место – Tropic Mayhem (игровая графика)\nСТОП', '1 место – питон (айдентика)\n2 место – анализ данных (саунд)\nСТОП', '2 место – Fireworks Massacre (игровая графика)\n2 место – Tress//passing (айдентика)\n1 место – Стеллаж TWIST (предметный дизайн)\n2 место – Minerals (саунд)\n3 место – Dark F (айдентика)\nСТОП', '3 место – Tress//passing (айдентика)\n3 место – colab. (айдентика)\nСТОП']","[""['1 место – Антиборщевик (айдентика)', '2 место – Ripped Beauty (айдентика)']"", ""['1 место – питон (айдентика)']"", ""['2 место – Tress//passing (айдентика)']"", '[]']","winners = []

# ваш код

while True:
    info = input()
    
    if info == 'СТОП':
        break
    
    if 'айдентика' in info and not(info.startswith('1 место')):
        winners.append(info)
print(winners)","winners = []

# ваш код

while True:
    info = input()
    
    if info == 'СТОП':
        break
    
    if 'айдентика' in info and not(info.startswith('3 место')):
        winners.append(info)
print(winners)","Ошибка в открытых и скрытых тестах. 

Ваш код охватывает не все возможные случаи. Так, не выполянется условие ""если строка не начинается со строки ""3 место"". Попробуйте дополнить условие if, чтобы охватить все возможные случаи.","['open', 'open', 'closed', 'closed']","<Task description>: Реализуйте следующую программу:

Задан пустой список winners. Этот код уже написан.
В цикле while считываются строки до тех пор, пока не введена строка ""СТОП"".
Для каждой вводимой строки сделайте проверку — если она не начинается со строки ""3 место"" и в ней есть слово ""айдентика"", добавьте ее в список winners.
Гарантируется, что до слова ""СТОП"" будет введена как минимум одна строка.
Напечатайте список winners. Строки в нем должны идти в том же порядке, что и при вводе. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: 2 место – Nightmares (саунд)
1 место – Антиборщевик (айдентика)
1 место – Исследователи (иллюстрация и комикс)
2 место – Ripped Beauty (айдентика)
1 место – Tropic Mayhem (игровая графика)
СТОП 
<Вывод>: ['1 место – Антиборщевик (айдентика)', '2 место – Ripped Beauty (айдентика)'] 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: 1 место – питон (айдентика)
2 место – анализ данных (саунд)
СТОП 
<Вывод>: ['1 место – питон (айдентика)'] 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: 2 место – Fireworks Massacre (игровая графика)
2 место – Tress//passing (айдентика)
1 место – Стеллаж TWIST (предметный дизайн)
2 место – Minerals (саунд)
3 место – Dark F (айдентика)
СТОП 
<Вывод>: ['2 место – Tress//passing (айдентика)'] 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: 3 место – Tress//passing (айдентика)
3 место – colab. (айдентика)
СТОП 
<Вывод>: [] 
<Решение студента>: winners = []

# ваш код

while True:
    info = input()
    
    if info == 'СТОП':
        break
    
    if 'айдентика' in info and not(info.startswith('1 место')):
        winners.append(info)
print(winners) 
<Идеальное решение>: winners = []

# ваш код

while True:
    info = input()
    
    if info == 'СТОП':
        break
    
    if 'айдентика' in info and not(info.startswith('3 место')):
        winners.append(info)
print(winners) 


<Комментарий эксперта>:"
285,610,38,"Реализуйте следующую программу:

Задан пустой список winners. Этот код уже написан.
В цикле while считываются строки до тех пор, пока не введена строка ""СТОП"".
Для каждой вводимой строки сделайте проверку — если она не начинается со строки ""3 место"" и в ней есть слово ""айдентика"", добавьте ее в список winners.
Гарантируется, что до слова ""СТОП"" будет введена как минимум одна строка.
Напечатайте список winners. Строки в нем должны идти в том же порядке, что и при вводе.","['2 место – Nightmares (саунд)\n1 место – Антиборщевик (айдентика)\n1 место – Исследователи (иллюстрация и комикс)\n2 место – Ripped Beauty (айдентика)\n1 место – Tropic Mayhem (игровая графика)\nСТОП', '1 место – питон (айдентика)\n2 место – анализ данных (саунд)\nСТОП', '2 место – Fireworks Massacre (игровая графика)\n2 место – Tress//passing (айдентика)\n1 место – Стеллаж TWIST (предметный дизайн)\n2 место – Minerals (саунд)\n3 место – Dark F (айдентика)\nСТОП', '3 место – Tress//passing (айдентика)\n3 место – colab. (айдентика)\nСТОП']","[""['1 место – Антиборщевик (айдентика)', '2 место – Ripped Beauty (айдентика)']"", ""['1 место – питон (айдентика)']"", ""['2 место – Tress//passing (айдентика)']"", '[]']","winners = []

# ваш код

while True:
    info = input()
    
    if info == 'СТОП':
        break
    
    if 'саунд' in info and not(info.startswith('3 место')):
        winners.append(info)
print(winners)","winners = []

# ваш код

while True:
    info = input()
    
    if info == 'СТОП':
        break
    
    if 'айдентика' in info and not(info.startswith('3 место')):
        winners.append(info)
print(winners)","Ошибка в открытых и скрытых тестах. 

Ваш код охватывает не все возможные случаи. Так, не выполняется условие ""в строке есть слово ""айдентика"". Попробуйте дополнить условие if, чтобы охватить все возможные случаи.","['open', 'open', 'closed', 'closed']","<Task description>: Реализуйте следующую программу:

Задан пустой список winners. Этот код уже написан.
В цикле while считываются строки до тех пор, пока не введена строка ""СТОП"".
Для каждой вводимой строки сделайте проверку — если она не начинается со строки ""3 место"" и в ней есть слово ""айдентика"", добавьте ее в список winners.
Гарантируется, что до слова ""СТОП"" будет введена как минимум одна строка.
Напечатайте список winners. Строки в нем должны идти в том же порядке, что и при вводе. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: 2 место – Nightmares (саунд)
1 место – Антиборщевик (айдентика)
1 место – Исследователи (иллюстрация и комикс)
2 место – Ripped Beauty (айдентика)
1 место – Tropic Mayhem (игровая графика)
СТОП 
<Вывод>: ['1 место – Антиборщевик (айдентика)', '2 место – Ripped Beauty (айдентика)'] 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: 1 место – питон (айдентика)
2 место – анализ данных (саунд)
СТОП 
<Вывод>: ['1 место – питон (айдентика)'] 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: 2 место – Fireworks Massacre (игровая графика)
2 место – Tress//passing (айдентика)
1 место – Стеллаж TWIST (предметный дизайн)
2 место – Minerals (саунд)
3 место – Dark F (айдентика)
СТОП 
<Вывод>: ['2 место – Tress//passing (айдентика)'] 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: 3 место – Tress//passing (айдентика)
3 место – colab. (айдентика)
СТОП 
<Вывод>: [] 
<Решение студента>: winners = []

# ваш код

while True:
    info = input()
    
    if info == 'СТОП':
        break
    
    if 'саунд' in info and not(info.startswith('3 место')):
        winners.append(info)
print(winners) 
<Идеальное решение>: winners = []

# ваш код

while True:
    info = input()
    
    if info == 'СТОП':
        break
    
    if 'айдентика' in info and not(info.startswith('3 место')):
        winners.append(info)
print(winners) 


<Комментарий эксперта>:"
286,611,38,"Реализуйте следующую программу:

Задан пустой список winners. Этот код уже написан.
В цикле while считываются строки до тех пор, пока не введена строка ""СТОП"".
Для каждой вводимой строки сделайте проверку — если она не начинается со строки ""3 место"" и в ней есть слово ""айдентика"", добавьте ее в список winners.
Гарантируется, что до слова ""СТОП"" будет введена как минимум одна строка.
Напечатайте список winners. Строки в нем должны идти в том же порядке, что и при вводе.","['2 место – Nightmares (саунд)\n1 место – Антиборщевик (айдентика)\n1 место – Исследователи (иллюстрация и комикс)\n2 место – Ripped Beauty (айдентика)\n1 место – Tropic Mayhem (игровая графика)\nСТОП', '1 место – питон (айдентика)\n2 место – анализ данных (саунд)\nСТОП', '2 место – Fireworks Massacre (игровая графика)\n2 место – Tress//passing (айдентика)\n1 место – Стеллаж TWIST (предметный дизайн)\n2 место – Minerals (саунд)\n3 место – Dark F (айдентика)\nСТОП', '3 место – Tress//passing (айдентика)\n3 место – colab. (айдентика)\nСТОП']","[""['1 место – Антиборщевик (айдентика)', '2 место – Ripped Beauty (айдентика)']"", ""['1 место – питон (айдентика)']"", ""['2 место – Tress//passing (айдентика)']"", '[]']","winners = []

# ваш код

while True:
    info = input()
    
    if info == 'СТОП':
        break
    
    if 'айдентика' in info and not(info.endswith('3 место')):
        winners.append(info)
print(winners)","winners = []

# ваш код

while True:
    info = input()
    
    if info == 'СТОП':
        break
    
    if 'айдентика' in info and not(info.startswith('3 место')):
        winners.append(info)
print(winners)","Ошибка в открытых и скрытых тестах. 

Ваш код охватывает не все возможные случаи. Так, не выполянется условие ""если строка не начинается со строки ""3 место"". Попробуйте дополнить условие if, чтобы охватить все возможные случаи.","['open', 'open', 'closed', 'closed']","<Task description>: Реализуйте следующую программу:

Задан пустой список winners. Этот код уже написан.
В цикле while считываются строки до тех пор, пока не введена строка ""СТОП"".
Для каждой вводимой строки сделайте проверку — если она не начинается со строки ""3 место"" и в ней есть слово ""айдентика"", добавьте ее в список winners.
Гарантируется, что до слова ""СТОП"" будет введена как минимум одна строка.
Напечатайте список winners. Строки в нем должны идти в том же порядке, что и при вводе. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: 2 место – Nightmares (саунд)
1 место – Антиборщевик (айдентика)
1 место – Исследователи (иллюстрация и комикс)
2 место – Ripped Beauty (айдентика)
1 место – Tropic Mayhem (игровая графика)
СТОП 
<Вывод>: ['1 место – Антиборщевик (айдентика)', '2 место – Ripped Beauty (айдентика)'] 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: 1 место – питон (айдентика)
2 место – анализ данных (саунд)
СТОП 
<Вывод>: ['1 место – питон (айдентика)'] 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: 2 место – Fireworks Massacre (игровая графика)
2 место – Tress//passing (айдентика)
1 место – Стеллаж TWIST (предметный дизайн)
2 место – Minerals (саунд)
3 место – Dark F (айдентика)
СТОП 
<Вывод>: ['2 место – Tress//passing (айдентика)'] 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: 3 место – Tress//passing (айдентика)
3 место – colab. (айдентика)
СТОП 
<Вывод>: [] 
<Решение студента>: winners = []

# ваш код

while True:
    info = input()
    
    if info == 'СТОП':
        break
    
    if 'айдентика' in info and not(info.endswith('3 место')):
        winners.append(info)
print(winners) 
<Идеальное решение>: winners = []

# ваш код

while True:
    info = input()
    
    if info == 'СТОП':
        break
    
    if 'айдентика' in info and not(info.startswith('3 место')):
        winners.append(info)
print(winners) 


<Комментарий эксперта>:"
287,612,38,"Реализуйте следующую программу:

Задан пустой список winners. Этот код уже написан.
В цикле while считываются строки до тех пор, пока не введена строка ""СТОП"".
Для каждой вводимой строки сделайте проверку — если она не начинается со строки ""3 место"" и в ней есть слово ""айдентика"", добавьте ее в список winners.
Гарантируется, что до слова ""СТОП"" будет введена как минимум одна строка.
Напечатайте список winners. Строки в нем должны идти в том же порядке, что и при вводе.","['2 место – Nightmares (саунд)\n1 место – Антиборщевик (айдентика)\n1 место – Исследователи (иллюстрация и комикс)\n2 место – Ripped Beauty (айдентика)\n1 место – Tropic Mayhem (игровая графика)\nСТОП', '1 место – питон (айдентика)\n2 место – анализ данных (саунд)\nСТОП', '2 место – Fireworks Massacre (игровая графика)\n2 место – Tress//passing (айдентика)\n1 место – Стеллаж TWIST (предметный дизайн)\n2 место – Minerals (саунд)\n3 место – Dark F (айдентика)\nСТОП', '3 место – Tress//passing (айдентика)\n3 место – colab. (айдентика)\nСТОП']","[""['1 место – Антиборщевик (айдентика)', '2 место – Ripped Beauty (айдентика)']"", ""['1 место – питон (айдентика)']"", ""['2 место – Tress//passing (айдентика)']"", '[]']","winners = []

# ваш код

while True:
    info = input()
    
    if info == 'СТОП':
        break
    
    if 'айдентика' in info and not(info.startswith('3 место')):
        winners.add(info)
print(winners)","winners = []

# ваш код

while True:
    info = input()
    
    if info == 'СТОП':
        break
    
    if 'айдентика' in info and not(info.startswith('3 место')):
        winners.append(info)
print(winners)",Некорректно использован метод добавления элементов в список. Список не имеет метода .add().,"['open', 'open', 'closed', 'closed']","<Task description>: Реализуйте следующую программу:

Задан пустой список winners. Этот код уже написан.
В цикле while считываются строки до тех пор, пока не введена строка ""СТОП"".
Для каждой вводимой строки сделайте проверку — если она не начинается со строки ""3 место"" и в ней есть слово ""айдентика"", добавьте ее в список winners.
Гарантируется, что до слова ""СТОП"" будет введена как минимум одна строка.
Напечатайте список winners. Строки в нем должны идти в том же порядке, что и при вводе. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: 2 место – Nightmares (саунд)
1 место – Антиборщевик (айдентика)
1 место – Исследователи (иллюстрация и комикс)
2 место – Ripped Beauty (айдентика)
1 место – Tropic Mayhem (игровая графика)
СТОП 
<Вывод>: ['1 место – Антиборщевик (айдентика)', '2 место – Ripped Beauty (айдентика)'] 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: 1 место – питон (айдентика)
2 место – анализ данных (саунд)
СТОП 
<Вывод>: ['1 место – питон (айдентика)'] 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: 2 место – Fireworks Massacre (игровая графика)
2 место – Tress//passing (айдентика)
1 место – Стеллаж TWIST (предметный дизайн)
2 место – Minerals (саунд)
3 место – Dark F (айдентика)
СТОП 
<Вывод>: ['2 место – Tress//passing (айдентика)'] 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: 3 место – Tress//passing (айдентика)
3 место – colab. (айдентика)
СТОП 
<Вывод>: [] 
<Решение студента>: winners = []

# ваш код

while True:
    info = input()
    
    if info == 'СТОП':
        break
    
    if 'айдентика' in info and not(info.startswith('3 место')):
        winners.add(info)
print(winners) 
<Идеальное решение>: winners = []

# ваш код

while True:
    info = input()
    
    if info == 'СТОП':
        break
    
    if 'айдентика' in info and not(info.startswith('3 место')):
        winners.append(info)
print(winners) 


<Комментарий эксперта>:"
288,613,38,"Реализуйте следующую программу:

Задан пустой список winners. Этот код уже написан.
В цикле while считываются строки до тех пор, пока не введена строка ""СТОП"".
Для каждой вводимой строки сделайте проверку — если она не начинается со строки ""3 место"" и в ней есть слово ""айдентика"", добавьте ее в список winners.
Гарантируется, что до слова ""СТОП"" будет введена как минимум одна строка.
Напечатайте список winners. Строки в нем должны идти в том же порядке, что и при вводе.","['2 место – Nightmares (саунд)\n1 место – Антиборщевик (айдентика)\n1 место – Исследователи (иллюстрация и комикс)\n2 место – Ripped Beauty (айдентика)\n1 место – Tropic Mayhem (игровая графика)\nСТОП', '1 место – питон (айдентика)\n2 место – анализ данных (саунд)\nСТОП', '2 место – Fireworks Massacre (игровая графика)\n2 место – Tress//passing (айдентика)\n1 место – Стеллаж TWIST (предметный дизайн)\n2 место – Minerals (саунд)\n3 место – Dark F (айдентика)\nСТОП', '3 место – Tress//passing (айдентика)\n3 место – colab. (айдентика)\nСТОП']","[""['1 место – Антиборщевик (айдентика)', '2 место – Ripped Beauty (айдентика)']"", ""['1 место – питон (айдентика)']"", ""['2 место – Tress//passing (айдентика)']"", '[]']","winners = []

# ваш код

while True:
    info = input()
    
    if info == 'СТОП':
        break
    
    if 'айдентика' in info and not(info.startswith('3 место')):
        winners.append(info)
    print(winners)","winners = []

# ваш код

while True:
    info = input()
    
    if info == 'СТОП':
        break
    
    if 'айдентика' in info and not(info.startswith('3 место')):
        winners.append(info)
print(winners)",Некорректная табуляция функции print().,"['open', 'open', 'closed', 'closed']","<Task description>: Реализуйте следующую программу:

Задан пустой список winners. Этот код уже написан.
В цикле while считываются строки до тех пор, пока не введена строка ""СТОП"".
Для каждой вводимой строки сделайте проверку — если она не начинается со строки ""3 место"" и в ней есть слово ""айдентика"", добавьте ее в список winners.
Гарантируется, что до слова ""СТОП"" будет введена как минимум одна строка.
Напечатайте список winners. Строки в нем должны идти в том же порядке, что и при вводе. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: 2 место – Nightmares (саунд)
1 место – Антиборщевик (айдентика)
1 место – Исследователи (иллюстрация и комикс)
2 место – Ripped Beauty (айдентика)
1 место – Tropic Mayhem (игровая графика)
СТОП 
<Вывод>: ['1 место – Антиборщевик (айдентика)', '2 место – Ripped Beauty (айдентика)'] 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: 1 место – питон (айдентика)
2 место – анализ данных (саунд)
СТОП 
<Вывод>: ['1 место – питон (айдентика)'] 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: 2 место – Fireworks Massacre (игровая графика)
2 место – Tress//passing (айдентика)
1 место – Стеллаж TWIST (предметный дизайн)
2 место – Minerals (саунд)
3 место – Dark F (айдентика)
СТОП 
<Вывод>: ['2 место – Tress//passing (айдентика)'] 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: 3 место – Tress//passing (айдентика)
3 место – colab. (айдентика)
СТОП 
<Вывод>: [] 
<Решение студента>: winners = []

# ваш код

while True:
    info = input()
    
    if info == 'СТОП':
        break
    
    if 'айдентика' in info and not(info.startswith('3 место')):
        winners.append(info)
    print(winners) 
<Идеальное решение>: winners = []

# ваш код

while True:
    info = input()
    
    if info == 'СТОП':
        break
    
    if 'айдентика' in info and not(info.startswith('3 место')):
        winners.append(info)
print(winners) 


<Комментарий эксперта>:"
289,614,38,"Реализуйте следующую программу:

Задан пустой список winners. Этот код уже написан.
В цикле while считываются строки до тех пор, пока не введена строка ""СТОП"".
Для каждой вводимой строки сделайте проверку — если она не начинается со строки ""3 место"" и в ней есть слово ""айдентика"", добавьте ее в список winners.
Гарантируется, что до слова ""СТОП"" будет введена как минимум одна строка.
Напечатайте список winners. Строки в нем должны идти в том же порядке, что и при вводе.","['2 место – Nightmares (саунд)\n1 место – Антиборщевик (айдентика)\n1 место – Исследователи (иллюстрация и комикс)\n2 место – Ripped Beauty (айдентика)\n1 место – Tropic Mayhem (игровая графика)\nСТОП', '1 место – питон (айдентика)\n2 место – анализ данных (саунд)\nСТОП', '2 место – Fireworks Massacre (игровая графика)\n2 место – Tress//passing (айдентика)\n1 место – Стеллаж TWIST (предметный дизайн)\n2 место – Minerals (саунд)\n3 место – Dark F (айдентика)\nСТОП', '3 место – Tress//passing (айдентика)\n3 место – colab. (айдентика)\nСТОП']","[""['1 место – Антиборщевик (айдентика)', '2 место – Ripped Beauty (айдентика)']"", ""['1 место – питон (айдентика)']"", ""['2 место – Tress//passing (айдентика)']"", '[]']","winners = []

# ваш код

while True:
    info = input()
    
    if info == 'СТОП':
        break
    
    if 'айдентика' in info and not(info.startswith('3 место')):
        winers.append(info)
print(winners)","winners = []

# ваш код

while True:
    info = input()
    
    if info == 'СТОП':
        break
    
    if 'айдентика' in info and not(info.startswith('3 место')):
        winners.append(info)
print(winners)",Синтаксическая ошибка. Обратите внимание на синтаксис всех переменных.,"['open', 'open', 'closed', 'closed']","<Task description>: Реализуйте следующую программу:

Задан пустой список winners. Этот код уже написан.
В цикле while считываются строки до тех пор, пока не введена строка ""СТОП"".
Для каждой вводимой строки сделайте проверку — если она не начинается со строки ""3 место"" и в ней есть слово ""айдентика"", добавьте ее в список winners.
Гарантируется, что до слова ""СТОП"" будет введена как минимум одна строка.
Напечатайте список winners. Строки в нем должны идти в том же порядке, что и при вводе. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: 2 место – Nightmares (саунд)
1 место – Антиборщевик (айдентика)
1 место – Исследователи (иллюстрация и комикс)
2 место – Ripped Beauty (айдентика)
1 место – Tropic Mayhem (игровая графика)
СТОП 
<Вывод>: ['1 место – Антиборщевик (айдентика)', '2 место – Ripped Beauty (айдентика)'] 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: 1 место – питон (айдентика)
2 место – анализ данных (саунд)
СТОП 
<Вывод>: ['1 место – питон (айдентика)'] 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: 2 место – Fireworks Massacre (игровая графика)
2 место – Tress//passing (айдентика)
1 место – Стеллаж TWIST (предметный дизайн)
2 место – Minerals (саунд)
3 место – Dark F (айдентика)
СТОП 
<Вывод>: ['2 место – Tress//passing (айдентика)'] 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: 3 место – Tress//passing (айдентика)
3 место – colab. (айдентика)
СТОП 
<Вывод>: [] 
<Решение студента>: winners = []

# ваш код

while True:
    info = input()
    
    if info == 'СТОП':
        break
    
    if 'айдентика' in info and not(info.startswith('3 место')):
        winers.append(info)
print(winners) 
<Идеальное решение>: winners = []

# ваш код

while True:
    info = input()
    
    if info == 'СТОП':
        break
    
    if 'айдентика' in info and not(info.startswith('3 место')):
        winners.append(info)
print(winners) 


<Комментарий эксперта>:"
290,615,38,"Реализуйте следующую программу:

Задан пустой список winners. Этот код уже написан.
В цикле while считываются строки до тех пор, пока не введена строка ""СТОП"".
Для каждой вводимой строки сделайте проверку — если она не начинается со строки ""3 место"" и в ней есть слово ""айдентика"", добавьте ее в список winners.
Гарантируется, что до слова ""СТОП"" будет введена как минимум одна строка.
Напечатайте список winners. Строки в нем должны идти в том же порядке, что и при вводе.","['2 место – Nightmares (саунд)\n1 место – Антиборщевик (айдентика)\n1 место – Исследователи (иллюстрация и комикс)\n2 место – Ripped Beauty (айдентика)\n1 место – Tropic Mayhem (игровая графика)\nСТОП', '1 место – питон (айдентика)\n2 место – анализ данных (саунд)\nСТОП', '2 место – Fireworks Massacre (игровая графика)\n2 место – Tress//passing (айдентика)\n1 место – Стеллаж TWIST (предметный дизайн)\n2 место – Minerals (саунд)\n3 место – Dark F (айдентика)\nСТОП', '3 место – Tress//passing (айдентика)\n3 место – colab. (айдентика)\nСТОП']","[""['1 место – Антиборщевик (айдентика)', '2 место – Ripped Beauty (айдентика)']"", ""['1 место – питон (айдентика)']"", ""['2 место – Tress//passing (айдентика)']"", '[]']","winners = []

# ваш код

while True:
    info = input()
    
    if info == 'СТОП':
        break
    
    if 'айдентика' in info and not(info.startswith('3 место')):
        winners.append(info)
print(*winners)","winners = []

# ваш код

while True:
    info = input()
    
    if info == 'СТОП':
        break
    
    if 'айдентика' in info and not(info.startswith('3 место')):
        winners.append(info)
print(winners)","Ошибка в открытых и скрытых тестах. 

Ваш код не выполянет условие ""Напечатайте список winners. Строки в нем должны идти в том же порядке, что и при вводе"". Попробуйте изменить фцнкцию print(), чтобы исправить ошибку.","['open', 'open', 'closed', 'closed']","<Task description>: Реализуйте следующую программу:

Задан пустой список winners. Этот код уже написан.
В цикле while считываются строки до тех пор, пока не введена строка ""СТОП"".
Для каждой вводимой строки сделайте проверку — если она не начинается со строки ""3 место"" и в ней есть слово ""айдентика"", добавьте ее в список winners.
Гарантируется, что до слова ""СТОП"" будет введена как минимум одна строка.
Напечатайте список winners. Строки в нем должны идти в том же порядке, что и при вводе. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: 2 место – Nightmares (саунд)
1 место – Антиборщевик (айдентика)
1 место – Исследователи (иллюстрация и комикс)
2 место – Ripped Beauty (айдентика)
1 место – Tropic Mayhem (игровая графика)
СТОП 
<Вывод>: ['1 место – Антиборщевик (айдентика)', '2 место – Ripped Beauty (айдентика)'] 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: 1 место – питон (айдентика)
2 место – анализ данных (саунд)
СТОП 
<Вывод>: ['1 место – питон (айдентика)'] 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: 2 место – Fireworks Massacre (игровая графика)
2 место – Tress//passing (айдентика)
1 место – Стеллаж TWIST (предметный дизайн)
2 место – Minerals (саунд)
3 место – Dark F (айдентика)
СТОП 
<Вывод>: ['2 место – Tress//passing (айдентика)'] 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: 3 место – Tress//passing (айдентика)
3 место – colab. (айдентика)
СТОП 
<Вывод>: [] 
<Решение студента>: winners = []

# ваш код

while True:
    info = input()
    
    if info == 'СТОП':
        break
    
    if 'айдентика' in info and not(info.startswith('3 место')):
        winners.append(info)
print(*winners) 
<Идеальное решение>: winners = []

# ваш код

while True:
    info = input()
    
    if info == 'СТОП':
        break
    
    if 'айдентика' in info and not(info.startswith('3 место')):
        winners.append(info)
print(winners) 


<Комментарий эксперта>:"
291,616,39,"Реализуйте следующую программу:

В переменную agencies считывается список названий агентств. Этот код уже написан.
Программа проверяет, какие названия агентств оканчиваются на ""ум"". Если такие строки есть, то программа сохраняет их в отдельный список.
В конце программа печатает отсортированный в алфавитном порядке список с названиями агентств, которые были туда сохранены.
Если таких строк нет, программа печатает пустой список.","['Шедеврум Авалонун Концептиус Кордицепсум Умникус', 'Концепт Про-дизайнум Трендикум Стор-ус', 'Усы Прокси Бэнкси']","[""['Кордицепсум', 'Шедеврум']"", ""['Про-дизайнум', 'Трендикум']"", '[]']","agencies = input().split()

for agency in agencies:
    if agency.endswith('ум'):
        us.append(agency)
        
print(sorted(us))","agencies = input().split()
us = []

for agency in agencies:
    if agency.endswith('ум'):
        us.append(agency)
        
print(sorted(us))","Синтаксическая ошибка. Вы пытаетесь обратиться к переменной, которая ранее не была определена. Проверьте, что все используемые Вами переменные были ранее заданы.","['open', 'open', 'closed']","<Task description>: Реализуйте следующую программу:

В переменную agencies считывается список названий агентств. Этот код уже написан.
Программа проверяет, какие названия агентств оканчиваются на ""ум"". Если такие строки есть, то программа сохраняет их в отдельный список.
В конце программа печатает отсортированный в алфавитном порядке список с названиями агентств, которые были туда сохранены.
Если таких строк нет, программа печатает пустой список. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: Шедеврум Авалонун Концептиус Кордицепсум Умникус 
<Вывод>: ['Кордицепсум', 'Шедеврум'] 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: Концепт Про-дизайнум Трендикум Стор-ус 
<Вывод>: ['Про-дизайнум', 'Трендикум'] 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: Усы Прокси Бэнкси 
<Вывод>: [] 
<Решение студента>: agencies = input().split()

for agency in agencies:
    if agency.endswith('ум'):
        us.append(agency)
        
print(sorted(us)) 
<Идеальное решение>: agencies = input().split()
us = []

for agency in agencies:
    if agency.endswith('ум'):
        us.append(agency)
        
print(sorted(us)) 


<Комментарий эксперта>:"
292,617,39,"Реализуйте следующую программу:

В переменную agencies считывается список названий агентств. Этот код уже написан.
Программа проверяет, какие названия агентств оканчиваются на ""ум"". Если такие строки есть, то программа сохраняет их в отдельный список.
В конце программа печатает отсортированный в алфавитном порядке список с названиями агентств, которые были туда сохранены.
Если таких строк нет, программа печатает пустой список.","['Шедеврум Авалонун Концептиус Кордицепсум Умникус', 'Концепт Про-дизайнум Трендикум Стор-ус', 'Усы Прокси Бэнкси']","[""['Кордицепсум', 'Шедеврум']"", ""['Про-дизайнум', 'Трендикум']"", '[]']","agencies = input().split()
us = []

for i in agencies:
    if agency.endswith('ум'):
        us.append(agency)
        
print(sorted(us))","agencies = input().split()
us = []

for agency in agencies:
    if agency.endswith('ум'):
        us.append(agency)
        
print(sorted(us))","Синтаксическая ошибка. Вы пытаетесь обратиться к переменной, которая ранее не была определена. Проверьте, что все используемые Вами переменные были ранее заданы.","['open', 'open', 'closed']","<Task description>: Реализуйте следующую программу:

В переменную agencies считывается список названий агентств. Этот код уже написан.
Программа проверяет, какие названия агентств оканчиваются на ""ум"". Если такие строки есть, то программа сохраняет их в отдельный список.
В конце программа печатает отсортированный в алфавитном порядке список с названиями агентств, которые были туда сохранены.
Если таких строк нет, программа печатает пустой список. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: Шедеврум Авалонун Концептиус Кордицепсум Умникус 
<Вывод>: ['Кордицепсум', 'Шедеврум'] 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: Концепт Про-дизайнум Трендикум Стор-ус 
<Вывод>: ['Про-дизайнум', 'Трендикум'] 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: Усы Прокси Бэнкси 
<Вывод>: [] 
<Решение студента>: agencies = input().split()
us = []

for i in agencies:
    if agency.endswith('ум'):
        us.append(agency)
        
print(sorted(us)) 
<Идеальное решение>: agencies = input().split()
us = []

for agency in agencies:
    if agency.endswith('ум'):
        us.append(agency)
        
print(sorted(us)) 


<Комментарий эксперта>:"
293,618,39,"Реализуйте следующую программу:

В переменную agencies считывается список названий агентств. Этот код уже написан.
Программа проверяет, какие названия агентств оканчиваются на ""ум"". Если такие строки есть, то программа сохраняет их в отдельный список.
В конце программа печатает отсортированный в алфавитном порядке список с названиями агентств, которые были туда сохранены.
Если таких строк нет, программа печатает пустой список.","['Шедеврум Авалонун Концептиус Кордицепсум Умникус', 'Концепт Про-дизайнум Трендикум Стор-ус', 'Усы Прокси Бэнкси']","[""['Кордицепсум', 'Шедеврум']"", ""['Про-дизайнум', 'Трендикум']"", '[]']","agencies = input().split()
us = []

for agency in agencies:
    if agency[-2] ==  'ум':
        us.append(agency)
        
print(sorted(us))","agencies = input().split()
us = []

for agency in agencies:
    if agency.endswith('ум'):
        us.append(agency)
        
print(sorted(us))","Ошибка в открытых и скрытых тестах. 

Ваш код некорректно обратабывает данные. Некорректным образом происходит попытка вызвать два последних элемента agency.","['open', 'open', 'closed']","<Task description>: Реализуйте следующую программу:

В переменную agencies считывается список названий агентств. Этот код уже написан.
Программа проверяет, какие названия агентств оканчиваются на ""ум"". Если такие строки есть, то программа сохраняет их в отдельный список.
В конце программа печатает отсортированный в алфавитном порядке список с названиями агентств, которые были туда сохранены.
Если таких строк нет, программа печатает пустой список. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: Шедеврум Авалонун Концептиус Кордицепсум Умникус 
<Вывод>: ['Кордицепсум', 'Шедеврум'] 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: Концепт Про-дизайнум Трендикум Стор-ус 
<Вывод>: ['Про-дизайнум', 'Трендикум'] 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: Усы Прокси Бэнкси 
<Вывод>: [] 
<Решение студента>: agencies = input().split()
us = []

for agency in agencies:
    if agency[-2] ==  'ум':
        us.append(agency)
        
print(sorted(us)) 
<Идеальное решение>: agencies = input().split()
us = []

for agency in agencies:
    if agency.endswith('ум'):
        us.append(agency)
        
print(sorted(us)) 


<Комментарий эксперта>:"
294,619,39,"Реализуйте следующую программу:

В переменную agencies считывается список названий агентств. Этот код уже написан.
Программа проверяет, какие названия агентств оканчиваются на ""ум"". Если такие строки есть, то программа сохраняет их в отдельный список.
В конце программа печатает отсортированный в алфавитном порядке список с названиями агентств, которые были туда сохранены.
Если таких строк нет, программа печатает пустой список.","['Шедеврум Авалонун Концептиус Кордицепсум Умникус', 'Концепт Про-дизайнум Трендикум Стор-ус', 'Усы Прокси Бэнкси']","[""['Кордицепсум', 'Шедеврум']"", ""['Про-дизайнум', 'Трендикум']"", '[]']","agencies = input().split()
us = []

for agency in agencies:
    if agency.endswith(ум):
        us.append(agency)
        
print(sorted(us))","agencies = input().split()
us = []

for agency in agencies:
    if agency.endswith('ум'):
        us.append(agency)
        
print(sorted(us))","Вы забыли заключить ""ум"" в каквычки.","['open', 'open', 'closed']","<Task description>: Реализуйте следующую программу:

В переменную agencies считывается список названий агентств. Этот код уже написан.
Программа проверяет, какие названия агентств оканчиваются на ""ум"". Если такие строки есть, то программа сохраняет их в отдельный список.
В конце программа печатает отсортированный в алфавитном порядке список с названиями агентств, которые были туда сохранены.
Если таких строк нет, программа печатает пустой список. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: Шедеврум Авалонун Концептиус Кордицепсум Умникус 
<Вывод>: ['Кордицепсум', 'Шедеврум'] 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: Концепт Про-дизайнум Трендикум Стор-ус 
<Вывод>: ['Про-дизайнум', 'Трендикум'] 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: Усы Прокси Бэнкси 
<Вывод>: [] 
<Решение студента>: agencies = input().split()
us = []

for agency in agencies:
    if agency.endswith(ум):
        us.append(agency)
        
print(sorted(us)) 
<Идеальное решение>: agencies = input().split()
us = []

for agency in agencies:
    if agency.endswith('ум'):
        us.append(agency)
        
print(sorted(us)) 


<Комментарий эксперта>:"
295,620,39,"Реализуйте следующую программу:

В переменную agencies считывается список названий агентств. Этот код уже написан.
Программа проверяет, какие названия агентств оканчиваются на ""ум"". Если такие строки есть, то программа сохраняет их в отдельный список.
В конце программа печатает отсортированный в алфавитном порядке список с названиями агентств, которые были туда сохранены.
Если таких строк нет, программа печатает пустой список.","['Шедеврум Авалонун Концептиус Кордицепсум Умникус', 'Концепт Про-дизайнум Трендикум Стор-ус', 'Усы Прокси Бэнкси']","[""['Кордицепсум', 'Шедеврум']"", ""['Про-дизайнум', 'Трендикум']"", '[]']","agencies = input().split()
us = []

for agency in agencies:
    if agency.endswith('ум'):
        us.append(agencies)
        
print(sorted(us))","agencies = input().split()
us = []

for agency in agencies:
    if agency.endswith('ум'):
        us.append(agency)
        
print(sorted(us))","Ошибка в открытых и скрытых тестах. 

Ваш код некорректно обрабатывает данные. Код выводит некорректную переменную. Убедитесь, что вы использовали корректные переменные в качестве параметров функции print().","['open', 'open', 'closed']","<Task description>: Реализуйте следующую программу:

В переменную agencies считывается список названий агентств. Этот код уже написан.
Программа проверяет, какие названия агентств оканчиваются на ""ум"". Если такие строки есть, то программа сохраняет их в отдельный список.
В конце программа печатает отсортированный в алфавитном порядке список с названиями агентств, которые были туда сохранены.
Если таких строк нет, программа печатает пустой список. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: Шедеврум Авалонун Концептиус Кордицепсум Умникус 
<Вывод>: ['Кордицепсум', 'Шедеврум'] 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: Концепт Про-дизайнум Трендикум Стор-ус 
<Вывод>: ['Про-дизайнум', 'Трендикум'] 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: Усы Прокси Бэнкси 
<Вывод>: [] 
<Решение студента>: agencies = input().split()
us = []

for agency in agencies:
    if agency.endswith('ум'):
        us.append(agencies)
        
print(sorted(us)) 
<Идеальное решение>: agencies = input().split()
us = []

for agency in agencies:
    if agency.endswith('ум'):
        us.append(agency)
        
print(sorted(us)) 


<Комментарий эксперта>:"
296,621,39,"Реализуйте следующую программу:

В переменную agencies считывается список названий агентств. Этот код уже написан.
Программа проверяет, какие названия агентств оканчиваются на ""ум"". Если такие строки есть, то программа сохраняет их в отдельный список.
В конце программа печатает отсортированный в алфавитном порядке список с названиями агентств, которые были туда сохранены.
Если таких строк нет, программа печатает пустой список.","['Шедеврум Авалонун Концептиус Кордицепсум Умникус', 'Концепт Про-дизайнум Трендикум Стор-ус', 'Усы Прокси Бэнкси']","[""['Кордицепсум', 'Шедеврум']"", ""['Про-дизайнум', 'Трендикум']"", '[]']","agencies = input().split()
us = []

for agency in agencies
    if agency.endswith('ум'):
        us.append(agency)
        
print(sorted(us))","agencies = input().split()
us = []

for agency in agencies:
    if agency.endswith('ум'):
        us.append(agency)
        
print(sorted(us))",Вы забыли поставить двоеточие после условия цикла for.,"['open', 'open', 'closed']","<Task description>: Реализуйте следующую программу:

В переменную agencies считывается список названий агентств. Этот код уже написан.
Программа проверяет, какие названия агентств оканчиваются на ""ум"". Если такие строки есть, то программа сохраняет их в отдельный список.
В конце программа печатает отсортированный в алфавитном порядке список с названиями агентств, которые были туда сохранены.
Если таких строк нет, программа печатает пустой список. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: Шедеврум Авалонун Концептиус Кордицепсум Умникус 
<Вывод>: ['Кордицепсум', 'Шедеврум'] 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: Концепт Про-дизайнум Трендикум Стор-ус 
<Вывод>: ['Про-дизайнум', 'Трендикум'] 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: Усы Прокси Бэнкси 
<Вывод>: [] 
<Решение студента>: agencies = input().split()
us = []

for agency in agencies
    if agency.endswith('ум'):
        us.append(agency)
        
print(sorted(us)) 
<Идеальное решение>: agencies = input().split()
us = []

for agency in agencies:
    if agency.endswith('ум'):
        us.append(agency)
        
print(sorted(us)) 


<Комментарий эксперта>:"
297,622,39,"Реализуйте следующую программу:

В переменную agencies считывается список названий агентств. Этот код уже написан.
Программа проверяет, какие названия агентств оканчиваются на ""ум"". Если такие строки есть, то программа сохраняет их в отдельный список.
В конце программа печатает отсортированный в алфавитном порядке список с названиями агентств, которые были туда сохранены.
Если таких строк нет, программа печатает пустой список.","['Шедеврум Авалонун Концептиус Кордицепсум Умникус', 'Концепт Про-дизайнум Трендикум Стор-ус', 'Усы Прокси Бэнкси']","[""['Кордицепсум', 'Шедеврум']"", ""['Про-дизайнум', 'Трендикум']"", '[]']","agencies = input().split()
us = []

for agency in agencies:
    if agency.endswith('ум'):
    us.append(agency)
        
print(sorted(us))","agencies = input().split()
us = []

for agency in agencies:
    if agency.endswith('ум'):
        us.append(agency)
        
print(sorted(us))",Некорректная табуляция внутри условной конструкции if.,"['open', 'open', 'closed']","<Task description>: Реализуйте следующую программу:

В переменную agencies считывается список названий агентств. Этот код уже написан.
Программа проверяет, какие названия агентств оканчиваются на ""ум"". Если такие строки есть, то программа сохраняет их в отдельный список.
В конце программа печатает отсортированный в алфавитном порядке список с названиями агентств, которые были туда сохранены.
Если таких строк нет, программа печатает пустой список. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: Шедеврум Авалонун Концептиус Кордицепсум Умникус 
<Вывод>: ['Кордицепсум', 'Шедеврум'] 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: Концепт Про-дизайнум Трендикум Стор-ус 
<Вывод>: ['Про-дизайнум', 'Трендикум'] 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: Усы Прокси Бэнкси 
<Вывод>: [] 
<Решение студента>: agencies = input().split()
us = []

for agency in agencies:
    if agency.endswith('ум'):
    us.append(agency)
        
print(sorted(us)) 
<Идеальное решение>: agencies = input().split()
us = []

for agency in agencies:
    if agency.endswith('ум'):
        us.append(agency)
        
print(sorted(us)) 


<Комментарий эксперта>:"
298,623,39,"Реализуйте следующую программу:

В переменную agencies считывается список названий агентств. Этот код уже написан.
Программа проверяет, какие названия агентств оканчиваются на ""ум"". Если такие строки есть, то программа сохраняет их в отдельный список.
В конце программа печатает отсортированный в алфавитном порядке список с названиями агентств, которые были туда сохранены.
Если таких строк нет, программа печатает пустой список.","['Шедеврум Авалонун Концептиус Кордицепсум Умникус', 'Концепт Про-дизайнум Трендикум Стор-ус', 'Усы Прокси Бэнкси']","[""['Кордицепсум', 'Шедеврум']"", ""['Про-дизайнум', 'Трендикум']"", '[]']","agencies = input().split()
us = []

for agency in agencies:
    if agency.endswith('ум'):
        us.append(agency)
        
print(us)","agencies = input().split()
us = []

for agency in agencies:
    if agency.endswith('ум'):
        us.append(agency)
        
print(sorted(us))","Ошибка в открытых и скрытых тестах. 

Ваш код охватывает не все возможные случаи. Так, не выполянется условие ""программа печатает отсортированный в алфавитном порядке список с названиями агентств, которые были туда сохранены"". Попробуйте изменить функцию print(), чтобы исправить ошибку.","['open', 'open', 'closed']","<Task description>: Реализуйте следующую программу:

В переменную agencies считывается список названий агентств. Этот код уже написан.
Программа проверяет, какие названия агентств оканчиваются на ""ум"". Если такие строки есть, то программа сохраняет их в отдельный список.
В конце программа печатает отсортированный в алфавитном порядке список с названиями агентств, которые были туда сохранены.
Если таких строк нет, программа печатает пустой список. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: Шедеврум Авалонун Концептиус Кордицепсум Умникус 
<Вывод>: ['Кордицепсум', 'Шедеврум'] 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: Концепт Про-дизайнум Трендикум Стор-ус 
<Вывод>: ['Про-дизайнум', 'Трендикум'] 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: Усы Прокси Бэнкси 
<Вывод>: [] 
<Решение студента>: agencies = input().split()
us = []

for agency in agencies:
    if agency.endswith('ум'):
        us.append(agency)
        
print(us) 
<Идеальное решение>: agencies = input().split()
us = []

for agency in agencies:
    if agency.endswith('ум'):
        us.append(agency)
        
print(sorted(us)) 


<Комментарий эксперта>:"
299,624,39,"Реализуйте следующую программу:

В переменную agencies считывается список названий агентств. Этот код уже написан.
Программа проверяет, какие названия агентств оканчиваются на ""ум"". Если такие строки есть, то программа сохраняет их в отдельный список.
В конце программа печатает отсортированный в алфавитном порядке список с названиями агентств, которые были туда сохранены.
Если таких строк нет, программа печатает пустой список.","['Шедеврум Авалонун Концептиус Кордицепсум Умникус', 'Концепт Про-дизайнум Трендикум Стор-ус', 'Усы Прокси Бэнкси']","[""['Кордицепсум', 'Шедеврум']"", ""['Про-дизайнум', 'Трендикум']"", '[]']","agencies = input().split()
us = []

for agency in agencies:
    if agency.endswith('ум'):
        us.append(agency)
        
print(sorted(us, reverse = True))","agencies = input().split()
us = []

for agency in agencies:
    if agency.endswith('ум'):
        us.append(agency)
        
print(sorted(us))","Ошибка в открытых и скрытых тестах. 

Ваш код охватывает не все возможные случаи. Так, не выполянется условие ""программа печатает отсортированный в алфавитном порядке список с названиями агентств, которые были туда сохранены"". Попробуйте изменить функцию print(), чтобы исправить ошибку.","['open', 'open', 'closed']","<Task description>: Реализуйте следующую программу:

В переменную agencies считывается список названий агентств. Этот код уже написан.
Программа проверяет, какие названия агентств оканчиваются на ""ум"". Если такие строки есть, то программа сохраняет их в отдельный список.
В конце программа печатает отсортированный в алфавитном порядке список с названиями агентств, которые были туда сохранены.
Если таких строк нет, программа печатает пустой список. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: Шедеврум Авалонун Концептиус Кордицепсум Умникус 
<Вывод>: ['Кордицепсум', 'Шедеврум'] 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: Концепт Про-дизайнум Трендикум Стор-ус 
<Вывод>: ['Про-дизайнум', 'Трендикум'] 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: Усы Прокси Бэнкси 
<Вывод>: [] 
<Решение студента>: agencies = input().split()
us = []

for agency in agencies:
    if agency.endswith('ум'):
        us.append(agency)
        
print(sorted(us, reverse = True)) 
<Идеальное решение>: agencies = input().split()
us = []

for agency in agencies:
    if agency.endswith('ум'):
        us.append(agency)
        
print(sorted(us)) 


<Комментарий эксперта>:"
300,625,39,"Реализуйте следующую программу:

В переменную agencies считывается список названий агентств. Этот код уже написан.
Программа проверяет, какие названия агентств оканчиваются на ""ум"". Если такие строки есть, то программа сохраняет их в отдельный список.
В конце программа печатает отсортированный в алфавитном порядке список с названиями агентств, которые были туда сохранены.
Если таких строк нет, программа печатает пустой список.","['Шедеврум Авалонун Концептиус Кордицепсум Умникус', 'Концепт Про-дизайнум Трендикум Стор-ус', 'Усы Прокси Бэнкси']","[""['Кордицепсум', 'Шедеврум']"", ""['Про-дизайнум', 'Трендикум']"", '[]']","agencies = input().split()
us = []

for agency in agencies:
    if agency.endswith('ум'):
        us.append(agency)
        
print(*sorted(us))","agencies = input().split()
us = []

for agency in agencies:
    if agency.endswith('ум'):
        us.append(agency)
        
print(sorted(us))","Ошибка в открытых и скрытых тестах. 

Ваш код охватывает не все возможные случаи. Так, не выполянется условие ""программа печатает отсортированный в алфавитном порядке список с названиями агентств, которые были туда сохранены"". Попробуйте изменить функцию print(), чтобы исправить ошибку.","['open', 'open', 'closed']","<Task description>: Реализуйте следующую программу:

В переменную agencies считывается список названий агентств. Этот код уже написан.
Программа проверяет, какие названия агентств оканчиваются на ""ум"". Если такие строки есть, то программа сохраняет их в отдельный список.
В конце программа печатает отсортированный в алфавитном порядке список с названиями агентств, которые были туда сохранены.
Если таких строк нет, программа печатает пустой список. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: Шедеврум Авалонун Концептиус Кордицепсум Умникус 
<Вывод>: ['Кордицепсум', 'Шедеврум'] 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: Концепт Про-дизайнум Трендикум Стор-ус 
<Вывод>: ['Про-дизайнум', 'Трендикум'] 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: Усы Прокси Бэнкси 
<Вывод>: [] 
<Решение студента>: agencies = input().split()
us = []

for agency in agencies:
    if agency.endswith('ум'):
        us.append(agency)
        
print(*sorted(us)) 
<Идеальное решение>: agencies = input().split()
us = []

for agency in agencies:
    if agency.endswith('ум'):
        us.append(agency)
        
print(sorted(us)) 


<Комментарий эксперта>:"
301,626,39,"Реализуйте следующую программу:

В переменную agencies считывается список названий агентств. Этот код уже написан.
Программа проверяет, какие названия агентств оканчиваются на ""ум"". Если такие строки есть, то программа сохраняет их в отдельный список.
В конце программа печатает отсортированный в алфавитном порядке список с названиями агентств, которые были туда сохранены.
Если таких строк нет, программа печатает пустой список.","['Шедеврум Авалонун Концептиус Кордицепсум Умникус', 'Концепт Про-дизайнум Трендикум Стор-ус', 'Усы Прокси Бэнкси']","[""['Кордицепсум', 'Шедеврум']"", ""['Про-дизайнум', 'Трендикум']"", '[]']","agencies = input().split()
us = []

for agency in agencies:
    if agency.endswith('ум'):
        us.append(agency)
        
print(*us)","agencies = input().split()
us = []

for agency in agencies:
    if agency.endswith('ум'):
        us.append(agency)
        
print(sorted(us))","Ошибка в открытых и скрытых тестах. 

Ваш код охватывает не все возможные случаи. Так, не выполянется условие ""программа печатает отсортированный в алфавитном порядке список с названиями агентств, которые были туда сохранены"". Попробуйте изменить функцию print(), чтобы исправить ошибку.","['open', 'open', 'closed']","<Task description>: Реализуйте следующую программу:

В переменную agencies считывается список названий агентств. Этот код уже написан.
Программа проверяет, какие названия агентств оканчиваются на ""ум"". Если такие строки есть, то программа сохраняет их в отдельный список.
В конце программа печатает отсортированный в алфавитном порядке список с названиями агентств, которые были туда сохранены.
Если таких строк нет, программа печатает пустой список. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: Шедеврум Авалонун Концептиус Кордицепсум Умникус 
<Вывод>: ['Кордицепсум', 'Шедеврум'] 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: Концепт Про-дизайнум Трендикум Стор-ус 
<Вывод>: ['Про-дизайнум', 'Трендикум'] 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: Усы Прокси Бэнкси 
<Вывод>: [] 
<Решение студента>: agencies = input().split()
us = []

for agency in agencies:
    if agency.endswith('ум'):
        us.append(agency)
        
print(*us) 
<Идеальное решение>: agencies = input().split()
us = []

for agency in agencies:
    if agency.endswith('ум'):
        us.append(agency)
        
print(sorted(us)) 


<Комментарий эксперта>:"
302,627,39,"Реализуйте следующую программу:

В переменную agencies считывается список названий агентств. Этот код уже написан.
Программа проверяет, какие названия агентств оканчиваются на ""ум"". Если такие строки есть, то программа сохраняет их в отдельный список.
В конце программа печатает отсортированный в алфавитном порядке список с названиями агентств, которые были туда сохранены.
Если таких строк нет, программа печатает пустой список.","['Шедеврум Авалонун Концептиус Кордицепсум Умникус', 'Концепт Про-дизайнум Трендикум Стор-ус', 'Усы Прокси Бэнкси']","[""['Кордицепсум', 'Шедеврум']"", ""['Про-дизайнум', 'Трендикум']"", '[]']","agencies = input().split()
us = []

for agency in agencies:
    if agency.endswith('ум'):
        us.append(agency)
        
    print(sorted(us))","agencies = input().split()
us = []

for agency in agencies:
    if agency.endswith('ум'):
        us.append(agency)
        
print(sorted(us))",Некорректная табуляция функции print().,"['open', 'open', 'closed']","<Task description>: Реализуйте следующую программу:

В переменную agencies считывается список названий агентств. Этот код уже написан.
Программа проверяет, какие названия агентств оканчиваются на ""ум"". Если такие строки есть, то программа сохраняет их в отдельный список.
В конце программа печатает отсортированный в алфавитном порядке список с названиями агентств, которые были туда сохранены.
Если таких строк нет, программа печатает пустой список. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: Шедеврум Авалонун Концептиус Кордицепсум Умникус 
<Вывод>: ['Кордицепсум', 'Шедеврум'] 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: Концепт Про-дизайнум Трендикум Стор-ус 
<Вывод>: ['Про-дизайнум', 'Трендикум'] 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: Усы Прокси Бэнкси 
<Вывод>: [] 
<Решение студента>: agencies = input().split()
us = []

for agency in agencies:
    if agency.endswith('ум'):
        us.append(agency)
        
    print(sorted(us)) 
<Идеальное решение>: agencies = input().split()
us = []

for agency in agencies:
    if agency.endswith('ум'):
        us.append(agency)
        
print(sorted(us)) 


<Комментарий эксперта>:"
303,628,40,"Анна и Галина выбирают, в каком агентстве заказать айдентику для бренда одежды. Реализуйте программу, которая поможет им сделать выбор:

В переменную anna_choice считывается список строк (названия агенств, которым доверяет Анна). Этот код уже написан.
В переменную galina_choice считывается список строк (названия агенств, которым доверяет Галина). Этот код уже написан.
В переменную top10 считывается список строк (названия агенств, входящих в топ-10).
Гарантируется, что для каждого списка будет введено хотя бы одно значение.
Программа выводит через запятую с пробелом названия агентств из топ-10, которым одновременно доверяют и Анна, и Галина.
Названия должны быть отсортированы в алфавитном порядке.
Если таких агенств нет, программа ничего не выводит. ","['Шедеврум Про-дизайнус Коммуникатус Симфониус Динамитус\nСимфониус Динамитус Импрово Шедеврум\nДинамитус Шедеврум Симфониус', 'Симфониус Эмпатус Эксклюзивус\nЭксклюзивус Эволютус Симфониус\nШедеврум Эмпатус', 'Инспиратус Экспрессивус Прогрессус Эксклюзивус\nЭксклюзивус Экспрессивус Авангардус\nАвангардус Инспиратус Эстетус Экспрессивус', 'Шедеврум Про-дизайнус Коммуникатус Симфониус Динамитус\nШедеврум Про-дизайнус Коммуникатус Симфониус Динамитус\nШедеврум Про-дизайнус Коммуникатус Симфониус Динамитус', 'Коммуникатус\nКоммуникатус\nКоммуникатус', 'Коммуникатус Симфониус Динамитус\nШедеврум Про-дизайнус\nКоммуникатус Симфониус Динамитус']","['Динамитус, Симфониус, Шедеврум', nan, 'Экспрессивус', 'Динамитус, Коммуникатус, Про-дизайнус, Симфониус, Шедеврум', 'Коммуникатус', nan]","anna_choice = input().split()
galina_choice = input().split()
top10 = input().split()

print(', '.join(sorted((anna_choice & galina_choice).intersection(top10))))","anna_choice = input().split()
galina_choice = input().split()
top10 = input().split()

print(', '.join(sorted((set(anna_choice) & set(galina_choice)).intersection(set(top10)))))","Ошибка при сравнении данных. Оператор ""&"" не используется для сравнения данных типа list.","['open', 'open', 'open', 'closed', 'closed', 'closed']","<Task description>: Анна и Галина выбирают, в каком агентстве заказать айдентику для бренда одежды. Реализуйте программу, которая поможет им сделать выбор:

В переменную anna_choice считывается список строк (названия агенств, которым доверяет Анна). Этот код уже написан.
В переменную galina_choice считывается список строк (названия агенств, которым доверяет Галина). Этот код уже написан.
В переменную top10 считывается список строк (названия агенств, входящих в топ-10).
Гарантируется, что для каждого списка будет введено хотя бы одно значение.
Программа выводит через запятую с пробелом названия агентств из топ-10, которым одновременно доверяют и Анна, и Галина.
Названия должны быть отсортированы в алфавитном порядке.
Если таких агенств нет, программа ничего не выводит.  
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: Шедеврум Про-дизайнус Коммуникатус Симфониус Динамитус
Симфониус Динамитус Импрово Шедеврум
Динамитус Шедеврум Симфониус 
<Вывод>: Динамитус, Симфониус, Шедеврум 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: Симфониус Эмпатус Эксклюзивус
Эксклюзивус Эволютус Симфониус
Шедеврум Эмпатус 
<Вывод>: nan 
<Example 3>: 
<Тип теста 3>: open 
<Ввод>: Инспиратус Экспрессивус Прогрессус Эксклюзивус
Эксклюзивус Экспрессивус Авангардус
Авангардус Инспиратус Эстетус Экспрессивус 
<Вывод>: Экспрессивус 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: Шедеврум Про-дизайнус Коммуникатус Симфониус Динамитус
Шедеврум Про-дизайнус Коммуникатус Симфониус Динамитус
Шедеврум Про-дизайнус Коммуникатус Симфониус Динамитус 
<Вывод>: Динамитус, Коммуникатус, Про-дизайнус, Симфониус, Шедеврум 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: Коммуникатус
Коммуникатус
Коммуникатус 
<Вывод>: Коммуникатус 
<Example 6>: 
<Тип теста 6>: closed 
<Ввод>: Коммуникатус Симфониус Динамитус
Шедеврум Про-дизайнус
Коммуникатус Симфониус Динамитус 
<Вывод>: nan 
<Решение студента>: anna_choice = input().split()
galina_choice = input().split()
top10 = input().split()

print(', '.join(sorted((anna_choice & galina_choice).intersection(top10)))) 
<Идеальное решение>: anna_choice = input().split()
galina_choice = input().split()
top10 = input().split()

print(', '.join(sorted((set(anna_choice) & set(galina_choice)).intersection(set(top10))))) 


<Комментарий эксперта>:"
304,629,40,"Анна и Галина выбирают, в каком агентстве заказать айдентику для бренда одежды. Реализуйте программу, которая поможет им сделать выбор:

В переменную anna_choice считывается список строк (названия агенств, которым доверяет Анна). Этот код уже написан.
В переменную galina_choice считывается список строк (названия агенств, которым доверяет Галина). Этот код уже написан.
В переменную top10 считывается список строк (названия агенств, входящих в топ-10).
Гарантируется, что для каждого списка будет введено хотя бы одно значение.
Программа выводит через запятую с пробелом названия агентств из топ-10, которым одновременно доверяют и Анна, и Галина.
Названия должны быть отсортированы в алфавитном порядке.
Если таких агенств нет, программа ничего не выводит. ","['Шедеврум Про-дизайнус Коммуникатус Симфониус Динамитус\nСимфониус Динамитус Импрово Шедеврум\nДинамитус Шедеврум Симфониус', 'Симфониус Эмпатус Эксклюзивус\nЭксклюзивус Эволютус Симфониус\nШедеврум Эмпатус', 'Инспиратус Экспрессивус Прогрессус Эксклюзивус\nЭксклюзивус Экспрессивус Авангардус\nАвангардус Инспиратус Эстетус Экспрессивус', 'Шедеврум Про-дизайнус Коммуникатус Симфониус Динамитус\nШедеврум Про-дизайнус Коммуникатус Симфониус Динамитус\nШедеврум Про-дизайнус Коммуникатус Симфониус Динамитус', 'Коммуникатус\nКоммуникатус\nКоммуникатус', 'Коммуникатус Симфониус Динамитус\nШедеврум Про-дизайнус\nКоммуникатус Симфониус Динамитус']","['Динамитус, Симфониус, Шедеврум', nan, 'Экспрессивус', 'Динамитус, Коммуникатус, Про-дизайнус, Симфониус, Шедеврум', 'Коммуникатус', nan]","anna_choice = input().split()
galina_choice = input().split()
top10 = input().split()

print(', '.join(sorted((set(anna_choice) - set(galina_choice)).intersection(set(top10)))))","anna_choice = input().split()
galina_choice = input().split()
top10 = input().split()

print(', '.join(sorted((set(anna_choice) & set(galina_choice)).intersection(set(top10)))))","Ошибка в открытых и скрытых тестах. 

Ваш код некорректно выполняет условия задания. Например, он не выполняет условия ""Программа выводит через запятую с пробелом названия агентств из топ-10, которым одновременно доверяют и Анна, и Галина"". Попробуйте изменить print() чтобы скорректировать ошибку.","['open', 'open', 'open', 'closed', 'closed', 'closed']","<Task description>: Анна и Галина выбирают, в каком агентстве заказать айдентику для бренда одежды. Реализуйте программу, которая поможет им сделать выбор:

В переменную anna_choice считывается список строк (названия агенств, которым доверяет Анна). Этот код уже написан.
В переменную galina_choice считывается список строк (названия агенств, которым доверяет Галина). Этот код уже написан.
В переменную top10 считывается список строк (названия агенств, входящих в топ-10).
Гарантируется, что для каждого списка будет введено хотя бы одно значение.
Программа выводит через запятую с пробелом названия агентств из топ-10, которым одновременно доверяют и Анна, и Галина.
Названия должны быть отсортированы в алфавитном порядке.
Если таких агенств нет, программа ничего не выводит.  
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: Шедеврум Про-дизайнус Коммуникатус Симфониус Динамитус
Симфониус Динамитус Импрово Шедеврум
Динамитус Шедеврум Симфониус 
<Вывод>: Динамитус, Симфониус, Шедеврум 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: Симфониус Эмпатус Эксклюзивус
Эксклюзивус Эволютус Симфониус
Шедеврум Эмпатус 
<Вывод>: nan 
<Example 3>: 
<Тип теста 3>: open 
<Ввод>: Инспиратус Экспрессивус Прогрессус Эксклюзивус
Эксклюзивус Экспрессивус Авангардус
Авангардус Инспиратус Эстетус Экспрессивус 
<Вывод>: Экспрессивус 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: Шедеврум Про-дизайнус Коммуникатус Симфониус Динамитус
Шедеврум Про-дизайнус Коммуникатус Симфониус Динамитус
Шедеврум Про-дизайнус Коммуникатус Симфониус Динамитус 
<Вывод>: Динамитус, Коммуникатус, Про-дизайнус, Симфониус, Шедеврум 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: Коммуникатус
Коммуникатус
Коммуникатус 
<Вывод>: Коммуникатус 
<Example 6>: 
<Тип теста 6>: closed 
<Ввод>: Коммуникатус Симфониус Динамитус
Шедеврум Про-дизайнус
Коммуникатус Симфониус Динамитус 
<Вывод>: nan 
<Решение студента>: anna_choice = input().split()
galina_choice = input().split()
top10 = input().split()

print(', '.join(sorted((set(anna_choice) - set(galina_choice)).intersection(set(top10))))) 
<Идеальное решение>: anna_choice = input().split()
galina_choice = input().split()
top10 = input().split()

print(', '.join(sorted((set(anna_choice) & set(galina_choice)).intersection(set(top10))))) 


<Комментарий эксперта>:"
305,630,40,"Анна и Галина выбирают, в каком агентстве заказать айдентику для бренда одежды. Реализуйте программу, которая поможет им сделать выбор:

В переменную anna_choice считывается список строк (названия агенств, которым доверяет Анна). Этот код уже написан.
В переменную galina_choice считывается список строк (названия агенств, которым доверяет Галина). Этот код уже написан.
В переменную top10 считывается список строк (названия агенств, входящих в топ-10).
Гарантируется, что для каждого списка будет введено хотя бы одно значение.
Программа выводит через запятую с пробелом названия агентств из топ-10, которым одновременно доверяют и Анна, и Галина.
Названия должны быть отсортированы в алфавитном порядке.
Если таких агенств нет, программа ничего не выводит. ","['Шедеврум Про-дизайнус Коммуникатус Симфониус Динамитус\nСимфониус Динамитус Импрово Шедеврум\nДинамитус Шедеврум Симфониус', 'Симфониус Эмпатус Эксклюзивус\nЭксклюзивус Эволютус Симфониус\nШедеврум Эмпатус', 'Инспиратус Экспрессивус Прогрессус Эксклюзивус\nЭксклюзивус Экспрессивус Авангардус\nАвангардус Инспиратус Эстетус Экспрессивус', 'Шедеврум Про-дизайнус Коммуникатус Симфониус Динамитус\nШедеврум Про-дизайнус Коммуникатус Симфониус Динамитус\nШедеврум Про-дизайнус Коммуникатус Симфониус Динамитус', 'Коммуникатус\nКоммуникатус\nКоммуникатус', 'Коммуникатус Симфониус Динамитус\nШедеврум Про-дизайнус\nКоммуникатус Симфониус Динамитус']","['Динамитус, Симфониус, Шедеврум', nan, 'Экспрессивус', 'Динамитус, Коммуникатус, Про-дизайнус, Симфониус, Шедеврум', 'Коммуникатус', nan]","anna_choice = input().split()
galina_choice = input().split()
top10 = input().split()

print(', '.join(sorted(set(anna_choice) & set(galina_choice) & (set(top10))))","anna_choice = input().split()
galina_choice = input().split()
top10 = input().split()

print(', '.join(sorted((set(anna_choice) & set(galina_choice)).intersection(set(top10)))))",Вы забыли поставить закрывающую скобку в print().,"['open', 'open', 'open', 'closed', 'closed', 'closed']","<Task description>: Анна и Галина выбирают, в каком агентстве заказать айдентику для бренда одежды. Реализуйте программу, которая поможет им сделать выбор:

В переменную anna_choice считывается список строк (названия агенств, которым доверяет Анна). Этот код уже написан.
В переменную galina_choice считывается список строк (названия агенств, которым доверяет Галина). Этот код уже написан.
В переменную top10 считывается список строк (названия агенств, входящих в топ-10).
Гарантируется, что для каждого списка будет введено хотя бы одно значение.
Программа выводит через запятую с пробелом названия агентств из топ-10, которым одновременно доверяют и Анна, и Галина.
Названия должны быть отсортированы в алфавитном порядке.
Если таких агенств нет, программа ничего не выводит.  
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: Шедеврум Про-дизайнус Коммуникатус Симфониус Динамитус
Симфониус Динамитус Импрово Шедеврум
Динамитус Шедеврум Симфониус 
<Вывод>: Динамитус, Симфониус, Шедеврум 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: Симфониус Эмпатус Эксклюзивус
Эксклюзивус Эволютус Симфониус
Шедеврум Эмпатус 
<Вывод>: nan 
<Example 3>: 
<Тип теста 3>: open 
<Ввод>: Инспиратус Экспрессивус Прогрессус Эксклюзивус
Эксклюзивус Экспрессивус Авангардус
Авангардус Инспиратус Эстетус Экспрессивус 
<Вывод>: Экспрессивус 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: Шедеврум Про-дизайнус Коммуникатус Симфониус Динамитус
Шедеврум Про-дизайнус Коммуникатус Симфониус Динамитус
Шедеврум Про-дизайнус Коммуникатус Симфониус Динамитус 
<Вывод>: Динамитус, Коммуникатус, Про-дизайнус, Симфониус, Шедеврум 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: Коммуникатус
Коммуникатус
Коммуникатус 
<Вывод>: Коммуникатус 
<Example 6>: 
<Тип теста 6>: closed 
<Ввод>: Коммуникатус Симфониус Динамитус
Шедеврум Про-дизайнус
Коммуникатус Симфониус Динамитус 
<Вывод>: nan 
<Решение студента>: anna_choice = input().split()
galina_choice = input().split()
top10 = input().split()

print(', '.join(sorted(set(anna_choice) & set(galina_choice) & (set(top10)))) 
<Идеальное решение>: anna_choice = input().split()
galina_choice = input().split()
top10 = input().split()

print(', '.join(sorted((set(anna_choice) & set(galina_choice)).intersection(set(top10))))) 


<Комментарий эксперта>:"
306,631,40,"Анна и Галина выбирают, в каком агентстве заказать айдентику для бренда одежды. Реализуйте программу, которая поможет им сделать выбор:

В переменную anna_choice считывается список строк (названия агенств, которым доверяет Анна). Этот код уже написан.
В переменную galina_choice считывается список строк (названия агенств, которым доверяет Галина). Этот код уже написан.
В переменную top10 считывается список строк (названия агенств, входящих в топ-10).
Гарантируется, что для каждого списка будет введено хотя бы одно значение.
Программа выводит через запятую с пробелом названия агентств из топ-10, которым одновременно доверяют и Анна, и Галина.
Названия должны быть отсортированы в алфавитном порядке.
Если таких агенств нет, программа ничего не выводит. ","['Шедеврум Про-дизайнус Коммуникатус Симфониус Динамитус\nСимфониус Динамитус Импрово Шедеврум\nДинамитус Шедеврум Симфониус', 'Симфониус Эмпатус Эксклюзивус\nЭксклюзивус Эволютус Симфониус\nШедеврум Эмпатус', 'Инспиратус Экспрессивус Прогрессус Эксклюзивус\nЭксклюзивус Экспрессивус Авангардус\nАвангардус Инспиратус Эстетус Экспрессивус', 'Шедеврум Про-дизайнус Коммуникатус Симфониус Динамитус\nШедеврум Про-дизайнус Коммуникатус Симфониус Динамитус\nШедеврум Про-дизайнус Коммуникатус Симфониус Динамитус', 'Коммуникатус\nКоммуникатус\nКоммуникатус', 'Коммуникатус Симфониус Динамитус\nШедеврум Про-дизайнус\nКоммуникатус Симфониус Динамитус']","['Динамитус, Симфониус, Шедеврум', nan, 'Экспрессивус', 'Динамитус, Коммуникатус, Про-дизайнус, Симфониус, Шедеврум', 'Коммуникатус', nan]","anna_choice = input().split()
galina_choice = input().split()
top10 = input().split()

print(', '.join(sorted((set(anna_choice) + set(galina_choice)).intersection(set(top10)))))","anna_choice = input().split()
galina_choice = input().split()
top10 = input().split()

print(', '.join(sorted((set(anna_choice) & set(galina_choice)).intersection(set(top10)))))","Ошибка в открытых и скрытых тестах. 

Обратите внимание, что оператор ""+"" не применим при сравнении множеств.","['open', 'open', 'open', 'closed', 'closed', 'closed']","<Task description>: Анна и Галина выбирают, в каком агентстве заказать айдентику для бренда одежды. Реализуйте программу, которая поможет им сделать выбор:

В переменную anna_choice считывается список строк (названия агенств, которым доверяет Анна). Этот код уже написан.
В переменную galina_choice считывается список строк (названия агенств, которым доверяет Галина). Этот код уже написан.
В переменную top10 считывается список строк (названия агенств, входящих в топ-10).
Гарантируется, что для каждого списка будет введено хотя бы одно значение.
Программа выводит через запятую с пробелом названия агентств из топ-10, которым одновременно доверяют и Анна, и Галина.
Названия должны быть отсортированы в алфавитном порядке.
Если таких агенств нет, программа ничего не выводит.  
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: Шедеврум Про-дизайнус Коммуникатус Симфониус Динамитус
Симфониус Динамитус Импрово Шедеврум
Динамитус Шедеврум Симфониус 
<Вывод>: Динамитус, Симфониус, Шедеврум 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: Симфониус Эмпатус Эксклюзивус
Эксклюзивус Эволютус Симфониус
Шедеврум Эмпатус 
<Вывод>: nan 
<Example 3>: 
<Тип теста 3>: open 
<Ввод>: Инспиратус Экспрессивус Прогрессус Эксклюзивус
Эксклюзивус Экспрессивус Авангардус
Авангардус Инспиратус Эстетус Экспрессивус 
<Вывод>: Экспрессивус 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: Шедеврум Про-дизайнус Коммуникатус Симфониус Динамитус
Шедеврум Про-дизайнус Коммуникатус Симфониус Динамитус
Шедеврум Про-дизайнус Коммуникатус Симфониус Динамитус 
<Вывод>: Динамитус, Коммуникатус, Про-дизайнус, Симфониус, Шедеврум 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: Коммуникатус
Коммуникатус
Коммуникатус 
<Вывод>: Коммуникатус 
<Example 6>: 
<Тип теста 6>: closed 
<Ввод>: Коммуникатус Симфониус Динамитус
Шедеврум Про-дизайнус
Коммуникатус Симфониус Динамитус 
<Вывод>: nan 
<Решение студента>: anna_choice = input().split()
galina_choice = input().split()
top10 = input().split()

print(', '.join(sorted((set(anna_choice) + set(galina_choice)).intersection(set(top10))))) 
<Идеальное решение>: anna_choice = input().split()
galina_choice = input().split()
top10 = input().split()

print(', '.join(sorted((set(anna_choice) & set(galina_choice)).intersection(set(top10))))) 


<Комментарий эксперта>:"
307,632,40,"Анна и Галина выбирают, в каком агентстве заказать айдентику для бренда одежды. Реализуйте программу, которая поможет им сделать выбор:

В переменную anna_choice считывается список строк (названия агенств, которым доверяет Анна). Этот код уже написан.
В переменную galina_choice считывается список строк (названия агенств, которым доверяет Галина). Этот код уже написан.
В переменную top10 считывается список строк (названия агенств, входящих в топ-10).
Гарантируется, что для каждого списка будет введено хотя бы одно значение.
Программа выводит через запятую с пробелом названия агентств из топ-10, которым одновременно доверяют и Анна, и Галина.
Названия должны быть отсортированы в алфавитном порядке.
Если таких агенств нет, программа ничего не выводит. ","['Шедеврум Про-дизайнус Коммуникатус Симфониус Динамитус\nСимфониус Динамитус Импрово Шедеврум\nДинамитус Шедеврум Симфониус', 'Симфониус Эмпатус Эксклюзивус\nЭксклюзивус Эволютус Симфониус\nШедеврум Эмпатус', 'Инспиратус Экспрессивус Прогрессус Эксклюзивус\nЭксклюзивус Экспрессивус Авангардус\nАвангардус Инспиратус Эстетус Экспрессивус', 'Шедеврум Про-дизайнус Коммуникатус Симфониус Динамитус\nШедеврум Про-дизайнус Коммуникатус Симфониус Динамитус\nШедеврум Про-дизайнус Коммуникатус Симфониус Динамитус', 'Коммуникатус\nКоммуникатус\nКоммуникатус', 'Коммуникатус Симфониус Динамитус\nШедеврум Про-дизайнус\nКоммуникатус Симфониус Динамитус']","['Динамитус, Симфониус, Шедеврум', nan, 'Экспрессивус', 'Динамитус, Коммуникатус, Про-дизайнус, Симфониус, Шедеврум', 'Коммуникатус', nan]","anna_choice = input().split()
galina_choice = input().split()
top10 = input().split()

print(', '.join(sorted((set(anna_choice) & set(galina_choice)) - set(top10))))","anna_choice = input().split()
galina_choice = input().split()
top10 = input().split()

print(', '.join(sorted((set(anna_choice) & set(galina_choice)).intersection(set(top10)))))","Ошибка в открытых и скрытых тестах. 

Ваш код некорректно выполняет условия задания. Например, он не выполняет условия ""Программа выводит через запятую с пробелом названия агентств из топ-10, которым одновременно доверяют и Анна, и Галина"". Попробуйте изменить print() чтобы скорректировать ошибку.","['open', 'open', 'open', 'closed', 'closed', 'closed']","<Task description>: Анна и Галина выбирают, в каком агентстве заказать айдентику для бренда одежды. Реализуйте программу, которая поможет им сделать выбор:

В переменную anna_choice считывается список строк (названия агенств, которым доверяет Анна). Этот код уже написан.
В переменную galina_choice считывается список строк (названия агенств, которым доверяет Галина). Этот код уже написан.
В переменную top10 считывается список строк (названия агенств, входящих в топ-10).
Гарантируется, что для каждого списка будет введено хотя бы одно значение.
Программа выводит через запятую с пробелом названия агентств из топ-10, которым одновременно доверяют и Анна, и Галина.
Названия должны быть отсортированы в алфавитном порядке.
Если таких агенств нет, программа ничего не выводит.  
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: Шедеврум Про-дизайнус Коммуникатус Симфониус Динамитус
Симфониус Динамитус Импрово Шедеврум
Динамитус Шедеврум Симфониус 
<Вывод>: Динамитус, Симфониус, Шедеврум 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: Симфониус Эмпатус Эксклюзивус
Эксклюзивус Эволютус Симфониус
Шедеврум Эмпатус 
<Вывод>: nan 
<Example 3>: 
<Тип теста 3>: open 
<Ввод>: Инспиратус Экспрессивус Прогрессус Эксклюзивус
Эксклюзивус Экспрессивус Авангардус
Авангардус Инспиратус Эстетус Экспрессивус 
<Вывод>: Экспрессивус 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: Шедеврум Про-дизайнус Коммуникатус Симфониус Динамитус
Шедеврум Про-дизайнус Коммуникатус Симфониус Динамитус
Шедеврум Про-дизайнус Коммуникатус Симфониус Динамитус 
<Вывод>: Динамитус, Коммуникатус, Про-дизайнус, Симфониус, Шедеврум 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: Коммуникатус
Коммуникатус
Коммуникатус 
<Вывод>: Коммуникатус 
<Example 6>: 
<Тип теста 6>: closed 
<Ввод>: Коммуникатус Симфониус Динамитус
Шедеврум Про-дизайнус
Коммуникатус Симфониус Динамитус 
<Вывод>: nan 
<Решение студента>: anna_choice = input().split()
galina_choice = input().split()
top10 = input().split()

print(', '.join(sorted((set(anna_choice) & set(galina_choice)) - set(top10)))) 
<Идеальное решение>: anna_choice = input().split()
galina_choice = input().split()
top10 = input().split()

print(', '.join(sorted((set(anna_choice) & set(galina_choice)).intersection(set(top10))))) 


<Комментарий эксперта>:"
308,633,40,"Анна и Галина выбирают, в каком агентстве заказать айдентику для бренда одежды. Реализуйте программу, которая поможет им сделать выбор:

В переменную anna_choice считывается список строк (названия агенств, которым доверяет Анна). Этот код уже написан.
В переменную galina_choice считывается список строк (названия агенств, которым доверяет Галина). Этот код уже написан.
В переменную top10 считывается список строк (названия агенств, входящих в топ-10).
Гарантируется, что для каждого списка будет введено хотя бы одно значение.
Программа выводит через запятую с пробелом названия агентств из топ-10, которым одновременно доверяют и Анна, и Галина.
Названия должны быть отсортированы в алфавитном порядке.
Если таких агенств нет, программа ничего не выводит. ","['Шедеврум Про-дизайнус Коммуникатус Симфониус Динамитус\nСимфониус Динамитус Импрово Шедеврум\nДинамитус Шедеврум Симфониус', 'Симфониус Эмпатус Эксклюзивус\nЭксклюзивус Эволютус Симфониус\nШедеврум Эмпатус', 'Инспиратус Экспрессивус Прогрессус Эксклюзивус\nЭксклюзивус Экспрессивус Авангардус\nАвангардус Инспиратус Эстетус Экспрессивус', 'Шедеврум Про-дизайнус Коммуникатус Симфониус Динамитус\nШедеврум Про-дизайнус Коммуникатус Симфониус Динамитус\nШедеврум Про-дизайнус Коммуникатус Симфониус Динамитус', 'Коммуникатус\nКоммуникатус\nКоммуникатус', 'Коммуникатус Симфониус Динамитус\nШедеврум Про-дизайнус\nКоммуникатус Симфониус Динамитус']","['Динамитус, Симфониус, Шедеврум', nan, 'Экспрессивус', 'Динамитус, Коммуникатус, Про-дизайнус, Симфониус, Шедеврум', 'Коммуникатус', nan]","anna_choice = input().split()
galina_choice = input().split()
top10 = input().split()

print(', '.join(sorted((set(annachoice) & set(galinachoice)).intersection(set(top10)))))","anna_choice = input().split()
galina_choice = input().split()
top10 = input().split()

print(', '.join(sorted((set(anna_choice) & set(galina_choice)).intersection(set(top10)))))","Синтаксическая ошибка, попытка обратиться к ранее не заданной переменной. Проверьте, что Вы правильно указали все переменные, к которым обращаетесь в коде.","['open', 'open', 'open', 'closed', 'closed', 'closed']","<Task description>: Анна и Галина выбирают, в каком агентстве заказать айдентику для бренда одежды. Реализуйте программу, которая поможет им сделать выбор:

В переменную anna_choice считывается список строк (названия агенств, которым доверяет Анна). Этот код уже написан.
В переменную galina_choice считывается список строк (названия агенств, которым доверяет Галина). Этот код уже написан.
В переменную top10 считывается список строк (названия агенств, входящих в топ-10).
Гарантируется, что для каждого списка будет введено хотя бы одно значение.
Программа выводит через запятую с пробелом названия агентств из топ-10, которым одновременно доверяют и Анна, и Галина.
Названия должны быть отсортированы в алфавитном порядке.
Если таких агенств нет, программа ничего не выводит.  
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: Шедеврум Про-дизайнус Коммуникатус Симфониус Динамитус
Симфониус Динамитус Импрово Шедеврум
Динамитус Шедеврум Симфониус 
<Вывод>: Динамитус, Симфониус, Шедеврум 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: Симфониус Эмпатус Эксклюзивус
Эксклюзивус Эволютус Симфониус
Шедеврум Эмпатус 
<Вывод>: nan 
<Example 3>: 
<Тип теста 3>: open 
<Ввод>: Инспиратус Экспрессивус Прогрессус Эксклюзивус
Эксклюзивус Экспрессивус Авангардус
Авангардус Инспиратус Эстетус Экспрессивус 
<Вывод>: Экспрессивус 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: Шедеврум Про-дизайнус Коммуникатус Симфониус Динамитус
Шедеврум Про-дизайнус Коммуникатус Симфониус Динамитус
Шедеврум Про-дизайнус Коммуникатус Симфониус Динамитус 
<Вывод>: Динамитус, Коммуникатус, Про-дизайнус, Симфониус, Шедеврум 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: Коммуникатус
Коммуникатус
Коммуникатус 
<Вывод>: Коммуникатус 
<Example 6>: 
<Тип теста 6>: closed 
<Ввод>: Коммуникатус Симфониус Динамитус
Шедеврум Про-дизайнус
Коммуникатус Симфониус Динамитус 
<Вывод>: nan 
<Решение студента>: anna_choice = input().split()
galina_choice = input().split()
top10 = input().split()

print(', '.join(sorted((set(annachoice) & set(galinachoice)).intersection(set(top10))))) 
<Идеальное решение>: anna_choice = input().split()
galina_choice = input().split()
top10 = input().split()

print(', '.join(sorted((set(anna_choice) & set(galina_choice)).intersection(set(top10))))) 


<Комментарий эксперта>:"
309,634,40,"Анна и Галина выбирают, в каком агентстве заказать айдентику для бренда одежды. Реализуйте программу, которая поможет им сделать выбор:

В переменную anna_choice считывается список строк (названия агенств, которым доверяет Анна). Этот код уже написан.
В переменную galina_choice считывается список строк (названия агенств, которым доверяет Галина). Этот код уже написан.
В переменную top10 считывается список строк (названия агенств, входящих в топ-10).
Гарантируется, что для каждого списка будет введено хотя бы одно значение.
Программа выводит через запятую с пробелом названия агентств из топ-10, которым одновременно доверяют и Анна, и Галина.
Названия должны быть отсортированы в алфавитном порядке.
Если таких агенств нет, программа ничего не выводит. ","['Шедеврум Про-дизайнус Коммуникатус Симфониус Динамитус\nСимфониус Динамитус Импрово Шедеврум\nДинамитус Шедеврум Симфониус', 'Симфониус Эмпатус Эксклюзивус\nЭксклюзивус Эволютус Симфониус\nШедеврум Эмпатус', 'Инспиратус Экспрессивус Прогрессус Эксклюзивус\nЭксклюзивус Экспрессивус Авангардус\nАвангардус Инспиратус Эстетус Экспрессивус', 'Шедеврум Про-дизайнус Коммуникатус Симфониус Динамитус\nШедеврум Про-дизайнус Коммуникатус Симфониус Динамитус\nШедеврум Про-дизайнус Коммуникатус Симфониус Динамитус', 'Коммуникатус\nКоммуникатус\nКоммуникатус', 'Коммуникатус Симфониус Динамитус\nШедеврум Про-дизайнус\nКоммуникатус Симфониус Динамитус']","['Динамитус, Симфониус, Шедеврум', nan, 'Экспрессивус', 'Динамитус, Коммуникатус, Про-дизайнус, Симфониус, Шедеврум', 'Коммуникатус', nan]","anna_choice = input().split()
galina_choice = input().split()
top10 = input().split()

print(', '.join(sorted((set(anna_choice) and set(galina_choice)).intersection(set(top10)))))","anna_choice = input().split()
galina_choice = input().split()
top10 = input().split()

print(', '.join(sorted((set(anna_choice) & set(galina_choice)).intersection(set(top10)))))","Ошибка в открытых и скрытых тестах. 

Обратите внимание, что оператор сравнения and не применим при сравнении множеств.","['open', 'open', 'open', 'closed', 'closed', 'closed']","<Task description>: Анна и Галина выбирают, в каком агентстве заказать айдентику для бренда одежды. Реализуйте программу, которая поможет им сделать выбор:

В переменную anna_choice считывается список строк (названия агенств, которым доверяет Анна). Этот код уже написан.
В переменную galina_choice считывается список строк (названия агенств, которым доверяет Галина). Этот код уже написан.
В переменную top10 считывается список строк (названия агенств, входящих в топ-10).
Гарантируется, что для каждого списка будет введено хотя бы одно значение.
Программа выводит через запятую с пробелом названия агентств из топ-10, которым одновременно доверяют и Анна, и Галина.
Названия должны быть отсортированы в алфавитном порядке.
Если таких агенств нет, программа ничего не выводит.  
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: Шедеврум Про-дизайнус Коммуникатус Симфониус Динамитус
Симфониус Динамитус Импрово Шедеврум
Динамитус Шедеврум Симфониус 
<Вывод>: Динамитус, Симфониус, Шедеврум 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: Симфониус Эмпатус Эксклюзивус
Эксклюзивус Эволютус Симфониус
Шедеврум Эмпатус 
<Вывод>: nan 
<Example 3>: 
<Тип теста 3>: open 
<Ввод>: Инспиратус Экспрессивус Прогрессус Эксклюзивус
Эксклюзивус Экспрессивус Авангардус
Авангардус Инспиратус Эстетус Экспрессивус 
<Вывод>: Экспрессивус 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: Шедеврум Про-дизайнус Коммуникатус Симфониус Динамитус
Шедеврум Про-дизайнус Коммуникатус Симфониус Динамитус
Шедеврум Про-дизайнус Коммуникатус Симфониус Динамитус 
<Вывод>: Динамитус, Коммуникатус, Про-дизайнус, Симфониус, Шедеврум 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: Коммуникатус
Коммуникатус
Коммуникатус 
<Вывод>: Коммуникатус 
<Example 6>: 
<Тип теста 6>: closed 
<Ввод>: Коммуникатус Симфониус Динамитус
Шедеврум Про-дизайнус
Коммуникатус Симфониус Динамитус 
<Вывод>: nan 
<Решение студента>: anna_choice = input().split()
galina_choice = input().split()
top10 = input().split()

print(', '.join(sorted((set(anna_choice) and set(galina_choice)).intersection(set(top10))))) 
<Идеальное решение>: anna_choice = input().split()
galina_choice = input().split()
top10 = input().split()

print(', '.join(sorted((set(anna_choice) & set(galina_choice)).intersection(set(top10))))) 


<Комментарий эксперта>:"
310,635,40,"Анна и Галина выбирают, в каком агентстве заказать айдентику для бренда одежды. Реализуйте программу, которая поможет им сделать выбор:

В переменную anna_choice считывается список строк (названия агенств, которым доверяет Анна). Этот код уже написан.
В переменную galina_choice считывается список строк (названия агенств, которым доверяет Галина). Этот код уже написан.
В переменную top10 считывается список строк (названия агенств, входящих в топ-10).
Гарантируется, что для каждого списка будет введено хотя бы одно значение.
Программа выводит через запятую с пробелом названия агентств из топ-10, которым одновременно доверяют и Анна, и Галина.
Названия должны быть отсортированы в алфавитном порядке.
Если таких агенств нет, программа ничего не выводит. ","['Шедеврум Про-дизайнус Коммуникатус Симфониус Динамитус\nСимфониус Динамитус Импрово Шедеврум\nДинамитус Шедеврум Симфониус', 'Симфониус Эмпатус Эксклюзивус\nЭксклюзивус Эволютус Симфониус\nШедеврум Эмпатус', 'Инспиратус Экспрессивус Прогрессус Эксклюзивус\nЭксклюзивус Экспрессивус Авангардус\nАвангардус Инспиратус Эстетус Экспрессивус', 'Шедеврум Про-дизайнус Коммуникатус Симфониус Динамитус\nШедеврум Про-дизайнус Коммуникатус Симфониус Динамитус\nШедеврум Про-дизайнус Коммуникатус Симфониус Динамитус', 'Коммуникатус\nКоммуникатус\nКоммуникатус', 'Коммуникатус Симфониус Динамитус\nШедеврум Про-дизайнус\nКоммуникатус Симфониус Динамитус']","['Динамитус, Симфониус, Шедеврум', nan, 'Экспрессивус', 'Динамитус, Коммуникатус, Про-дизайнус, Симфониус, Шедеврум', 'Коммуникатус', nan]","anna_choice = input().split()
galina_choice = input().split()
top10 = input().split()

print(', '.join((set(anna_choice) & set(galina_choice)).intersection(set(top10))))","anna_choice = input().split()
galina_choice = input().split()
top10 = input().split()

print(', '.join(sorted((set(anna_choice) & set(galina_choice)).intersection(set(top10)))))","Ошибка в открытых и скрытых тестах. 

Ваш код некорректно выполняет условия задания. Например, он не выполняет условия ""Программа выводит через запятую с пробелом названия агентств из топ-10, которым одновременно доверяют и Анна, и Галина. Названия должны быть отсортированы в алфавитном порядке"". Попробуйте изменить print() чтобы скорректировать ошибку.","['open', 'open', 'open', 'closed', 'closed', 'closed']","<Task description>: Анна и Галина выбирают, в каком агентстве заказать айдентику для бренда одежды. Реализуйте программу, которая поможет им сделать выбор:

В переменную anna_choice считывается список строк (названия агенств, которым доверяет Анна). Этот код уже написан.
В переменную galina_choice считывается список строк (названия агенств, которым доверяет Галина). Этот код уже написан.
В переменную top10 считывается список строк (названия агенств, входящих в топ-10).
Гарантируется, что для каждого списка будет введено хотя бы одно значение.
Программа выводит через запятую с пробелом названия агентств из топ-10, которым одновременно доверяют и Анна, и Галина.
Названия должны быть отсортированы в алфавитном порядке.
Если таких агенств нет, программа ничего не выводит.  
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: Шедеврум Про-дизайнус Коммуникатус Симфониус Динамитус
Симфониус Динамитус Импрово Шедеврум
Динамитус Шедеврум Симфониус 
<Вывод>: Динамитус, Симфониус, Шедеврум 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: Симфониус Эмпатус Эксклюзивус
Эксклюзивус Эволютус Симфониус
Шедеврум Эмпатус 
<Вывод>: nan 
<Example 3>: 
<Тип теста 3>: open 
<Ввод>: Инспиратус Экспрессивус Прогрессус Эксклюзивус
Эксклюзивус Экспрессивус Авангардус
Авангардус Инспиратус Эстетус Экспрессивус 
<Вывод>: Экспрессивус 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: Шедеврум Про-дизайнус Коммуникатус Симфониус Динамитус
Шедеврум Про-дизайнус Коммуникатус Симфониус Динамитус
Шедеврум Про-дизайнус Коммуникатус Симфониус Динамитус 
<Вывод>: Динамитус, Коммуникатус, Про-дизайнус, Симфониус, Шедеврум 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: Коммуникатус
Коммуникатус
Коммуникатус 
<Вывод>: Коммуникатус 
<Example 6>: 
<Тип теста 6>: closed 
<Ввод>: Коммуникатус Симфониус Динамитус
Шедеврум Про-дизайнус
Коммуникатус Симфониус Динамитус 
<Вывод>: nan 
<Решение студента>: anna_choice = input().split()
galina_choice = input().split()
top10 = input().split()

print(', '.join((set(anna_choice) & set(galina_choice)).intersection(set(top10)))) 
<Идеальное решение>: anna_choice = input().split()
galina_choice = input().split()
top10 = input().split()

print(', '.join(sorted((set(anna_choice) & set(galina_choice)).intersection(set(top10))))) 


<Комментарий эксперта>:"
311,636,40,"Анна и Галина выбирают, в каком агентстве заказать айдентику для бренда одежды. Реализуйте программу, которая поможет им сделать выбор:

В переменную anna_choice считывается список строк (названия агенств, которым доверяет Анна). Этот код уже написан.
В переменную galina_choice считывается список строк (названия агенств, которым доверяет Галина). Этот код уже написан.
В переменную top10 считывается список строк (названия агенств, входящих в топ-10).
Гарантируется, что для каждого списка будет введено хотя бы одно значение.
Программа выводит через запятую с пробелом названия агентств из топ-10, которым одновременно доверяют и Анна, и Галина.
Названия должны быть отсортированы в алфавитном порядке.
Если таких агенств нет, программа ничего не выводит. ","['Шедеврум Про-дизайнус Коммуникатус Симфониус Динамитус\nСимфониус Динамитус Импрово Шедеврум\nДинамитус Шедеврум Симфониус', 'Симфониус Эмпатус Эксклюзивус\nЭксклюзивус Эволютус Симфониус\nШедеврум Эмпатус', 'Инспиратус Экспрессивус Прогрессус Эксклюзивус\nЭксклюзивус Экспрессивус Авангардус\nАвангардус Инспиратус Эстетус Экспрессивус', 'Шедеврум Про-дизайнус Коммуникатус Симфониус Динамитус\nШедеврум Про-дизайнус Коммуникатус Симфониус Динамитус\nШедеврум Про-дизайнус Коммуникатус Симфониус Динамитус', 'Коммуникатус\nКоммуникатус\nКоммуникатус', 'Коммуникатус Симфониус Динамитус\nШедеврум Про-дизайнус\nКоммуникатус Симфониус Динамитус']","['Динамитус, Симфониус, Шедеврум', nan, 'Экспрессивус', 'Динамитус, Коммуникатус, Про-дизайнус, Симфониус, Шедеврум', 'Коммуникатус', nan]","anna_choice = input().split()
galina_choice = input().split()
top10 = input().split()

print('; '.join(sorted((set(anna_choice) & set(galina_choice)).intersection(set(top10)))))","anna_choice = input().split()
galina_choice = input().split()
top10 = input().split()

print(', '.join(sorted((set(anna_choice) & set(galina_choice)).intersection(set(top10)))))","Ошибка в открытых и скрытых тестах. 

Ваш код некорректно выполняет условия задания. Например, он не выполняет условия ""Программа выводит через запятую с пробелом названия агентств из топ-10, которым одновременно доверяют и Анна, и Галина. Названия должны быть отсортированы в алфавитном порядке"". Попробуйте изменить print() чтобы скорректировать ошибку.","['open', 'open', 'open', 'closed', 'closed', 'closed']","<Task description>: Анна и Галина выбирают, в каком агентстве заказать айдентику для бренда одежды. Реализуйте программу, которая поможет им сделать выбор:

В переменную anna_choice считывается список строк (названия агенств, которым доверяет Анна). Этот код уже написан.
В переменную galina_choice считывается список строк (названия агенств, которым доверяет Галина). Этот код уже написан.
В переменную top10 считывается список строк (названия агенств, входящих в топ-10).
Гарантируется, что для каждого списка будет введено хотя бы одно значение.
Программа выводит через запятую с пробелом названия агентств из топ-10, которым одновременно доверяют и Анна, и Галина.
Названия должны быть отсортированы в алфавитном порядке.
Если таких агенств нет, программа ничего не выводит.  
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: Шедеврум Про-дизайнус Коммуникатус Симфониус Динамитус
Симфониус Динамитус Импрово Шедеврум
Динамитус Шедеврум Симфониус 
<Вывод>: Динамитус, Симфониус, Шедеврум 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: Симфониус Эмпатус Эксклюзивус
Эксклюзивус Эволютус Симфониус
Шедеврум Эмпатус 
<Вывод>: nan 
<Example 3>: 
<Тип теста 3>: open 
<Ввод>: Инспиратус Экспрессивус Прогрессус Эксклюзивус
Эксклюзивус Экспрессивус Авангардус
Авангардус Инспиратус Эстетус Экспрессивус 
<Вывод>: Экспрессивус 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: Шедеврум Про-дизайнус Коммуникатус Симфониус Динамитус
Шедеврум Про-дизайнус Коммуникатус Симфониус Динамитус
Шедеврум Про-дизайнус Коммуникатус Симфониус Динамитус 
<Вывод>: Динамитус, Коммуникатус, Про-дизайнус, Симфониус, Шедеврум 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: Коммуникатус
Коммуникатус
Коммуникатус 
<Вывод>: Коммуникатус 
<Example 6>: 
<Тип теста 6>: closed 
<Ввод>: Коммуникатус Симфониус Динамитус
Шедеврум Про-дизайнус
Коммуникатус Симфониус Динамитус 
<Вывод>: nan 
<Решение студента>: anna_choice = input().split()
galina_choice = input().split()
top10 = input().split()

print('; '.join(sorted((set(anna_choice) & set(galina_choice)).intersection(set(top10))))) 
<Идеальное решение>: anna_choice = input().split()
galina_choice = input().split()
top10 = input().split()

print(', '.join(sorted((set(anna_choice) & set(galina_choice)).intersection(set(top10))))) 


<Комментарий эксперта>:"
312,637,40,"Анна и Галина выбирают, в каком агентстве заказать айдентику для бренда одежды. Реализуйте программу, которая поможет им сделать выбор:

В переменную anna_choice считывается список строк (названия агенств, которым доверяет Анна). Этот код уже написан.
В переменную galina_choice считывается список строк (названия агенств, которым доверяет Галина). Этот код уже написан.
В переменную top10 считывается список строк (названия агенств, входящих в топ-10).
Гарантируется, что для каждого списка будет введено хотя бы одно значение.
Программа выводит через запятую с пробелом названия агентств из топ-10, которым одновременно доверяют и Анна, и Галина.
Названия должны быть отсортированы в алфавитном порядке.
Если таких агенств нет, программа ничего не выводит. ","['Шедеврум Про-дизайнус Коммуникатус Симфониус Динамитус\nСимфониус Динамитус Импрово Шедеврум\nДинамитус Шедеврум Симфониус', 'Симфониус Эмпатус Эксклюзивус\nЭксклюзивус Эволютус Симфониус\nШедеврум Эмпатус', 'Инспиратус Экспрессивус Прогрессус Эксклюзивус\nЭксклюзивус Экспрессивус Авангардус\nАвангардус Инспиратус Эстетус Экспрессивус', 'Шедеврум Про-дизайнус Коммуникатус Симфониус Динамитус\nШедеврум Про-дизайнус Коммуникатус Симфониус Динамитус\nШедеврум Про-дизайнус Коммуникатус Симфониус Динамитус', 'Коммуникатус\nКоммуникатус\nКоммуникатус', 'Коммуникатус Симфониус Динамитус\nШедеврум Про-дизайнус\nКоммуникатус Симфониус Динамитус']","['Динамитус, Симфониус, Шедеврум', nan, 'Экспрессивус', 'Динамитус, Коммуникатус, Про-дизайнус, Симфониус, Шедеврум', 'Коммуникатус', nan]","anna_choice = input().split()
galina_choice = input().split()
top10 = input().split()

print(', '.join(sorted((set(anna_choice) & set(galina_choice)).intersection(set(top10)), reverse = True)))","anna_choice = input().split()
galina_choice = input().split()
top10 = input().split()

print(', '.join(sorted((set(anna_choice) & set(galina_choice)).intersection(set(top10)))))","Ошибка в открытых и скрытых тестах. 

Ваш код некорректно выполняет условия задания. Например, он не выполняет условия ""Названия должны быть отсортированы в алфавитном порядке"". Попробуйте изменить print() чтобы скорректировать ошибку.","['open', 'open', 'open', 'closed', 'closed', 'closed']","<Task description>: Анна и Галина выбирают, в каком агентстве заказать айдентику для бренда одежды. Реализуйте программу, которая поможет им сделать выбор:

В переменную anna_choice считывается список строк (названия агенств, которым доверяет Анна). Этот код уже написан.
В переменную galina_choice считывается список строк (названия агенств, которым доверяет Галина). Этот код уже написан.
В переменную top10 считывается список строк (названия агенств, входящих в топ-10).
Гарантируется, что для каждого списка будет введено хотя бы одно значение.
Программа выводит через запятую с пробелом названия агентств из топ-10, которым одновременно доверяют и Анна, и Галина.
Названия должны быть отсортированы в алфавитном порядке.
Если таких агенств нет, программа ничего не выводит.  
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: Шедеврум Про-дизайнус Коммуникатус Симфониус Динамитус
Симфониус Динамитус Импрово Шедеврум
Динамитус Шедеврум Симфониус 
<Вывод>: Динамитус, Симфониус, Шедеврум 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: Симфониус Эмпатус Эксклюзивус
Эксклюзивус Эволютус Симфониус
Шедеврум Эмпатус 
<Вывод>: nan 
<Example 3>: 
<Тип теста 3>: open 
<Ввод>: Инспиратус Экспрессивус Прогрессус Эксклюзивус
Эксклюзивус Экспрессивус Авангардус
Авангардус Инспиратус Эстетус Экспрессивус 
<Вывод>: Экспрессивус 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: Шедеврум Про-дизайнус Коммуникатус Симфониус Динамитус
Шедеврум Про-дизайнус Коммуникатус Симфониус Динамитус
Шедеврум Про-дизайнус Коммуникатус Симфониус Динамитус 
<Вывод>: Динамитус, Коммуникатус, Про-дизайнус, Симфониус, Шедеврум 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: Коммуникатус
Коммуникатус
Коммуникатус 
<Вывод>: Коммуникатус 
<Example 6>: 
<Тип теста 6>: closed 
<Ввод>: Коммуникатус Симфониус Динамитус
Шедеврум Про-дизайнус
Коммуникатус Симфониус Динамитус 
<Вывод>: nan 
<Решение студента>: anna_choice = input().split()
galina_choice = input().split()
top10 = input().split()

print(', '.join(sorted((set(anna_choice) & set(galina_choice)).intersection(set(top10)), reverse = True))) 
<Идеальное решение>: anna_choice = input().split()
galina_choice = input().split()
top10 = input().split()

print(', '.join(sorted((set(anna_choice) & set(galina_choice)).intersection(set(top10))))) 


<Комментарий эксперта>:"
313,638,40,"Анна и Галина выбирают, в каком агентстве заказать айдентику для бренда одежды. Реализуйте программу, которая поможет им сделать выбор:

В переменную anna_choice считывается список строк (названия агенств, которым доверяет Анна). Этот код уже написан.
В переменную galina_choice считывается список строк (названия агенств, которым доверяет Галина). Этот код уже написан.
В переменную top10 считывается список строк (названия агенств, входящих в топ-10).
Гарантируется, что для каждого списка будет введено хотя бы одно значение.
Программа выводит через запятую с пробелом названия агентств из топ-10, которым одновременно доверяют и Анна, и Галина.
Названия должны быть отсортированы в алфавитном порядке.
Если таких агенств нет, программа ничего не выводит. ","['Шедеврум Про-дизайнус Коммуникатус Симфониус Динамитус\nСимфониус Динамитус Импрово Шедеврум\nДинамитус Шедеврум Симфониус', 'Симфониус Эмпатус Эксклюзивус\nЭксклюзивус Эволютус Симфониус\nШедеврум Эмпатус', 'Инспиратус Экспрессивус Прогрессус Эксклюзивус\nЭксклюзивус Экспрессивус Авангардус\nАвангардус Инспиратус Эстетус Экспрессивус', 'Шедеврум Про-дизайнус Коммуникатус Симфониус Динамитус\nШедеврум Про-дизайнус Коммуникатус Симфониус Динамитус\nШедеврум Про-дизайнус Коммуникатус Симфониус Динамитус', 'Коммуникатус\nКоммуникатус\nКоммуникатус', 'Коммуникатус Симфониус Динамитус\nШедеврум Про-дизайнус\nКоммуникатус Симфониус Динамитус']","['Динамитус, Симфониус, Шедеврум', nan, 'Экспрессивус', 'Динамитус, Коммуникатус, Про-дизайнус, Симфониус, Шедеврум', 'Коммуникатус', nan]","anna_choice = input().split()
galina_choice = input().split()
top10 = input().split()

print(', '.join(sorted(set(anna_choice) & set(galina_choice))))","anna_choice = input().split()
galina_choice = input().split()
top10 = input().split()

print(', '.join(sorted((set(anna_choice) & set(galina_choice)).intersection(set(top10)))))","Ошибка в открытых и скрытых тестах. 

Ваш код некорректно выполняет условия задания. Например, он не выполняет условия ""Программа выводит через запятую с пробелом названия агентств из топ-10, которым одновременно доверяют и Анна, и Галина. Названия должны быть отсортированы в алфавитном порядке"". Попробуйте изменить print() чтобы скорректировать ошибку.","['open', 'open', 'open', 'closed', 'closed', 'closed']","<Task description>: Анна и Галина выбирают, в каком агентстве заказать айдентику для бренда одежды. Реализуйте программу, которая поможет им сделать выбор:

В переменную anna_choice считывается список строк (названия агенств, которым доверяет Анна). Этот код уже написан.
В переменную galina_choice считывается список строк (названия агенств, которым доверяет Галина). Этот код уже написан.
В переменную top10 считывается список строк (названия агенств, входящих в топ-10).
Гарантируется, что для каждого списка будет введено хотя бы одно значение.
Программа выводит через запятую с пробелом названия агентств из топ-10, которым одновременно доверяют и Анна, и Галина.
Названия должны быть отсортированы в алфавитном порядке.
Если таких агенств нет, программа ничего не выводит.  
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: Шедеврум Про-дизайнус Коммуникатус Симфониус Динамитус
Симфониус Динамитус Импрово Шедеврум
Динамитус Шедеврум Симфониус 
<Вывод>: Динамитус, Симфониус, Шедеврум 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: Симфониус Эмпатус Эксклюзивус
Эксклюзивус Эволютус Симфониус
Шедеврум Эмпатус 
<Вывод>: nan 
<Example 3>: 
<Тип теста 3>: open 
<Ввод>: Инспиратус Экспрессивус Прогрессус Эксклюзивус
Эксклюзивус Экспрессивус Авангардус
Авангардус Инспиратус Эстетус Экспрессивус 
<Вывод>: Экспрессивус 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: Шедеврум Про-дизайнус Коммуникатус Симфониус Динамитус
Шедеврум Про-дизайнус Коммуникатус Симфониус Динамитус
Шедеврум Про-дизайнус Коммуникатус Симфониус Динамитус 
<Вывод>: Динамитус, Коммуникатус, Про-дизайнус, Симфониус, Шедеврум 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: Коммуникатус
Коммуникатус
Коммуникатус 
<Вывод>: Коммуникатус 
<Example 6>: 
<Тип теста 6>: closed 
<Ввод>: Коммуникатус Симфониус Динамитус
Шедеврум Про-дизайнус
Коммуникатус Симфониус Динамитус 
<Вывод>: nan 
<Решение студента>: anna_choice = input().split()
galina_choice = input().split()
top10 = input().split()

print(', '.join(sorted(set(anna_choice) & set(galina_choice)))) 
<Идеальное решение>: anna_choice = input().split()
galina_choice = input().split()
top10 = input().split()

print(', '.join(sorted((set(anna_choice) & set(galina_choice)).intersection(set(top10))))) 


<Комментарий эксперта>:"
314,639,40,"Анна и Галина выбирают, в каком агентстве заказать айдентику для бренда одежды. Реализуйте программу, которая поможет им сделать выбор:

В переменную anna_choice считывается список строк (названия агенств, которым доверяет Анна). Этот код уже написан.
В переменную galina_choice считывается список строк (названия агенств, которым доверяет Галина). Этот код уже написан.
В переменную top10 считывается список строк (названия агенств, входящих в топ-10).
Гарантируется, что для каждого списка будет введено хотя бы одно значение.
Программа выводит через запятую с пробелом названия агентств из топ-10, которым одновременно доверяют и Анна, и Галина.
Названия должны быть отсортированы в алфавитном порядке.
Если таких агенств нет, программа ничего не выводит. ","['Шедеврум Про-дизайнус Коммуникатус Симфониус Динамитус\nСимфониус Динамитус Импрово Шедеврум\nДинамитус Шедеврум Симфониус', 'Симфониус Эмпатус Эксклюзивус\nЭксклюзивус Эволютус Симфониус\nШедеврум Эмпатус', 'Инспиратус Экспрессивус Прогрессус Эксклюзивус\nЭксклюзивус Экспрессивус Авангардус\nАвангардус Инспиратус Эстетус Экспрессивус', 'Шедеврум Про-дизайнус Коммуникатус Симфониус Динамитус\nШедеврум Про-дизайнус Коммуникатус Симфониус Динамитус\nШедеврум Про-дизайнус Коммуникатус Симфониус Динамитус', 'Коммуникатус\nКоммуникатус\nКоммуникатус', 'Коммуникатус Симфониус Динамитус\nШедеврум Про-дизайнус\nКоммуникатус Симфониус Динамитус']","['Динамитус, Симфониус, Шедеврум', nan, 'Экспрессивус', 'Динамитус, Коммуникатус, Про-дизайнус, Симфониус, Шедеврум', 'Коммуникатус', nan]","anna_choice = input().split()
galina_choice = input().split()
top10 = input().split()

print(', '.join(sorted(set(anna_choice) & set(top10))))","anna_choice = input().split()
galina_choice = input().split()
top10 = input().split()

print(', '.join(sorted((set(anna_choice) & set(galina_choice)).intersection(set(top10)))))","Ошибка в открытых и скрытых тестах. 

Ваш код некорректно выполняет условия задания. Например, он не выполняет условия ""Программа выводит через запятую с пробелом названия агентств из топ-10, которым одновременно доверяют и Анна, и Галина. Названия должны быть отсортированы в алфавитном порядке"". Попробуйте изменить print() чтобы скорректировать ошибку.","['open', 'open', 'open', 'closed', 'closed', 'closed']","<Task description>: Анна и Галина выбирают, в каком агентстве заказать айдентику для бренда одежды. Реализуйте программу, которая поможет им сделать выбор:

В переменную anna_choice считывается список строк (названия агенств, которым доверяет Анна). Этот код уже написан.
В переменную galina_choice считывается список строк (названия агенств, которым доверяет Галина). Этот код уже написан.
В переменную top10 считывается список строк (названия агенств, входящих в топ-10).
Гарантируется, что для каждого списка будет введено хотя бы одно значение.
Программа выводит через запятую с пробелом названия агентств из топ-10, которым одновременно доверяют и Анна, и Галина.
Названия должны быть отсортированы в алфавитном порядке.
Если таких агенств нет, программа ничего не выводит.  
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: Шедеврум Про-дизайнус Коммуникатус Симфониус Динамитус
Симфониус Динамитус Импрово Шедеврум
Динамитус Шедеврум Симфониус 
<Вывод>: Динамитус, Симфониус, Шедеврум 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: Симфониус Эмпатус Эксклюзивус
Эксклюзивус Эволютус Симфониус
Шедеврум Эмпатус 
<Вывод>: nan 
<Example 3>: 
<Тип теста 3>: open 
<Ввод>: Инспиратус Экспрессивус Прогрессус Эксклюзивус
Эксклюзивус Экспрессивус Авангардус
Авангардус Инспиратус Эстетус Экспрессивус 
<Вывод>: Экспрессивус 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: Шедеврум Про-дизайнус Коммуникатус Симфониус Динамитус
Шедеврум Про-дизайнус Коммуникатус Симфониус Динамитус
Шедеврум Про-дизайнус Коммуникатус Симфониус Динамитус 
<Вывод>: Динамитус, Коммуникатус, Про-дизайнус, Симфониус, Шедеврум 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: Коммуникатус
Коммуникатус
Коммуникатус 
<Вывод>: Коммуникатус 
<Example 6>: 
<Тип теста 6>: closed 
<Ввод>: Коммуникатус Симфониус Динамитус
Шедеврум Про-дизайнус
Коммуникатус Симфониус Динамитус 
<Вывод>: nan 
<Решение студента>: anna_choice = input().split()
galina_choice = input().split()
top10 = input().split()

print(', '.join(sorted(set(anna_choice) & set(top10)))) 
<Идеальное решение>: anna_choice = input().split()
galina_choice = input().split()
top10 = input().split()

print(', '.join(sorted((set(anna_choice) & set(galina_choice)).intersection(set(top10))))) 


<Комментарий эксперта>:"
315,640,40,"Анна и Галина выбирают, в каком агентстве заказать айдентику для бренда одежды. Реализуйте программу, которая поможет им сделать выбор:

В переменную anna_choice считывается список строк (названия агенств, которым доверяет Анна). Этот код уже написан.
В переменную galina_choice считывается список строк (названия агенств, которым доверяет Галина). Этот код уже написан.
В переменную top10 считывается список строк (названия агенств, входящих в топ-10).
Гарантируется, что для каждого списка будет введено хотя бы одно значение.
Программа выводит через запятую с пробелом названия агентств из топ-10, которым одновременно доверяют и Анна, и Галина.
Названия должны быть отсортированы в алфавитном порядке.
Если таких агенств нет, программа ничего не выводит. ","['Шедеврум Про-дизайнус Коммуникатус Симфониус Динамитус\nСимфониус Динамитус Импрово Шедеврум\nДинамитус Шедеврум Симфониус', 'Симфониус Эмпатус Эксклюзивус\nЭксклюзивус Эволютус Симфониус\nШедеврум Эмпатус', 'Инспиратус Экспрессивус Прогрессус Эксклюзивус\nЭксклюзивус Экспрессивус Авангардус\nАвангардус Инспиратус Эстетус Экспрессивус', 'Шедеврум Про-дизайнус Коммуникатус Симфониус Динамитус\nШедеврум Про-дизайнус Коммуникатус Симфониус Динамитус\nШедеврум Про-дизайнус Коммуникатус Симфониус Динамитус', 'Коммуникатус\nКоммуникатус\nКоммуникатус', 'Коммуникатус Симфониус Динамитус\nШедеврум Про-дизайнус\nКоммуникатус Симфониус Динамитус']","['Динамитус, Симфониус, Шедеврум', nan, 'Экспрессивус', 'Динамитус, Коммуникатус, Про-дизайнус, Симфониус, Шедеврум', 'Коммуникатус', nan]","anna_choice = input().split()
galina_choice = input().split()
top10 = input().split()

print(', '.join(sorted(set(galina_choice) & set(top10))))","anna_choice = input().split()
galina_choice = input().split()
top10 = input().split()

print(', '.join(sorted((set(anna_choice) & set(galina_choice)).intersection(set(top10)))))","Ошибка в открытых и скрытых тестах. 

Ваш код некорректно выполняет условия задания. Например, он не выполняет условия ""Программа выводит через запятую с пробелом названия агентств из топ-10, которым одновременно доверяют и Анна, и Галина. Названия должны быть отсортированы в алфавитном порядке"". Попробуйте изменить print() чтобы скорректировать ошибку.","['open', 'open', 'open', 'closed', 'closed', 'closed']","<Task description>: Анна и Галина выбирают, в каком агентстве заказать айдентику для бренда одежды. Реализуйте программу, которая поможет им сделать выбор:

В переменную anna_choice считывается список строк (названия агенств, которым доверяет Анна). Этот код уже написан.
В переменную galina_choice считывается список строк (названия агенств, которым доверяет Галина). Этот код уже написан.
В переменную top10 считывается список строк (названия агенств, входящих в топ-10).
Гарантируется, что для каждого списка будет введено хотя бы одно значение.
Программа выводит через запятую с пробелом названия агентств из топ-10, которым одновременно доверяют и Анна, и Галина.
Названия должны быть отсортированы в алфавитном порядке.
Если таких агенств нет, программа ничего не выводит.  
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: Шедеврум Про-дизайнус Коммуникатус Симфониус Динамитус
Симфониус Динамитус Импрово Шедеврум
Динамитус Шедеврум Симфониус 
<Вывод>: Динамитус, Симфониус, Шедеврум 
<Example 2>: 
<Тип теста 2>: open 
<Ввод>: Симфониус Эмпатус Эксклюзивус
Эксклюзивус Эволютус Симфониус
Шедеврум Эмпатус 
<Вывод>: nan 
<Example 3>: 
<Тип теста 3>: open 
<Ввод>: Инспиратус Экспрессивус Прогрессус Эксклюзивус
Эксклюзивус Экспрессивус Авангардус
Авангардус Инспиратус Эстетус Экспрессивус 
<Вывод>: Экспрессивус 
<Example 4>: 
<Тип теста 4>: closed 
<Ввод>: Шедеврум Про-дизайнус Коммуникатус Симфониус Динамитус
Шедеврум Про-дизайнус Коммуникатус Симфониус Динамитус
Шедеврум Про-дизайнус Коммуникатус Симфониус Динамитус 
<Вывод>: Динамитус, Коммуникатус, Про-дизайнус, Симфониус, Шедеврум 
<Example 5>: 
<Тип теста 5>: closed 
<Ввод>: Коммуникатус
Коммуникатус
Коммуникатус 
<Вывод>: Коммуникатус 
<Example 6>: 
<Тип теста 6>: closed 
<Ввод>: Коммуникатус Симфониус Динамитус
Шедеврум Про-дизайнус
Коммуникатус Симфониус Динамитус 
<Вывод>: nan 
<Решение студента>: anna_choice = input().split()
galina_choice = input().split()
top10 = input().split()

print(', '.join(sorted(set(galina_choice) & set(top10)))) 
<Идеальное решение>: anna_choice = input().split()
galina_choice = input().split()
top10 = input().split()

print(', '.join(sorted((set(anna_choice) & set(galina_choice)).intersection(set(top10))))) 


<Комментарий эксперта>:"
316,667,43,"Галина анализирует стоимость услуг дизайнеров для ее сайта, которые собраны в файле формата csv. Напишите программу, которая выводит все строки с услугами интересующего дизайнера, а стоимость каждой услуги не превышает 5000 рублей.

Программа должна открывать структурированный текстовый файл offers.csv, в кодировке utf-8, где на каждой строке записана следующая информация об услугах: название услуги, имя дизайнера, стоимость услуги. Например, строка ""Создание лендинга, Анастасия Иванова, 12000 р."" означает, что за создание лендинга дизайнер Анастасия Иванова запрашивает 12000 рублей.
Гарантируется, что стоимость услуги всегда записана в формате ""<целое число> р."".
Разделителями данных в файле служат запятые с пробелом.
Гарантируется, что в файле есть как минимум одна строка с данными. 
С клавиатуры вводится строка — имя дизайнера. Этот код уже написан.
Программа должна выводить строки из оригинального файла, в которых есть только услуги интересующего дизайнера, а стоимость каждой услуги не превышает 5000 рублей (не забудьте удалить символы конца строки!).
Если подходящих под условие строк в файле нет, то программа ничего не выводит.
ДОПОЛНИТЕЛЬНО
Ваше решение будет проверяться на закрытых тестах. Ваш код должен считывать файл offers.csv без дополнительных указаний (например, пути к файлу на вашем компьютере).
В открытом тесте используется файл offers.csv. Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.","['Александр Смирнов', 'Мария Иванова', 'Дмитрий Михайлов']","['Разработка логотипа, Александр Смирнов, 4000 р.\nСоздание анимации, Александр Смирнов, 2000 р.\nСоздание карточек для социальных сетей, Александр Смирнов, 3500 р.', 'Создание иллюстрации, Мария Иванова, 5000 р.', nan]","name = input()

open('offers.csv', encoding='utf-8') as infile:
    for line in infile:
        info = line.strip().split(', ')
        if info[1] == name and int(info[-1].split()[0]) <= 5000:
            print(line.strip())","name = input()

with open('offers.csv', encoding='utf-8') as infile:
    for line in infile:
        info = line.strip().split(', ')
        if info[1] == name and int(info[-1].split()[0]) <= 5000:
            print(line.strip())",Некорректный синтаксис при использовании функции open.,"['open', 'closed', 'closed']","<Task description>: Галина анализирует стоимость услуг дизайнеров для ее сайта, которые собраны в файле формата csv. Напишите программу, которая выводит все строки с услугами интересующего дизайнера, а стоимость каждой услуги не превышает 5000 рублей.

Программа должна открывать структурированный текстовый файл offers.csv, в кодировке utf-8, где на каждой строке записана следующая информация об услугах: название услуги, имя дизайнера, стоимость услуги. Например, строка ""Создание лендинга, Анастасия Иванова, 12000 р."" означает, что за создание лендинга дизайнер Анастасия Иванова запрашивает 12000 рублей.
Гарантируется, что стоимость услуги всегда записана в формате ""<целое число> р."".
Разделителями данных в файле служат запятые с пробелом.
Гарантируется, что в файле есть как минимум одна строка с данными. 
С клавиатуры вводится строка — имя дизайнера. Этот код уже написан.
Программа должна выводить строки из оригинального файла, в которых есть только услуги интересующего дизайнера, а стоимость каждой услуги не превышает 5000 рублей (не забудьте удалить символы конца строки!).
Если подходящих под условие строк в файле нет, то программа ничего не выводит.
ДОПОЛНИТЕЛЬНО
Ваше решение будет проверяться на закрытых тестах. Ваш код должен считывать файл offers.csv без дополнительных указаний (например, пути к файлу на вашем компьютере).
В открытом тесте используется файл offers.csv. Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: Александр Смирнов 
<Вывод>: Разработка логотипа, Александр Смирнов, 4000 р.
Создание анимации, Александр Смирнов, 2000 р.
Создание карточек для социальных сетей, Александр Смирнов, 3500 р. 
<Example 2>: 
<Тип теста 2>: closed 
<Ввод>: Мария Иванова 
<Вывод>: Создание иллюстрации, Мария Иванова, 5000 р. 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: Дмитрий Михайлов 
<Вывод>: nan 
<Решение студента>: name = input()

open('offers.csv', encoding='utf-8') as infile:
    for line in infile:
        info = line.strip().split(', ')
        if info[1] == name and int(info[-1].split()[0]) <= 5000:
            print(line.strip()) 
<Идеальное решение>: name = input()

with open('offers.csv', encoding='utf-8') as infile:
    for line in infile:
        info = line.strip().split(', ')
        if info[1] == name and int(info[-1].split()[0]) <= 5000:
            print(line.strip()) 


<Комментарий эксперта>:"
317,668,43,"Галина анализирует стоимость услуг дизайнеров для ее сайта, которые собраны в файле формата csv. Напишите программу, которая выводит все строки с услугами интересующего дизайнера, а стоимость каждой услуги не превышает 5000 рублей.

Программа должна открывать структурированный текстовый файл offers.csv, в кодировке utf-8, где на каждой строке записана следующая информация об услугах: название услуги, имя дизайнера, стоимость услуги. Например, строка ""Создание лендинга, Анастасия Иванова, 12000 р."" означает, что за создание лендинга дизайнер Анастасия Иванова запрашивает 12000 рублей.
Гарантируется, что стоимость услуги всегда записана в формате ""<целое число> р."".
Разделителями данных в файле служат запятые с пробелом.
Гарантируется, что в файле есть как минимум одна строка с данными. 
С клавиатуры вводится строка — имя дизайнера. Этот код уже написан.
Программа должна выводить строки из оригинального файла, в которых есть только услуги интересующего дизайнера, а стоимость каждой услуги не превышает 5000 рублей (не забудьте удалить символы конца строки!).
Если подходящих под условие строк в файле нет, то программа ничего не выводит.
ДОПОЛНИТЕЛЬНО
Ваше решение будет проверяться на закрытых тестах. Ваш код должен считывать файл offers.csv без дополнительных указаний (например, пути к файлу на вашем компьютере).
В открытом тесте используется файл offers.csv. Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.","['Александр Смирнов', 'Мария Иванова', 'Дмитрий Михайлов']","['Разработка логотипа, Александр Смирнов, 4000 р.\nСоздание анимации, Александр Смирнов, 2000 р.\nСоздание карточек для социальных сетей, Александр Смирнов, 3500 р.', 'Создание иллюстрации, Мария Иванова, 5000 р.', nan]","name = input()

with open('offers.txt', encoding='utf-8') as infile:
    for line in infile:
        info = line.strip().split(', ')
        if info[1] == name and int(info[-1].split()[0]) <= 5000:
            print(line.strip())","name = input()

with open('offers.csv', encoding='utf-8') as infile:
    for line in infile:
        info = line.strip().split(', ')
        if info[1] == name and int(info[-1].split()[0]) <= 5000:
            print(line.strip())",Ошибка при открытии файла. Обращение к файлу некорректного формата.,"['open', 'closed', 'closed']","<Task description>: Галина анализирует стоимость услуг дизайнеров для ее сайта, которые собраны в файле формата csv. Напишите программу, которая выводит все строки с услугами интересующего дизайнера, а стоимость каждой услуги не превышает 5000 рублей.

Программа должна открывать структурированный текстовый файл offers.csv, в кодировке utf-8, где на каждой строке записана следующая информация об услугах: название услуги, имя дизайнера, стоимость услуги. Например, строка ""Создание лендинга, Анастасия Иванова, 12000 р."" означает, что за создание лендинга дизайнер Анастасия Иванова запрашивает 12000 рублей.
Гарантируется, что стоимость услуги всегда записана в формате ""<целое число> р."".
Разделителями данных в файле служат запятые с пробелом.
Гарантируется, что в файле есть как минимум одна строка с данными. 
С клавиатуры вводится строка — имя дизайнера. Этот код уже написан.
Программа должна выводить строки из оригинального файла, в которых есть только услуги интересующего дизайнера, а стоимость каждой услуги не превышает 5000 рублей (не забудьте удалить символы конца строки!).
Если подходящих под условие строк в файле нет, то программа ничего не выводит.
ДОПОЛНИТЕЛЬНО
Ваше решение будет проверяться на закрытых тестах. Ваш код должен считывать файл offers.csv без дополнительных указаний (например, пути к файлу на вашем компьютере).
В открытом тесте используется файл offers.csv. Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: Александр Смирнов 
<Вывод>: Разработка логотипа, Александр Смирнов, 4000 р.
Создание анимации, Александр Смирнов, 2000 р.
Создание карточек для социальных сетей, Александр Смирнов, 3500 р. 
<Example 2>: 
<Тип теста 2>: closed 
<Ввод>: Мария Иванова 
<Вывод>: Создание иллюстрации, Мария Иванова, 5000 р. 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: Дмитрий Михайлов 
<Вывод>: nan 
<Решение студента>: name = input()

with open('offers.txt', encoding='utf-8') as infile:
    for line in infile:
        info = line.strip().split(', ')
        if info[1] == name and int(info[-1].split()[0]) <= 5000:
            print(line.strip()) 
<Идеальное решение>: name = input()

with open('offers.csv', encoding='utf-8') as infile:
    for line in infile:
        info = line.strip().split(', ')
        if info[1] == name and int(info[-1].split()[0]) <= 5000:
            print(line.strip()) 


<Комментарий эксперта>:"
318,669,43,"Галина анализирует стоимость услуг дизайнеров для ее сайта, которые собраны в файле формата csv. Напишите программу, которая выводит все строки с услугами интересующего дизайнера, а стоимость каждой услуги не превышает 5000 рублей.

Программа должна открывать структурированный текстовый файл offers.csv, в кодировке utf-8, где на каждой строке записана следующая информация об услугах: название услуги, имя дизайнера, стоимость услуги. Например, строка ""Создание лендинга, Анастасия Иванова, 12000 р."" означает, что за создание лендинга дизайнер Анастасия Иванова запрашивает 12000 рублей.
Гарантируется, что стоимость услуги всегда записана в формате ""<целое число> р."".
Разделителями данных в файле служат запятые с пробелом.
Гарантируется, что в файле есть как минимум одна строка с данными. 
С клавиатуры вводится строка — имя дизайнера. Этот код уже написан.
Программа должна выводить строки из оригинального файла, в которых есть только услуги интересующего дизайнера, а стоимость каждой услуги не превышает 5000 рублей (не забудьте удалить символы конца строки!).
Если подходящих под условие строк в файле нет, то программа ничего не выводит.
ДОПОЛНИТЕЛЬНО
Ваше решение будет проверяться на закрытых тестах. Ваш код должен считывать файл offers.csv без дополнительных указаний (например, пути к файлу на вашем компьютере).
В открытом тесте используется файл offers.csv. Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.","['Александр Смирнов', 'Мария Иванова', 'Дмитрий Михайлов']","['Разработка логотипа, Александр Смирнов, 4000 р.\nСоздание анимации, Александр Смирнов, 2000 р.\nСоздание карточек для социальных сетей, Александр Смирнов, 3500 р.', 'Создание иллюстрации, Мария Иванова, 5000 р.', nan]","name = input()

with open('offers.csv', encoding='utf-8') as file:
    for line in infile:
        info = line.strip().split(', ')
        if info[1] == name and int(info[-1].split()[0]) <= 5000:
            print(line.strip())","name = input()

with open('offers.csv', encoding='utf-8') as infile:
    for line in infile:
        info = line.strip().split(', ')
        if info[1] == name and int(info[-1].split()[0]) <= 5000:
            print(line.strip())","Ошибка при обращении к незаданной переменной. Проверьте, что все Ваши переменные корректно заданы.","['open', 'closed', 'closed']","<Task description>: Галина анализирует стоимость услуг дизайнеров для ее сайта, которые собраны в файле формата csv. Напишите программу, которая выводит все строки с услугами интересующего дизайнера, а стоимость каждой услуги не превышает 5000 рублей.

Программа должна открывать структурированный текстовый файл offers.csv, в кодировке utf-8, где на каждой строке записана следующая информация об услугах: название услуги, имя дизайнера, стоимость услуги. Например, строка ""Создание лендинга, Анастасия Иванова, 12000 р."" означает, что за создание лендинга дизайнер Анастасия Иванова запрашивает 12000 рублей.
Гарантируется, что стоимость услуги всегда записана в формате ""<целое число> р."".
Разделителями данных в файле служат запятые с пробелом.
Гарантируется, что в файле есть как минимум одна строка с данными. 
С клавиатуры вводится строка — имя дизайнера. Этот код уже написан.
Программа должна выводить строки из оригинального файла, в которых есть только услуги интересующего дизайнера, а стоимость каждой услуги не превышает 5000 рублей (не забудьте удалить символы конца строки!).
Если подходящих под условие строк в файле нет, то программа ничего не выводит.
ДОПОЛНИТЕЛЬНО
Ваше решение будет проверяться на закрытых тестах. Ваш код должен считывать файл offers.csv без дополнительных указаний (например, пути к файлу на вашем компьютере).
В открытом тесте используется файл offers.csv. Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: Александр Смирнов 
<Вывод>: Разработка логотипа, Александр Смирнов, 4000 р.
Создание анимации, Александр Смирнов, 2000 р.
Создание карточек для социальных сетей, Александр Смирнов, 3500 р. 
<Example 2>: 
<Тип теста 2>: closed 
<Ввод>: Мария Иванова 
<Вывод>: Создание иллюстрации, Мария Иванова, 5000 р. 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: Дмитрий Михайлов 
<Вывод>: nan 
<Решение студента>: name = input()

with open('offers.csv', encoding='utf-8') as file:
    for line in infile:
        info = line.strip().split(', ')
        if info[1] == name and int(info[-1].split()[0]) <= 5000:
            print(line.strip()) 
<Идеальное решение>: name = input()

with open('offers.csv', encoding='utf-8') as infile:
    for line in infile:
        info = line.strip().split(', ')
        if info[1] == name and int(info[-1].split()[0]) <= 5000:
            print(line.strip()) 


<Комментарий эксперта>:"
319,670,43,"Галина анализирует стоимость услуг дизайнеров для ее сайта, которые собраны в файле формата csv. Напишите программу, которая выводит все строки с услугами интересующего дизайнера, а стоимость каждой услуги не превышает 5000 рублей.

Программа должна открывать структурированный текстовый файл offers.csv, в кодировке utf-8, где на каждой строке записана следующая информация об услугах: название услуги, имя дизайнера, стоимость услуги. Например, строка ""Создание лендинга, Анастасия Иванова, 12000 р."" означает, что за создание лендинга дизайнер Анастасия Иванова запрашивает 12000 рублей.
Гарантируется, что стоимость услуги всегда записана в формате ""<целое число> р."".
Разделителями данных в файле служат запятые с пробелом.
Гарантируется, что в файле есть как минимум одна строка с данными. 
С клавиатуры вводится строка — имя дизайнера. Этот код уже написан.
Программа должна выводить строки из оригинального файла, в которых есть только услуги интересующего дизайнера, а стоимость каждой услуги не превышает 5000 рублей (не забудьте удалить символы конца строки!).
Если подходящих под условие строк в файле нет, то программа ничего не выводит.
ДОПОЛНИТЕЛЬНО
Ваше решение будет проверяться на закрытых тестах. Ваш код должен считывать файл offers.csv без дополнительных указаний (например, пути к файлу на вашем компьютере).
В открытом тесте используется файл offers.csv. Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.","['Александр Смирнов', 'Мария Иванова', 'Дмитрий Михайлов']","['Разработка логотипа, Александр Смирнов, 4000 р.\nСоздание анимации, Александр Смирнов, 2000 р.\nСоздание карточек для социальных сетей, Александр Смирнов, 3500 р.', 'Создание иллюстрации, Мария Иванова, 5000 р.', nan]","name = input()

with open(offers.csv, encoding='utf-8') as infile:
    for line in infile:
        info = line.strip().split(', ')
        if info[1] == name and int(info[-1].split()[0]) <= 5000:
            print(line.strip())","name = input()

with open('offers.csv', encoding='utf-8') as infile:
    for line in infile:
        info = line.strip().split(', ')
        if info[1] == name and int(info[-1].split()[0]) <= 5000:
            print(line.strip())",Ошибка при открытии файла. При обращении к файлу необходимо заключать его название в кавычки.,"['open', 'closed', 'closed']","<Task description>: Галина анализирует стоимость услуг дизайнеров для ее сайта, которые собраны в файле формата csv. Напишите программу, которая выводит все строки с услугами интересующего дизайнера, а стоимость каждой услуги не превышает 5000 рублей.

Программа должна открывать структурированный текстовый файл offers.csv, в кодировке utf-8, где на каждой строке записана следующая информация об услугах: название услуги, имя дизайнера, стоимость услуги. Например, строка ""Создание лендинга, Анастасия Иванова, 12000 р."" означает, что за создание лендинга дизайнер Анастасия Иванова запрашивает 12000 рублей.
Гарантируется, что стоимость услуги всегда записана в формате ""<целое число> р."".
Разделителями данных в файле служат запятые с пробелом.
Гарантируется, что в файле есть как минимум одна строка с данными. 
С клавиатуры вводится строка — имя дизайнера. Этот код уже написан.
Программа должна выводить строки из оригинального файла, в которых есть только услуги интересующего дизайнера, а стоимость каждой услуги не превышает 5000 рублей (не забудьте удалить символы конца строки!).
Если подходящих под условие строк в файле нет, то программа ничего не выводит.
ДОПОЛНИТЕЛЬНО
Ваше решение будет проверяться на закрытых тестах. Ваш код должен считывать файл offers.csv без дополнительных указаний (например, пути к файлу на вашем компьютере).
В открытом тесте используется файл offers.csv. Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: Александр Смирнов 
<Вывод>: Разработка логотипа, Александр Смирнов, 4000 р.
Создание анимации, Александр Смирнов, 2000 р.
Создание карточек для социальных сетей, Александр Смирнов, 3500 р. 
<Example 2>: 
<Тип теста 2>: closed 
<Ввод>: Мария Иванова 
<Вывод>: Создание иллюстрации, Мария Иванова, 5000 р. 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: Дмитрий Михайлов 
<Вывод>: nan 
<Решение студента>: name = input()

with open(offers.csv, encoding='utf-8') as infile:
    for line in infile:
        info = line.strip().split(', ')
        if info[1] == name and int(info[-1].split()[0]) <= 5000:
            print(line.strip()) 
<Идеальное решение>: name = input()

with open('offers.csv', encoding='utf-8') as infile:
    for line in infile:
        info = line.strip().split(', ')
        if info[1] == name and int(info[-1].split()[0]) <= 5000:
            print(line.strip()) 


<Комментарий эксперта>:"
320,671,43,"Галина анализирует стоимость услуг дизайнеров для ее сайта, которые собраны в файле формата csv. Напишите программу, которая выводит все строки с услугами интересующего дизайнера, а стоимость каждой услуги не превышает 5000 рублей.

Программа должна открывать структурированный текстовый файл offers.csv, в кодировке utf-8, где на каждой строке записана следующая информация об услугах: название услуги, имя дизайнера, стоимость услуги. Например, строка ""Создание лендинга, Анастасия Иванова, 12000 р."" означает, что за создание лендинга дизайнер Анастасия Иванова запрашивает 12000 рублей.
Гарантируется, что стоимость услуги всегда записана в формате ""<целое число> р."".
Разделителями данных в файле служат запятые с пробелом.
Гарантируется, что в файле есть как минимум одна строка с данными. 
С клавиатуры вводится строка — имя дизайнера. Этот код уже написан.
Программа должна выводить строки из оригинального файла, в которых есть только услуги интересующего дизайнера, а стоимость каждой услуги не превышает 5000 рублей (не забудьте удалить символы конца строки!).
Если подходящих под условие строк в файле нет, то программа ничего не выводит.
ДОПОЛНИТЕЛЬНО
Ваше решение будет проверяться на закрытых тестах. Ваш код должен считывать файл offers.csv без дополнительных указаний (например, пути к файлу на вашем компьютере).
В открытом тесте используется файл offers.csv. Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.","['Александр Смирнов', 'Мария Иванова', 'Дмитрий Михайлов']","['Разработка логотипа, Александр Смирнов, 4000 р.\nСоздание анимации, Александр Смирнов, 2000 р.\nСоздание карточек для социальных сетей, Александр Смирнов, 3500 р.', 'Создание иллюстрации, Мария Иванова, 5000 р.', nan]","name = input()

with open('offers.csv', encoding='utf-8') as infile:
    for line in infile:
        info = line.split(',')
        if info[1] == name and int(info[-1].split()[0]) <= 5000:
            print(line.strip())","name = input()

with open('offers.csv', encoding='utf-8') as infile:
    for line in infile:
        info = line.strip().split(', ')
        if info[1] == name and int(info[-1].split()[0]) <= 5000:
            print(line.strip())","Ошибка в открытых и скрытых тестах. 

Ваш код использует неверный параметр в функции split().","['open', 'closed', 'closed']","<Task description>: Галина анализирует стоимость услуг дизайнеров для ее сайта, которые собраны в файле формата csv. Напишите программу, которая выводит все строки с услугами интересующего дизайнера, а стоимость каждой услуги не превышает 5000 рублей.

Программа должна открывать структурированный текстовый файл offers.csv, в кодировке utf-8, где на каждой строке записана следующая информация об услугах: название услуги, имя дизайнера, стоимость услуги. Например, строка ""Создание лендинга, Анастасия Иванова, 12000 р."" означает, что за создание лендинга дизайнер Анастасия Иванова запрашивает 12000 рублей.
Гарантируется, что стоимость услуги всегда записана в формате ""<целое число> р."".
Разделителями данных в файле служат запятые с пробелом.
Гарантируется, что в файле есть как минимум одна строка с данными. 
С клавиатуры вводится строка — имя дизайнера. Этот код уже написан.
Программа должна выводить строки из оригинального файла, в которых есть только услуги интересующего дизайнера, а стоимость каждой услуги не превышает 5000 рублей (не забудьте удалить символы конца строки!).
Если подходящих под условие строк в файле нет, то программа ничего не выводит.
ДОПОЛНИТЕЛЬНО
Ваше решение будет проверяться на закрытых тестах. Ваш код должен считывать файл offers.csv без дополнительных указаний (например, пути к файлу на вашем компьютере).
В открытом тесте используется файл offers.csv. Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: Александр Смирнов 
<Вывод>: Разработка логотипа, Александр Смирнов, 4000 р.
Создание анимации, Александр Смирнов, 2000 р.
Создание карточек для социальных сетей, Александр Смирнов, 3500 р. 
<Example 2>: 
<Тип теста 2>: closed 
<Ввод>: Мария Иванова 
<Вывод>: Создание иллюстрации, Мария Иванова, 5000 р. 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: Дмитрий Михайлов 
<Вывод>: nan 
<Решение студента>: name = input()

with open('offers.csv', encoding='utf-8') as infile:
    for line in infile:
        info = line.split(',')
        if info[1] == name and int(info[-1].split()[0]) <= 5000:
            print(line.strip()) 
<Идеальное решение>: name = input()

with open('offers.csv', encoding='utf-8') as infile:
    for line in infile:
        info = line.strip().split(', ')
        if info[1] == name and int(info[-1].split()[0]) <= 5000:
            print(line.strip()) 


<Комментарий эксперта>:"
321,672,43,"Галина анализирует стоимость услуг дизайнеров для ее сайта, которые собраны в файле формата csv. Напишите программу, которая выводит все строки с услугами интересующего дизайнера, а стоимость каждой услуги не превышает 5000 рублей.

Программа должна открывать структурированный текстовый файл offers.csv, в кодировке utf-8, где на каждой строке записана следующая информация об услугах: название услуги, имя дизайнера, стоимость услуги. Например, строка ""Создание лендинга, Анастасия Иванова, 12000 р."" означает, что за создание лендинга дизайнер Анастасия Иванова запрашивает 12000 рублей.
Гарантируется, что стоимость услуги всегда записана в формате ""<целое число> р."".
Разделителями данных в файле служат запятые с пробелом.
Гарантируется, что в файле есть как минимум одна строка с данными. 
С клавиатуры вводится строка — имя дизайнера. Этот код уже написан.
Программа должна выводить строки из оригинального файла, в которых есть только услуги интересующего дизайнера, а стоимость каждой услуги не превышает 5000 рублей (не забудьте удалить символы конца строки!).
Если подходящих под условие строк в файле нет, то программа ничего не выводит.
ДОПОЛНИТЕЛЬНО
Ваше решение будет проверяться на закрытых тестах. Ваш код должен считывать файл offers.csv без дополнительных указаний (например, пути к файлу на вашем компьютере).
В открытом тесте используется файл offers.csv. Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.","['Александр Смирнов', 'Мария Иванова', 'Дмитрий Михайлов']","['Разработка логотипа, Александр Смирнов, 4000 р.\nСоздание анимации, Александр Смирнов, 2000 р.\nСоздание карточек для социальных сетей, Александр Смирнов, 3500 р.', 'Создание иллюстрации, Мария Иванова, 5000 р.', nan]","name = input()

with open('offers.csv', encoding='utf-8') as infile:
    for line in infile:
        info = line.strip().split(', ')
        if info[1] = name and int(info[-1].split()[0]) <= 5000:
            print(line.strip())","name = input()

with open('offers.csv', encoding='utf-8') as infile:
    for line in infile:
        info = line.strip().split(', ')
        if info[1] == name and int(info[-1].split()[0]) <= 5000:
            print(line.strip())",Синтаксическая ошибка. При сравнении значений двух переменных следует использовать знак двойного равенства.,"['open', 'closed', 'closed']","<Task description>: Галина анализирует стоимость услуг дизайнеров для ее сайта, которые собраны в файле формата csv. Напишите программу, которая выводит все строки с услугами интересующего дизайнера, а стоимость каждой услуги не превышает 5000 рублей.

Программа должна открывать структурированный текстовый файл offers.csv, в кодировке utf-8, где на каждой строке записана следующая информация об услугах: название услуги, имя дизайнера, стоимость услуги. Например, строка ""Создание лендинга, Анастасия Иванова, 12000 р."" означает, что за создание лендинга дизайнер Анастасия Иванова запрашивает 12000 рублей.
Гарантируется, что стоимость услуги всегда записана в формате ""<целое число> р."".
Разделителями данных в файле служат запятые с пробелом.
Гарантируется, что в файле есть как минимум одна строка с данными. 
С клавиатуры вводится строка — имя дизайнера. Этот код уже написан.
Программа должна выводить строки из оригинального файла, в которых есть только услуги интересующего дизайнера, а стоимость каждой услуги не превышает 5000 рублей (не забудьте удалить символы конца строки!).
Если подходящих под условие строк в файле нет, то программа ничего не выводит.
ДОПОЛНИТЕЛЬНО
Ваше решение будет проверяться на закрытых тестах. Ваш код должен считывать файл offers.csv без дополнительных указаний (например, пути к файлу на вашем компьютере).
В открытом тесте используется файл offers.csv. Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: Александр Смирнов 
<Вывод>: Разработка логотипа, Александр Смирнов, 4000 р.
Создание анимации, Александр Смирнов, 2000 р.
Создание карточек для социальных сетей, Александр Смирнов, 3500 р. 
<Example 2>: 
<Тип теста 2>: closed 
<Ввод>: Мария Иванова 
<Вывод>: Создание иллюстрации, Мария Иванова, 5000 р. 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: Дмитрий Михайлов 
<Вывод>: nan 
<Решение студента>: name = input()

with open('offers.csv', encoding='utf-8') as infile:
    for line in infile:
        info = line.strip().split(', ')
        if info[1] = name and int(info[-1].split()[0]) <= 5000:
            print(line.strip()) 
<Идеальное решение>: name = input()

with open('offers.csv', encoding='utf-8') as infile:
    for line in infile:
        info = line.strip().split(', ')
        if info[1] == name and int(info[-1].split()[0]) <= 5000:
            print(line.strip()) 


<Комментарий эксперта>:"
322,673,43,"Галина анализирует стоимость услуг дизайнеров для ее сайта, которые собраны в файле формата csv. Напишите программу, которая выводит все строки с услугами интересующего дизайнера, а стоимость каждой услуги не превышает 5000 рублей.

Программа должна открывать структурированный текстовый файл offers.csv, в кодировке utf-8, где на каждой строке записана следующая информация об услугах: название услуги, имя дизайнера, стоимость услуги. Например, строка ""Создание лендинга, Анастасия Иванова, 12000 р."" означает, что за создание лендинга дизайнер Анастасия Иванова запрашивает 12000 рублей.
Гарантируется, что стоимость услуги всегда записана в формате ""<целое число> р."".
Разделителями данных в файле служат запятые с пробелом.
Гарантируется, что в файле есть как минимум одна строка с данными. 
С клавиатуры вводится строка — имя дизайнера. Этот код уже написан.
Программа должна выводить строки из оригинального файла, в которых есть только услуги интересующего дизайнера, а стоимость каждой услуги не превышает 5000 рублей (не забудьте удалить символы конца строки!).
Если подходящих под условие строк в файле нет, то программа ничего не выводит.
ДОПОЛНИТЕЛЬНО
Ваше решение будет проверяться на закрытых тестах. Ваш код должен считывать файл offers.csv без дополнительных указаний (например, пути к файлу на вашем компьютере).
В открытом тесте используется файл offers.csv. Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.","['Александр Смирнов', 'Мария Иванова', 'Дмитрий Михайлов']","['Разработка логотипа, Александр Смирнов, 4000 р.\nСоздание анимации, Александр Смирнов, 2000 р.\nСоздание карточек для социальных сетей, Александр Смирнов, 3500 р.', 'Создание иллюстрации, Мария Иванова, 5000 р.', nan]","name = input()

with open('offers.csv', encoding='utf-8') as infile:
    for line in infile:
        info = line.strip().split(', ')
        if info[1] == name & int(info[-1].split()[0]) <= 5000:
            print(line.strip())","name = input()

with open('offers.csv', encoding='utf-8') as infile:
    for line in infile:
        info = line.strip().split(', ')
        if info[1] == name and int(info[-1].split()[0]) <= 5000:
            print(line.strip())","Ошибка при сравнении данных. Оператор ""&"" не используется для проверки выполнения двух условий одновременно.","['open', 'closed', 'closed']","<Task description>: Галина анализирует стоимость услуг дизайнеров для ее сайта, которые собраны в файле формата csv. Напишите программу, которая выводит все строки с услугами интересующего дизайнера, а стоимость каждой услуги не превышает 5000 рублей.

Программа должна открывать структурированный текстовый файл offers.csv, в кодировке utf-8, где на каждой строке записана следующая информация об услугах: название услуги, имя дизайнера, стоимость услуги. Например, строка ""Создание лендинга, Анастасия Иванова, 12000 р."" означает, что за создание лендинга дизайнер Анастасия Иванова запрашивает 12000 рублей.
Гарантируется, что стоимость услуги всегда записана в формате ""<целое число> р."".
Разделителями данных в файле служат запятые с пробелом.
Гарантируется, что в файле есть как минимум одна строка с данными. 
С клавиатуры вводится строка — имя дизайнера. Этот код уже написан.
Программа должна выводить строки из оригинального файла, в которых есть только услуги интересующего дизайнера, а стоимость каждой услуги не превышает 5000 рублей (не забудьте удалить символы конца строки!).
Если подходящих под условие строк в файле нет, то программа ничего не выводит.
ДОПОЛНИТЕЛЬНО
Ваше решение будет проверяться на закрытых тестах. Ваш код должен считывать файл offers.csv без дополнительных указаний (например, пути к файлу на вашем компьютере).
В открытом тесте используется файл offers.csv. Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: Александр Смирнов 
<Вывод>: Разработка логотипа, Александр Смирнов, 4000 р.
Создание анимации, Александр Смирнов, 2000 р.
Создание карточек для социальных сетей, Александр Смирнов, 3500 р. 
<Example 2>: 
<Тип теста 2>: closed 
<Ввод>: Мария Иванова 
<Вывод>: Создание иллюстрации, Мария Иванова, 5000 р. 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: Дмитрий Михайлов 
<Вывод>: nan 
<Решение студента>: name = input()

with open('offers.csv', encoding='utf-8') as infile:
    for line in infile:
        info = line.strip().split(', ')
        if info[1] == name & int(info[-1].split()[0]) <= 5000:
            print(line.strip()) 
<Идеальное решение>: name = input()

with open('offers.csv', encoding='utf-8') as infile:
    for line in infile:
        info = line.strip().split(', ')
        if info[1] == name and int(info[-1].split()[0]) <= 5000:
            print(line.strip()) 


<Комментарий эксперта>:"
323,674,43,"Галина анализирует стоимость услуг дизайнеров для ее сайта, которые собраны в файле формата csv. Напишите программу, которая выводит все строки с услугами интересующего дизайнера, а стоимость каждой услуги не превышает 5000 рублей.

Программа должна открывать структурированный текстовый файл offers.csv, в кодировке utf-8, где на каждой строке записана следующая информация об услугах: название услуги, имя дизайнера, стоимость услуги. Например, строка ""Создание лендинга, Анастасия Иванова, 12000 р."" означает, что за создание лендинга дизайнер Анастасия Иванова запрашивает 12000 рублей.
Гарантируется, что стоимость услуги всегда записана в формате ""<целое число> р."".
Разделителями данных в файле служат запятые с пробелом.
Гарантируется, что в файле есть как минимум одна строка с данными. 
С клавиатуры вводится строка — имя дизайнера. Этот код уже написан.
Программа должна выводить строки из оригинального файла, в которых есть только услуги интересующего дизайнера, а стоимость каждой услуги не превышает 5000 рублей (не забудьте удалить символы конца строки!).
Если подходящих под условие строк в файле нет, то программа ничего не выводит.
ДОПОЛНИТЕЛЬНО
Ваше решение будет проверяться на закрытых тестах. Ваш код должен считывать файл offers.csv без дополнительных указаний (например, пути к файлу на вашем компьютере).
В открытом тесте используется файл offers.csv. Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.","['Александр Смирнов', 'Мария Иванова', 'Дмитрий Михайлов']","['Разработка логотипа, Александр Смирнов, 4000 р.\nСоздание анимации, Александр Смирнов, 2000 р.\nСоздание карточек для социальных сетей, Александр Смирнов, 3500 р.', 'Создание иллюстрации, Мария Иванова, 5000 р.', nan]","name = input()

with open('offers.csv', encoding='utf-8') as infile:
    for line in infile:
        info = line.strip().split(', ')
        if info[1] != name and int(info[-1].split()[0]) <= 5000:
            print(line.strip())","name = input()

with open('offers.csv', encoding='utf-8') as infile:
    for line in infile:
        info = line.strip().split(', ')
        if info[1] == name and int(info[-1].split()[0]) <= 5000:
            print(line.strip())","Ошибка в открытых и скрытых тестах. 

Ваш код некорректно выполняет условия задания. Например, он не выполняет условия ""программа должна выводить строки из оригинального файла, в которых есть только услуги интересующего дизайнера, а стоимость каждой услуги не превышает 5000 рублей"". Попробуйте изменить условную конструкцию if, чтобы скорректировать ошибку.","['open', 'closed', 'closed']","<Task description>: Галина анализирует стоимость услуг дизайнеров для ее сайта, которые собраны в файле формата csv. Напишите программу, которая выводит все строки с услугами интересующего дизайнера, а стоимость каждой услуги не превышает 5000 рублей.

Программа должна открывать структурированный текстовый файл offers.csv, в кодировке utf-8, где на каждой строке записана следующая информация об услугах: название услуги, имя дизайнера, стоимость услуги. Например, строка ""Создание лендинга, Анастасия Иванова, 12000 р."" означает, что за создание лендинга дизайнер Анастасия Иванова запрашивает 12000 рублей.
Гарантируется, что стоимость услуги всегда записана в формате ""<целое число> р."".
Разделителями данных в файле служат запятые с пробелом.
Гарантируется, что в файле есть как минимум одна строка с данными. 
С клавиатуры вводится строка — имя дизайнера. Этот код уже написан.
Программа должна выводить строки из оригинального файла, в которых есть только услуги интересующего дизайнера, а стоимость каждой услуги не превышает 5000 рублей (не забудьте удалить символы конца строки!).
Если подходящих под условие строк в файле нет, то программа ничего не выводит.
ДОПОЛНИТЕЛЬНО
Ваше решение будет проверяться на закрытых тестах. Ваш код должен считывать файл offers.csv без дополнительных указаний (например, пути к файлу на вашем компьютере).
В открытом тесте используется файл offers.csv. Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: Александр Смирнов 
<Вывод>: Разработка логотипа, Александр Смирнов, 4000 р.
Создание анимации, Александр Смирнов, 2000 р.
Создание карточек для социальных сетей, Александр Смирнов, 3500 р. 
<Example 2>: 
<Тип теста 2>: closed 
<Ввод>: Мария Иванова 
<Вывод>: Создание иллюстрации, Мария Иванова, 5000 р. 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: Дмитрий Михайлов 
<Вывод>: nan 
<Решение студента>: name = input()

with open('offers.csv', encoding='utf-8') as infile:
    for line in infile:
        info = line.strip().split(', ')
        if info[1] != name and int(info[-1].split()[0]) <= 5000:
            print(line.strip()) 
<Идеальное решение>: name = input()

with open('offers.csv', encoding='utf-8') as infile:
    for line in infile:
        info = line.strip().split(', ')
        if info[1] == name and int(info[-1].split()[0]) <= 5000:
            print(line.strip()) 


<Комментарий эксперта>:"
324,675,43,"Галина анализирует стоимость услуг дизайнеров для ее сайта, которые собраны в файле формата csv. Напишите программу, которая выводит все строки с услугами интересующего дизайнера, а стоимость каждой услуги не превышает 5000 рублей.

Программа должна открывать структурированный текстовый файл offers.csv, в кодировке utf-8, где на каждой строке записана следующая информация об услугах: название услуги, имя дизайнера, стоимость услуги. Например, строка ""Создание лендинга, Анастасия Иванова, 12000 р."" означает, что за создание лендинга дизайнер Анастасия Иванова запрашивает 12000 рублей.
Гарантируется, что стоимость услуги всегда записана в формате ""<целое число> р."".
Разделителями данных в файле служат запятые с пробелом.
Гарантируется, что в файле есть как минимум одна строка с данными. 
С клавиатуры вводится строка — имя дизайнера. Этот код уже написан.
Программа должна выводить строки из оригинального файла, в которых есть только услуги интересующего дизайнера, а стоимость каждой услуги не превышает 5000 рублей (не забудьте удалить символы конца строки!).
Если подходящих под условие строк в файле нет, то программа ничего не выводит.
ДОПОЛНИТЕЛЬНО
Ваше решение будет проверяться на закрытых тестах. Ваш код должен считывать файл offers.csv без дополнительных указаний (например, пути к файлу на вашем компьютере).
В открытом тесте используется файл offers.csv. Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.","['Александр Смирнов', 'Мария Иванова', 'Дмитрий Михайлов']","['Разработка логотипа, Александр Смирнов, 4000 р.\nСоздание анимации, Александр Смирнов, 2000 р.\nСоздание карточек для социальных сетей, Александр Смирнов, 3500 р.', 'Создание иллюстрации, Мария Иванова, 5000 р.', nan]","name = input()

with open('offers.csv', encoding='utf-8') as infile:
    for line in infile:
        info = line.strip().split(', ')
        if info[1] == name or int(info[-1].split()[0]) <= 5000:
            print(line.strip())","name = input()

with open('offers.csv', encoding='utf-8') as infile:
    for line in infile:
        info = line.strip().split(', ')
        if info[1] == name and int(info[-1].split()[0]) <= 5000:
            print(line.strip())","Ошибка в открытых и скрытых тестах. 

Ваш код некорректно выполняет условия задания. Например, он не выполняет условия ""программа должна выводить строки из оригинального файла, в которых есть только услуги интересующего дизайнера, а стоимость каждой услуги не превышает 5000 рублей"". Попробуйте изменить условную конструкцию if, чтобы скорректировать ошибку.","['open', 'closed', 'closed']","<Task description>: Галина анализирует стоимость услуг дизайнеров для ее сайта, которые собраны в файле формата csv. Напишите программу, которая выводит все строки с услугами интересующего дизайнера, а стоимость каждой услуги не превышает 5000 рублей.

Программа должна открывать структурированный текстовый файл offers.csv, в кодировке utf-8, где на каждой строке записана следующая информация об услугах: название услуги, имя дизайнера, стоимость услуги. Например, строка ""Создание лендинга, Анастасия Иванова, 12000 р."" означает, что за создание лендинга дизайнер Анастасия Иванова запрашивает 12000 рублей.
Гарантируется, что стоимость услуги всегда записана в формате ""<целое число> р."".
Разделителями данных в файле служат запятые с пробелом.
Гарантируется, что в файле есть как минимум одна строка с данными. 
С клавиатуры вводится строка — имя дизайнера. Этот код уже написан.
Программа должна выводить строки из оригинального файла, в которых есть только услуги интересующего дизайнера, а стоимость каждой услуги не превышает 5000 рублей (не забудьте удалить символы конца строки!).
Если подходящих под условие строк в файле нет, то программа ничего не выводит.
ДОПОЛНИТЕЛЬНО
Ваше решение будет проверяться на закрытых тестах. Ваш код должен считывать файл offers.csv без дополнительных указаний (например, пути к файлу на вашем компьютере).
В открытом тесте используется файл offers.csv. Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: Александр Смирнов 
<Вывод>: Разработка логотипа, Александр Смирнов, 4000 р.
Создание анимации, Александр Смирнов, 2000 р.
Создание карточек для социальных сетей, Александр Смирнов, 3500 р. 
<Example 2>: 
<Тип теста 2>: closed 
<Ввод>: Мария Иванова 
<Вывод>: Создание иллюстрации, Мария Иванова, 5000 р. 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: Дмитрий Михайлов 
<Вывод>: nan 
<Решение студента>: name = input()

with open('offers.csv', encoding='utf-8') as infile:
    for line in infile:
        info = line.strip().split(', ')
        if info[1] == name or int(info[-1].split()[0]) <= 5000:
            print(line.strip()) 
<Идеальное решение>: name = input()

with open('offers.csv', encoding='utf-8') as infile:
    for line in infile:
        info = line.strip().split(', ')
        if info[1] == name and int(info[-1].split()[0]) <= 5000:
            print(line.strip()) 


<Комментарий эксперта>:"
325,676,43,"Галина анализирует стоимость услуг дизайнеров для ее сайта, которые собраны в файле формата csv. Напишите программу, которая выводит все строки с услугами интересующего дизайнера, а стоимость каждой услуги не превышает 5000 рублей.

Программа должна открывать структурированный текстовый файл offers.csv, в кодировке utf-8, где на каждой строке записана следующая информация об услугах: название услуги, имя дизайнера, стоимость услуги. Например, строка ""Создание лендинга, Анастасия Иванова, 12000 р."" означает, что за создание лендинга дизайнер Анастасия Иванова запрашивает 12000 рублей.
Гарантируется, что стоимость услуги всегда записана в формате ""<целое число> р."".
Разделителями данных в файле служат запятые с пробелом.
Гарантируется, что в файле есть как минимум одна строка с данными. 
С клавиатуры вводится строка — имя дизайнера. Этот код уже написан.
Программа должна выводить строки из оригинального файла, в которых есть только услуги интересующего дизайнера, а стоимость каждой услуги не превышает 5000 рублей (не забудьте удалить символы конца строки!).
Если подходящих под условие строк в файле нет, то программа ничего не выводит.
ДОПОЛНИТЕЛЬНО
Ваше решение будет проверяться на закрытых тестах. Ваш код должен считывать файл offers.csv без дополнительных указаний (например, пути к файлу на вашем компьютере).
В открытом тесте используется файл offers.csv. Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.","['Александр Смирнов', 'Мария Иванова', 'Дмитрий Михайлов']","['Разработка логотипа, Александр Смирнов, 4000 р.\nСоздание анимации, Александр Смирнов, 2000 р.\nСоздание карточек для социальных сетей, Александр Смирнов, 3500 р.', 'Создание иллюстрации, Мария Иванова, 5000 р.', nan]","name = input()

with open('offers.csv', encoding='utf-8') as infile:
    for line in infile:
        info = line.strip().split(', ')
        if info[1] == name and int(info[-1].split()[0]) < 5000:
            print(line.strip())","name = input()

with open('offers.csv', encoding='utf-8') as infile:
    for line in infile:
        info = line.strip().split(', ')
        if info[1] == name and int(info[-1].split()[0]) <= 5000:
            print(line.strip())","Ошибка в открытых и скрытых тестах. 

Ваш код некорректно выполняет условия задания. Например, он не выполняет условия ""программа должна выводить строки из оригинального файла, в которых есть только услуги интересующего дизайнера, а стоимость каждой услуги не превышает 5000 рублей"". Попробуйте изменить условную конструкцию if, чтобы скорректировать ошибку.","['open', 'closed', 'closed']","<Task description>: Галина анализирует стоимость услуг дизайнеров для ее сайта, которые собраны в файле формата csv. Напишите программу, которая выводит все строки с услугами интересующего дизайнера, а стоимость каждой услуги не превышает 5000 рублей.

Программа должна открывать структурированный текстовый файл offers.csv, в кодировке utf-8, где на каждой строке записана следующая информация об услугах: название услуги, имя дизайнера, стоимость услуги. Например, строка ""Создание лендинга, Анастасия Иванова, 12000 р."" означает, что за создание лендинга дизайнер Анастасия Иванова запрашивает 12000 рублей.
Гарантируется, что стоимость услуги всегда записана в формате ""<целое число> р."".
Разделителями данных в файле служат запятые с пробелом.
Гарантируется, что в файле есть как минимум одна строка с данными. 
С клавиатуры вводится строка — имя дизайнера. Этот код уже написан.
Программа должна выводить строки из оригинального файла, в которых есть только услуги интересующего дизайнера, а стоимость каждой услуги не превышает 5000 рублей (не забудьте удалить символы конца строки!).
Если подходящих под условие строк в файле нет, то программа ничего не выводит.
ДОПОЛНИТЕЛЬНО
Ваше решение будет проверяться на закрытых тестах. Ваш код должен считывать файл offers.csv без дополнительных указаний (например, пути к файлу на вашем компьютере).
В открытом тесте используется файл offers.csv. Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: Александр Смирнов 
<Вывод>: Разработка логотипа, Александр Смирнов, 4000 р.
Создание анимации, Александр Смирнов, 2000 р.
Создание карточек для социальных сетей, Александр Смирнов, 3500 р. 
<Example 2>: 
<Тип теста 2>: closed 
<Ввод>: Мария Иванова 
<Вывод>: Создание иллюстрации, Мария Иванова, 5000 р. 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: Дмитрий Михайлов 
<Вывод>: nan 
<Решение студента>: name = input()

with open('offers.csv', encoding='utf-8') as infile:
    for line in infile:
        info = line.strip().split(', ')
        if info[1] == name and int(info[-1].split()[0]) < 5000:
            print(line.strip()) 
<Идеальное решение>: name = input()

with open('offers.csv', encoding='utf-8') as infile:
    for line in infile:
        info = line.strip().split(', ')
        if info[1] == name and int(info[-1].split()[0]) <= 5000:
            print(line.strip()) 


<Комментарий эксперта>:"
326,677,43,"Галина анализирует стоимость услуг дизайнеров для ее сайта, которые собраны в файле формата csv. Напишите программу, которая выводит все строки с услугами интересующего дизайнера, а стоимость каждой услуги не превышает 5000 рублей.

Программа должна открывать структурированный текстовый файл offers.csv, в кодировке utf-8, где на каждой строке записана следующая информация об услугах: название услуги, имя дизайнера, стоимость услуги. Например, строка ""Создание лендинга, Анастасия Иванова, 12000 р."" означает, что за создание лендинга дизайнер Анастасия Иванова запрашивает 12000 рублей.
Гарантируется, что стоимость услуги всегда записана в формате ""<целое число> р."".
Разделителями данных в файле служат запятые с пробелом.
Гарантируется, что в файле есть как минимум одна строка с данными. 
С клавиатуры вводится строка — имя дизайнера. Этот код уже написан.
Программа должна выводить строки из оригинального файла, в которых есть только услуги интересующего дизайнера, а стоимость каждой услуги не превышает 5000 рублей (не забудьте удалить символы конца строки!).
Если подходящих под условие строк в файле нет, то программа ничего не выводит.
ДОПОЛНИТЕЛЬНО
Ваше решение будет проверяться на закрытых тестах. Ваш код должен считывать файл offers.csv без дополнительных указаний (например, пути к файлу на вашем компьютере).
В открытом тесте используется файл offers.csv. Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.","['Александр Смирнов', 'Мария Иванова', 'Дмитрий Михайлов']","['Разработка логотипа, Александр Смирнов, 4000 р.\nСоздание анимации, Александр Смирнов, 2000 р.\nСоздание карточек для социальных сетей, Александр Смирнов, 3500 р.', 'Создание иллюстрации, Мария Иванова, 5000 р.', nan]","name = input()

with open('offers.csv', encoding='utf-8') as infile:
    for line in infile:
        info = line.strip().split(', ')
        if info[1] == name and info[-1].split()[0] <= 5000:
            print(line.strip())","name = input()

with open('offers.csv', encoding='utf-8') as infile:
    for line in infile:
        info = line.strip().split(', ')
        if info[1] == name and int(info[-1].split()[0]) <= 5000:
            print(line.strip())","Ошибка при использовании оператора <=. Сравнивать можно только переменные типа int. Скорректируйте условие if, для исправления ошибки.","['open', 'closed', 'closed']","<Task description>: Галина анализирует стоимость услуг дизайнеров для ее сайта, которые собраны в файле формата csv. Напишите программу, которая выводит все строки с услугами интересующего дизайнера, а стоимость каждой услуги не превышает 5000 рублей.

Программа должна открывать структурированный текстовый файл offers.csv, в кодировке utf-8, где на каждой строке записана следующая информация об услугах: название услуги, имя дизайнера, стоимость услуги. Например, строка ""Создание лендинга, Анастасия Иванова, 12000 р."" означает, что за создание лендинга дизайнер Анастасия Иванова запрашивает 12000 рублей.
Гарантируется, что стоимость услуги всегда записана в формате ""<целое число> р."".
Разделителями данных в файле служат запятые с пробелом.
Гарантируется, что в файле есть как минимум одна строка с данными. 
С клавиатуры вводится строка — имя дизайнера. Этот код уже написан.
Программа должна выводить строки из оригинального файла, в которых есть только услуги интересующего дизайнера, а стоимость каждой услуги не превышает 5000 рублей (не забудьте удалить символы конца строки!).
Если подходящих под условие строк в файле нет, то программа ничего не выводит.
ДОПОЛНИТЕЛЬНО
Ваше решение будет проверяться на закрытых тестах. Ваш код должен считывать файл offers.csv без дополнительных указаний (например, пути к файлу на вашем компьютере).
В открытом тесте используется файл offers.csv. Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: Александр Смирнов 
<Вывод>: Разработка логотипа, Александр Смирнов, 4000 р.
Создание анимации, Александр Смирнов, 2000 р.
Создание карточек для социальных сетей, Александр Смирнов, 3500 р. 
<Example 2>: 
<Тип теста 2>: closed 
<Ввод>: Мария Иванова 
<Вывод>: Создание иллюстрации, Мария Иванова, 5000 р. 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: Дмитрий Михайлов 
<Вывод>: nan 
<Решение студента>: name = input()

with open('offers.csv', encoding='utf-8') as infile:
    for line in infile:
        info = line.strip().split(', ')
        if info[1] == name and info[-1].split()[0] <= 5000:
            print(line.strip()) 
<Идеальное решение>: name = input()

with open('offers.csv', encoding='utf-8') as infile:
    for line in infile:
        info = line.strip().split(', ')
        if info[1] == name and int(info[-1].split()[0]) <= 5000:
            print(line.strip()) 


<Комментарий эксперта>:"
327,678,43,"Галина анализирует стоимость услуг дизайнеров для ее сайта, которые собраны в файле формата csv. Напишите программу, которая выводит все строки с услугами интересующего дизайнера, а стоимость каждой услуги не превышает 5000 рублей.

Программа должна открывать структурированный текстовый файл offers.csv, в кодировке utf-8, где на каждой строке записана следующая информация об услугах: название услуги, имя дизайнера, стоимость услуги. Например, строка ""Создание лендинга, Анастасия Иванова, 12000 р."" означает, что за создание лендинга дизайнер Анастасия Иванова запрашивает 12000 рублей.
Гарантируется, что стоимость услуги всегда записана в формате ""<целое число> р."".
Разделителями данных в файле служат запятые с пробелом.
Гарантируется, что в файле есть как минимум одна строка с данными. 
С клавиатуры вводится строка — имя дизайнера. Этот код уже написан.
Программа должна выводить строки из оригинального файла, в которых есть только услуги интересующего дизайнера, а стоимость каждой услуги не превышает 5000 рублей (не забудьте удалить символы конца строки!).
Если подходящих под условие строк в файле нет, то программа ничего не выводит.
ДОПОЛНИТЕЛЬНО
Ваше решение будет проверяться на закрытых тестах. Ваш код должен считывать файл offers.csv без дополнительных указаний (например, пути к файлу на вашем компьютере).
В открытом тесте используется файл offers.csv. Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.","['Александр Смирнов', 'Мария Иванова', 'Дмитрий Михайлов']","['Разработка логотипа, Александр Смирнов, 4000 р.\nСоздание анимации, Александр Смирнов, 2000 р.\nСоздание карточек для социальных сетей, Александр Смирнов, 3500 р.', 'Создание иллюстрации, Мария Иванова, 5000 р.', nan]","name = input()

with open('offers.csv', encoding='utf-8') as infile:
    for line in infile:
        info = line.strip().split(', ')
        if info[2] == name and int(info[3].split()[0]) <= 5000:
            print(line.strip())","name = input()

with open('offers.csv', encoding='utf-8') as infile:
    for line in infile:
        info = line.strip().split(', ')
        if info[1] == name and int(info[-1].split()[0]) <= 5000:
            print(line.strip())","Ошибка при итерации по символам каждого слова. Помните, что в Python нумерация элементов начинается с 0.","['open', 'closed', 'closed']","<Task description>: Галина анализирует стоимость услуг дизайнеров для ее сайта, которые собраны в файле формата csv. Напишите программу, которая выводит все строки с услугами интересующего дизайнера, а стоимость каждой услуги не превышает 5000 рублей.

Программа должна открывать структурированный текстовый файл offers.csv, в кодировке utf-8, где на каждой строке записана следующая информация об услугах: название услуги, имя дизайнера, стоимость услуги. Например, строка ""Создание лендинга, Анастасия Иванова, 12000 р."" означает, что за создание лендинга дизайнер Анастасия Иванова запрашивает 12000 рублей.
Гарантируется, что стоимость услуги всегда записана в формате ""<целое число> р."".
Разделителями данных в файле служат запятые с пробелом.
Гарантируется, что в файле есть как минимум одна строка с данными. 
С клавиатуры вводится строка — имя дизайнера. Этот код уже написан.
Программа должна выводить строки из оригинального файла, в которых есть только услуги интересующего дизайнера, а стоимость каждой услуги не превышает 5000 рублей (не забудьте удалить символы конца строки!).
Если подходящих под условие строк в файле нет, то программа ничего не выводит.
ДОПОЛНИТЕЛЬНО
Ваше решение будет проверяться на закрытых тестах. Ваш код должен считывать файл offers.csv без дополнительных указаний (например, пути к файлу на вашем компьютере).
В открытом тесте используется файл offers.csv. Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: Александр Смирнов 
<Вывод>: Разработка логотипа, Александр Смирнов, 4000 р.
Создание анимации, Александр Смирнов, 2000 р.
Создание карточек для социальных сетей, Александр Смирнов, 3500 р. 
<Example 2>: 
<Тип теста 2>: closed 
<Ввод>: Мария Иванова 
<Вывод>: Создание иллюстрации, Мария Иванова, 5000 р. 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: Дмитрий Михайлов 
<Вывод>: nan 
<Решение студента>: name = input()

with open('offers.csv', encoding='utf-8') as infile:
    for line in infile:
        info = line.strip().split(', ')
        if info[2] == name and int(info[3].split()[0]) <= 5000:
            print(line.strip()) 
<Идеальное решение>: name = input()

with open('offers.csv', encoding='utf-8') as infile:
    for line in infile:
        info = line.strip().split(', ')
        if info[1] == name and int(info[-1].split()[0]) <= 5000:
            print(line.strip()) 


<Комментарий эксперта>:"
328,679,43,"Галина анализирует стоимость услуг дизайнеров для ее сайта, которые собраны в файле формата csv. Напишите программу, которая выводит все строки с услугами интересующего дизайнера, а стоимость каждой услуги не превышает 5000 рублей.

Программа должна открывать структурированный текстовый файл offers.csv, в кодировке utf-8, где на каждой строке записана следующая информация об услугах: название услуги, имя дизайнера, стоимость услуги. Например, строка ""Создание лендинга, Анастасия Иванова, 12000 р."" означает, что за создание лендинга дизайнер Анастасия Иванова запрашивает 12000 рублей.
Гарантируется, что стоимость услуги всегда записана в формате ""<целое число> р."".
Разделителями данных в файле служат запятые с пробелом.
Гарантируется, что в файле есть как минимум одна строка с данными. 
С клавиатуры вводится строка — имя дизайнера. Этот код уже написан.
Программа должна выводить строки из оригинального файла, в которых есть только услуги интересующего дизайнера, а стоимость каждой услуги не превышает 5000 рублей (не забудьте удалить символы конца строки!).
Если подходящих под условие строк в файле нет, то программа ничего не выводит.
ДОПОЛНИТЕЛЬНО
Ваше решение будет проверяться на закрытых тестах. Ваш код должен считывать файл offers.csv без дополнительных указаний (например, пути к файлу на вашем компьютере).
В открытом тесте используется файл offers.csv. Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.","['Александр Смирнов', 'Мария Иванова', 'Дмитрий Михайлов']","['Разработка логотипа, Александр Смирнов, 4000 р.\nСоздание анимации, Александр Смирнов, 2000 р.\nСоздание карточек для социальных сетей, Александр Смирнов, 3500 р.', 'Создание иллюстрации, Мария Иванова, 5000 р.', nan]","name = input()

with open('offers.csv', encoding='utf-8') as infile:
    for line in infile:
        info = line.strip().split(', ')
        if info[1] == name and int(info[-1]) <= 5000:
            print(line.strip())","name = input()

with open('offers.csv', encoding='utf-8') as infile:
    for line in infile:
        info = line.strip().split(', ')
        if info[1] == name and int(info[-1].split()[0]) <= 5000:
            print(line.strip())",Ошибка при преобразовании данных в int. Вы пытаетесь преобразовать нечисловые значения в формат int.,"['open', 'closed', 'closed']","<Task description>: Галина анализирует стоимость услуг дизайнеров для ее сайта, которые собраны в файле формата csv. Напишите программу, которая выводит все строки с услугами интересующего дизайнера, а стоимость каждой услуги не превышает 5000 рублей.

Программа должна открывать структурированный текстовый файл offers.csv, в кодировке utf-8, где на каждой строке записана следующая информация об услугах: название услуги, имя дизайнера, стоимость услуги. Например, строка ""Создание лендинга, Анастасия Иванова, 12000 р."" означает, что за создание лендинга дизайнер Анастасия Иванова запрашивает 12000 рублей.
Гарантируется, что стоимость услуги всегда записана в формате ""<целое число> р."".
Разделителями данных в файле служат запятые с пробелом.
Гарантируется, что в файле есть как минимум одна строка с данными. 
С клавиатуры вводится строка — имя дизайнера. Этот код уже написан.
Программа должна выводить строки из оригинального файла, в которых есть только услуги интересующего дизайнера, а стоимость каждой услуги не превышает 5000 рублей (не забудьте удалить символы конца строки!).
Если подходящих под условие строк в файле нет, то программа ничего не выводит.
ДОПОЛНИТЕЛЬНО
Ваше решение будет проверяться на закрытых тестах. Ваш код должен считывать файл offers.csv без дополнительных указаний (например, пути к файлу на вашем компьютере).
В открытом тесте используется файл offers.csv. Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: Александр Смирнов 
<Вывод>: Разработка логотипа, Александр Смирнов, 4000 р.
Создание анимации, Александр Смирнов, 2000 р.
Создание карточек для социальных сетей, Александр Смирнов, 3500 р. 
<Example 2>: 
<Тип теста 2>: closed 
<Ввод>: Мария Иванова 
<Вывод>: Создание иллюстрации, Мария Иванова, 5000 р. 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: Дмитрий Михайлов 
<Вывод>: nan 
<Решение студента>: name = input()

with open('offers.csv', encoding='utf-8') as infile:
    for line in infile:
        info = line.strip().split(', ')
        if info[1] == name and int(info[-1]) <= 5000:
            print(line.strip()) 
<Идеальное решение>: name = input()

with open('offers.csv', encoding='utf-8') as infile:
    for line in infile:
        info = line.strip().split(', ')
        if info[1] == name and int(info[-1].split()[0]) <= 5000:
            print(line.strip()) 


<Комментарий эксперта>:"
329,680,43,"Галина анализирует стоимость услуг дизайнеров для ее сайта, которые собраны в файле формата csv. Напишите программу, которая выводит все строки с услугами интересующего дизайнера, а стоимость каждой услуги не превышает 5000 рублей.

Программа должна открывать структурированный текстовый файл offers.csv, в кодировке utf-8, где на каждой строке записана следующая информация об услугах: название услуги, имя дизайнера, стоимость услуги. Например, строка ""Создание лендинга, Анастасия Иванова, 12000 р."" означает, что за создание лендинга дизайнер Анастасия Иванова запрашивает 12000 рублей.
Гарантируется, что стоимость услуги всегда записана в формате ""<целое число> р."".
Разделителями данных в файле служат запятые с пробелом.
Гарантируется, что в файле есть как минимум одна строка с данными. 
С клавиатуры вводится строка — имя дизайнера. Этот код уже написан.
Программа должна выводить строки из оригинального файла, в которых есть только услуги интересующего дизайнера, а стоимость каждой услуги не превышает 5000 рублей (не забудьте удалить символы конца строки!).
Если подходящих под условие строк в файле нет, то программа ничего не выводит.
ДОПОЛНИТЕЛЬНО
Ваше решение будет проверяться на закрытых тестах. Ваш код должен считывать файл offers.csv без дополнительных указаний (например, пути к файлу на вашем компьютере).
В открытом тесте используется файл offers.csv. Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.","['Александр Смирнов', 'Мария Иванова', 'Дмитрий Михайлов']","['Разработка логотипа, Александр Смирнов, 4000 р.\nСоздание анимации, Александр Смирнов, 2000 р.\nСоздание карточек для социальных сетей, Александр Смирнов, 3500 р.', 'Создание иллюстрации, Мария Иванова, 5000 р.', nan]","name = input()

with open('offers.csv', encoding='utf-8') as infile:
    for line in infile:
        info = line.strip().split(', ')
        if info[1] == name and int(info[-1].split()[0]) <= 5000:
            print(line)","name = input()

with open('offers.csv', encoding='utf-8') as infile:
    for line in infile:
        info = line.strip().split(', ')
        if info[1] == name and int(info[-1].split()[0]) <= 5000:
            print(line.strip())","Ошибка в открытых и скрытых тестах. 

Ваш код некорректно выполняет условия задания. Например, он не выполняет условие ""не забудьте удалить символы конца строки"". Попробуйте изменить функцию print(), чтобы скорректировать ошибку.","['open', 'closed', 'closed']","<Task description>: Галина анализирует стоимость услуг дизайнеров для ее сайта, которые собраны в файле формата csv. Напишите программу, которая выводит все строки с услугами интересующего дизайнера, а стоимость каждой услуги не превышает 5000 рублей.

Программа должна открывать структурированный текстовый файл offers.csv, в кодировке utf-8, где на каждой строке записана следующая информация об услугах: название услуги, имя дизайнера, стоимость услуги. Например, строка ""Создание лендинга, Анастасия Иванова, 12000 р."" означает, что за создание лендинга дизайнер Анастасия Иванова запрашивает 12000 рублей.
Гарантируется, что стоимость услуги всегда записана в формате ""<целое число> р."".
Разделителями данных в файле служат запятые с пробелом.
Гарантируется, что в файле есть как минимум одна строка с данными. 
С клавиатуры вводится строка — имя дизайнера. Этот код уже написан.
Программа должна выводить строки из оригинального файла, в которых есть только услуги интересующего дизайнера, а стоимость каждой услуги не превышает 5000 рублей (не забудьте удалить символы конца строки!).
Если подходящих под условие строк в файле нет, то программа ничего не выводит.
ДОПОЛНИТЕЛЬНО
Ваше решение будет проверяться на закрытых тестах. Ваш код должен считывать файл offers.csv без дополнительных указаний (например, пути к файлу на вашем компьютере).
В открытом тесте используется файл offers.csv. Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: Александр Смирнов 
<Вывод>: Разработка логотипа, Александр Смирнов, 4000 р.
Создание анимации, Александр Смирнов, 2000 р.
Создание карточек для социальных сетей, Александр Смирнов, 3500 р. 
<Example 2>: 
<Тип теста 2>: closed 
<Ввод>: Мария Иванова 
<Вывод>: Создание иллюстрации, Мария Иванова, 5000 р. 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: Дмитрий Михайлов 
<Вывод>: nan 
<Решение студента>: name = input()

with open('offers.csv', encoding='utf-8') as infile:
    for line in infile:
        info = line.strip().split(', ')
        if info[1] == name and int(info[-1].split()[0]) <= 5000:
            print(line) 
<Идеальное решение>: name = input()

with open('offers.csv', encoding='utf-8') as infile:
    for line in infile:
        info = line.strip().split(', ')
        if info[1] == name and int(info[-1].split()[0]) <= 5000:
            print(line.strip()) 


<Комментарий эксперта>:"
330,681,43,"Галина анализирует стоимость услуг дизайнеров для ее сайта, которые собраны в файле формата csv. Напишите программу, которая выводит все строки с услугами интересующего дизайнера, а стоимость каждой услуги не превышает 5000 рублей.

Программа должна открывать структурированный текстовый файл offers.csv, в кодировке utf-8, где на каждой строке записана следующая информация об услугах: название услуги, имя дизайнера, стоимость услуги. Например, строка ""Создание лендинга, Анастасия Иванова, 12000 р."" означает, что за создание лендинга дизайнер Анастасия Иванова запрашивает 12000 рублей.
Гарантируется, что стоимость услуги всегда записана в формате ""<целое число> р."".
Разделителями данных в файле служат запятые с пробелом.
Гарантируется, что в файле есть как минимум одна строка с данными. 
С клавиатуры вводится строка — имя дизайнера. Этот код уже написан.
Программа должна выводить строки из оригинального файла, в которых есть только услуги интересующего дизайнера, а стоимость каждой услуги не превышает 5000 рублей (не забудьте удалить символы конца строки!).
Если подходящих под условие строк в файле нет, то программа ничего не выводит.
ДОПОЛНИТЕЛЬНО
Ваше решение будет проверяться на закрытых тестах. Ваш код должен считывать файл offers.csv без дополнительных указаний (например, пути к файлу на вашем компьютере).
В открытом тесте используется файл offers.csv. Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.","['Александр Смирнов', 'Мария Иванова', 'Дмитрий Михайлов']","['Разработка логотипа, Александр Смирнов, 4000 р.\nСоздание анимации, Александр Смирнов, 2000 р.\nСоздание карточек для социальных сетей, Александр Смирнов, 3500 р.', 'Создание иллюстрации, Мария Иванова, 5000 р.', nan]","name = input()

with open('offers.csv', encoding='utf-8') as infile:
    for line in infile:
        info = line.strip().split(', ')
        if info[1] == name and int(info[-1].split()[0]) <= 5000:
        print(line.strip())","name = input()

with open('offers.csv', encoding='utf-8') as infile:
    for line in infile:
        info = line.strip().split(', ')
        if info[1] == name and int(info[-1].split()[0]) <= 5000:
            print(line.strip())",Некорректная табуляция функции print().,"['open', 'closed', 'closed']","<Task description>: Галина анализирует стоимость услуг дизайнеров для ее сайта, которые собраны в файле формата csv. Напишите программу, которая выводит все строки с услугами интересующего дизайнера, а стоимость каждой услуги не превышает 5000 рублей.

Программа должна открывать структурированный текстовый файл offers.csv, в кодировке utf-8, где на каждой строке записана следующая информация об услугах: название услуги, имя дизайнера, стоимость услуги. Например, строка ""Создание лендинга, Анастасия Иванова, 12000 р."" означает, что за создание лендинга дизайнер Анастасия Иванова запрашивает 12000 рублей.
Гарантируется, что стоимость услуги всегда записана в формате ""<целое число> р."".
Разделителями данных в файле служат запятые с пробелом.
Гарантируется, что в файле есть как минимум одна строка с данными. 
С клавиатуры вводится строка — имя дизайнера. Этот код уже написан.
Программа должна выводить строки из оригинального файла, в которых есть только услуги интересующего дизайнера, а стоимость каждой услуги не превышает 5000 рублей (не забудьте удалить символы конца строки!).
Если подходящих под условие строк в файле нет, то программа ничего не выводит.
ДОПОЛНИТЕЛЬНО
Ваше решение будет проверяться на закрытых тестах. Ваш код должен считывать файл offers.csv без дополнительных указаний (например, пути к файлу на вашем компьютере).
В открытом тесте используется файл offers.csv. Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: Александр Смирнов 
<Вывод>: Разработка логотипа, Александр Смирнов, 4000 р.
Создание анимации, Александр Смирнов, 2000 р.
Создание карточек для социальных сетей, Александр Смирнов, 3500 р. 
<Example 2>: 
<Тип теста 2>: closed 
<Ввод>: Мария Иванова 
<Вывод>: Создание иллюстрации, Мария Иванова, 5000 р. 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: Дмитрий Михайлов 
<Вывод>: nan 
<Решение студента>: name = input()

with open('offers.csv', encoding='utf-8') as infile:
    for line in infile:
        info = line.strip().split(', ')
        if info[1] == name and int(info[-1].split()[0]) <= 5000:
        print(line.strip()) 
<Идеальное решение>: name = input()

with open('offers.csv', encoding='utf-8') as infile:
    for line in infile:
        info = line.strip().split(', ')
        if info[1] == name and int(info[-1].split()[0]) <= 5000:
            print(line.strip()) 


<Комментарий эксперта>:"
331,730,47,"Лолита изучает, какие студии дизайна чаще всего дают комментарии в ее любимом журнале. Помогите определить студии, встретившиеся в тексте более двух раз. Гарантируется, что в тексте только названия сервисов написаны в кавычках «». 

ФОРМАТ ВВОДА
Текстовый файл designtalks.txt, в котором записан текст из журнала. 
Гарантируется, что пустых строк в файле нет.
Гарантируется, что в файле будет упоминание хотя бы одной студии.
Также дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.
ФОРМАТ ВЫВОДА
Студии дизайна, встретившиеся в тексте более двух раз.
Студии должны быть записаны в обратном алфавитном порядке через запятую и пробел.
ДОПОЛНИТЕЛЬНО
В открытом тесте используется файл designtalks.txt. Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Создайте пустой словарь, в который будете записывать слова и их количество.
Откройте файл в режиме чтения в кодировке utf-8.
Обратитесь к каждой строке в файле и выполните следующие действия:
уберите невидимые символы в конце строки (символ перехода на новую строку);
обратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;
разбейте строку по разделителю, в результате получите список;
обратитесь к каждому элементу в получившемся списке. Если первый символ — это кавычка «, тогда это студия дизайна, и нужно проверить:
если этого названия еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.
если такое название уже есть в словаре из п.1, то нужно увеличить его значение на 1.
После цикла создайте пустой список — в него нужно будет добавить те названия, значение которых в словаре более 2.
Обратитесь к парам ключ-значение в словаре: если значение строго больше 2, то добавьте ключ в список из п.4.
Отсортируйте список в обратном алфавитном порядке и напечатайте его элементы через запятую и пробел.","[nan, nan, nan]","['«Экспериментус», «СделаемЗавтра», «Айсбергус»', '«КреативныйПуть», «Кибервизион», «ГрафиксЭксперт»', '«ДизайнПроект»']","punctuation = '!#$%&()*+,-./:;<=>?@^_'

data = {}

open('designtalks.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0] == '«':
                if w not in data:
                    data[w] = 1
                else:
                    data[w] += 1
                    
res = []

for k, v in data.items():
    if v > 2:
        res.append(k)
        
print(*sorted(res, reverse=True), sep=', ')","punctuation = '!#$%&()*+,-./:;<=>?@^_'

data = {}

with open('designtalks.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0] == '«':
                if w not in data:
                    data[w] = 1
                else:
                    data[w] += 1
                    
res = []

for k, v in data.items():
    if v > 2:
        res.append(k)
        
print(*sorted(res, reverse=True), sep=', ')",Некорректный синтаксис при использовании функции open.,"['open', 'closed', 'closed']","<Task description>: Лолита изучает, какие студии дизайна чаще всего дают комментарии в ее любимом журнале. Помогите определить студии, встретившиеся в тексте более двух раз. Гарантируется, что в тексте только названия сервисов написаны в кавычках «». 

ФОРМАТ ВВОДА
Текстовый файл designtalks.txt, в котором записан текст из журнала. 
Гарантируется, что пустых строк в файле нет.
Гарантируется, что в файле будет упоминание хотя бы одной студии.
Также дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.
ФОРМАТ ВЫВОДА
Студии дизайна, встретившиеся в тексте более двух раз.
Студии должны быть записаны в обратном алфавитном порядке через запятую и пробел.
ДОПОЛНИТЕЛЬНО
В открытом тесте используется файл designtalks.txt. Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Создайте пустой словарь, в который будете записывать слова и их количество.
Откройте файл в режиме чтения в кодировке utf-8.
Обратитесь к каждой строке в файле и выполните следующие действия:
уберите невидимые символы в конце строки (символ перехода на новую строку);
обратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;
разбейте строку по разделителю, в результате получите список;
обратитесь к каждому элементу в получившемся списке. Если первый символ — это кавычка «, тогда это студия дизайна, и нужно проверить:
если этого названия еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.
если такое название уже есть в словаре из п.1, то нужно увеличить его значение на 1.
После цикла создайте пустой список — в него нужно будет добавить те названия, значение которых в словаре более 2.
Обратитесь к парам ключ-значение в словаре: если значение строго больше 2, то добавьте ключ в список из п.4.
Отсортируйте список в обратном алфавитном порядке и напечатайте его элементы через запятую и пробел. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: nan 
<Вывод>: «Экспериментус», «СделаемЗавтра», «Айсбергус» 
<Example 2>: 
<Тип теста 2>: closed 
<Ввод>: nan 
<Вывод>: «КреативныйПуть», «Кибервизион», «ГрафиксЭксперт» 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: nan 
<Вывод>: «ДизайнПроект» 
<Решение студента>: punctuation = '!#$%&()*+,-./:;<=>?@^_'

data = {}

open('designtalks.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0] == '«':
                if w not in data:
                    data[w] = 1
                else:
                    data[w] += 1
                    
res = []

for k, v in data.items():
    if v > 2:
        res.append(k)
        
print(*sorted(res, reverse=True), sep=', ') 
<Идеальное решение>: punctuation = '!#$%&()*+,-./:;<=>?@^_'

data = {}

with open('designtalks.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0] == '«':
                if w not in data:
                    data[w] = 1
                else:
                    data[w] += 1
                    
res = []

for k, v in data.items():
    if v > 2:
        res.append(k)
        
print(*sorted(res, reverse=True), sep=', ') 


<Комментарий эксперта>:"
332,731,47,"Лолита изучает, какие студии дизайна чаще всего дают комментарии в ее любимом журнале. Помогите определить студии, встретившиеся в тексте более двух раз. Гарантируется, что в тексте только названия сервисов написаны в кавычках «». 

ФОРМАТ ВВОДА
Текстовый файл designtalks.txt, в котором записан текст из журнала. 
Гарантируется, что пустых строк в файле нет.
Гарантируется, что в файле будет упоминание хотя бы одной студии.
Также дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.
ФОРМАТ ВЫВОДА
Студии дизайна, встретившиеся в тексте более двух раз.
Студии должны быть записаны в обратном алфавитном порядке через запятую и пробел.
ДОПОЛНИТЕЛЬНО
В открытом тесте используется файл designtalks.txt. Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Создайте пустой словарь, в который будете записывать слова и их количество.
Откройте файл в режиме чтения в кодировке utf-8.
Обратитесь к каждой строке в файле и выполните следующие действия:
уберите невидимые символы в конце строки (символ перехода на новую строку);
обратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;
разбейте строку по разделителю, в результате получите список;
обратитесь к каждому элементу в получившемся списке. Если первый символ — это кавычка «, тогда это студия дизайна, и нужно проверить:
если этого названия еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.
если такое название уже есть в словаре из п.1, то нужно увеличить его значение на 1.
После цикла создайте пустой список — в него нужно будет добавить те названия, значение которых в словаре более 2.
Обратитесь к парам ключ-значение в словаре: если значение строго больше 2, то добавьте ключ в список из п.4.
Отсортируйте список в обратном алфавитном порядке и напечатайте его элементы через запятую и пробел.","[nan, nan, nan]","['«Экспериментус», «СделаемЗавтра», «Айсбергус»', '«КреативныйПуть», «Кибервизион», «ГрафиксЭксперт»', '«ДизайнПроект»']","punctuation = '!#$%&()*+,-./:;<=>?@^_'

data = {}

with open('designtalks.csv', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0] == '«':
                if w not in data:
                    data[w] = 1
                else:
                    data[w] += 1
                    
res = []

for k, v in data.items():
    if v > 2:
        res.append(k)
        
print(*sorted(res, reverse=True), sep=', ')","punctuation = '!#$%&()*+,-./:;<=>?@^_'

data = {}

with open('designtalks.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0] == '«':
                if w not in data:
                    data[w] = 1
                else:
                    data[w] += 1
                    
res = []

for k, v in data.items():
    if v > 2:
        res.append(k)
        
print(*sorted(res, reverse=True), sep=', ')",Ошибка при открытии файла. Обращение к файлу некорректного формата.,"['open', 'closed', 'closed']","<Task description>: Лолита изучает, какие студии дизайна чаще всего дают комментарии в ее любимом журнале. Помогите определить студии, встретившиеся в тексте более двух раз. Гарантируется, что в тексте только названия сервисов написаны в кавычках «». 

ФОРМАТ ВВОДА
Текстовый файл designtalks.txt, в котором записан текст из журнала. 
Гарантируется, что пустых строк в файле нет.
Гарантируется, что в файле будет упоминание хотя бы одной студии.
Также дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.
ФОРМАТ ВЫВОДА
Студии дизайна, встретившиеся в тексте более двух раз.
Студии должны быть записаны в обратном алфавитном порядке через запятую и пробел.
ДОПОЛНИТЕЛЬНО
В открытом тесте используется файл designtalks.txt. Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Создайте пустой словарь, в который будете записывать слова и их количество.
Откройте файл в режиме чтения в кодировке utf-8.
Обратитесь к каждой строке в файле и выполните следующие действия:
уберите невидимые символы в конце строки (символ перехода на новую строку);
обратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;
разбейте строку по разделителю, в результате получите список;
обратитесь к каждому элементу в получившемся списке. Если первый символ — это кавычка «, тогда это студия дизайна, и нужно проверить:
если этого названия еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.
если такое название уже есть в словаре из п.1, то нужно увеличить его значение на 1.
После цикла создайте пустой список — в него нужно будет добавить те названия, значение которых в словаре более 2.
Обратитесь к парам ключ-значение в словаре: если значение строго больше 2, то добавьте ключ в список из п.4.
Отсортируйте список в обратном алфавитном порядке и напечатайте его элементы через запятую и пробел. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: nan 
<Вывод>: «Экспериментус», «СделаемЗавтра», «Айсбергус» 
<Example 2>: 
<Тип теста 2>: closed 
<Ввод>: nan 
<Вывод>: «КреативныйПуть», «Кибервизион», «ГрафиксЭксперт» 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: nan 
<Вывод>: «ДизайнПроект» 
<Решение студента>: punctuation = '!#$%&()*+,-./:;<=>?@^_'

data = {}

with open('designtalks.csv', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0] == '«':
                if w not in data:
                    data[w] = 1
                else:
                    data[w] += 1
                    
res = []

for k, v in data.items():
    if v > 2:
        res.append(k)
        
print(*sorted(res, reverse=True), sep=', ') 
<Идеальное решение>: punctuation = '!#$%&()*+,-./:;<=>?@^_'

data = {}

with open('designtalks.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0] == '«':
                if w not in data:
                    data[w] = 1
                else:
                    data[w] += 1
                    
res = []

for k, v in data.items():
    if v > 2:
        res.append(k)
        
print(*sorted(res, reverse=True), sep=', ') 


<Комментарий эксперта>:"
333,732,47,"Лолита изучает, какие студии дизайна чаще всего дают комментарии в ее любимом журнале. Помогите определить студии, встретившиеся в тексте более двух раз. Гарантируется, что в тексте только названия сервисов написаны в кавычках «». 

ФОРМАТ ВВОДА
Текстовый файл designtalks.txt, в котором записан текст из журнала. 
Гарантируется, что пустых строк в файле нет.
Гарантируется, что в файле будет упоминание хотя бы одной студии.
Также дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.
ФОРМАТ ВЫВОДА
Студии дизайна, встретившиеся в тексте более двух раз.
Студии должны быть записаны в обратном алфавитном порядке через запятую и пробел.
ДОПОЛНИТЕЛЬНО
В открытом тесте используется файл designtalks.txt. Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Создайте пустой словарь, в который будете записывать слова и их количество.
Откройте файл в режиме чтения в кодировке utf-8.
Обратитесь к каждой строке в файле и выполните следующие действия:
уберите невидимые символы в конце строки (символ перехода на новую строку);
обратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;
разбейте строку по разделителю, в результате получите список;
обратитесь к каждому элементу в получившемся списке. Если первый символ — это кавычка «, тогда это студия дизайна, и нужно проверить:
если этого названия еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.
если такое название уже есть в словаре из п.1, то нужно увеличить его значение на 1.
После цикла создайте пустой список — в него нужно будет добавить те названия, значение которых в словаре более 2.
Обратитесь к парам ключ-значение в словаре: если значение строго больше 2, то добавьте ключ в список из п.4.
Отсортируйте список в обратном алфавитном порядке и напечатайте его элементы через запятую и пробел.","[nan, nan, nan]","['«Экспериментус», «СделаемЗавтра», «Айсбергус»', '«КреативныйПуть», «Кибервизион», «ГрафиксЭксперт»', '«ДизайнПроект»']","punctuation = '!#$%&()*+,-./:;<=>?@^_'

with open('designtalks.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0] == '«':
                if w not in data:
                    data[w] = 1
                else:
                    data[w] += 1
                    
res = []

for k, v in data.items():
    if v > 2:
        res.append(k)
        
print(*sorted(res, reverse=True), sep=', ')","punctuation = '!#$%&()*+,-./:;<=>?@^_'

data = {}

with open('designtalks.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0] == '«':
                if w not in data:
                    data[w] = 1
                else:
                    data[w] += 1
                    
res = []

for k, v in data.items():
    if v > 2:
        res.append(k)
        
print(*sorted(res, reverse=True), sep=', ')","Ошибка при обращении к незаданной переменной. Проверьте, что все Ваши переменные корректно заданы.","['open', 'closed', 'closed']","<Task description>: Лолита изучает, какие студии дизайна чаще всего дают комментарии в ее любимом журнале. Помогите определить студии, встретившиеся в тексте более двух раз. Гарантируется, что в тексте только названия сервисов написаны в кавычках «». 

ФОРМАТ ВВОДА
Текстовый файл designtalks.txt, в котором записан текст из журнала. 
Гарантируется, что пустых строк в файле нет.
Гарантируется, что в файле будет упоминание хотя бы одной студии.
Также дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.
ФОРМАТ ВЫВОДА
Студии дизайна, встретившиеся в тексте более двух раз.
Студии должны быть записаны в обратном алфавитном порядке через запятую и пробел.
ДОПОЛНИТЕЛЬНО
В открытом тесте используется файл designtalks.txt. Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Создайте пустой словарь, в который будете записывать слова и их количество.
Откройте файл в режиме чтения в кодировке utf-8.
Обратитесь к каждой строке в файле и выполните следующие действия:
уберите невидимые символы в конце строки (символ перехода на новую строку);
обратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;
разбейте строку по разделителю, в результате получите список;
обратитесь к каждому элементу в получившемся списке. Если первый символ — это кавычка «, тогда это студия дизайна, и нужно проверить:
если этого названия еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.
если такое название уже есть в словаре из п.1, то нужно увеличить его значение на 1.
После цикла создайте пустой список — в него нужно будет добавить те названия, значение которых в словаре более 2.
Обратитесь к парам ключ-значение в словаре: если значение строго больше 2, то добавьте ключ в список из п.4.
Отсортируйте список в обратном алфавитном порядке и напечатайте его элементы через запятую и пробел. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: nan 
<Вывод>: «Экспериментус», «СделаемЗавтра», «Айсбергус» 
<Example 2>: 
<Тип теста 2>: closed 
<Ввод>: nan 
<Вывод>: «КреативныйПуть», «Кибервизион», «ГрафиксЭксперт» 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: nan 
<Вывод>: «ДизайнПроект» 
<Решение студента>: punctuation = '!#$%&()*+,-./:;<=>?@^_'

with open('designtalks.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0] == '«':
                if w not in data:
                    data[w] = 1
                else:
                    data[w] += 1
                    
res = []

for k, v in data.items():
    if v > 2:
        res.append(k)
        
print(*sorted(res, reverse=True), sep=', ') 
<Идеальное решение>: punctuation = '!#$%&()*+,-./:;<=>?@^_'

data = {}

with open('designtalks.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0] == '«':
                if w not in data:
                    data[w] = 1
                else:
                    data[w] += 1
                    
res = []

for k, v in data.items():
    if v > 2:
        res.append(k)
        
print(*sorted(res, reverse=True), sep=', ') 


<Комментарий эксперта>:"
334,733,47,"Лолита изучает, какие студии дизайна чаще всего дают комментарии в ее любимом журнале. Помогите определить студии, встретившиеся в тексте более двух раз. Гарантируется, что в тексте только названия сервисов написаны в кавычках «». 

ФОРМАТ ВВОДА
Текстовый файл designtalks.txt, в котором записан текст из журнала. 
Гарантируется, что пустых строк в файле нет.
Гарантируется, что в файле будет упоминание хотя бы одной студии.
Также дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.
ФОРМАТ ВЫВОДА
Студии дизайна, встретившиеся в тексте более двух раз.
Студии должны быть записаны в обратном алфавитном порядке через запятую и пробел.
ДОПОЛНИТЕЛЬНО
В открытом тесте используется файл designtalks.txt. Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Создайте пустой словарь, в который будете записывать слова и их количество.
Откройте файл в режиме чтения в кодировке utf-8.
Обратитесь к каждой строке в файле и выполните следующие действия:
уберите невидимые символы в конце строки (символ перехода на новую строку);
обратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;
разбейте строку по разделителю, в результате получите список;
обратитесь к каждому элементу в получившемся списке. Если первый символ — это кавычка «, тогда это студия дизайна, и нужно проверить:
если этого названия еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.
если такое название уже есть в словаре из п.1, то нужно увеличить его значение на 1.
После цикла создайте пустой список — в него нужно будет добавить те названия, значение которых в словаре более 2.
Обратитесь к парам ключ-значение в словаре: если значение строго больше 2, то добавьте ключ в список из п.4.
Отсортируйте список в обратном алфавитном порядке и напечатайте его элементы через запятую и пробел.","[nan, nan, nan]","['«Экспериментус», «СделаемЗавтра», «Айсбергус»', '«КреативныйПуть», «Кибервизион», «ГрафиксЭксперт»', '«ДизайнПроект»']","punctuation = '!#$%&()*+,-./:;<=>?@^_'

data = {}

with open('designtalks.txt', 'r', encoding='utf-8') as myfile:
    for line in my_file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0] == '«':
                if w not in data:
                    data[w] = 1
                else:
                    data[w] += 1
                    
res = []

for k, v in data.items():
    if v > 2:
        res.append(k)
        
print(*sorted(res, reverse=True), sep=', ')","punctuation = '!#$%&()*+,-./:;<=>?@^_'

data = {}

with open('designtalks.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0] == '«':
                if w not in data:
                    data[w] = 1
                else:
                    data[w] += 1
                    
res = []

for k, v in data.items():
    if v > 2:
        res.append(k)
        
print(*sorted(res, reverse=True), sep=', ')","Ошибка при обращении к незаданной переменной. Проверьте, что все Ваши переменные корректно заданы.","['open', 'closed', 'closed']","<Task description>: Лолита изучает, какие студии дизайна чаще всего дают комментарии в ее любимом журнале. Помогите определить студии, встретившиеся в тексте более двух раз. Гарантируется, что в тексте только названия сервисов написаны в кавычках «». 

ФОРМАТ ВВОДА
Текстовый файл designtalks.txt, в котором записан текст из журнала. 
Гарантируется, что пустых строк в файле нет.
Гарантируется, что в файле будет упоминание хотя бы одной студии.
Также дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.
ФОРМАТ ВЫВОДА
Студии дизайна, встретившиеся в тексте более двух раз.
Студии должны быть записаны в обратном алфавитном порядке через запятую и пробел.
ДОПОЛНИТЕЛЬНО
В открытом тесте используется файл designtalks.txt. Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Создайте пустой словарь, в который будете записывать слова и их количество.
Откройте файл в режиме чтения в кодировке utf-8.
Обратитесь к каждой строке в файле и выполните следующие действия:
уберите невидимые символы в конце строки (символ перехода на новую строку);
обратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;
разбейте строку по разделителю, в результате получите список;
обратитесь к каждому элементу в получившемся списке. Если первый символ — это кавычка «, тогда это студия дизайна, и нужно проверить:
если этого названия еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.
если такое название уже есть в словаре из п.1, то нужно увеличить его значение на 1.
После цикла создайте пустой список — в него нужно будет добавить те названия, значение которых в словаре более 2.
Обратитесь к парам ключ-значение в словаре: если значение строго больше 2, то добавьте ключ в список из п.4.
Отсортируйте список в обратном алфавитном порядке и напечатайте его элементы через запятую и пробел. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: nan 
<Вывод>: «Экспериментус», «СделаемЗавтра», «Айсбергус» 
<Example 2>: 
<Тип теста 2>: closed 
<Ввод>: nan 
<Вывод>: «КреативныйПуть», «Кибервизион», «ГрафиксЭксперт» 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: nan 
<Вывод>: «ДизайнПроект» 
<Решение студента>: punctuation = '!#$%&()*+,-./:;<=>?@^_'

data = {}

with open('designtalks.txt', 'r', encoding='utf-8') as myfile:
    for line in my_file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0] == '«':
                if w not in data:
                    data[w] = 1
                else:
                    data[w] += 1
                    
res = []

for k, v in data.items():
    if v > 2:
        res.append(k)
        
print(*sorted(res, reverse=True), sep=', ') 
<Идеальное решение>: punctuation = '!#$%&()*+,-./:;<=>?@^_'

data = {}

with open('designtalks.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0] == '«':
                if w not in data:
                    data[w] = 1
                else:
                    data[w] += 1
                    
res = []

for k, v in data.items():
    if v > 2:
        res.append(k)
        
print(*sorted(res, reverse=True), sep=', ') 


<Комментарий эксперта>:"
335,734,47,"Лолита изучает, какие студии дизайна чаще всего дают комментарии в ее любимом журнале. Помогите определить студии, встретившиеся в тексте более двух раз. Гарантируется, что в тексте только названия сервисов написаны в кавычках «». 

ФОРМАТ ВВОДА
Текстовый файл designtalks.txt, в котором записан текст из журнала. 
Гарантируется, что пустых строк в файле нет.
Гарантируется, что в файле будет упоминание хотя бы одной студии.
Также дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.
ФОРМАТ ВЫВОДА
Студии дизайна, встретившиеся в тексте более двух раз.
Студии должны быть записаны в обратном алфавитном порядке через запятую и пробел.
ДОПОЛНИТЕЛЬНО
В открытом тесте используется файл designtalks.txt. Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Создайте пустой словарь, в который будете записывать слова и их количество.
Откройте файл в режиме чтения в кодировке utf-8.
Обратитесь к каждой строке в файле и выполните следующие действия:
уберите невидимые символы в конце строки (символ перехода на новую строку);
обратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;
разбейте строку по разделителю, в результате получите список;
обратитесь к каждому элементу в получившемся списке. Если первый символ — это кавычка «, тогда это студия дизайна, и нужно проверить:
если этого названия еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.
если такое название уже есть в словаре из п.1, то нужно увеличить его значение на 1.
После цикла создайте пустой список — в него нужно будет добавить те названия, значение которых в словаре более 2.
Обратитесь к парам ключ-значение в словаре: если значение строго больше 2, то добавьте ключ в список из п.4.
Отсортируйте список в обратном алфавитном порядке и напечатайте его элементы через запятую и пробел.","[nan, nan, nan]","['«Экспериментус», «СделаемЗавтра», «Айсбергус»', '«КреативныйПуть», «Кибервизион», «ГрафиксЭксперт»', '«ДизайнПроект»']","punctuation = '!#$%&()*+,-./:;<=>?@^_'

data = {}

with open('designtalks.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        
        line = line.split()
        for w in line:
            if w[0] == '«':
                if w not in data:
                    data[w] = 1
                else:
                    data[w] += 1
                    
res = []

for k, v in data.items():
    if v > 2:
        res.append(k)
        
print(*sorted(res, reverse=True), sep=', ')","punctuation = '!#$%&()*+,-./:;<=>?@^_'

data = {}

with open('designtalks.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0] == '«':
                if w not in data:
                    data[w] = 1
                else:
                    data[w] += 1
                    
res = []

for k, v in data.items():
    if v > 2:
        res.append(k)
        
print(*sorted(res, reverse=True), sep=', ')","Ошибка в открытых и скрытых тестах. 

Ваш код некорректно обрабатывает данные. Ваш код не выполняет условие ""также дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст"" Попробуйте изменить код, чтобы скорректировать ошибку.","['open', 'closed', 'closed']","<Task description>: Лолита изучает, какие студии дизайна чаще всего дают комментарии в ее любимом журнале. Помогите определить студии, встретившиеся в тексте более двух раз. Гарантируется, что в тексте только названия сервисов написаны в кавычках «». 

ФОРМАТ ВВОДА
Текстовый файл designtalks.txt, в котором записан текст из журнала. 
Гарантируется, что пустых строк в файле нет.
Гарантируется, что в файле будет упоминание хотя бы одной студии.
Также дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.
ФОРМАТ ВЫВОДА
Студии дизайна, встретившиеся в тексте более двух раз.
Студии должны быть записаны в обратном алфавитном порядке через запятую и пробел.
ДОПОЛНИТЕЛЬНО
В открытом тесте используется файл designtalks.txt. Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Создайте пустой словарь, в который будете записывать слова и их количество.
Откройте файл в режиме чтения в кодировке utf-8.
Обратитесь к каждой строке в файле и выполните следующие действия:
уберите невидимые символы в конце строки (символ перехода на новую строку);
обратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;
разбейте строку по разделителю, в результате получите список;
обратитесь к каждому элементу в получившемся списке. Если первый символ — это кавычка «, тогда это студия дизайна, и нужно проверить:
если этого названия еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.
если такое название уже есть в словаре из п.1, то нужно увеличить его значение на 1.
После цикла создайте пустой список — в него нужно будет добавить те названия, значение которых в словаре более 2.
Обратитесь к парам ключ-значение в словаре: если значение строго больше 2, то добавьте ключ в список из п.4.
Отсортируйте список в обратном алфавитном порядке и напечатайте его элементы через запятую и пробел. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: nan 
<Вывод>: «Экспериментус», «СделаемЗавтра», «Айсбергус» 
<Example 2>: 
<Тип теста 2>: closed 
<Ввод>: nan 
<Вывод>: «КреативныйПуть», «Кибервизион», «ГрафиксЭксперт» 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: nan 
<Вывод>: «ДизайнПроект» 
<Решение студента>: punctuation = '!#$%&()*+,-./:;<=>?@^_'

data = {}

with open('designtalks.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        
        line = line.split()
        for w in line:
            if w[0] == '«':
                if w not in data:
                    data[w] = 1
                else:
                    data[w] += 1
                    
res = []

for k, v in data.items():
    if v > 2:
        res.append(k)
        
print(*sorted(res, reverse=True), sep=', ') 
<Идеальное решение>: punctuation = '!#$%&()*+,-./:;<=>?@^_'

data = {}

with open('designtalks.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0] == '«':
                if w not in data:
                    data[w] = 1
                else:
                    data[w] += 1
                    
res = []

for k, v in data.items():
    if v > 2:
        res.append(k)
        
print(*sorted(res, reverse=True), sep=', ') 


<Комментарий эксперта>:"
336,735,47,"Лолита изучает, какие студии дизайна чаще всего дают комментарии в ее любимом журнале. Помогите определить студии, встретившиеся в тексте более двух раз. Гарантируется, что в тексте только названия сервисов написаны в кавычках «». 

ФОРМАТ ВВОДА
Текстовый файл designtalks.txt, в котором записан текст из журнала. 
Гарантируется, что пустых строк в файле нет.
Гарантируется, что в файле будет упоминание хотя бы одной студии.
Также дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.
ФОРМАТ ВЫВОДА
Студии дизайна, встретившиеся в тексте более двух раз.
Студии должны быть записаны в обратном алфавитном порядке через запятую и пробел.
ДОПОЛНИТЕЛЬНО
В открытом тесте используется файл designtalks.txt. Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Создайте пустой словарь, в который будете записывать слова и их количество.
Откройте файл в режиме чтения в кодировке utf-8.
Обратитесь к каждой строке в файле и выполните следующие действия:
уберите невидимые символы в конце строки (символ перехода на новую строку);
обратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;
разбейте строку по разделителю, в результате получите список;
обратитесь к каждому элементу в получившемся списке. Если первый символ — это кавычка «, тогда это студия дизайна, и нужно проверить:
если этого названия еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.
если такое название уже есть в словаре из п.1, то нужно увеличить его значение на 1.
После цикла создайте пустой список — в него нужно будет добавить те названия, значение которых в словаре более 2.
Обратитесь к парам ключ-значение в словаре: если значение строго больше 2, то добавьте ключ в список из п.4.
Отсортируйте список в обратном алфавитном порядке и напечатайте его элементы через запятую и пробел.","[nan, nan, nan]","['«Экспериментус», «СделаемЗавтра», «Айсбергус»', '«КреативныйПуть», «Кибервизион», «ГрафиксЭксперт»', '«ДизайнПроект»']","punctuation = '!#$%&()*+,-./:;<=>?@^_'

data = {}

with open('designtalks.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line.strip()
        
        for p in punctuation:
           line.replace(p, '')
        
        line.split()
        for w in line:
            if w[0] == '«':
                if w not in data:
                    data[w] = 1
                else:
                    data[w] += 1
                    
res = []

for k, v in data.items():
    if v > 2:
        res.append(k)
        
print(*sorted(res, reverse=True), sep=', ')","punctuation = '!#$%&()*+,-./:;<=>?@^_'

data = {}

with open('designtalks.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0] == '«':
                if w not in data:
                    data[w] = 1
                else:
                    data[w] += 1
                    
res = []

for k, v in data.items():
    if v > 2:
        res.append(k)
        
print(*sorted(res, reverse=True), sep=', ')","Для перезаписи переменной должны соблюдаться нормы синтаксиса формата ""x = ...""","['open', 'closed', 'closed']","<Task description>: Лолита изучает, какие студии дизайна чаще всего дают комментарии в ее любимом журнале. Помогите определить студии, встретившиеся в тексте более двух раз. Гарантируется, что в тексте только названия сервисов написаны в кавычках «». 

ФОРМАТ ВВОДА
Текстовый файл designtalks.txt, в котором записан текст из журнала. 
Гарантируется, что пустых строк в файле нет.
Гарантируется, что в файле будет упоминание хотя бы одной студии.
Также дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.
ФОРМАТ ВЫВОДА
Студии дизайна, встретившиеся в тексте более двух раз.
Студии должны быть записаны в обратном алфавитном порядке через запятую и пробел.
ДОПОЛНИТЕЛЬНО
В открытом тесте используется файл designtalks.txt. Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Создайте пустой словарь, в который будете записывать слова и их количество.
Откройте файл в режиме чтения в кодировке utf-8.
Обратитесь к каждой строке в файле и выполните следующие действия:
уберите невидимые символы в конце строки (символ перехода на новую строку);
обратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;
разбейте строку по разделителю, в результате получите список;
обратитесь к каждому элементу в получившемся списке. Если первый символ — это кавычка «, тогда это студия дизайна, и нужно проверить:
если этого названия еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.
если такое название уже есть в словаре из п.1, то нужно увеличить его значение на 1.
После цикла создайте пустой список — в него нужно будет добавить те названия, значение которых в словаре более 2.
Обратитесь к парам ключ-значение в словаре: если значение строго больше 2, то добавьте ключ в список из п.4.
Отсортируйте список в обратном алфавитном порядке и напечатайте его элементы через запятую и пробел. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: nan 
<Вывод>: «Экспериментус», «СделаемЗавтра», «Айсбергус» 
<Example 2>: 
<Тип теста 2>: closed 
<Ввод>: nan 
<Вывод>: «КреативныйПуть», «Кибервизион», «ГрафиксЭксперт» 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: nan 
<Вывод>: «ДизайнПроект» 
<Решение студента>: punctuation = '!#$%&()*+,-./:;<=>?@^_'

data = {}

with open('designtalks.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line.strip()
        
        for p in punctuation:
           line.replace(p, '')
        
        line.split()
        for w in line:
            if w[0] == '«':
                if w not in data:
                    data[w] = 1
                else:
                    data[w] += 1
                    
res = []

for k, v in data.items():
    if v > 2:
        res.append(k)
        
print(*sorted(res, reverse=True), sep=', ') 
<Идеальное решение>: punctuation = '!#$%&()*+,-./:;<=>?@^_'

data = {}

with open('designtalks.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0] == '«':
                if w not in data:
                    data[w] = 1
                else:
                    data[w] += 1
                    
res = []

for k, v in data.items():
    if v > 2:
        res.append(k)
        
print(*sorted(res, reverse=True), sep=', ') 


<Комментарий эксперта>:"
337,736,47,"Лолита изучает, какие студии дизайна чаще всего дают комментарии в ее любимом журнале. Помогите определить студии, встретившиеся в тексте более двух раз. Гарантируется, что в тексте только названия сервисов написаны в кавычках «». 

ФОРМАТ ВВОДА
Текстовый файл designtalks.txt, в котором записан текст из журнала. 
Гарантируется, что пустых строк в файле нет.
Гарантируется, что в файле будет упоминание хотя бы одной студии.
Также дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.
ФОРМАТ ВЫВОДА
Студии дизайна, встретившиеся в тексте более двух раз.
Студии должны быть записаны в обратном алфавитном порядке через запятую и пробел.
ДОПОЛНИТЕЛЬНО
В открытом тесте используется файл designtalks.txt. Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Создайте пустой словарь, в который будете записывать слова и их количество.
Откройте файл в режиме чтения в кодировке utf-8.
Обратитесь к каждой строке в файле и выполните следующие действия:
уберите невидимые символы в конце строки (символ перехода на новую строку);
обратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;
разбейте строку по разделителю, в результате получите список;
обратитесь к каждому элементу в получившемся списке. Если первый символ — это кавычка «, тогда это студия дизайна, и нужно проверить:
если этого названия еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.
если такое название уже есть в словаре из п.1, то нужно увеличить его значение на 1.
После цикла создайте пустой список — в него нужно будет добавить те названия, значение которых в словаре более 2.
Обратитесь к парам ключ-значение в словаре: если значение строго больше 2, то добавьте ключ в список из п.4.
Отсортируйте список в обратном алфавитном порядке и напечатайте его элементы через запятую и пробел.","[nan, nan, nan]","['«Экспериментус», «СделаемЗавтра», «Айсбергус»', '«КреативныйПуть», «Кибервизион», «ГрафиксЭксперт»', '«ДизайнПроект»']","punctuation = '!#$%&()*+,-./:;<=>?@^_'

data = {}

with open('designtalks.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0] = '«':
                if w not in data:
                    data[w] = 1
                else:
                    data[w] += 1
                    
res = []

for k, v in data.items():
    if v > 2:
        res.append(k)
        
print(*sorted(res, reverse=True), sep=', ')","punctuation = '!#$%&()*+,-./:;<=>?@^_'

data = {}

with open('designtalks.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0] == '«':
                if w not in data:
                    data[w] = 1
                else:
                    data[w] += 1
                    
res = []

for k, v in data.items():
    if v > 2:
        res.append(k)
        
print(*sorted(res, reverse=True), sep=', ')",Синтаксическая ошибка. При сравнении двух значений следует использовать знако двойного равенства.,"['open', 'closed', 'closed']","<Task description>: Лолита изучает, какие студии дизайна чаще всего дают комментарии в ее любимом журнале. Помогите определить студии, встретившиеся в тексте более двух раз. Гарантируется, что в тексте только названия сервисов написаны в кавычках «». 

ФОРМАТ ВВОДА
Текстовый файл designtalks.txt, в котором записан текст из журнала. 
Гарантируется, что пустых строк в файле нет.
Гарантируется, что в файле будет упоминание хотя бы одной студии.
Также дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.
ФОРМАТ ВЫВОДА
Студии дизайна, встретившиеся в тексте более двух раз.
Студии должны быть записаны в обратном алфавитном порядке через запятую и пробел.
ДОПОЛНИТЕЛЬНО
В открытом тесте используется файл designtalks.txt. Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Создайте пустой словарь, в который будете записывать слова и их количество.
Откройте файл в режиме чтения в кодировке utf-8.
Обратитесь к каждой строке в файле и выполните следующие действия:
уберите невидимые символы в конце строки (символ перехода на новую строку);
обратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;
разбейте строку по разделителю, в результате получите список;
обратитесь к каждому элементу в получившемся списке. Если первый символ — это кавычка «, тогда это студия дизайна, и нужно проверить:
если этого названия еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.
если такое название уже есть в словаре из п.1, то нужно увеличить его значение на 1.
После цикла создайте пустой список — в него нужно будет добавить те названия, значение которых в словаре более 2.
Обратитесь к парам ключ-значение в словаре: если значение строго больше 2, то добавьте ключ в список из п.4.
Отсортируйте список в обратном алфавитном порядке и напечатайте его элементы через запятую и пробел. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: nan 
<Вывод>: «Экспериментус», «СделаемЗавтра», «Айсбергус» 
<Example 2>: 
<Тип теста 2>: closed 
<Ввод>: nan 
<Вывод>: «КреативныйПуть», «Кибервизион», «ГрафиксЭксперт» 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: nan 
<Вывод>: «ДизайнПроект» 
<Решение студента>: punctuation = '!#$%&()*+,-./:;<=>?@^_'

data = {}

with open('designtalks.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0] = '«':
                if w not in data:
                    data[w] = 1
                else:
                    data[w] += 1
                    
res = []

for k, v in data.items():
    if v > 2:
        res.append(k)
        
print(*sorted(res, reverse=True), sep=', ') 
<Идеальное решение>: punctuation = '!#$%&()*+,-./:;<=>?@^_'

data = {}

with open('designtalks.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0] == '«':
                if w not in data:
                    data[w] = 1
                else:
                    data[w] += 1
                    
res = []

for k, v in data.items():
    if v > 2:
        res.append(k)
        
print(*sorted(res, reverse=True), sep=', ') 


<Комментарий эксперта>:"
338,737,47,"Лолита изучает, какие студии дизайна чаще всего дают комментарии в ее любимом журнале. Помогите определить студии, встретившиеся в тексте более двух раз. Гарантируется, что в тексте только названия сервисов написаны в кавычках «». 

ФОРМАТ ВВОДА
Текстовый файл designtalks.txt, в котором записан текст из журнала. 
Гарантируется, что пустых строк в файле нет.
Гарантируется, что в файле будет упоминание хотя бы одной студии.
Также дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.
ФОРМАТ ВЫВОДА
Студии дизайна, встретившиеся в тексте более двух раз.
Студии должны быть записаны в обратном алфавитном порядке через запятую и пробел.
ДОПОЛНИТЕЛЬНО
В открытом тесте используется файл designtalks.txt. Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Создайте пустой словарь, в который будете записывать слова и их количество.
Откройте файл в режиме чтения в кодировке utf-8.
Обратитесь к каждой строке в файле и выполните следующие действия:
уберите невидимые символы в конце строки (символ перехода на новую строку);
обратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;
разбейте строку по разделителю, в результате получите список;
обратитесь к каждому элементу в получившемся списке. Если первый символ — это кавычка «, тогда это студия дизайна, и нужно проверить:
если этого названия еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.
если такое название уже есть в словаре из п.1, то нужно увеличить его значение на 1.
После цикла создайте пустой список — в него нужно будет добавить те названия, значение которых в словаре более 2.
Обратитесь к парам ключ-значение в словаре: если значение строго больше 2, то добавьте ключ в список из п.4.
Отсортируйте список в обратном алфавитном порядке и напечатайте его элементы через запятую и пробел.","[nan, nan, nan]","['«Экспериментус», «СделаемЗавтра», «Айсбергус»', '«КреативныйПуть», «Кибервизион», «ГрафиксЭксперт»', '«ДизайнПроект»']","punctuation = '!#$%&()*+,-./:;<=>?@^_'

data = {}

with open('designtalks.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0] == ""«':
                if w not in data:
                    data[w] = 1
                else:
                    data[w] += 1
                    
res = []

for k, v in data.items():
    if v > 2:
        res.append(k)
        
print(*sorted(res, reverse=True), sep=', ')","punctuation = '!#$%&()*+,-./:;<=>?@^_'

data = {}

with open('designtalks.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0] == '«':
                if w not in data:
                    data[w] = 1
                else:
                    data[w] += 1
                    
res = []

for k, v in data.items():
    if v > 2:
        res.append(k)
        
print(*sorted(res, reverse=True), sep=', ')","Синтаксическая ошибка. Значение ""«"" должно быть заключено в кавычки одинакового формата.","['open', 'closed', 'closed']","<Task description>: Лолита изучает, какие студии дизайна чаще всего дают комментарии в ее любимом журнале. Помогите определить студии, встретившиеся в тексте более двух раз. Гарантируется, что в тексте только названия сервисов написаны в кавычках «». 

ФОРМАТ ВВОДА
Текстовый файл designtalks.txt, в котором записан текст из журнала. 
Гарантируется, что пустых строк в файле нет.
Гарантируется, что в файле будет упоминание хотя бы одной студии.
Также дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.
ФОРМАТ ВЫВОДА
Студии дизайна, встретившиеся в тексте более двух раз.
Студии должны быть записаны в обратном алфавитном порядке через запятую и пробел.
ДОПОЛНИТЕЛЬНО
В открытом тесте используется файл designtalks.txt. Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Создайте пустой словарь, в который будете записывать слова и их количество.
Откройте файл в режиме чтения в кодировке utf-8.
Обратитесь к каждой строке в файле и выполните следующие действия:
уберите невидимые символы в конце строки (символ перехода на новую строку);
обратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;
разбейте строку по разделителю, в результате получите список;
обратитесь к каждому элементу в получившемся списке. Если первый символ — это кавычка «, тогда это студия дизайна, и нужно проверить:
если этого названия еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.
если такое название уже есть в словаре из п.1, то нужно увеличить его значение на 1.
После цикла создайте пустой список — в него нужно будет добавить те названия, значение которых в словаре более 2.
Обратитесь к парам ключ-значение в словаре: если значение строго больше 2, то добавьте ключ в список из п.4.
Отсортируйте список в обратном алфавитном порядке и напечатайте его элементы через запятую и пробел. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: nan 
<Вывод>: «Экспериментус», «СделаемЗавтра», «Айсбергус» 
<Example 2>: 
<Тип теста 2>: closed 
<Ввод>: nan 
<Вывод>: «КреативныйПуть», «Кибервизион», «ГрафиксЭксперт» 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: nan 
<Вывод>: «ДизайнПроект» 
<Решение студента>: punctuation = '!#$%&()*+,-./:;<=>?@^_'

data = {}

with open('designtalks.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0] == ""«':
                if w not in data:
                    data[w] = 1
                else:
                    data[w] += 1
                    
res = []

for k, v in data.items():
    if v > 2:
        res.append(k)
        
print(*sorted(res, reverse=True), sep=', ') 
<Идеальное решение>: punctuation = '!#$%&()*+,-./:;<=>?@^_'

data = {}

with open('designtalks.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0] == '«':
                if w not in data:
                    data[w] = 1
                else:
                    data[w] += 1
                    
res = []

for k, v in data.items():
    if v > 2:
        res.append(k)
        
print(*sorted(res, reverse=True), sep=', ') 


<Комментарий эксперта>:"
339,738,47,"Лолита изучает, какие студии дизайна чаще всего дают комментарии в ее любимом журнале. Помогите определить студии, встретившиеся в тексте более двух раз. Гарантируется, что в тексте только названия сервисов написаны в кавычках «». 

ФОРМАТ ВВОДА
Текстовый файл designtalks.txt, в котором записан текст из журнала. 
Гарантируется, что пустых строк в файле нет.
Гарантируется, что в файле будет упоминание хотя бы одной студии.
Также дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.
ФОРМАТ ВЫВОДА
Студии дизайна, встретившиеся в тексте более двух раз.
Студии должны быть записаны в обратном алфавитном порядке через запятую и пробел.
ДОПОЛНИТЕЛЬНО
В открытом тесте используется файл designtalks.txt. Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Создайте пустой словарь, в который будете записывать слова и их количество.
Откройте файл в режиме чтения в кодировке utf-8.
Обратитесь к каждой строке в файле и выполните следующие действия:
уберите невидимые символы в конце строки (символ перехода на новую строку);
обратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;
разбейте строку по разделителю, в результате получите список;
обратитесь к каждому элементу в получившемся списке. Если первый символ — это кавычка «, тогда это студия дизайна, и нужно проверить:
если этого названия еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.
если такое название уже есть в словаре из п.1, то нужно увеличить его значение на 1.
После цикла создайте пустой список — в него нужно будет добавить те названия, значение которых в словаре более 2.
Обратитесь к парам ключ-значение в словаре: если значение строго больше 2, то добавьте ключ в список из п.4.
Отсортируйте список в обратном алфавитном порядке и напечатайте его элементы через запятую и пробел.","[nan, nan, nan]","['«Экспериментус», «СделаемЗавтра», «Айсбергус»', '«КреативныйПуть», «Кибервизион», «ГрафиксЭксперт»', '«ДизайнПроект»']","punctuation = '!#$%&()*+,-./:;<=>?@^_'

data = {}

with open('designtalks.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0] == '«':
                if w in data:
                    data[w] = 1
                else:
                    data[w] += 1
                    
res = []

for k, v in data.items():
    if v > 2:
        res.append(k)
        
print(*sorted(res, reverse=True), sep=', ')","punctuation = '!#$%&()*+,-./:;<=>?@^_'

data = {}

with open('designtalks.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0] == '«':
                if w not in data:
                    data[w] = 1
                else:
                    data[w] += 1
                    
res = []

for k, v in data.items():
    if v > 2:
        res.append(k)
        
print(*sorted(res, reverse=True), sep=', ')","Ошибка в открытых и скрытых тестах. 

Ваш код некорректно обрабатывает данные. При добавлении слова в словарь необходимо учитывать, что первый элемент слова начинается с заглавной буквы.","['open', 'closed', 'closed']","<Task description>: Лолита изучает, какие студии дизайна чаще всего дают комментарии в ее любимом журнале. Помогите определить студии, встретившиеся в тексте более двух раз. Гарантируется, что в тексте только названия сервисов написаны в кавычках «». 

ФОРМАТ ВВОДА
Текстовый файл designtalks.txt, в котором записан текст из журнала. 
Гарантируется, что пустых строк в файле нет.
Гарантируется, что в файле будет упоминание хотя бы одной студии.
Также дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.
ФОРМАТ ВЫВОДА
Студии дизайна, встретившиеся в тексте более двух раз.
Студии должны быть записаны в обратном алфавитном порядке через запятую и пробел.
ДОПОЛНИТЕЛЬНО
В открытом тесте используется файл designtalks.txt. Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Создайте пустой словарь, в который будете записывать слова и их количество.
Откройте файл в режиме чтения в кодировке utf-8.
Обратитесь к каждой строке в файле и выполните следующие действия:
уберите невидимые символы в конце строки (символ перехода на новую строку);
обратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;
разбейте строку по разделителю, в результате получите список;
обратитесь к каждому элементу в получившемся списке. Если первый символ — это кавычка «, тогда это студия дизайна, и нужно проверить:
если этого названия еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.
если такое название уже есть в словаре из п.1, то нужно увеличить его значение на 1.
После цикла создайте пустой список — в него нужно будет добавить те названия, значение которых в словаре более 2.
Обратитесь к парам ключ-значение в словаре: если значение строго больше 2, то добавьте ключ в список из п.4.
Отсортируйте список в обратном алфавитном порядке и напечатайте его элементы через запятую и пробел. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: nan 
<Вывод>: «Экспериментус», «СделаемЗавтра», «Айсбергус» 
<Example 2>: 
<Тип теста 2>: closed 
<Ввод>: nan 
<Вывод>: «КреативныйПуть», «Кибервизион», «ГрафиксЭксперт» 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: nan 
<Вывод>: «ДизайнПроект» 
<Решение студента>: punctuation = '!#$%&()*+,-./:;<=>?@^_'

data = {}

with open('designtalks.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0] == '«':
                if w in data:
                    data[w] = 1
                else:
                    data[w] += 1
                    
res = []

for k, v in data.items():
    if v > 2:
        res.append(k)
        
print(*sorted(res, reverse=True), sep=', ') 
<Идеальное решение>: punctuation = '!#$%&()*+,-./:;<=>?@^_'

data = {}

with open('designtalks.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0] == '«':
                if w not in data:
                    data[w] = 1
                else:
                    data[w] += 1
                    
res = []

for k, v in data.items():
    if v > 2:
        res.append(k)
        
print(*sorted(res, reverse=True), sep=', ') 


<Комментарий эксперта>:"
340,739,47,"Лолита изучает, какие студии дизайна чаще всего дают комментарии в ее любимом журнале. Помогите определить студии, встретившиеся в тексте более двух раз. Гарантируется, что в тексте только названия сервисов написаны в кавычках «». 

ФОРМАТ ВВОДА
Текстовый файл designtalks.txt, в котором записан текст из журнала. 
Гарантируется, что пустых строк в файле нет.
Гарантируется, что в файле будет упоминание хотя бы одной студии.
Также дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.
ФОРМАТ ВЫВОДА
Студии дизайна, встретившиеся в тексте более двух раз.
Студии должны быть записаны в обратном алфавитном порядке через запятую и пробел.
ДОПОЛНИТЕЛЬНО
В открытом тесте используется файл designtalks.txt. Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Создайте пустой словарь, в который будете записывать слова и их количество.
Откройте файл в режиме чтения в кодировке utf-8.
Обратитесь к каждой строке в файле и выполните следующие действия:
уберите невидимые символы в конце строки (символ перехода на новую строку);
обратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;
разбейте строку по разделителю, в результате получите список;
обратитесь к каждому элементу в получившемся списке. Если первый символ — это кавычка «, тогда это студия дизайна, и нужно проверить:
если этого названия еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.
если такое название уже есть в словаре из п.1, то нужно увеличить его значение на 1.
После цикла создайте пустой список — в него нужно будет добавить те названия, значение которых в словаре более 2.
Обратитесь к парам ключ-значение в словаре: если значение строго больше 2, то добавьте ключ в список из п.4.
Отсортируйте список в обратном алфавитном порядке и напечатайте его элементы через запятую и пробел.","[nan, nan, nan]","['«Экспериментус», «СделаемЗавтра», «Айсбергус»', '«КреативныйПуть», «Кибервизион», «ГрафиксЭксперт»', '«ДизайнПроект»']","punctuation = '!#$%&()*+,-./:;<=>?@^_'

data = {}

with open('designtalks.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0] == '«':
                if w not in data:
                    data[w] = 1
                else:
                    data[w] += 1
                    
for k, v in data.items():
    if v > 2:
        res.append(k)
        
print(*sorted(res, reverse=True), sep=', ')","punctuation = '!#$%&()*+,-./:;<=>?@^_'

data = {}

with open('designtalks.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0] == '«':
                if w not in data:
                    data[w] = 1
                else:
                    data[w] += 1
                    
res = []

for k, v in data.items():
    if v > 2:
        res.append(k)
        
print(*sorted(res, reverse=True), sep=', ')","Ошибка при обращении к незаданной переменной. Проверьте, что все Ваши переменные корректно заданы.","['open', 'closed', 'closed']","<Task description>: Лолита изучает, какие студии дизайна чаще всего дают комментарии в ее любимом журнале. Помогите определить студии, встретившиеся в тексте более двух раз. Гарантируется, что в тексте только названия сервисов написаны в кавычках «». 

ФОРМАТ ВВОДА
Текстовый файл designtalks.txt, в котором записан текст из журнала. 
Гарантируется, что пустых строк в файле нет.
Гарантируется, что в файле будет упоминание хотя бы одной студии.
Также дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.
ФОРМАТ ВЫВОДА
Студии дизайна, встретившиеся в тексте более двух раз.
Студии должны быть записаны в обратном алфавитном порядке через запятую и пробел.
ДОПОЛНИТЕЛЬНО
В открытом тесте используется файл designtalks.txt. Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Создайте пустой словарь, в который будете записывать слова и их количество.
Откройте файл в режиме чтения в кодировке utf-8.
Обратитесь к каждой строке в файле и выполните следующие действия:
уберите невидимые символы в конце строки (символ перехода на новую строку);
обратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;
разбейте строку по разделителю, в результате получите список;
обратитесь к каждому элементу в получившемся списке. Если первый символ — это кавычка «, тогда это студия дизайна, и нужно проверить:
если этого названия еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.
если такое название уже есть в словаре из п.1, то нужно увеличить его значение на 1.
После цикла создайте пустой список — в него нужно будет добавить те названия, значение которых в словаре более 2.
Обратитесь к парам ключ-значение в словаре: если значение строго больше 2, то добавьте ключ в список из п.4.
Отсортируйте список в обратном алфавитном порядке и напечатайте его элементы через запятую и пробел. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: nan 
<Вывод>: «Экспериментус», «СделаемЗавтра», «Айсбергус» 
<Example 2>: 
<Тип теста 2>: closed 
<Ввод>: nan 
<Вывод>: «КреативныйПуть», «Кибервизион», «ГрафиксЭксперт» 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: nan 
<Вывод>: «ДизайнПроект» 
<Решение студента>: punctuation = '!#$%&()*+,-./:;<=>?@^_'

data = {}

with open('designtalks.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0] == '«':
                if w not in data:
                    data[w] = 1
                else:
                    data[w] += 1
                    
for k, v in data.items():
    if v > 2:
        res.append(k)
        
print(*sorted(res, reverse=True), sep=', ') 
<Идеальное решение>: punctuation = '!#$%&()*+,-./:;<=>?@^_'

data = {}

with open('designtalks.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0] == '«':
                if w not in data:
                    data[w] = 1
                else:
                    data[w] += 1
                    
res = []

for k, v in data.items():
    if v > 2:
        res.append(k)
        
print(*sorted(res, reverse=True), sep=', ') 


<Комментарий эксперта>:"
341,740,47,"Лолита изучает, какие студии дизайна чаще всего дают комментарии в ее любимом журнале. Помогите определить студии, встретившиеся в тексте более двух раз. Гарантируется, что в тексте только названия сервисов написаны в кавычках «». 

ФОРМАТ ВВОДА
Текстовый файл designtalks.txt, в котором записан текст из журнала. 
Гарантируется, что пустых строк в файле нет.
Гарантируется, что в файле будет упоминание хотя бы одной студии.
Также дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.
ФОРМАТ ВЫВОДА
Студии дизайна, встретившиеся в тексте более двух раз.
Студии должны быть записаны в обратном алфавитном порядке через запятую и пробел.
ДОПОЛНИТЕЛЬНО
В открытом тесте используется файл designtalks.txt. Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Создайте пустой словарь, в который будете записывать слова и их количество.
Откройте файл в режиме чтения в кодировке utf-8.
Обратитесь к каждой строке в файле и выполните следующие действия:
уберите невидимые символы в конце строки (символ перехода на новую строку);
обратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;
разбейте строку по разделителю, в результате получите список;
обратитесь к каждому элементу в получившемся списке. Если первый символ — это кавычка «, тогда это студия дизайна, и нужно проверить:
если этого названия еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.
если такое название уже есть в словаре из п.1, то нужно увеличить его значение на 1.
После цикла создайте пустой список — в него нужно будет добавить те названия, значение которых в словаре более 2.
Обратитесь к парам ключ-значение в словаре: если значение строго больше 2, то добавьте ключ в список из п.4.
Отсортируйте список в обратном алфавитном порядке и напечатайте его элементы через запятую и пробел.","[nan, nan, nan]","['«Экспериментус», «СделаемЗавтра», «Айсбергус»', '«КреативныйПуть», «Кибервизион», «ГрафиксЭксперт»', '«ДизайнПроект»']","punctuation = '!#$%&()*+,-./:;<=>?@^_'

data = {}

with open('designtalks.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0] == '«':
                if w not in data:
                    data[w] = 1
                else:
                    data[w] += 1
                    
res = []

for k, v in data:
    if v > 2:
        res.append(k)
        
print(*sorted(res, reverse=True), sep=', ')","punctuation = '!#$%&()*+,-./:;<=>?@^_'

data = {}

with open('designtalks.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0] == '«':
                if w not in data:
                    data[w] = 1
                else:
                    data[w] += 1
                    
res = []

for k, v in data.items():
    if v > 2:
        res.append(k)
        
print(*sorted(res, reverse=True), sep=', ')","Ошибка при обращении к элементам словаря data. Попытка обратиться к двум значениям, вместо одного. Используйте опреатор .items().","['open', 'closed', 'closed']","<Task description>: Лолита изучает, какие студии дизайна чаще всего дают комментарии в ее любимом журнале. Помогите определить студии, встретившиеся в тексте более двух раз. Гарантируется, что в тексте только названия сервисов написаны в кавычках «». 

ФОРМАТ ВВОДА
Текстовый файл designtalks.txt, в котором записан текст из журнала. 
Гарантируется, что пустых строк в файле нет.
Гарантируется, что в файле будет упоминание хотя бы одной студии.
Также дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.
ФОРМАТ ВЫВОДА
Студии дизайна, встретившиеся в тексте более двух раз.
Студии должны быть записаны в обратном алфавитном порядке через запятую и пробел.
ДОПОЛНИТЕЛЬНО
В открытом тесте используется файл designtalks.txt. Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Создайте пустой словарь, в который будете записывать слова и их количество.
Откройте файл в режиме чтения в кодировке utf-8.
Обратитесь к каждой строке в файле и выполните следующие действия:
уберите невидимые символы в конце строки (символ перехода на новую строку);
обратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;
разбейте строку по разделителю, в результате получите список;
обратитесь к каждому элементу в получившемся списке. Если первый символ — это кавычка «, тогда это студия дизайна, и нужно проверить:
если этого названия еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.
если такое название уже есть в словаре из п.1, то нужно увеличить его значение на 1.
После цикла создайте пустой список — в него нужно будет добавить те названия, значение которых в словаре более 2.
Обратитесь к парам ключ-значение в словаре: если значение строго больше 2, то добавьте ключ в список из п.4.
Отсортируйте список в обратном алфавитном порядке и напечатайте его элементы через запятую и пробел. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: nan 
<Вывод>: «Экспериментус», «СделаемЗавтра», «Айсбергус» 
<Example 2>: 
<Тип теста 2>: closed 
<Ввод>: nan 
<Вывод>: «КреативныйПуть», «Кибервизион», «ГрафиксЭксперт» 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: nan 
<Вывод>: «ДизайнПроект» 
<Решение студента>: punctuation = '!#$%&()*+,-./:;<=>?@^_'

data = {}

with open('designtalks.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0] == '«':
                if w not in data:
                    data[w] = 1
                else:
                    data[w] += 1
                    
res = []

for k, v in data:
    if v > 2:
        res.append(k)
        
print(*sorted(res, reverse=True), sep=', ') 
<Идеальное решение>: punctuation = '!#$%&()*+,-./:;<=>?@^_'

data = {}

with open('designtalks.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0] == '«':
                if w not in data:
                    data[w] = 1
                else:
                    data[w] += 1
                    
res = []

for k, v in data.items():
    if v > 2:
        res.append(k)
        
print(*sorted(res, reverse=True), sep=', ') 


<Комментарий эксперта>:"
342,741,47,"Лолита изучает, какие студии дизайна чаще всего дают комментарии в ее любимом журнале. Помогите определить студии, встретившиеся в тексте более двух раз. Гарантируется, что в тексте только названия сервисов написаны в кавычках «». 

ФОРМАТ ВВОДА
Текстовый файл designtalks.txt, в котором записан текст из журнала. 
Гарантируется, что пустых строк в файле нет.
Гарантируется, что в файле будет упоминание хотя бы одной студии.
Также дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.
ФОРМАТ ВЫВОДА
Студии дизайна, встретившиеся в тексте более двух раз.
Студии должны быть записаны в обратном алфавитном порядке через запятую и пробел.
ДОПОЛНИТЕЛЬНО
В открытом тесте используется файл designtalks.txt. Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Создайте пустой словарь, в который будете записывать слова и их количество.
Откройте файл в режиме чтения в кодировке utf-8.
Обратитесь к каждой строке в файле и выполните следующие действия:
уберите невидимые символы в конце строки (символ перехода на новую строку);
обратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;
разбейте строку по разделителю, в результате получите список;
обратитесь к каждому элементу в получившемся списке. Если первый символ — это кавычка «, тогда это студия дизайна, и нужно проверить:
если этого названия еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.
если такое название уже есть в словаре из п.1, то нужно увеличить его значение на 1.
После цикла создайте пустой список — в него нужно будет добавить те названия, значение которых в словаре более 2.
Обратитесь к парам ключ-значение в словаре: если значение строго больше 2, то добавьте ключ в список из п.4.
Отсортируйте список в обратном алфавитном порядке и напечатайте его элементы через запятую и пробел.","[nan, nan, nan]","['«Экспериментус», «СделаемЗавтра», «Айсбергус»', '«КреативныйПуть», «Кибервизион», «ГрафиксЭксперт»', '«ДизайнПроект»']","punctuation = '!#$%&()*+,-./:;<=>?@^_'

data = {}

with open('designtalks.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0] == '«':
                if w not in data:
                    data[w] = 1
                else:
                    data[w] += 1
                    
res = []

for k, v in data.items():
    if v >= 2:
        res.append(k)
        
print(*sorted(res, reverse=True), sep=', ')","punctuation = '!#$%&()*+,-./:;<=>?@^_'

data = {}

with open('designtalks.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0] == '«':
                if w not in data:
                    data[w] = 1
                else:
                    data[w] += 1
                    
res = []

for k, v in data.items():
    if v > 2:
        res.append(k)
        
print(*sorted(res, reverse=True), sep=', ')","Ошибка в открытых и скрытых тестах. 

Ваш код некорректно выполняет условия задания. Например, он не выполняет условие ""выведите студии дизайна, встретившиеся в тексте более двух раз"". Попробуйте изменить условную конструкцию if, чтобы скорректировать ошибку.","['open', 'closed', 'closed']","<Task description>: Лолита изучает, какие студии дизайна чаще всего дают комментарии в ее любимом журнале. Помогите определить студии, встретившиеся в тексте более двух раз. Гарантируется, что в тексте только названия сервисов написаны в кавычках «». 

ФОРМАТ ВВОДА
Текстовый файл designtalks.txt, в котором записан текст из журнала. 
Гарантируется, что пустых строк в файле нет.
Гарантируется, что в файле будет упоминание хотя бы одной студии.
Также дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.
ФОРМАТ ВЫВОДА
Студии дизайна, встретившиеся в тексте более двух раз.
Студии должны быть записаны в обратном алфавитном порядке через запятую и пробел.
ДОПОЛНИТЕЛЬНО
В открытом тесте используется файл designtalks.txt. Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Создайте пустой словарь, в который будете записывать слова и их количество.
Откройте файл в режиме чтения в кодировке utf-8.
Обратитесь к каждой строке в файле и выполните следующие действия:
уберите невидимые символы в конце строки (символ перехода на новую строку);
обратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;
разбейте строку по разделителю, в результате получите список;
обратитесь к каждому элементу в получившемся списке. Если первый символ — это кавычка «, тогда это студия дизайна, и нужно проверить:
если этого названия еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.
если такое название уже есть в словаре из п.1, то нужно увеличить его значение на 1.
После цикла создайте пустой список — в него нужно будет добавить те названия, значение которых в словаре более 2.
Обратитесь к парам ключ-значение в словаре: если значение строго больше 2, то добавьте ключ в список из п.4.
Отсортируйте список в обратном алфавитном порядке и напечатайте его элементы через запятую и пробел. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: nan 
<Вывод>: «Экспериментус», «СделаемЗавтра», «Айсбергус» 
<Example 2>: 
<Тип теста 2>: closed 
<Ввод>: nan 
<Вывод>: «КреативныйПуть», «Кибервизион», «ГрафиксЭксперт» 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: nan 
<Вывод>: «ДизайнПроект» 
<Решение студента>: punctuation = '!#$%&()*+,-./:;<=>?@^_'

data = {}

with open('designtalks.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0] == '«':
                if w not in data:
                    data[w] = 1
                else:
                    data[w] += 1
                    
res = []

for k, v in data.items():
    if v >= 2:
        res.append(k)
        
print(*sorted(res, reverse=True), sep=', ') 
<Идеальное решение>: punctuation = '!#$%&()*+,-./:;<=>?@^_'

data = {}

with open('designtalks.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0] == '«':
                if w not in data:
                    data[w] = 1
                else:
                    data[w] += 1
                    
res = []

for k, v in data.items():
    if v > 2:
        res.append(k)
        
print(*sorted(res, reverse=True), sep=', ') 


<Комментарий эксперта>:"
343,742,47,"Лолита изучает, какие студии дизайна чаще всего дают комментарии в ее любимом журнале. Помогите определить студии, встретившиеся в тексте более двух раз. Гарантируется, что в тексте только названия сервисов написаны в кавычках «». 

ФОРМАТ ВВОДА
Текстовый файл designtalks.txt, в котором записан текст из журнала. 
Гарантируется, что пустых строк в файле нет.
Гарантируется, что в файле будет упоминание хотя бы одной студии.
Также дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.
ФОРМАТ ВЫВОДА
Студии дизайна, встретившиеся в тексте более двух раз.
Студии должны быть записаны в обратном алфавитном порядке через запятую и пробел.
ДОПОЛНИТЕЛЬНО
В открытом тесте используется файл designtalks.txt. Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Создайте пустой словарь, в который будете записывать слова и их количество.
Откройте файл в режиме чтения в кодировке utf-8.
Обратитесь к каждой строке в файле и выполните следующие действия:
уберите невидимые символы в конце строки (символ перехода на новую строку);
обратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;
разбейте строку по разделителю, в результате получите список;
обратитесь к каждому элементу в получившемся списке. Если первый символ — это кавычка «, тогда это студия дизайна, и нужно проверить:
если этого названия еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.
если такое название уже есть в словаре из п.1, то нужно увеличить его значение на 1.
После цикла создайте пустой список — в него нужно будет добавить те названия, значение которых в словаре более 2.
Обратитесь к парам ключ-значение в словаре: если значение строго больше 2, то добавьте ключ в список из п.4.
Отсортируйте список в обратном алфавитном порядке и напечатайте его элементы через запятую и пробел.","[nan, nan, nan]","['«Экспериментус», «СделаемЗавтра», «Айсбергус»', '«КреативныйПуть», «Кибервизион», «ГрафиксЭксперт»', '«ДизайнПроект»']","punctuation = '!#$%&()*+,-./:;<=>?@^_'

data = {}

with open('designtalks.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0] == '«':
                if w not in data:
                    data[w] = 1
                else:
                    data[w] += 1
                    
res = []

for k, v in data.items():
    if v > 2:
        res.append(v)
        
print(*sorted(res))","punctuation = '!#$%&()*+,-./:;<=>?@^_'

data = {}

with open('designtalks.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0] == '«':
                if w not in data:
                    data[w] = 1
                else:
                    data[w] += 1
                    
res = []

for k, v in data.items():
    if v > 2:
        res.append(k)
        
print(*sorted(res, reverse=True), sep=', ')","Ошибка в открытых и скрытых тестах. 

Ваш код некорректно выполняет условия задания. Например, он не выполняет условие ""cтудии должны быть записаны в обратном алфавитном порядке через запятую и пробел"". Попробуйте изменить условную конструкцию if, чтобы скорректировать ошибку.","['open', 'closed', 'closed']","<Task description>: Лолита изучает, какие студии дизайна чаще всего дают комментарии в ее любимом журнале. Помогите определить студии, встретившиеся в тексте более двух раз. Гарантируется, что в тексте только названия сервисов написаны в кавычках «». 

ФОРМАТ ВВОДА
Текстовый файл designtalks.txt, в котором записан текст из журнала. 
Гарантируется, что пустых строк в файле нет.
Гарантируется, что в файле будет упоминание хотя бы одной студии.
Также дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.
ФОРМАТ ВЫВОДА
Студии дизайна, встретившиеся в тексте более двух раз.
Студии должны быть записаны в обратном алфавитном порядке через запятую и пробел.
ДОПОЛНИТЕЛЬНО
В открытом тесте используется файл designtalks.txt. Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Создайте пустой словарь, в который будете записывать слова и их количество.
Откройте файл в режиме чтения в кодировке utf-8.
Обратитесь к каждой строке в файле и выполните следующие действия:
уберите невидимые символы в конце строки (символ перехода на новую строку);
обратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;
разбейте строку по разделителю, в результате получите список;
обратитесь к каждому элементу в получившемся списке. Если первый символ — это кавычка «, тогда это студия дизайна, и нужно проверить:
если этого названия еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.
если такое название уже есть в словаре из п.1, то нужно увеличить его значение на 1.
После цикла создайте пустой список — в него нужно будет добавить те названия, значение которых в словаре более 2.
Обратитесь к парам ключ-значение в словаре: если значение строго больше 2, то добавьте ключ в список из п.4.
Отсортируйте список в обратном алфавитном порядке и напечатайте его элементы через запятую и пробел. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: nan 
<Вывод>: «Экспериментус», «СделаемЗавтра», «Айсбергус» 
<Example 2>: 
<Тип теста 2>: closed 
<Ввод>: nan 
<Вывод>: «КреативныйПуть», «Кибервизион», «ГрафиксЭксперт» 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: nan 
<Вывод>: «ДизайнПроект» 
<Решение студента>: punctuation = '!#$%&()*+,-./:;<=>?@^_'

data = {}

with open('designtalks.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0] == '«':
                if w not in data:
                    data[w] = 1
                else:
                    data[w] += 1
                    
res = []

for k, v in data.items():
    if v > 2:
        res.append(v)
        
print(*sorted(res)) 
<Идеальное решение>: punctuation = '!#$%&()*+,-./:;<=>?@^_'

data = {}

with open('designtalks.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0] == '«':
                if w not in data:
                    data[w] = 1
                else:
                    data[w] += 1
                    
res = []

for k, v in data.items():
    if v > 2:
        res.append(k)
        
print(*sorted(res, reverse=True), sep=', ') 


<Комментарий эксперта>:"
344,743,47,"Лолита изучает, какие студии дизайна чаще всего дают комментарии в ее любимом журнале. Помогите определить студии, встретившиеся в тексте более двух раз. Гарантируется, что в тексте только названия сервисов написаны в кавычках «». 

ФОРМАТ ВВОДА
Текстовый файл designtalks.txt, в котором записан текст из журнала. 
Гарантируется, что пустых строк в файле нет.
Гарантируется, что в файле будет упоминание хотя бы одной студии.
Также дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.
ФОРМАТ ВЫВОДА
Студии дизайна, встретившиеся в тексте более двух раз.
Студии должны быть записаны в обратном алфавитном порядке через запятую и пробел.
ДОПОЛНИТЕЛЬНО
В открытом тесте используется файл designtalks.txt. Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Создайте пустой словарь, в который будете записывать слова и их количество.
Откройте файл в режиме чтения в кодировке utf-8.
Обратитесь к каждой строке в файле и выполните следующие действия:
уберите невидимые символы в конце строки (символ перехода на новую строку);
обратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;
разбейте строку по разделителю, в результате получите список;
обратитесь к каждому элементу в получившемся списке. Если первый символ — это кавычка «, тогда это студия дизайна, и нужно проверить:
если этого названия еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.
если такое название уже есть в словаре из п.1, то нужно увеличить его значение на 1.
После цикла создайте пустой список — в него нужно будет добавить те названия, значение которых в словаре более 2.
Обратитесь к парам ключ-значение в словаре: если значение строго больше 2, то добавьте ключ в список из п.4.
Отсортируйте список в обратном алфавитном порядке и напечатайте его элементы через запятую и пробел.","[nan, nan, nan]","['«Экспериментус», «СделаемЗавтра», «Айсбергус»', '«КреативныйПуть», «Кибервизион», «ГрафиксЭксперт»', '«ДизайнПроект»']","punctuation = '!#$%&()*+,-./:;<=>?@^_'

data = {}

with open('designtalks.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0] == '«':
                if w not in data:
                    data[w] = 1
                else:
                    data[w] += 1
                    
res = []

for k, v in data.items():
    if v > 2:
        res.append(k)
        
print(*sorted(res), sep=', ')","punctuation = '!#$%&()*+,-./:;<=>?@^_'

data = {}

with open('designtalks.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0] == '«':
                if w not in data:
                    data[w] = 1
                else:
                    data[w] += 1
                    
res = []

for k, v in data.items():
    if v > 2:
        res.append(k)
        
print(*sorted(res, reverse=True), sep=', ')","Ошибка в открытых и скрытых тестах. 

Ваш код некорректно выполняет условия задания. Например, он не выполняет условие ""cтудии должны быть записаны в обратном алфавитном порядке через запятую и пробел"". Попробуйте изменить условную конструкцию if, чтобы скорректировать ошибку.","['open', 'closed', 'closed']","<Task description>: Лолита изучает, какие студии дизайна чаще всего дают комментарии в ее любимом журнале. Помогите определить студии, встретившиеся в тексте более двух раз. Гарантируется, что в тексте только названия сервисов написаны в кавычках «». 

ФОРМАТ ВВОДА
Текстовый файл designtalks.txt, в котором записан текст из журнала. 
Гарантируется, что пустых строк в файле нет.
Гарантируется, что в файле будет упоминание хотя бы одной студии.
Также дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.
ФОРМАТ ВЫВОДА
Студии дизайна, встретившиеся в тексте более двух раз.
Студии должны быть записаны в обратном алфавитном порядке через запятую и пробел.
ДОПОЛНИТЕЛЬНО
В открытом тесте используется файл designtalks.txt. Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Создайте пустой словарь, в который будете записывать слова и их количество.
Откройте файл в режиме чтения в кодировке utf-8.
Обратитесь к каждой строке в файле и выполните следующие действия:
уберите невидимые символы в конце строки (символ перехода на новую строку);
обратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;
разбейте строку по разделителю, в результате получите список;
обратитесь к каждому элементу в получившемся списке. Если первый символ — это кавычка «, тогда это студия дизайна, и нужно проверить:
если этого названия еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.
если такое название уже есть в словаре из п.1, то нужно увеличить его значение на 1.
После цикла создайте пустой список — в него нужно будет добавить те названия, значение которых в словаре более 2.
Обратитесь к парам ключ-значение в словаре: если значение строго больше 2, то добавьте ключ в список из п.4.
Отсортируйте список в обратном алфавитном порядке и напечатайте его элементы через запятую и пробел. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: nan 
<Вывод>: «Экспериментус», «СделаемЗавтра», «Айсбергус» 
<Example 2>: 
<Тип теста 2>: closed 
<Ввод>: nan 
<Вывод>: «КреативныйПуть», «Кибервизион», «ГрафиксЭксперт» 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: nan 
<Вывод>: «ДизайнПроект» 
<Решение студента>: punctuation = '!#$%&()*+,-./:;<=>?@^_'

data = {}

with open('designtalks.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0] == '«':
                if w not in data:
                    data[w] = 1
                else:
                    data[w] += 1
                    
res = []

for k, v in data.items():
    if v > 2:
        res.append(k)
        
print(*sorted(res), sep=', ') 
<Идеальное решение>: punctuation = '!#$%&()*+,-./:;<=>?@^_'

data = {}

with open('designtalks.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0] == '«':
                if w not in data:
                    data[w] = 1
                else:
                    data[w] += 1
                    
res = []

for k, v in data.items():
    if v > 2:
        res.append(k)
        
print(*sorted(res, reverse=True), sep=', ') 


<Комментарий эксперта>:"
345,744,47,"Лолита изучает, какие студии дизайна чаще всего дают комментарии в ее любимом журнале. Помогите определить студии, встретившиеся в тексте более двух раз. Гарантируется, что в тексте только названия сервисов написаны в кавычках «». 

ФОРМАТ ВВОДА
Текстовый файл designtalks.txt, в котором записан текст из журнала. 
Гарантируется, что пустых строк в файле нет.
Гарантируется, что в файле будет упоминание хотя бы одной студии.
Также дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.
ФОРМАТ ВЫВОДА
Студии дизайна, встретившиеся в тексте более двух раз.
Студии должны быть записаны в обратном алфавитном порядке через запятую и пробел.
ДОПОЛНИТЕЛЬНО
В открытом тесте используется файл designtalks.txt. Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Создайте пустой словарь, в который будете записывать слова и их количество.
Откройте файл в режиме чтения в кодировке utf-8.
Обратитесь к каждой строке в файле и выполните следующие действия:
уберите невидимые символы в конце строки (символ перехода на новую строку);
обратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;
разбейте строку по разделителю, в результате получите список;
обратитесь к каждому элементу в получившемся списке. Если первый символ — это кавычка «, тогда это студия дизайна, и нужно проверить:
если этого названия еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.
если такое название уже есть в словаре из п.1, то нужно увеличить его значение на 1.
После цикла создайте пустой список — в него нужно будет добавить те названия, значение которых в словаре более 2.
Обратитесь к парам ключ-значение в словаре: если значение строго больше 2, то добавьте ключ в список из п.4.
Отсортируйте список в обратном алфавитном порядке и напечатайте его элементы через запятую и пробел.","[nan, nan, nan]","['«Экспериментус», «СделаемЗавтра», «Айсбергус»', '«КреативныйПуть», «Кибервизион», «ГрафиксЭксперт»', '«ДизайнПроект»']","punctuation = '!#$%&()*+,-./:;<=>?@^_'

data = {}

with open('designtalks.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0] == '«':
                if w not in data:
                    data[w] = 1
                else:
                    data[w] += 1
                    
res = []

for k, v in data.items():
    if v > 2:
        res.append(k)
        
print(*sorted(res, reverse=True), sep='; ')","punctuation = '!#$%&()*+,-./:;<=>?@^_'

data = {}

with open('designtalks.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0] == '«':
                if w not in data:
                    data[w] = 1
                else:
                    data[w] += 1
                    
res = []

for k, v in data.items():
    if v > 2:
        res.append(k)
        
print(*sorted(res, reverse=True), sep=', ')","Ошибка в открытых и скрытых тестах. 

Ваш код некорректно выполняет условия задания. Например, он не выполняет условие ""cтудии должны быть записаны в обратном алфавитном порядке через запятую и пробел"". Попробуйте изменить условную конструкцию if, чтобы скорректировать ошибку.","['open', 'closed', 'closed']","<Task description>: Лолита изучает, какие студии дизайна чаще всего дают комментарии в ее любимом журнале. Помогите определить студии, встретившиеся в тексте более двух раз. Гарантируется, что в тексте только названия сервисов написаны в кавычках «». 

ФОРМАТ ВВОДА
Текстовый файл designtalks.txt, в котором записан текст из журнала. 
Гарантируется, что пустых строк в файле нет.
Гарантируется, что в файле будет упоминание хотя бы одной студии.
Также дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.
ФОРМАТ ВЫВОДА
Студии дизайна, встретившиеся в тексте более двух раз.
Студии должны быть записаны в обратном алфавитном порядке через запятую и пробел.
ДОПОЛНИТЕЛЬНО
В открытом тесте используется файл designtalks.txt. Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Создайте пустой словарь, в который будете записывать слова и их количество.
Откройте файл в режиме чтения в кодировке utf-8.
Обратитесь к каждой строке в файле и выполните следующие действия:
уберите невидимые символы в конце строки (символ перехода на новую строку);
обратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;
разбейте строку по разделителю, в результате получите список;
обратитесь к каждому элементу в получившемся списке. Если первый символ — это кавычка «, тогда это студия дизайна, и нужно проверить:
если этого названия еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.
если такое название уже есть в словаре из п.1, то нужно увеличить его значение на 1.
После цикла создайте пустой список — в него нужно будет добавить те названия, значение которых в словаре более 2.
Обратитесь к парам ключ-значение в словаре: если значение строго больше 2, то добавьте ключ в список из п.4.
Отсортируйте список в обратном алфавитном порядке и напечатайте его элементы через запятую и пробел. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: nan 
<Вывод>: «Экспериментус», «СделаемЗавтра», «Айсбергус» 
<Example 2>: 
<Тип теста 2>: closed 
<Ввод>: nan 
<Вывод>: «КреативныйПуть», «Кибервизион», «ГрафиксЭксперт» 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: nan 
<Вывод>: «ДизайнПроект» 
<Решение студента>: punctuation = '!#$%&()*+,-./:;<=>?@^_'

data = {}

with open('designtalks.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0] == '«':
                if w not in data:
                    data[w] = 1
                else:
                    data[w] += 1
                    
res = []

for k, v in data.items():
    if v > 2:
        res.append(k)
        
print(*sorted(res, reverse=True), sep='; ') 
<Идеальное решение>: punctuation = '!#$%&()*+,-./:;<=>?@^_'

data = {}

with open('designtalks.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0] == '«':
                if w not in data:
                    data[w] = 1
                else:
                    data[w] += 1
                    
res = []

for k, v in data.items():
    if v > 2:
        res.append(k)
        
print(*sorted(res, reverse=True), sep=', ') 


<Комментарий эксперта>:"
346,745,47,"Лолита изучает, какие студии дизайна чаще всего дают комментарии в ее любимом журнале. Помогите определить студии, встретившиеся в тексте более двух раз. Гарантируется, что в тексте только названия сервисов написаны в кавычках «». 

ФОРМАТ ВВОДА
Текстовый файл designtalks.txt, в котором записан текст из журнала. 
Гарантируется, что пустых строк в файле нет.
Гарантируется, что в файле будет упоминание хотя бы одной студии.
Также дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.
ФОРМАТ ВЫВОДА
Студии дизайна, встретившиеся в тексте более двух раз.
Студии должны быть записаны в обратном алфавитном порядке через запятую и пробел.
ДОПОЛНИТЕЛЬНО
В открытом тесте используется файл designtalks.txt. Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Создайте пустой словарь, в который будете записывать слова и их количество.
Откройте файл в режиме чтения в кодировке utf-8.
Обратитесь к каждой строке в файле и выполните следующие действия:
уберите невидимые символы в конце строки (символ перехода на новую строку);
обратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;
разбейте строку по разделителю, в результате получите список;
обратитесь к каждому элементу в получившемся списке. Если первый символ — это кавычка «, тогда это студия дизайна, и нужно проверить:
если этого названия еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.
если такое название уже есть в словаре из п.1, то нужно увеличить его значение на 1.
После цикла создайте пустой список — в него нужно будет добавить те названия, значение которых в словаре более 2.
Обратитесь к парам ключ-значение в словаре: если значение строго больше 2, то добавьте ключ в список из п.4.
Отсортируйте список в обратном алфавитном порядке и напечатайте его элементы через запятую и пробел.","[nan, nan, nan]","['«Экспериментус», «СделаемЗавтра», «Айсбергус»', '«КреативныйПуть», «Кибервизион», «ГрафиксЭксперт»', '«ДизайнПроект»']","punctuation = '!#$%&()*+,-./:;<=>?@^_'

data = {}

with open('designtalks.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0] == '«':
                if w not in data:
                    data[w] = 1
                else:
                    data[w] += 1
                    
res = []

for k, v in data.items():
    if v > 2:
        res.append(k)
        
    print(*sorted(res, reverse=True), sep=', ')","punctuation = '!#$%&()*+,-./:;<=>?@^_'

data = {}

with open('designtalks.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0] == '«':
                if w not in data:
                    data[w] = 1
                else:
                    data[w] += 1
                    
res = []

for k, v in data.items():
    if v > 2:
        res.append(k)
        
print(*sorted(res, reverse=True), sep=', ')",Некорректная табуляция функции print().,"['open', 'closed', 'closed']","<Task description>: Лолита изучает, какие студии дизайна чаще всего дают комментарии в ее любимом журнале. Помогите определить студии, встретившиеся в тексте более двух раз. Гарантируется, что в тексте только названия сервисов написаны в кавычках «». 

ФОРМАТ ВВОДА
Текстовый файл designtalks.txt, в котором записан текст из журнала. 
Гарантируется, что пустых строк в файле нет.
Гарантируется, что в файле будет упоминание хотя бы одной студии.
Также дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.
ФОРМАТ ВЫВОДА
Студии дизайна, встретившиеся в тексте более двух раз.
Студии должны быть записаны в обратном алфавитном порядке через запятую и пробел.
ДОПОЛНИТЕЛЬНО
В открытом тесте используется файл designtalks.txt. Вы можете скачать его и проверить свое решение локально.
В примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.
АЛГОРИТМ РЕШЕНИЯ 
Это один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.
Создайте пустой словарь, в который будете записывать слова и их количество.
Откройте файл в режиме чтения в кодировке utf-8.
Обратитесь к каждой строке в файле и выполните следующие действия:
уберите невидимые символы в конце строки (символ перехода на новую строку);
обратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;
разбейте строку по разделителю, в результате получите список;
обратитесь к каждому элементу в получившемся списке. Если первый символ — это кавычка «, тогда это студия дизайна, и нужно проверить:
если этого названия еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.
если такое название уже есть в словаре из п.1, то нужно увеличить его значение на 1.
После цикла создайте пустой список — в него нужно будет добавить те названия, значение которых в словаре более 2.
Обратитесь к парам ключ-значение в словаре: если значение строго больше 2, то добавьте ключ в список из п.4.
Отсортируйте список в обратном алфавитном порядке и напечатайте его элементы через запятую и пробел. 
<Example 1>: 
<Тип теста 1>: open 
<Ввод>: nan 
<Вывод>: «Экспериментус», «СделаемЗавтра», «Айсбергус» 
<Example 2>: 
<Тип теста 2>: closed 
<Ввод>: nan 
<Вывод>: «КреативныйПуть», «Кибервизион», «ГрафиксЭксперт» 
<Example 3>: 
<Тип теста 3>: closed 
<Ввод>: nan 
<Вывод>: «ДизайнПроект» 
<Решение студента>: punctuation = '!#$%&()*+,-./:;<=>?@^_'

data = {}

with open('designtalks.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0] == '«':
                if w not in data:
                    data[w] = 1
                else:
                    data[w] += 1
                    
res = []

for k, v in data.items():
    if v > 2:
        res.append(k)
        
    print(*sorted(res, reverse=True), sep=', ') 
<Идеальное решение>: punctuation = '!#$%&()*+,-./:;<=>?@^_'

data = {}

with open('designtalks.txt', 'r', encoding='utf-8') as my_file:
    for line in my_file:
        line = line.strip()
        
        for p in punctuation:
            line = line.replace(p, '')
        
        line = line.split()
        for w in line:
            if w[0] == '«':
                if w not in data:
                    data[w] = 1
                else:
                    data[w] += 1
                    
res = []

for k, v in data.items():
    if v > 2:
        res.append(k)
        
print(*sorted(res, reverse=True), sep=', ') 


<Комментарий эксперта>:"
